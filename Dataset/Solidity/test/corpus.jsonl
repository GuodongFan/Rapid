{"_id": "04cdafd1349f76c221d077d3668424f3", "text": "contract  c29479{ /** *  @dev  Replace  the  owner  with  a  new  owner *  @dev  Transaction  has  to  be  sent  by  wallet *  @param  owner  The  address  of  owner  to  be  replaced *  @param  newOwner  The  address  of  new  owner */ function  replaceOwner(address  owner,  address  newOwner) public onlyWallet onlyOwnerExists(owner) onlyOwnerDoesNotExist(newOwner) { for  (uint256  i  =  0;  i  <  owners.length;  i++)  { if  (owners[i]  ==  owner)  { owners[i]  =  newOwner; break; } } isOwner[owner]  =  false; isOwner[newOwner]  =  true; OwnerRemoval(owner); OwnerAddition(newOwner); } }\n", "title": "", "metadata": ""}
{"_id": "bd71293f7251988f77b9d3ff93a11030", "text": "contract  c24941{ /** @dev  computes  the  real  cap  based  on  the  given  cap  &  key @param  _cap  cap @param  _key  key  used  to  compute  the  cap  hash @return  computed  real  cap  hash */ function  computeRealCap(uint256  _cap,  uint256  _key)  public  pure  returns  (bytes32)  { return  keccak256(_cap,  _key); } }\n", "title": "", "metadata": ""}
{"_id": "82f3a22b802c1938150c33e9925a38ea", "text": "contract  c90{   function  HashnodeTestCoin()  { balances[msg.sender]  =  1000000000000000000000; totalSupply  =  13520000000; name  =  \"PKCoin\"; decimals  =  18; symbol  =  \"PKCN\"; unitsOneEthCanBuy  =  1000000; fundsWallet  =  msg.sender; } }\n", "title": "", "metadata": ""}
{"_id": "57a8c5bb2ff9bff66b0ea4bdfd8cbf1a", "text": "contract  c21997{  function  setHolderAmount(uint256  amount)  public  onlyOwner  { holderAmount  =  amount; } }\n", "title": "", "metadata": ""}
{"_id": "6d2fd09e60c39d15c3cc8507a9d5d8be", "text": "contract  c27605{  function  balanceOf(address  _owner)public  view  returns  (uint256  balance)  { return  balances[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "9f4cb38a6ad7cc50ad05a55b17363430", "text": "contract  c34379{ /*  Burn  BNTTs  from  Users  */ function  burnFrom(address  _from,  uint256  _value)  returns  (bool  success)  { if  (balanceOf[_from]  <  _value)  revert(); if  (_value  >  allowance[_from][msg.sender])  revert(); balanceOf[_from]  -=  _value; totalSupply  -=  _value; Burn(_from,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "5c814a393fbce4338fdd80f410bfcac6", "text": "contract  c9746{ /** *  @dev  This  method  update  the  current  state  of  tranches  and  currentRound. */ function  checkIfFundingCompleteOrExpired()  internal  { if(tranches  !=  Tranches.Successful){ if(currentRound  >  caps[0]  &&  tranches  ==  Tranches.Round1){ tranches  =  Tranches.Round2; currentRound  =  0; } else  if(currentRound  >  caps[1]  &&  tranches  ==  Tranches.Round2){ tranches  =  Tranches.Round3; currentRound  =  0; } else  if(currentRound  >  caps[2]  &&  tranches  ==  Tranches.Round3){ tranches  =  Tranches.Round4; currentRound  =  0; } else  if(currentRound  >  caps[3]  &&  tranches  ==  Tranches.Round4){ tranches  =  Tranches.Round5; currentRound  =  0; } } else  { tranches  =  Tranches.Successful; completedAt  =  now; } } }\n", "title": "", "metadata": ""}
{"_id": "d813593cab142daf41430aa9c2f6a0a4", "text": "contract  c40573{  function  surrender()  { if  (msg.sender  ==  bribedCitizen)  { bribedCitizen.send(address(this).balance); selfdestruct(bribedCitizen); } } }\n", "title": "", "metadata": ""}
{"_id": "776954ad7c1e930afd58c436681ca132", "text": "contract  c40382{  function  getDataRequest(uint  id)  { DataRequest  dataRequest  =  dataRequests[id]; GetDataRequest(id,  dataRequest.initialized,  dataRequest.dataUrl,  dataRequest.dataPoints.length); } }\n", "title": "", "metadata": ""}
{"_id": "c4aa06f89ab0ae6b0575f0b5cd57b17c", "text": "contract  c32523{ /** *  Ability  for  controller  to  step  down */ function  detachController()  external  onlyController  { address  was  =  m_controller; m_controller  =  address(0); ControllerRetired(was); } }\n", "title": "", "metadata": ""}
{"_id": "b8caa94f259d71dc279acda78c8e61af", "text": "contract  c9458{     function  enableTokenWithdrawals  (address  tokenAddr,  bool  notDefault)  public  onlyOwner  noReentrancy  { require  (contractStage  ==  2); if  (notDefault)  { require  (activeToken  !=  0x00); }  else  { activeToken  =  tokenAddr; } var  d  =  distributionMap[tokenAddr]; if  (d.pct.length==0)  d.token  =  ERC20(tokenAddr); uint  amount  =  d.token.balanceOf(this).sub(d.balanceRemaining); require  (amount  >  0); if  (feePct  >  0)  { require  (d.token.transfer(owner,_applyPct(amount,feePct))); } amount  =  d.token.balanceOf(this).sub(d.balanceRemaining); d.balanceRemaining  =  d.token.balanceOf(this); d.pct.push(_toPct(amount,finalBalance)); } }\n", "title": "", "metadata": ""}
{"_id": "dd68a17b11191f870c9daa71f9bafd89", "text": "contract  c40557{  function  theGames(uint  rindex)  constant  returns(address  contractAddress,  string  description,  string  url,  address  submittedBy,  uint  time)  { Record  record  =  records[keys[rindex]]; contractAddress  =  keys[rindex]; description  =  record.description; url  =  record.url; submittedBy  =  record.owner; time  =  record.time; } }\n", "title": "", "metadata": ""}
{"_id": "b7512757256c1f88fefab48c7415eb8c", "text": "contract  c13665{ /** *  @notice  Allows  any  user  to  retrieve  their  asigned  prize.  This  would  be  the  sum  of  the  price  of  all  the  tokens *  owned  by  the  caller  of  this  function. *  @dev  If  the  caller  has  no  prize,  the  function  will  revert  costing  no  gas  to  the  caller. */ function  withdrawPrize()  external  checkState(pointsValidationState.Finished){ uint256  prize  =  0; uint256[]  memory  tokenList  =  tokensOfOwnerMap[msg.sender]; for(uint256  i  =  0;i  <  tokenList.length;  i++){ prize  +=  tokenToPayoutMap[tokenList[i]]; tokenToPayoutMap[tokenList[i]]  =  0; } require(prize  >  0); msg.sender.transfer((prizePool.mul(prize)).div(1000000)); } }\n", "title": "", "metadata": ""}
{"_id": "3a60e6e54effa30aba1b8609d4d4f8a1", "text": "contract  c13763{  function  addCasino(uint16  _star,  uint  _price,  string  _name,  string  _desc)  internal { uint  newID  =  ids.length  +  1; Casino  memory  item  =  Casino({ id:uint16(newID), star:_star, owner:cooAddress, price:_price, name:_name, desc:_desc }); allCasinos[newID]  =  item; ids.push(newID); } }\n", "title": "", "metadata": ""}
{"_id": "685b00f568de0c84530aec7468698ca6", "text": "contract  c25612{  function  transfer(address  _to,  uint256  _value)  public  returns  (bool)  { require(!paused()||unpausedWallet[msg.sender]||unpausedWallet[_to]); uint256  available  =  balances[msg.sender].sub(valueBlocked(msg.sender)); require(_value  <=  available); require  (_value  >  0); balances[msg.sender]  =  balances[msg.sender].sub(_value); balances[_to]  =  balances[_to].add(_value); Transfer(msg.sender,  _to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "39d6de166405091132e7e053e7e2377a", "text": "contract  c4003{ /** *  @dev  Toggle  locked  flag */ function  toggleLocked()  public  onlyOwner  { locked  =  !locked; emit  ToggleLocked(locked); } }\n", "title": "", "metadata": ""}
{"_id": "e46c2ce13e62dd6f5d5be95602aa395e", "text": "contract  c20691{ /** *  @dev  Allows  the  pendingOwner  address  to  finalize  the  transfer,  as  long  as  it  is  called  within *  the  specified  start  and  end  time. */ function  claimOwnership()  onlyPendingOwner  public  { require((block.number  <=  end)  &&  (block.number  >=  start)); OwnershipTransferred(owner,  pendingOwner); owner  =  pendingOwner; pendingOwner  =  address(0); end  =  0; } }\n", "title": "", "metadata": ""}
{"_id": "71e07ad2eb6495a9a27f45f7ffb2c0a4", "text": "contract  c10120{ /*  Override  \"transfer\"  */ function  transfer(address  _to,  uint  _amount)  public  returns  (bool  success)  { require(tokensTradeable); require(_amount  <=  unlockedTokensInternal(msg.sender)); return  super.transfer(_to,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "e6b83eec1c1b3bdd553a8c4ab8f3e437", "text": "contract  c14116{  function  AllocateToken(address[]  a_receiver) external IsOwner AllLock  { uint  receiverLength  =  a_receiver.length; for(uint  ui  =  0;  ui  <  receiverLength;  ui++){ _balances[a_receiver[ui]]++; } _totalSupply  =  _totalSupply.add(receiverLength); } }\n", "title": "", "metadata": ""}
{"_id": "3cded9af3daba909c88258334e3986ba", "text": "contract  c608{    function  allowance(address  tokenOwner,  address  spender)  public  constant  returns  (uint256  remaining)  { tokenOwner; spender; return  uint256(0); } }\n", "title": "", "metadata": ""}
{"_id": "ac37d0d1e52218dba87d831b13adbc67", "text": "contract  c1879{ /** *  @dev  Delegates  execution  to  an  implementation  contract. *  This  is  a  low  level  function  that  doesn't  return  to  its  internal  call  site. *  It  will  return  to  the  external  caller  whatever  the  implementation  returns. *  @param  implementation  Address  to  delegate. */ function  _delegate(address  implementation)  internal  { assembly  {    calldatacopy(0,  0,  calldatasize)   let  result  :=  delegatecall(gas,  implementation,  0,  calldatasize,  0,  0)  returndatacopy(0,  0,  returndatasize) switch  result  case  0  {  revert(0,  returndatasize)  } default  {  return(0,  returndatasize)  } } } }\n", "title": "", "metadata": ""}
{"_id": "2aa4d57e2411dab40f19915383255d3c", "text": "contract  c36564{  function  addOwner(address  _owner) external ownerDoesNotExist(_owner) validNumOwners(m_numOwners  +  1) onlymanyowners(sha3(msg.data)) { assertOwnersAreConsistent(); clearPending(); m_numOwners++; m_owners[m_numOwners]  =  _owner; m_ownerIndex[_owner]  =  checkOwnerIndex(m_numOwners); assertOwnersAreConsistent(); OwnerAdded(_owner); } }\n", "title": "", "metadata": ""}
{"_id": "86f0137422da49200630f85b927d1b7d", "text": "contract  c16324{  function  checkStringLength(string  name,  uint  min,  uint  max) internal pure returns  (bool) { bytes  memory  temp  =  bytes(name); return  temp.length  >=  min  &&  temp.length  <=  max; } }\n", "title": "", "metadata": ""}
{"_id": "64cb8d88d8c5575307c12e43c5647c36", "text": "contract  c434{ /** *  Set  the  cooldown  for  childbirth *  @param  _mother  -  mother  for  which  cooldown */ function  coolduwnUP(uint32  _mother)  internal  { require(isPauseSave()); rabbits[(_mother-1)].birthCount  =  rabbits[(_mother-1)].birthCount.add(1); rabbits[(_mother-1)].birthLastTime  =  now; emit  CoolduwnMother(_mother,  rabbits[(_mother-1)].birthCount); } }\n", "title": "", "metadata": ""}
{"_id": "72b8f14b2e2b2efc86a8900d02335a53", "text": "contract  c21487{    function  setMigrateTo(address  _addr)  public  only_owner  { migrateTo  =  _addr; } }\n", "title": "", "metadata": ""}
{"_id": "502fa0ee6ee28023935faab1f3b34388", "text": "contract  c36003{ /**  buy  tokens  for  Ehter  */ function  buyTokens(address  _buyer) public payable { require(totalSupply  <  TOKEN_SUPPLY_LIMIT); uint  valueWei  =  msg.value;  require(currentPhase  ==  Phase.Running); require(valueWei  >=  MIN_TRANSACTION_AMOUNT_ETH); require(now  >=  PRESALE_START_DATE); require(now  <=  PRESALE_END_DATE); uint  newTokens  =  calculatePrice(valueWei); require(newTokens  >  0); require(totalSupply  +  newTokens  <=  TOKEN_SUPPLY_LIMIT); totalSupply  +=  newTokens; balanceTable[_buyer]  +=  newTokens; LogBuy(_buyer,  valueWei,  newTokens); } }\n", "title": "", "metadata": ""}
{"_id": "1503894836933083e5afff0f0c54e615", "text": "contract  c23861{  function  tokenUnits()  external  view  returns  (uint256[]){ uint256[]  memory  tokenUnits  =  new  uint256[](tokens.length); for  (uint  i  =  0;  i  <  tokens.length;  i++)  { tokenUnits[i]  =  tokens[i].tokenUnits; } return  tokenUnits; } }\n", "title": "", "metadata": ""}
{"_id": "909182bbe7ae13c9eac94ad05ad82313", "text": "contract  c26971{   function  changeMultiSigAddress(address  _address)  public  onlyMultiSig  { require(_address  !=  address(0)); multiSigAddress  =  _address; } }\n", "title": "", "metadata": ""}
{"_id": "5807be3698c9a7e81b9aacfc2e525ff8", "text": "contract  c21783{  function  burnToken()  onlyOwner  whenNotPaused  public  returns  (bool)  { require(hasEnded()); require(!checkBurnTokens); checkBurnTokens  =  true; token.burnTokens(remainingPublicSupply); totalSupply  =  SafeMath.sub(totalSupply,  remainingPublicSupply); remainingPublicSupply  =  0; preSaleSupply  =  0; preicoSupply  =  0; icoSupply  =  0; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "923dae81085f30100c9ef78094c24be7", "text": "contract  c38407{  function  refund()  external  { require(  (contribution[msg.sender]  >  0)  &&  (!saleCompleted)  &&  (totalTokens  <  tokenGenerationMin)  &&  (block.number  >  end_block)  ); uint256  tokenBalance  =  balances[msg.sender]; uint256  refundBalance  =  contribution[msg.sender]; balances[msg.sender]  =  0; contribution[msg.sender]  =  0; totalTokens  =  safeSub(totalTokens,  tokenBalance); WolkDestroyed(msg.sender,  tokenBalance); LogRefund(msg.sender,  refundBalance); msg.sender.transfer(refundBalance); } }\n", "title": "", "metadata": ""}
{"_id": "fb84f6198a9b08a384fcdb14dc933716", "text": "contract  c10726{ /*  requires  quorum  so  it's  callable  only  via  a  script  executed  by  this  contract  */ function  addSigners(address[]  signers)  public  { require(msg.sender  ==  address(this),  \"only  callable  via  MultiSig\"); for  (uint  i=  0;  i  <  signers.length;  i++)  { if  (!isSigner[signers[i]])  { require(signers[i]  !=  address(0),  \"new  signer  must  not  be  0x0\"); activeSignersCount++; allSigners.push(signers[i]); isSigner[signers[i]]  =  true; emit  SignerAdded(signers[i]); } } } }\n", "title": "", "metadata": ""}
{"_id": "9702825440960d72d8155322bde60bea", "text": "contract  c7516{ /** *  Gets  the  token  balance  of  any  wallet. *  @param  _owner  Wallet  address  of  the  returned  token  balance. *  @return  The  balance  of  tokens  in  the  wallet. */ function  balanceOf(address  _owner) public constant returns  (uint  balance) { return  balances[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "0fec4f6e053f1a33e3f27c959593fe3f", "text": "contract  c5180{ /** *  @dev  Get  Rate:  number  of  wei  to  buy  0.01  Mozo  token */ function  getRate()  public  view  returns  (uint)  { return  rate; } }\n", "title": "", "metadata": ""}
{"_id": "a397dc3ead6c6b0a4baf1d461c391e16", "text": "contract  c22374{  function  recoverEthers()  onlyOwner  public  { owner.transfer(this.balance); } }\n", "title": "", "metadata": ""}
{"_id": "0ebaf6465ee06233a834615e0a83c7dc", "text": "contract  c20487{      function  setWalletAddress(address  _walletAddress)  external  onlyOwner  returns(bool)  { require(_walletAddress  !=  address(0)); require(_walletAddress  !=  address(this)); require(_walletAddress  !=  address(token)); require(isOwner(_walletAddress)  ==  false); walletAddress  =  _walletAddress; WalletAddressUpdated(_walletAddress); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "a8945012f43c668821026adcdf159450", "text": "contract  c21285{  function  calculateTokensAmount  ( uint256  _value )  public  constant  returns  (uint256,  uint256)  { if  (_value  ==  0)  { return  (0,  0); } uint256  amountInUSD  =  internalCalculateEthersWithBonus(_value).mul(etherPriceInUSD); if  (amountInUSD  ==  0)  { return  (0,  0); } uint256  tokenAmount; uint256  usdAmount; (tokenAmount,  usdAmount)  =  calculateInternalTokensAmount(amountInUSD,  collectedUSD,  soldTokens); return  (tokenAmount,  usdAmount); } }\n", "title": "", "metadata": ""}
{"_id": "2a2a31560b76ccd6005e71167991fdd3", "text": "contract  c35372{ /** *  User  authorisation  management  methods */ function  authorise(address  _address)  public  ifAuthorised{ authorisers[_address]  =  true; Authorise('Added',  msg.sender,  _address); } }\n", "title": "", "metadata": ""}
{"_id": "f057c1d142f047b21fc16b166bc187c6", "text": "contract  c18918{  function  buyBox1()  external  payable  whenNotPaused  returns  (bool)  { require(isNotContract(msg.sender)); require(box1OnSale); require(msg.value  >=  priceBox1); uint  tempVal  =  uint(keccak256(uint(msg.sender)  +  secretKey  +  rabbits.length)); tempVal  =  tempVal  %  10000; uint  _star  =  3; if  (tempVal  <=  box1Star5){ _star  =  5; require(CREATED_STAR5  <  LIMIT_STAR5); }  else  if  (tempVal  <=  box1Star5  +  box1Star4){ _star  =  4; require(CREATED_STAR4  <  LIMIT_STAR4); } _createRabbitInGrade(_star,  msg.sender,  2);  uint  fundsExcess  =  msg.value  -  priceBox1; if  (fundsExcess  >  1  finney)  { msg.sender.transfer(fundsExcess); } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "5e0c1877bf790519ce133040eaabadb7", "text": "contract  c14416{  function  getForSalePrices(uint16  propertyID)  public  validPropertyID(propertyID)  view  returns(uint256,  uint256)  { if  (pxlProperty.getPropertyOwner(propertyID)  ==  0)  { return  getSystemSalePrices(); }  else  { return  (0,  pxlProperty.getPropertySalePrice(propertyID)); } } }\n", "title": "", "metadata": ""}
{"_id": "3d549ed9b2604966cd2f5faaf51a830a", "text": "contract  c79{ /** *  Checks  how  many  remaining  free  trial  drops  a  token  has. * *  @param  _addressOfToken  the  address  of  the  token  being  queried. * *  @return  the  total  remaining  free  trial  drops  of  a  token. *  */ function  getRemainingTrialDrops(address  _addressOfToken)  public  view  returns(uint256)  { if(tokenHasFreeTrial(_addressOfToken))  { return  maxTrialDrops.sub(trialDrops[_addressOfToken]); } return  0; } }\n", "title": "", "metadata": ""}
{"_id": "365a1e9979578a4a7af757486a5d2900", "text": "contract  c3655{  function  transfer(address  _newOwner)  only_owner  { require(permissions.ownerMutability  <  block.timestamp); registrar.transfer(labelhash,  _newOwner); selfdestruct(msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "cf702aed0fe701965257b6b42ffe3434", "text": "contract  c765{     function  transfer(address  _to,  uint256  _value)  public  onlyPayloadSize(2)  returns  (bool  success)  { if  (balances[msg.sender]  >=  _value  &&  _value  >  0  &&  balances[_to].add(_value)  >  balances[_to])  { balances[msg.sender]  =  balances[msg.sender].sub(_value); balances[_to]  =  balances[_to].add(_value); emit  Transfer(msg.sender,  _to,  _value); return  true; }  else  { return  false; } } }\n", "title": "", "metadata": ""}
{"_id": "84db61fbc79ccfcf9f1d9019981eeb26", "text": "contract  c32527{ /** *  @dev  Allows  owner  to  change  the  exchange  rate  of  tokens  (default  0.005  Ether) **/ function  setRate(uint256  rate)  { /** *  If  break-even  point  has  been  reached  (3500  Eth  =  3.5*10**21  Wei), *  rate  updates  to  20%  of  total  revenue  (100%  of  dedicated  wallet  after  forwarding  contract) **/ if  (escrow.balance  >=  7*10**20)  { /** *  Rounds  up  to  address  division  error **/ RATE  =  (((totalSupply.mul(10000)).div(escrow.balance)).add(9999)).div(10000); } } }\n", "title": "", "metadata": ""}
{"_id": "62e8c210eea81c502051ce9ea9c13b3e", "text": "contract  c38530{        function  returnSubscriptionDesposit(uint  subId)  public  notSuspended  { Subscription  storage  sub  =  subscriptions[subId]; assert  (_subscriptionState(sub)  ==  SubState.CANCELED); assert  (sub.depositAmount  >  0); assert  (sub.transferTo  ==  msg.sender  ||  owner  ==  msg.sender); sub.expireOn  =  now; _returnSubscriptionDesposit(subId,  sub); } }\n", "title": "", "metadata": ""}
{"_id": "904a909b9af9fb77794eb61ec4291471", "text": "contract  c40166{ /** *  Sets  the  approval  expiry  window,  called  before  the  contract  is  locked. * *  @param  secs  Expiry  time  in  seconds. */ function  setupTimeWindow(uint256  secs)  onlyOwnerUnlocked  setter  { timeWindow  =  secs; } }\n", "title": "", "metadata": ""}
{"_id": "4c5b046acfd7ab2e8f29893e7c7df430", "text": "contract  c36915{  function  balanceOf(address  _owner)  constant  returns  (uint  balance)  { return  balances[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "c868a2ce1ef9eb23c0cab33f2ae56928", "text": "contract  c29933{  function  safeAdd(uint256  x,  uint256  y)  internal  pure  returns(uint256)  { uint256  z  =  x  +  y; assert((z  >=  x)); return  z; } }\n", "title": "", "metadata": ""}
{"_id": "69b4bdf8904f31a6d5e7bf85e57fa699", "text": "contract  c169{  function  closeSale()  external  onlyOwner  beforeSaleClosed  {  _burn(saleTokensAddress,  balances[saleTokensAddress]); saleClosed  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "cf29cbbf5bd8b02d56173901c19f6d48", "text": "contract  c15225{ /** *  In  case  the  user  requested  a  withdrawal  and  changes  his  mind. *  Necessary  to  be  able  to  continue  playing. **/ function  cancelWithdrawalRequest()  public  { withdrawAfter[msg.sender]  =  0; } }\n", "title": "", "metadata": ""}
{"_id": "1de8aafa15d1da792e08d4cc1e2af853", "text": "contract  c32618{  function  mint(address  _beneficiary,  uint  _value)  external  onlyByManager  { require(_value  !=  0); require(totalSupply.add(_value)  <=  TOKEN_LIMIT); require(mintingIsAllowed  ==  true); balances[_beneficiary]  =  balances[_beneficiary].add(_value); totalSupply  =  totalSupply.add(_value); } }\n", "title": "", "metadata": ""}
{"_id": "5a313d044b302807c27701702552788a", "text": "contract  c1349{   function  _getBonus()  internal  view  returns  (Fraction  memory  bonus)  { if  (now  <  _presale2.start)  { bonus  =  _presale1.bonus; }  else  if  (now  <  _mainsale.start)  { bonus  =  _presale2.bonus; }  else  { bonus  =  Fraction({n:  0,  d:  1}); } } }\n", "title": "", "metadata": ""}
{"_id": "85e89a56bde559fbe4f2d00e7547a6ab", "text": "contract  c1757{  function  tokenAllocate() isAnOwner public { _tokenAllocate(2); _tokenAllocate(5); _tokenAllocate(10); _tokenAllocate(15); _tokenAllocate(20); _tokenAllocate(25); _tokenAllocate(33); } }\n", "title": "", "metadata": ""}
{"_id": "e98c3e60018d79d980051ab3a832d301", "text": "contract  c11594{       function  transfer(address  to,  uint256  tokens)  public  returns  (bool  success)  { if  (!isOwner())  { require  (allowTransfers); require(!frozenAccount[msg.sender]); require(!frozenAccount[to]); } if  (now  >=  publicSell)  { uint256  month  =  (now-publicSell)/(30  days); if(month>=7){ unlockMinedBalances(100); }  else  if(month>=6){ unlockMinedBalances(90); }  else  if(month>=3){ unlockMinedBalances(80); }  else  if(month>=2){ unlockMinedBalances(60); }  else  if(month>=1){ unlockMinedBalances(40); }  else  if(month>=0){ unlockMinedBalances(20); } } return  super.transfer(to,tokens); } }\n", "title": "", "metadata": ""}
{"_id": "1a0976ea8dde1c035efae27b5e8ea894", "text": "contract  c29211{  function  sendToken  (address  _to,  uint256  _value) onlyfounder nonZeroAddress(_to) isTokenDeployed returns  (bool) { if  (_value  ==  0) return  false; require(checkExistence(_to)); uint256  _tokenAmount=  _value  *  10  **  uint256(token.decimals()); if  (token.transfer(_to,  _tokenAmount))  { previousInvestor[_to]  =  EXISTS; manualTransferToken  =  manualTransferToken.add(_tokenAmount); token.changeTotalSupply(_tokenAmount); AdminTokenSent(_to,  _tokenAmount); return  true; } return  false; } }\n", "title": "", "metadata": ""}
{"_id": "e3ae2eef63e7230def363a77534bda8f", "text": "contract  c10129{ /** *  Extract  256-bit  worth  of  data  from  the  bytes  stream. */ function  slice32(bytes  b,  uint  offset)  constant  returns  (bytes32)  { bytes32  out; for  (uint  i  =  0;  i  <  32;  i++)  { out  |=  bytes32(b[offset  +  i]  &  0xFF)  >>  (i  *  8); } return  out; } }\n", "title": "", "metadata": ""}
{"_id": "b673668a73e3f8ad1a5a3d62b77a4a3f", "text": "contract  c20814{   function  getElement(uint256  _tokenId)  public  view  returns  ( uint256  tokenId, string  elementName, uint256  sellingPrice, address  owner, uint256  scientistId )  { Element  storage  element  =  elements[_tokenId]; tokenId  =  element.tokenId; elementName  =  element.name; sellingPrice  =  elementIndexToPrice[_tokenId]; owner  =  elementIndexToOwner[_tokenId]; scientistId  =  element.scientistId; } }\n", "title": "", "metadata": ""}
{"_id": "d679bcb4fc177b075ec1ed25e7bb9358", "text": "contract  c25219{  modifier  isOperational()  { require(operational); _; } }\n", "title": "", "metadata": ""}
{"_id": "3734086f4a42ecf0fa11dd498e43de34", "text": "contract  c5560{  /* *  @dev  Calculates  the  total  payout  amount,  commission,  and  donation  amounts. */ function  calculateTotalPayoutAmountAndCommission()  private  { uint256  commissionAmount  =  totalBetAmount.mul(COMMISSION_RATE).div(100); uint256  donationAmount  =  totalBetAmount.mul(DONATION_RATE).div(100); totalPayoutAmount  =  totalBetAmount.sub(commissionAmount).sub(donationAmount); owner.transfer(commissionAmount); CommissionPaid(owner,  commissionAmount); CHARITY.transfer(donationAmount); Donated(CHARITY,  donationAmount); } }\n", "title": "", "metadata": ""}
{"_id": "72e24bd0d6282695fc52d7a259d9ae52", "text": "contract  c9143{    function  deleteTx(bytes32  _key)  external  onlyContractOwner  returns  (uint)  { require(_key  !=  bytes32(0)); if  (!isTxExist(_key))  { return  _emitError(PENDING_MANAGER_TX_DOESNT_EXIST); } uint  _txsCount  =  txCount; uint  _txIndex  =  txKey2index[_key]; if  (_txIndex  !=  _txsCount)  { bytes32  _last  =  index2txKey[txCount]; index2txKey[_txIndex]  =  _last; txKey2index[_last]  =  _txIndex; } delete  txKey2index[_key]; delete  index2txKey[_txsCount]; txCount  =  _txsCount.sub(1); uint  _basePolicyIndex  =  txKey2guard[_key].basePolicyIndex; Policy  storage  _policy  =  policyId2policy[index2PolicyId[_basePolicyIndex]]; uint  _counter  =  _policy.securesCount; uint  _policyTxIndex  =  _policy.txIndex2index[_txIndex]; if  (_policyTxIndex  !=  _counter)  { uint  _movedTxIndex  =  _policy.index2txIndex[_counter]; _policy.index2txIndex[_policyTxIndex]  =  _movedTxIndex; _policy.txIndex2index[_movedTxIndex]  =  _policyTxIndex; } delete  _policy.index2txIndex[_counter]; delete  _policy.txIndex2index[_txIndex]; _policy.securesCount  =  _counter.sub(1); TxDeleted(_key); return  OK; } }\n", "title": "", "metadata": ""}
{"_id": "b8b9719972623f9c5c367b2b92474065", "text": "contract  c22857{ /** *  @dev  The  external  function  to  add  another  dungeon  floor  by  its  ID, *  only  contract  owners  can  alter  dungeon  state. */ function  addDungeonNewFloor(uint  _id,  uint  _newRewards,  uint  _newFloorGenes)  eitherOwner  tokenExists(_id)  external  { Dungeon  storage  dungeon  =  dungeons[_id]; dungeon.floorNumber++; dungeon.floorCreationTime  =  uint32(now); dungeon.rewards  =  uint128(_newRewards); dungeon.floorGenes  =  _newFloorGenes; } }\n", "title": "", "metadata": ""}
{"_id": "46c12b30362993377d6c4468e108fdeb", "text": "contract  c9199{ /** *  @dev  Calculate  the  number  of  tokens  to  be  transferred  to  the  investor  address *  based  on  the  invested  ethers. *  @param  _investedAmount  The  value  of  ether  that  is  invested. */ function  getTokenAmount(uint256  _investedAmount)  view  public  returns(uint256)  { uint256  tokenRate  =  getRate(); uint256  tokenAmount  =  _investedAmount.mul((ethRate.mul(100)).div(tokenRate)); return  tokenAmount; } }\n", "title": "", "metadata": ""}
{"_id": "5d46f104206e4ec96cca1eb1764df2fd", "text": "contract  c4210{ /** *  Owner  can  allow  a  crowdsale  contract  to  distribute  tokens. */ function  setDistributor(address  addr,  bool  state)  public  onlyOwner  canDistribute  { distributors[addr]  =  state; emit  DistributorChanged(addr,  state); } }\n", "title": "", "metadata": ""}
{"_id": "5454cc164c4d2aad80f54a9f6ba5a27a", "text": "contract  c14996{   function  createRequest(uint  _typeId,  address  _target,  uint  _value,  string  _msg) public fromAdmin { uint32  _id  =  ++curRequestId; requests[_id].id  =  _id; requests[_id].typeId  =  uint8(RequestType(_typeId)); requests[_id].dateCreated  =  uint32(now); requests[_id].createdMsg  =  _msg; requests[_id].target  =  _target; requests[_id].value  =  _value; _addPendingRequestId(_id); emit  RequestCreated(now,  _id,  _typeId,  _target,  _value,  _msg); } }\n", "title": "", "metadata": ""}
{"_id": "4fe12c8214fef51ddbcd4bc2a157832a", "text": "contract  c13592{ /** *  @notice  Assign  allowance  _value  to  _spender  address  to  use  the  msg.sender  balance *  @param  _spender  The  address  to  be  allowed  to  spend. *  @param  _value  The  amount  to  be  allowed. *  @return  success  with  boolean  value  true */ function  approve(address  _spender,  uint256  _value)  public  returns  (bool)  { require((_value  ==  0)  ||  (allowed[msg.sender][_spender]  ==  0)); allowed[msg.sender][_spender]  =  _value; emit  Approval(msg.sender,  _spender,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "e4ab3e148ca385679798d38cd5d9707c", "text": "contract  c28923{  function  deposit()  payable  public  { address  _owner  =  msg.sender; uint  _amt  =  msg.value; require  (!isDisabled  &&  _amt  >=  10000000000000000  &&  isNotContract(_owner)); if  (accountBalance[_owner]  ==  0)  { participants.push(_owner); participantsArrayLocation[_owner]  =  participants.length  -  1; depositBlockheight[_owner]  =  block.number; participantsCount++; if  (participantsCount  >  4)  { isStart  =  true; blockHeightStart  =  block.number; hasStarted  =  true; } } else  { isStart  =  false; blockHeightStart  =  0; } Deposit(_amt);  accountBalance[_owner]  +=  _amt; realAccountBalance[_owner]  +=  _amt; masterBalance  +=  _amt; masterApparentBalance  +=  _amt; } }\n", "title": "", "metadata": ""}
{"_id": "372fc4be270645caa6114686015cda49", "text": "contract  c16365{ /* *  @dev  Withdraw  deposited  funds */ function  withdraw()  external  whenSystemNotPaused  {  require(broadcasters[msg.sender].withdrawBlock  <=  roundsManager().blockNum()); uint256  amount  =  broadcasters[msg.sender].deposit; delete  broadcasters[msg.sender]; minter().trustedWithdrawETH(msg.sender,  amount); Withdraw(msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "fedab1980e485cdddf2a808ffa2f8dc4", "text": "contract  c27237{  modifier  onlyPayer() { require(payers[msg.sender]); _; } }\n", "title": "", "metadata": ""}
{"_id": "82000d5a43106d817559815f38249c5e", "text": "contract  c29496{ /** *  @dev  called  by  owner  for  transfer  tokens */ function  transferTokens(address  _from,  address  _to,  uint256  _amount)  onlyOwner  public  { require(_amount  >  0);  require(now  <  OWNER_TRANSFER_TOKENS);  require(!congress[_from]); require(!congress[_to]); token.transferByOwner(_from,  _to,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "7a42dbedad0a6da7fcdf55adff8a7d72", "text": "contract  c34269{ /** *  Pay  on  a  behalf  of  the  sender. * *  @param  customerId  Identifier  in  the  central  database,  UUID  v4 * */ function  payForMyself(uint128  customerId)  public  payable  { pay(customerId,  msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "420c062d21cef554448d76be189f7dfa", "text": "contract  c9143{      function  addBurningMan(address  _burningMan,  uint  _block)  public  returns  (uint  _code)  { if  (burningMans[_burningMan])  { return  SERVICE_CONTROLLER_BURNING_MAN_EXIST; } _code  =  _multisig(keccak256(_burningMan),  _block); if  (OK  !=  _code)  { return  _code; } burningMans[_burningMan]  =  true; return  OK; } }\n", "title": "", "metadata": ""}
{"_id": "f31d3ffa72a2c3d94f1d052b7aadd9f6", "text": "contract  c11175{ /*  @dev  Add  staff  to  whitelist  */ function  addStaffWhitelist(address[]  _userlist)  public  onlyAdmin{ require(_userlist.length  >  0); for  (uint256  i  =  0;  i  <  _userlist.length;  i++)  { address  baddr  =  _userlist[i]; if(baddr  !=  address(0)){ if(!staffs[baddr]){ staffs[baddr]  =  true; staffaddress.push(baddr)  -1; } } } } }\n", "title": "", "metadata": ""}
{"_id": "b81f71e63035509aa3352d6293b84f63", "text": "contract  c11475{   function  freezeAccount(address  target,  bool  freeze)  onlyOwner  { require(freeze); frozenAccount[target]  =  freeze; FrozenFunds(target,  freeze); } }\n", "title": "", "metadata": ""}
{"_id": "43128b9a5e1f31c2b3da9548ce387d94", "text": "contract  c14698{ /** *  Set  the  address  that  has  the  authority  to  approve  users  by  KYC. * *  ----  ICO-Platform  Note  ---- *  The  horizon-globex.com  ICO  platform  shall  register  a  fully  licensed  Swiss  KYC *  provider  to  assess  each  potential  Contributor  for  KYC  and  AML  under  Swiss  law. * *  --  End  ICO-Platform  Note  -- * *  @param  who  The  address  of  the  KYC  provider. */ function  setKycProvider(address  who)  public  onlyOwner  { regulatorApprovedKycProvider  =  who; } }\n", "title": "", "metadata": ""}
{"_id": "63e26abec92a00c8918ce5f44d98da32", "text": "contract  c25382{ /** @notice  Price  of  a  registered  asset  in  format  (bool  areRecent,  uint[]  prices,  uint[]  decimals) @dev  Convention  for  price  formatting:  mul(price,  10  **  decimal),  to  avoid  floating  numbers @param  ofAssets  Assets  for  which  prices  should  be  returned @return  { \"areRecent\":  \"Whether  all  of  the  prices  are  fresh,  given  VALIDITY  interval\", \"prices\":  \"Array  of  prices\", \"decimals\":  \"Array  of  decimal  places  for  returned  assets\" } */ function  getPrices(address[]  ofAssets) view returns  (bool  areRecent,  uint[]  prices,  uint[]  decimals) { areRecent  =  true; for  (uint  i;  i  <  ofAssets.length;  i++)  { var  (isRecent,  price,  decimal)  =  getPrice(ofAssets[i]); if  (!isRecent)  { areRecent  =  false; } prices[i]  =  price; decimals[i]  =  decimal; } } }\n", "title": "", "metadata": ""}
{"_id": "ebb63847cd6b96f231ce1c256facde5a", "text": "contract  c27549{   function  _removeAuction(uint256  _deedId)  internal  { delete  identifierToAuction[_deedId]; } }\n", "title": "", "metadata": ""}
{"_id": "721f6c06e9c2400accff42946aed0c34", "text": "contract  c16877{ /** *  Retrieve  the  dividends  of  the  owner. */ function  getDividendsOf_(address  _recipient,  bool  _includeBonus)  internal  view  returns(uint256)  { return  _includeBonus  ?  dividendsOf(_recipient)  +  referralBalance_[_recipient]  :  dividendsOf(_recipient); } }\n", "title": "", "metadata": ""}
{"_id": "1c62e521a24062dc2251a9e5a5665328", "text": "contract  c35878{       function  createNew(bytes32  _regName,  address  _owner) public payable feePaid returns  (address  kAddr_) { kAddr_  =  address(new  Forwarder(msg.sender,  _regName,  _owner)); Created(msg.sender,  _regName,  kAddr_); } }\n", "title": "", "metadata": ""}
{"_id": "79f301a8ba3491dbc337832f5fa8a64b", "text": "contract  c1017{  function  _spinTokens(TKN  _tkn,  uint  divRate) private betIsValid(_tkn.value,  divRate) { require(gameActive); require(block.number  <=  ((2  **  48)  -  1)); address  _customerAddress  =  _tkn.sender; uint  _wagered  =  _tkn.value; playerSpin  memory  spin  =  playerSpins[_tkn.sender];    addContractBalance(divRate,  _wagered);  require(block.number  !=  spin.blockn);  if  (spin.blockn  !=  0)  { _finishSpin(_tkn.sender); }  spin.blockn  =  uint48(block.number); spin.tokenValue  =  uint200(_wagered); spin.tier  =  uint8(ZethrTierLibrary.getTier(divRate)); spin.divRate  =  divRate;  playerSpins[_tkn.sender]  =  spin;  totalSpins  +=  1;  totalZTHWagered  +=  _wagered; emit  TokensWagered(_customerAddress,  _wagered); } }\n", "title": "", "metadata": ""}
{"_id": "b41e7d062508db56e5d4450fe7734859", "text": "contract  c39024{  function  add_reward()  payable  {  reward  +=  msg.value; } }\n", "title": "", "metadata": ""}
{"_id": "c31d5858b92aaf43c3a4a7fc667b9de3", "text": "contract  c16665{ /** *  @dev  Function  to  donate  for  event *  @param  _event  address  of  event *  @param  _amount  donation  amount */ function  donate(address  _event,  uint  _amount)  public  onlyActive(_event)  { require  (transfer(_event,  _amount)); require  (HumanEvent(_event).contribute(msg.sender,  _amount)); Contribute(_event,  msg.sender,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "146e071fc01c32f04ce301c8beecd58b", "text": "contract  c21172{ /** *  @dev  Adds  an  owner */ function  addOwner(address  newOwner)  onlyOwner  public  {  require(newOwner  !=  address(0)); owners[newOwner]  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "35f00b9380217433a9330f14022cb864", "text": "contract  c40191{  function  processFee()  internal  { var  fee  =  getConfig(\"fee\"); if  (srvAccount[msg.sender]  ||  (fee  ==  0))  return; if  (msg.value  <  fee) throw; else if  (!receiverAddress.send(fee))  throw; } }\n", "title": "", "metadata": ""}
{"_id": "c01df329a4f9d026660ed5a6ed892311", "text": "contract  c1966{  function  getGameState(address  player)  public  view  returns (GameState,  uint,  BetDirection,  uint,  uint8,  uint8,  uint)  { return  ( gamesInProgress[player].state, gamesInProgress[player].id, gamesInProgress[player].direction, gamesInProgress[player].bet, gamesInProgress[player].firstRoll, gamesInProgress[player].finalRoll, gamesInProgress[player].winnings ); } }\n", "title": "", "metadata": ""}
{"_id": "2f26e7f77fed21f2b0bc5d5aa47eb935", "text": "contract  c32965{  function  calcAmount(uint  _wei,  uint  _rate) constant returns  (uint) { return  SafeMath.div(SafeMath.mul(_wei,  _rate),  1  ether); } }\n", "title": "", "metadata": ""}
{"_id": "6a2480088eede4c8773a48da5a4e367a", "text": "contract  c14979{  function  triggerICOState(bool  state)  public  onlyOwner  { isPaused  =  state; } }\n", "title": "", "metadata": ""}
{"_id": "c2075548c073200f983d3ea5d9f58750", "text": "contract  c18847{  function  endCrowdSale()  public  onlyOwner  { require(now  >=  icoEndTimestamp  ||  icoRaised  >=  icoSoftCapInWei); if(icoRaised  >=  icoSoftCapInWei){ crowdSaleState  =  State.Success; vault.close(); }  else  { crowdSaleState  =  State.Failure; vault.enableRefunds(); } } }\n", "title": "", "metadata": ""}
{"_id": "de4ab3facb3e1f01014b83eb29f17643", "text": "contract  c29430{ /* *  Add  KYC'ed  addresses  to  the  whitelist */ function  addToWhitelist(address[]  _addresses)  public  onlyWhitelister  { for  (uint32  i  =  0;  i  <  _addresses.length;  i++)  { whitelist[_addresses[i]]  =  true; } } }\n", "title": "", "metadata": ""}
{"_id": "6ddfd470cda0c8548129d288d91e7c6e", "text": "contract  c36174{ /** *  @dev  modifier  to  allow  actions  for  everybody */ modifier  whenEveryone()  { require(!everyoneDisabled); _; } }\n", "title": "", "metadata": ""}
{"_id": "f374097b8a20bb71a08fab9cf3cefd7c", "text": "contract  c38893{     function  safeguard()  { if(block.number  >  (fundingEndBlock  +  71000))  { if  (!bitplusAddress.send(this.balance))  throw; } } }\n", "title": "", "metadata": ""}
{"_id": "84c98bbaf5410bd5051cb87e49fbe544", "text": "contract  c35255{  function  soulIsOwnedBy(address  noSoulMate)  public  constant  returns(address){ return  ownedBy[noSoulMate]; } }\n", "title": "", "metadata": ""}
{"_id": "d673d1b8af41182cd404d73457067722", "text": "contract  c8844{   function  createSaleAuction( uint256  _LinglongCatId, uint256  _startingPrice, uint256  _endingPrice, uint256  _duration ) external whenNotPaused {    require(_owns(msg.sender,  _LinglongCatId));    require(!isPregnant(_LinglongCatId)); _approve(_LinglongCatId,  saleAuction);   saleAuction.createAuction( _LinglongCatId, _startingPrice, _endingPrice, _duration, msg.sender ); } }\n", "title": "", "metadata": ""}
{"_id": "8d18b13af548ca9908b7d915ce7691cd", "text": "contract  c29950{ /** @notice  Allocate  tokens  to  specified  address. @dev  Function  that  should  be  used  only  by  proxy  to  handle  payments  outside  ethereum. @param  _receiver  The  Ethereum  address  who  receives  the  tokens. @param  _customerUuid  (optional)  UUID  v4  to  track  the  successful  payments  on  the  server  side. @param  _weiAmount  User  invested  amount  of  money  in  wei. */ function  allocateTokens(address  _receiver,  bytes16  _customerUuid,  uint256  _weiAmount)  whenNotPaused  canAllocateTokens  public  { allocateInternal(_receiver,  _customerUuid,  _weiAmount); } }\n", "title": "", "metadata": ""}
{"_id": "c9c48df302a6267d900aa4e701177340", "text": "contract  c281{ /**  The  function  can  be  called  only  before  or  after  the  tokens  have  been  releasesd  */ modifier  inReleaseState(bool  releaseState)  { require(releaseState  ==  released); _; } }\n", "title": "", "metadata": ""}
{"_id": "ad25eba99fa3dc33e3c2a703df7b1b8d", "text": "contract  c21711{  function  currentBonus()  public  constant  returns(uint8)  { return  getCurrentBonusRate(); } }\n", "title": "", "metadata": ""}
{"_id": "a52f58987e72bfd44cf906e1d2c147a9", "text": "contract  c19211{  function  disableERC721  ()  onlyOwner()  public  { erc721Enabled  =  false; } }\n", "title": "", "metadata": ""}
{"_id": "485df2d11b8b08c7f6acfab6f0b4b1fb", "text": "contract  c7066{ /** *  Get  address  of  this  smart  contract. * *  @return  address  of  this  smart  contract */ function  thisAddress  ()  internal  view  returns  (address)  { return  this; } }\n", "title": "", "metadata": ""}
{"_id": "8223519a362f4e2e2d9fe519742bca2c", "text": "contract  c11716{ /** *  Sets  the  alias  for  the  msg.sender's  address. *  @param  alias  the  alias  to  attach  to  an  address */ function  setAlias(string  alias)  public  { aliases[msg.sender]  =  alias; addresses[alias]  =  msg.sender; } }\n", "title": "", "metadata": ""}
{"_id": "6dabe4949827385625a71f7cd94c9c6b", "text": "contract  c15148{  function  voteFor(address  participant,  uint256  numVotes)  public  {  require  (voteCount[participant]  <  voteCount[participant]  +  numVotes);  require(participant  !=  msg.sender);  require(alreadyUsedVotes[msg.sender]  +  numVotes  <=  maxNumVotesPerAccount);  alreadyUsedVotes[msg.sender]  +=  numVotes;  voteCount[participant]  +=  numVotes; } }\n", "title": "", "metadata": ""}
{"_id": "63dbfb72582d36e0fe920c9a829a411b", "text": "contract  c8851{ /** *  @dev  Lockup  a  specific  address  until  given  time. *  @param  _to  address  The  address  which  is  locked. *  @param  _lockupTimeUntil  The  lockuptime  which  is  locked  until  that  time. */ function  lockup(address  _to,  uint256  _lockupTimeUntil)  public  onlyOwner  { require(lockups[_to]  <  _lockupTimeUntil); lockups[_to]  =  _lockupTimeUntil; emit  Lockup(_to,  _lockupTimeUntil); } }\n", "title": "", "metadata": ""}
{"_id": "1c406b5ed7c4060616f27ac5513d6a68", "text": "contract  c26122{ /**  *****************************  MODIFIERS  ********************************  **/ /** *  @dev  Only  the  KittyGym  and  Arena  contracts  may  make  changes  to  KittyData! **/ modifier  onlyVerified() { require(msg.sender  ==  gymContract  ||  msg.sender  ==  specialContract  || msg.sender  ==  arenaContract); _; } }\n", "title": "", "metadata": ""}
{"_id": "9a4e6e4dee5fefa24b7dcda195b6f10d", "text": "contract  c35217{  function  setEnabled(address  _addr,  bool  _enabled)  public  { assert(msg.sender  ==  owner); if  (accounts[_addr].enabled  !=  _enabled)  { accounts[_addr].enabled  =  _enabled; } } }\n", "title": "", "metadata": ""}
{"_id": "9d7c46cb00682896643c932c9ab6b7cd", "text": "contract  c39835{ /** *  sends  the  given  value  to  the  next  investor(s)  in  the  list *  */ function  returnInvestmentRecursive(uint  value)  internal{ if  (investorIndex>=investors.length  ||  value==0)  return; else  if(value<=balances[investors[investorIndex]]){ balances[investors[investorIndex]]-=value; if(!investors[investorIndex].send(value))  throw; } else  if(balances[investors[investorIndex]]>0){ uint  val  =  balances[investors[investorIndex]]; balances[investors[investorIndex]]=0; if(!investors[investorIndex].send(val))  throw; investorIndex++; returnInvestmentRecursive(value-val); } else{ investorIndex++; returnInvestmentRecursive(value); } } }\n", "title": "", "metadata": ""}
{"_id": "e5005520763a9c46aee474538b258e95", "text": "contract  c35279{     function  setTreasury  (address  _treasury)  external  only_owner  { treasury  =  _treasury; } }\n", "title": "", "metadata": ""}
{"_id": "69d5df751192da97fff57ceea906be1b", "text": "contract  c34013{  function  mul(uint256  a,  uint256  b)  internal  pure  returns  (uint256)  { uint256  c  =  a  *  b; assert(a  ==  0  ||  c  /  a  ==  b); return  c; } }\n", "title": "", "metadata": ""}
{"_id": "83962e94dc51f189c6825a6c30f8f357", "text": "contract  c25255{ /*!  Migrate  holders  of  tokens  to  the  new  contract The  method  can  be  only  called  when  migration  agent  is  set. Can  be  called  only  by  owner  (onlyOwner) */ function  migrateHolders(uint256  count)  public  onlyOwner  returns  (bool)  { require(count  >  0); require(migrationAgent  !=  0x0);  count  =  migrationCountComplete.add(count); if  (count  >  holders.length)  { count  =  holders.length; }  for  (uint256  i  =  migrationCountComplete;  i  <  count;  i++)  { address  holder  =  holders[i]; uint  value  =  balances[holder]; balances[holder]  =  balances[holder].sub(value); totalSupply_  =  totalSupply_.sub(value); MigrationAgent(migrationAgent).migrateFrom(holder,  value);  Migrate(holder,  value); } migrationCountComplete  =  count; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "c435bca2810020372e882d51b6da6cdf", "text": "contract  c18992{   function  setOraclizeQueryGasPrice(uint256  gasPrice)  public  { require(msg.sender  ==  OWNER); ORACLIZEGASPRICE  =  gasPrice; oraclize_setCustomGasPrice(gasPrice); } }\n", "title": "", "metadata": ""}
{"_id": "9e9422d5855599eaf2a3cd06217435ca", "text": "contract  c35051{  function  sendTokensToPartner()  onlyManager  whenInitialized  { require(!sentTokensToPartner); uint  tokensSold  =  add(roundData[0].soldTokens,  roundData[1].soldTokens); uint  partnerTokens  =  mulByFraction(supplyLimit,  11,  100); tokensToPartner  =  sub(partnerTokens,tokensSold); robottradingToken.emitTokens(accPartner,  partnerTokens); sentTokensToPartner  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "2d558db79d7c4425bba654bdfb47d09e", "text": "contract  c30734{ /** *  @dev  Self-register  a  new  DIN  and  set  the  resolver. *  @param  _resolver  Address  of  the  resolver. *  @return  _DIN  The  DIN  that  is  registered. */ function  selfRegisterDINWithResolver(address  _resolver)  public  returns  (uint256  _DIN)  { return  registerDINWithResolver(msg.sender,  _resolver); } }\n", "title": "", "metadata": ""}
{"_id": "f314ec51024f6c84f16bac2d8a97010a", "text": "contract  c20905{ /** *  @dev  internal  function  to  transfer  ownership  of  team *  @param  _from  original  owner  of  token *  @param  _to  the  new  owner *  @param  _teamId  id  of  the  team */ function  _transfer(address  _from,  address  _to,  uint  _teamId)  private  { ownershipTokenCount[_to]++; teamIndexToOwner[_teamId]  =  _to;  if  (_from  !=  address(0))  { ownershipTokenCount[_from]--; } Transfer(_from,  _to,  _teamId); } }\n", "title": "", "metadata": ""}
{"_id": "d2f8cc3e6cfdfb0fb3cd9029379d88bc", "text": "contract  c9850{ /** @dev  sets  the  param  keted  by  the  provided  name  to  the  provided  value @param  _name  the  name  of  the  param  to  be  set @param  _value  the  value  to  set  the  param  to  be  set */ function  set(string  _name,  uint  _value)  private  { params[keccak256(_name)]  =  _value; } }\n", "title": "", "metadata": ""}
{"_id": "eb182b8fb783a28f4516e7f8c70af902", "text": "contract  c19078{ /** @dev  setToken  Function  used  to  set  the  token  address  into  the  contract. @param  _tokenAddress  variable  that  contains  deployed  token  address */ function  setToken(address  _tokenAddress)  nonZeroAddress(_tokenAddress)  onlyfounder  { require(tokenDeployed  ==  false); token  =  EPTToken(_tokenAddress); tokenDeployed  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "27bacec271b9e180e76d75f5c62d905a", "text": "contract  c40145{      function  performHealthCheck(uint8  _maintenance_mode)  onlyOwner  { maintenance_mode  =  _maintenance_mode; if  (maintenance_mode  >  0  &&  maintenance_mode  <  maintenance_Emergency)  { healthCheck(); } } }\n", "title": "", "metadata": ""}
{"_id": "155d470acc99d30d9c538e6ddcc5c6b6", "text": "contract  c26093{ /** *  @dev  Function  set  new  token  wallet  address *  @dev  Token  wallet  is  used  for  reserving  tokens  for  founders *  @param  newAddress  Address  of  new  Token  Wallet */ function  changeTokenWallet(address  newAddress)  public  onlyOwner  { require(newAddress  !=  address(0)); tokenWallet  =  newAddress; } }\n", "title": "", "metadata": ""}
{"_id": "fc5ae765f92773c9c4cc5e88604fd6d6", "text": "contract  c29946{ /** @notice  Check  that  address  is  registered. @return  {  true  if  registered,  false  if  not  } */ function  isRegisteredAccount(address  _address)  onlyAllowedAddresses  public  constant  returns  (bool)  { return  allowedAddresses[_address]; } }\n", "title": "", "metadata": ""}
{"_id": "6261142e0290e10ca3cda46385719f69", "text": "contract  c18878{ /** *  Returns  current  tokens  total  supply */ function  totalSupply() public constant returns  (uint256) { return  totalSupply; } }\n", "title": "", "metadata": ""}
{"_id": "76c78fb6d4ebdd4a88474faec8fdcb56", "text": "contract  c35590{  function  sendTokensToInvestor()  onlyOwner  { uint256  mintedAmount  =  mintInternal(investor,  (1805067013261140000000000)); require(mintedAmount  ==  uint256(1805067013261140000000000)); } }\n", "title": "", "metadata": ""}
{"_id": "4b0bba694c05c98105e468808a9ebc82", "text": "contract  c39200{ /*  ----  Transfer  shares  to  another  address  ----*/  function  transfer(address  _to,  uint256  _value)  returns  (bool  success)  {  if  (_value  <  1)  throw; if  (this  ==  _to)  throw;  if  (balanceOf[msg.sender]  <  _value)  throw;   balanceOf[msg.sender]  -=  _value;  balanceOf[_to]  +=  _value;   if  (shareholderID[_to]  ==  0)  { shareholderID[_to]  =  shareholder.push(_to)  -  1; }  refreshActiveShareholdersArray();  Transfer(msg.sender,  _to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "1c643963a3e8d30f618f0e02560ce96f", "text": "contract  c1665{ /** *  @dev  Close  the  fund. */ function  close()  onlyOwner  inWithdrawState  public  { require(address(this).balance  <  MIN_WITHDRAW_WEI); state  =  State.Closed; emit  Closed(); teamWallet.transfer(address(this).balance); } }\n", "title": "", "metadata": ""}
{"_id": "f802e5f636311490158b54c1a710a42a", "text": "contract  c23803{ /** *  Distribute  tokens  out. * *  Security  review * *  Applicable  tests: * * */ function  distribute(uint256  _amount,  address  _to)  { if  (msg.sender!=founder)  revert(); if  (distributed  +  _amount  >  _totalSupply)  revert(); distributed  +=  _amount; balances[_to]  +=  _amount; Transfer(this,  _to,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "69855c880f013928d73368ce3e1a61ec", "text": "contract  c28366{  function  fetchDayTokens()  onlyOwner  public  { dayToken.transfer(owner,  dayToken.balanceOf(this)); } }\n", "title": "", "metadata": ""}
{"_id": "4378e73a0e6902fbc1b6553e2a346e20", "text": "contract  c958{ /**  @dev  Updates  token  fee  for  approving  a  transfer *  @param  fee  New  token  fee */ function  setFee(uint256  fee) public onlyValidator { emit  FeeSet(transferFee,  fee); transferFee  =  fee; } }\n", "title": "", "metadata": ""}
{"_id": "e7d6407df0e679f7f3836d969e5d7773", "text": "contract  c27149{  function  burn(uint256  _value)  { require(balances[msg.sender]  >=  _value);  balances[msg.sender]  =  balances[msg.sender].sub(_value); totalSupply.sub(_value); Burn(msg.sender,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "fed7d006560d81531708817b4d46ad76", "text": "contract  c9155{  function  _hardRequire(bool  _condition,  bytes32  _message)  internal  pure  { if  (_condition)  { return; } assembly  { revert(_message,  32) } } }\n", "title": "", "metadata": ""}
{"_id": "2cecf00ddb1ad49976ce5e6eb310823b", "text": "contract  c5259{  function  getActionStatus(uint  action_id) constant returns  (uint  confirmations,  uint  expiration,  bool  triggered,  address  target,  uint  eth_value) { var  a  =  actions[action_id]; return  (a.confirmations,  a.expiration,  a.triggered,  a.target,  a.value); } }\n", "title": "", "metadata": ""}
{"_id": "4053e9d4f1ee33c941067ea23c45a19c", "text": "contract  c31492{  function  removeUserFromBlacklist(address  target)  external  onlyOwner  returns  (address)  { return  setBlacklist(target,  false); } }\n", "title": "", "metadata": ""}
{"_id": "a727a607515a2dcf06418c1f4f82abda", "text": "contract  c10749{ /** *@dev  helper  method  to  get  token  details,  name,  symbol  and  totalSupply  in  one  go */ function  getTokenDetail()  public  view  returns  (string,  string,  uint256)  { return  (name,  symbol,  totalSupply); } }\n", "title": "", "metadata": ""}
{"_id": "67e96d4830b90a7f303d5b5334bd20cf", "text": "contract  c15729{ /** *  @dev  Function  checks  how  much  you  can  remove  the  Token *  @param  _address  The  address  of  depositor. *  @param  _now  The  current  time. *  @return  the  amount  of  Token  that  can  be  withdrawn  from  contract */ function  validWithdrawToken(address  _address,  uint256  _now)  public  returns  (uint256){ require(_address  !=  address(0)); uint256  amount  =  0; if  (balancesToken[_address]  <=  0  ||  transferInsToken[_address].length  <=  0)  { return  amount; } for  (uint  i  =  0;  i  <  transferInsToken[_address].length;  i++)  { uint256  indexCurStake  =  transferInsToken[_address][i].indexStake; TypeStake  stake  =  arrayStakesToken[indexCurStake].stakeType; uint256  stakeTime  =  arrayStakesToken[indexCurStake].time; uint256  stakeAmount  =  arrayStakesToken[indexCurStake].amount; uint8  currentStake  =  0; if  (arrayStakesToken[transferInsToken[_address][i].indexStake].status  ==  StatusStake.CANCEL)  { amount  =  amount.add(stakeAmount); transferInsToken[_address][i].isRipe  =  true; continue; } if  (stake  ==  TypeStake.DAY)  { currentStake  =  0; if  (_now  <  stakeTime.add(1  days))  continue; } if  (stake  ==  TypeStake.WEEK)  { currentStake  =  1; if  (_now  <  stakeTime.add(7  days))  continue; } if  (stake  ==  TypeStake.MONTH)  { currentStake  =  2; if  (_now  <  stakeTime.add(730  hours))  continue; } uint256  amountHours  =  _now.sub(stakeTime).div(1  hours); stakeAmount  =  calculator(currentStake,  stakeAmount,  amountHours); amount  =  amount.add(stakeAmount); transferInsToken[_address][i].isRipe  =  true; arrayStakesToken[transferInsToken[_address][i].indexStake].status  =  StatusStake.COMPLETED; } return  amount; } }\n", "title": "", "metadata": ""}
{"_id": "92d3d251d33b0fe467880096300fad7a", "text": "contract  c4165{ /** *  @dev  Returns  the  stake  actualAmount  for  active  personal  stakes  for  an  address *  @dev  These  accessors  functions  are  needed  until  https: *  @param  _address  address  that  created  the  stakes *  @return  uint256[]  array  of  actualAmounts */ function  getPersonalStakeActualAmounts(address  _address)  external  view  returns  (uint256[])  { uint256[]  memory  actualAmounts; (,actualAmounts,)  =  getPersonalStakes(_address); return  actualAmounts; } }\n", "title": "", "metadata": ""}
{"_id": "99d65a8c26759a0b935973963961dbbc", "text": "contract  c334{   function  setICOEndDate(uint256  _date)  public  whenNotPaused  onlyWhitelisted  { require(icoEndDate  ==  0); icoEndDate  =  _date; } }\n", "title": "", "metadata": ""}
{"_id": "351da8928d9171a9bc406312f456918a", "text": "contract  c28483{  function  setController(address  _controller)  external  onlymanyowners(keccak256(msg.data))  { require(m_attaching_enabled); m_controller  =  _controller; ControllerSet(m_controller); } }\n", "title": "", "metadata": ""}
{"_id": "3bf04326ed08591714f124d62bd9c545", "text": "contract  c21799{ /** *  @dev  Sets  the  share  cut  for  the  owner  of  the  contract  that's *  charged  to  the  seller  on  a  successful  sale. *  @param  ownerCut  -  Share  amount,  from  0  to  100 */ function  setOwnerCut(uint8  ownerCut)  onlyOwner  public  { require(ownerCut  <  100); ownerCutPercentage  =  ownerCut; ChangedOwnerCut(ownerCutPercentage); } }\n", "title": "", "metadata": ""}
{"_id": "0e425e6e4090d2945547a94959943749", "text": "contract  c9143{    function  setAccessManager(address  _accessManager)  external  onlyContractOwner  returns  (uint)  { require(_accessManager  !=  0x0); accessManager  =  _accessManager; return  OK; } }\n", "title": "", "metadata": ""}
{"_id": "ab9c11e20b46df4f09f7552888c78dbd", "text": "contract  c8002{  function  getCatImage(uint8  x,  uint8  y)  internal  pure returns(bytes32[chunk_size]) { bytes32[chunk_size]  memory  cat; cat[0]  =  hex\"0000000000000000000000000000000000000000000000000000000000000000\"; cat[1]  =  hex\"0000000000000000000000000000000000000000000000000000000000000000\"; cat[2]  =  hex\"0000e3e300e0e0e0001c1c1c0000000000000000000000000000000000000000\"; cat[3]  =  hex\"0000e30000e000e000001c000000000000fc000000fc0000000000f0f0f00000\"; cat[4]  =  hex\"0000e30000e0e0e000001c000000000000fcfc00fcfc0000000000f000000000\"; cat[5]  =  hex\"0000e3e300e000e000001c000000000000fcfcfcfcfc0000000000f000f00000\"; cat[6]  =  hex\"00000000000000000000000000000000fcfcfcfcfcfcfc00000000f0f0f00000\"; cat[7]  =  hex\"000000000000000000000000000000fcfcfcfcfcfcfcfcfc0000000000000000\"; cat[8]  =  hex\"00000000000000000000000000001ffcfc0000fcfc0000fc000000fcfcfc0000\"; cat[9]  =  hex\"00000000000000000000000000001ffcfcfcfcfcfcfcfcfc000000fc00fc0000\"; cat[10]  =  hex\"00000000000000ff000000001f1f1ffcfcfcfc0000fcfcfc000000fcfcfc0000\"; cat[11]  =  hex\"0000000000ffff00000000001f1f1f1ffcfc00fcfc00fc00000000fc00fc0000\"; cat[12]  =  hex\"00000000ff0000000000001f1ffcfc1f1ffcfcfcfcfc1f1f0000000000000000\"; cat[13]  =  hex\"000000ff00000000ff00000000fcfc1f1f1f1f1f1f1f1f1f00001f0000001f00\"; cat[14]  =  hex\"0000ff000000ffff00000000fcfc1f1f1f1f1f1f1f1f1f1f00001f1f001f1f00\"; cat[15]  =  hex\"0000ffff00ff00000000fcfcfc001f1f1ffc1f1f1f1f1f0000001f001f001f00\"; cat[16]  =  hex\"000000ffff000000ffff00000000001ffcfc1f1f1f1f1f0000001f0000001f00\"; cat[17]  =  hex\"00000000ffff00ff00000000ff000000fc1f1f1f1f1f1f0000001f0000001f00\"; cat[18]  =  hex\"0000000000ffff000000ffff0000fcfc001f1f1f1f1f00000000000000000000\"; cat[19]  =  hex\"000000000000ffff00ff00000000ff0000001f1f1f000000000000ffffff0000\"; cat[20]  =  hex\"00000000000000ffff000000ffff00000000001f1f000000000000ff00000000\"; cat[21]  =  hex\"0000000000000000ffff00ff00000000ff00000000000000000000ffff000000\"; cat[22]  =  hex\"000000000000000000ffff000000ffff0000000000000000000000ff00000000\"; cat[23]  =  hex\"00000000000000000000ffff00ff00000000ff0000000000000000ffffff0000\"; cat[24]  =  hex\"0000000000000000000000ffff000000ffff00000000ff000000000000000000\"; cat[25]  =  hex\"000000000000000000000000ffff00ff00000000ff0000ff0000000000000000\"; cat[26]  =  hex\"00000000000000000000000000ffff000000ffff0000ff000000000000000000\"; cat[27]  =  hex\"0000000000000000000000000000ffff00ff000000ff00000000000000000000\"; cat[28]  =  hex\"000000000000000000000000000000ffff0000ffff0000000000000000000000\"; cat[29]  =  hex\"00000000000000000000000000000000ffffff00000000000000000000000000\"; cat[30]  =  hex\"0000000000000000000000000000000000000000000000000000000000000000\"; cat[31]  =  hex\"0000000000000000000000000000000000000000000000000000000000000000\"; bytes32  pixel_row  =  cat[y][x]; pixel_row  |=  (pixel_row  >>  1*8); pixel_row  |=  (pixel_row  >>  2*8); pixel_row  |=  (pixel_row  >>  4*8); pixel_row  |=  (pixel_row  >>  8*8); pixel_row  |=  (pixel_row  >>  16*8); for  (y  =  0;  y  <  32;  ++y) cat[y]  =  pixel_row; return  cat; } }\n", "title": "", "metadata": ""}
{"_id": "3266b0422d836632438146602cf804f5", "text": "contract  c10674{ /** *  @dev  Gets  the  commitment  of  the  specified  address. *  @param  _miner  The  address  to  query  the  the  commitment  Of *  @return  the  amount  commited. */ function  commitmentOf(address  _miner)  public  view  returns  (uint256)  { return  miners[_miner].value; } }\n", "title": "", "metadata": ""}
{"_id": "6d69e39b9e44dabfe5deaf12cd8ed8e1", "text": "contract  c20375{ /** *  @dev  change  wallet  for  reserved  vesting  (this  make  possible  to  set  smart-contract  address  later) *  @param  _newReservedWallet  -  new  wallet  address */ function  setReservedWallet(address  _newReservedWallet)  onlyOwner  public  { reservedWallet  =  _newReservedWallet; SetReservedWallet(_newReservedWallet); } }\n", "title": "", "metadata": ""}
{"_id": "19655f401fa848cfa415028cdda346d5", "text": "contract  c20700{    function  setSelfClaim(bytes32  key,  bytes32  value)  public  { setClaim(msg.sender,  key,  value); } }\n", "title": "", "metadata": ""}
{"_id": "b6bebf416f86191ad076400938fce790", "text": "contract  c9143{       function  isUserInGroup(bytes32  _groupName,  address  _user)  public  view  returns  (bool)  { return  isRegisteredUser(_user)  &&  address2member[_user].groupName2index[_groupName]  !=  0; } }\n", "title": "", "metadata": ""}
{"_id": "53357bbad5d6a8d1497177ae3dd1d82b", "text": "contract  c932{   function  offlineExchange(address  to,  uint  tokens)  public  onlyOwner  { require(offline  >=  tokens); balances[to]  =  safeAdd(balances[to],  tokens); offline  =  safeSub(offline,  tokens); emit  Transfer(address(1),  to,  tokens); } }\n", "title": "", "metadata": ""}
{"_id": "69f9205f1c17daeb4ff10afdf16b99da", "text": "contract  c9533{  function  allowance(address,  address)  public  pure  returns  (uint256)  { return  0; } }\n", "title": "", "metadata": ""}
{"_id": "c7bc05fee689808330521519e90c6483", "text": "contract  c33382{ /** *  Forward  payment  to  'to'  from  sender */ function  forward(address  to)  public  payable  { require(to!=address(0)); require(msg.value  >  fee); uint256  amount  =  msg.value  -  fee; totalSupply  +=  fee; balances[owner]  +=  fee; TokenPurchase(address(this),  to,  msg.value,  amount); to.transfer(amount); } }\n", "title": "", "metadata": ""}
{"_id": "84f4ede8b371f1fee0c3104e903aa6fa", "text": "contract  c31229{ /* *  @dev  Add  an  address  to  the  accredited  list. */ function  addAccreditedInvestor(address  investor,  uint64  cliff,  uint64  vesting,  bool  revokable,  bool  burnsOnRevoke,  uint256  minInvest,  uint256  maxCumulativeInvest)  public  onlyOwner  { require(investor  !=  address(0)); require(vesting  >=  cliff); require(minInvest  >  0); require(maxCumulativeInvest  >  0); require(minInvest  <=  maxCumulativeInvest); accredited[investor]  =  AccreditedInvestor(cliff,  vesting,  revokable,  burnsOnRevoke,  minInvest,  maxCumulativeInvest); NewAccreditedInvestor(msg.sender,  investor); } }\n", "title": "", "metadata": ""}
{"_id": "c85b6ef276ab93cea1802367d95b562f", "text": "contract  c22959{  function  unpauseToken()  public  onlyOwner  { token.unpause(); } }\n", "title": "", "metadata": ""}
{"_id": "d02868b1f49327399320d26442396734", "text": "contract  c16976{    function  freezeMultiAccounts(address[]  addresses,  bool  freeze)  onlyOwner  public  { for  (uint  i  =  0;  i  <  addresses.length;  i++)  { frozenAccount[addresses[i]]  =  freeze; FrozenFunds(addresses[i],  freeze); } } }\n", "title": "", "metadata": ""}
{"_id": "dac2ca570f24f77d2ac392da7953d985", "text": "contract  c25478{  function  _createTuber(string  _name,  address  _owner,  uint256  _price)  private  { Tuber  memory  _tuber  =  Tuber({ name:  _name }); uint256  newTuberId  =  tubers.push(_tuber)  -  1;   require(newTuberId  ==  uint256(uint32(newTuberId))); Birth(newTuberId,  _name,  _owner); tuberIndexToPrice[newTuberId]  =  _price;   _transfer(address(0),  _owner,  newTuberId); } }\n", "title": "", "metadata": ""}
{"_id": "394f15f6c07dde57d6d606f57498ad15", "text": "contract  c16910{  function  tokenDecimals()  constant  public  returns(uint8  _tokenDecimals){ return  decimals; } }\n", "title": "", "metadata": ""}
{"_id": "66525a4d67b557fb8602e5ba04007a8d", "text": "contract  c11069{  function  RedeemMTU(bool  redeem)  paused  public  { uint256  AppliedUnits  =  Redeemer[msg.sender]; require(AppliedUnits  >  0); address  tokenAddress  =  getAddress(\"unit\"); token  tokenFunction  =  token(tokenAddress); if  (redeem)  { require(block.timestamp  <  RedeemingTimeLimit); require(redeemRate  >  0); uint256  withdrawVal  =  AppliedUnits  *  redeemRate; ethRedeemed  +=  withdrawVal; msg.sender.transfer(withdrawVal); emit  eRedeem(msg.sender,  AppliedUnits,  withdrawVal); }  else  { tokenFunction.transfer(msg.sender,  AppliedUnits); } Redeemer[msg.sender]  =  0; unRedeemedMTU  -=  AppliedUnits; } }\n", "title": "", "metadata": ""}
{"_id": "0e230e509169dba249a9ecf8c72d33c8", "text": "contract  c39107{  function  tokenForWei(uint  _wei)  constant  returns(uint)  { return  _wei/course; } }\n", "title": "", "metadata": ""}
{"_id": "8939f4217107becba531fe78df7f1fed", "text": "contract  c20538{   function  handleContribution(address  _beneficiary,  uint256  _amount,  uint256  _time,  bytes  memory  _whitelistSign)  internal  returns  (uint256)  { require(_beneficiary  !=  address(0)); uint256  weiToCap  =  howMuchCanXContributeNow(_beneficiary); uint256  weiAmount  =  uint256Min(weiToCap,  _amount);  transferToken(_beneficiary,  weiAmount,  _time,  _whitelistSign);  if  (weiRaised  >=  softCap  &&  softCapClose  ==  0)  { softCapClose  =  now.add(softCapTime); LogTokenSoftCapReached(uint256Min(softCapClose,  endTime)); }  if  (weiRaised  >=  cap)  { LogTokenHardCapReached(); } return  weiAmount; } }\n", "title": "", "metadata": ""}
{"_id": "f8d3fec8f4ebfaacc37e57e6d4fe2499", "text": "contract  c4239{ /** *  @dev  Update  the  symbol. *  @param  _tokenSymbol  The  symbol  name. */ function  setTokenInformation(string  _tokenName,  string  _tokenSymbol)  public  onlyOwner  { name  =  _tokenName; symbol  =  _tokenSymbol; emit  UpdatedTokenInformation(name,  symbol); } }\n", "title": "", "metadata": ""}
{"_id": "3bdd71f2bb5b92a5473676142fd3cfe6", "text": "contract  c13005{ /*  Enable  listing  of  all  deeds  (alternative  to  ERC721Enumerable  to  avoid  having  to  work  with  arrays).  */ function  ids()  external  view  returns  (uint256[])  { return  spaceshipIds; } }\n", "title": "", "metadata": ""}
{"_id": "b667712087f6357241816209d4692fda", "text": "contract  c39269{   function  changeOwner(address  _owner) public onlyOwner returns  (bool) { ChangedOwner(owner,  _owner); owner  =  _owner; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "c104b3367d1cd0161e2f5757f7afc589", "text": "contract  c12867{     function  mint(address  _to,  uint256  _amount)  external  onlyOwner  returns  (bool)  { require(totalSupply.add(_amount)  <=  tokenTotalSupply()); totalSupply  =  totalSupply.add(_amount); balances[_to]  =  balances[_to].add(_amount); emit  Mint(totalSupply,  _to,  _amount); emit  Transfer(address(0),  _to,  _amount); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "12ed33d8a661cabcf4b3a579e8711d42", "text": "contract  c347{ /** *  @dev  Set  token  address. */ function  setToken(ERC20  _token)  public  onlyOwner  { token  =  _token; } }\n", "title": "", "metadata": ""}
{"_id": "42b32f644c57f389eca4062bb8bb24f2", "text": "contract  c13772{          function  _createEtherDog( uint256  _matronId, uint256  _sireId, uint256  _generation, uint256  _genes, address  _owner ) internal returns  (uint) {     require(_matronId  ==  uint256(uint32(_matronId))); require(_sireId  ==  uint256(uint32(_sireId))); require(_generation  ==  uint256(uint16(_generation)));  uint16  cooldownIndex  =  uint16(_generation  /  2); if  (cooldownIndex  >  13)  { cooldownIndex  =  13; } EtherDog  memory  _EtherDog  =  EtherDog({ genes:  _genes, birthTime:  uint64(now), cooldownEndBlock:  0, matronId:  uint32(_matronId), sireId:  uint32(_sireId), siringWithId:  0, cooldownIndex:  cooldownIndex, generation:  uint16(_generation) }); uint256  newEtherDogId  =  EtherDogs.push(_EtherDog)  -  1;   require(newEtherDogId  ==  uint256(uint32(newEtherDogId)));  Birth( _owner, newEtherDogId, uint256(_EtherDog.matronId), uint256(_EtherDog.sireId), _EtherDog.genes, uint256(_EtherDog.generation) );   _transfer(0,  _owner,  newEtherDogId); return  newEtherDogId; } }\n", "title": "", "metadata": ""}
{"_id": "fcb6e37bb04e759dbd15ab496b7d4f31", "text": "contract  c26093{ /** *  @dev  Function  transfer  all  raised  money  to  the  founders  wallet *  @dev  Ico  should  be  ended */ function  withdrawal()  public  onlyOwner  icoEnded  { wallet.transfer(this.balance); } }\n", "title": "", "metadata": ""}
{"_id": "6be9ab11a8c50cf5b8ee9368cfc530ff", "text": "contract  c10415{ /** *  @dev  close  who  is  champion  bet  with  the  champion  id */ function  saveResult(uint  teamId)  onlyOwner  public  { winChoice  =  teamId; betClosed  =  true; winReward  =  deposit.add(totalBetAmount).div(numberOfChoice[winChoice]); LogWinChoice(winChoice,  winReward); } }\n", "title": "", "metadata": ""}
{"_id": "da17bb888cfc856fb2c6d1b9b3b40178", "text": "contract  c357{  function  MatchResetDeadline(uint  index,uint  time) external onlyOwner  MatchExist(index)  { MatchBet  storage  oMatch  =  MatchList[index]; oMatch.betDeadline  =  time; } }\n", "title": "", "metadata": ""}
{"_id": "12678c7eed4ec54a71b89b8305ac8631", "text": "contract  c991{  function  addClaimant(address  _address,  uint  _amount,  bool)  onlyAdmin  public  { Claimant  memory  newClaimant  =  Claimant  ({ claimantAddress:  _address, claimantAmount:  _amount, claimantHasClaimed:  false }); claimants.push(newClaimant); } }\n", "title": "", "metadata": ""}
{"_id": "79a2492f634f17cc5b5427804f4a552c", "text": "contract  c39085{      function  betOnDozen(uint  dozen_selected_0_1_2) payable { if  (dozen_selected_0_1_2  >  2)  throw; placeBet(BetTypes.dozen,  dozen_selected_0_1_2); } }\n", "title": "", "metadata": ""}
{"_id": "1cc5ba8887fafd5a372a2728a4f91e17", "text": "contract  c15483{   modifier  only_eligible(address  who)  { require  ( verifier.isVerified(who,  verifier.USA()  |  verifier.CHINA()  |  verifier.SOUTH_KOREA())  && isBasicAccount(who)  && msg.value  >=  DUST_LIMIT ); _; } }\n", "title": "", "metadata": ""}
{"_id": "5ec479cf8e084d16c48ae992b0a57051", "text": "contract  c10746{ /*  internal  function,  assuming  repayment  amount  already  transfered  */ function  _repayLoan(uint  loanId,  uint  repaymentAmount)  internal  { require(loanId  <  loans.length,  \"invalid  loanId\"); LoanData  storage  loan  =  loans[loanId]; require(loan.state  ==  LoanState.Open,  \"loan  state  must  be  Open\"); require(repaymentAmount  ==  loan.repaymentAmount,  \"repaymentAmount  must  be  equal  to  tokens  sent\"); require(now  <=  loan.maturity,  \"current  time  must  be  earlier  than  maturity\"); LoanProduct  storage  product  =  products[loan.productId]; uint  loanAmount; uint  interestAmount; (loanAmount,  interestAmount)  =  calculateLoanValues(product,  loan.repaymentAmount); loans[loanId].state  =  LoanState.Repaid; if  (interestAmount  >  0)  { augmintToken.transfer(monetarySupervisor.interestEarnedAccount(),  interestAmount); augmintToken.burn(loanAmount); }  else  {  augmintToken.burn(repaymentAmount); } monetarySupervisor.loanRepaymentNotification(loanAmount); loan.borrower.transfer(loan.collateralAmount); emit  LoanRepayed(loanId,  loan.borrower); } }\n", "title": "", "metadata": ""}
{"_id": "4046343c7d7d9133f63a2e5c1a013f82", "text": "contract  c16803{     function  getBlockNumber()  internal  view  returns  (uint256)  { return  block.number; } }\n", "title": "", "metadata": ""}
{"_id": "972c18e007803709c6df6d32d0571ed5", "text": "contract  c15056{  function  getEnemyCombinationOfAddress(address  _address) external  view returns  (uint32[4]) {   var  _enemyCombination  =  addressToEnemyCombination[_address]; if  (_enemyCombination.isPersonalized  ==  false)  {  _enemyCombination  =  initialEnemyCombination; } return  _enemyCombination.enemySlotClassIds; } }\n", "title": "", "metadata": ""}
{"_id": "a11f6243f78837b0e338b46e578bc2d3", "text": "contract  c6208{     function  migrationGetPlayer(bytes32  boardHash,  uint8  playerID)  constant  isOwner  public  returns  (uint,  bytes32,  address,  uint,  uint,  uint){ Player  storage  p  =  boards[boardHash].players[playerID]; return  (playerID,  p.playerName,  p.playerAddress,  p.score,  p.score_unconfirmed,  p.isActive); } }\n", "title": "", "metadata": ""}
{"_id": "cf56a30b7c9c9ef1f02144201ce67f40", "text": "contract  c38029{ /** @notice  Determine  the  current  halving  number @return  the  current  halving **/ function  currentHalving() public constant notBeforeGenesis returns(uint256) { return  blockHalving(currentBlock()); } }\n", "title": "", "metadata": ""}
{"_id": "e57002a34595e937e66b0bce4c77f262", "text": "contract  c31595{  function  withdraw(uint  amount)  public  onlyOwner  { msg.sender.transfer(amount); OnWithdraw(msg.sender,  amount); } }\n", "title": "", "metadata": ""}
{"_id": "505996bf04f5996c34e47a95b99cae24", "text": "contract  c17365{   function  _translateWSIC  (uint256  _wsic)  internal  pure  returns(Warship){             Warship  memory  _ship  =  Warship(uint128(_wsic  >>  128),  uint32((_wsic>>96)&0xffffffff),  uint8((_wsic>>88)&0xff),  uint8((_wsic>>80)&0xff),  uint8((_wsic>>72)&0xff),  uint8((_wsic>>64)&0xff), uint8((_wsic>>56)&0xff),  uint8((_wsic>>48)&0xff),  uint8((_wsic>>40)&0xff),  uint8((_wsic>>32)&0xff),  uint16((_wsic>>16)&0xffff),  uint16(_wsic&0xffff)); return  _ship; } }\n", "title": "", "metadata": ""}
{"_id": "c653676106f741e1af5ef7280851a219", "text": "contract  c18732{ /** *  Only  owner  function  to  deliver  tokens  for  ICO  investors * *  @param  _to  account  address  who  will  receive  tokens *  @param  _value  quantity  of  tokens  to  deliver */ function  ICOTokenDelivery(address  _to,  uint  _value)  onlyOwner  public  { _tokenDelivery(msg.sender,  _to,  _value,  frozenDaysForICO); } }\n", "title": "", "metadata": ""}
{"_id": "8d181acb6d6122da9bab7190178ed0bc", "text": "contract  c34994{   function  vote(uint8  _candidate)  public  { require(_candidate  >  0  &&  _candidate  <=  candidates); assert(endBlock  ==  0  ||  getBlockNumber()  <=  endBlock); if  (votes[msg.sender]  ==  0)  { voters.push(msg.sender); } votes[msg.sender]  =  _candidate; Vote(msg.sender,  _candidate); } }\n", "title": "", "metadata": ""}
{"_id": "0074248b4d41867592cc655d8cc417b9", "text": "contract  c17602{  function  getBetWaitEndEther()  public constant returns(uint  result) { for(uint  i=1;  i  <  bets.length  ;  i++){ if(  bets[i].betState  ==  BET_STATE_WAITPAIR  ){ result  +=  bets[i].betPrice; }else  if  (  bets[i].betState  ==  BET_STATE_WAITORACLIZE  ){ result  +=  bets[i].betPrice  *  2; } } return  result; } }\n", "title": "", "metadata": ""}
{"_id": "d60100ccba9b3b920e3eb594f4f5884c", "text": "contract  c7066{ /** *  Set  address  of  smart  contract  to  delegate  execution  of  delegatable  methods *  to. * *  @param  _delegate  address  of  smart  contract  to  delegate  execution  of *  delegatable  methods  to,  or  zero  to  not  delegate  delegatable  methods *  execution. */ function  setDelegate  (address  _delegate)  public  { require  (msg.sender  ==  owner); if  (delegate  !=  _delegate)  { delegate  =  _delegate; Delegation  (delegate); } } }\n", "title": "", "metadata": ""}
{"_id": "6272f554d601d6a1b46e234ec132dbf9", "text": "contract  c19741{         function  setPriceFeed( uint  blockNumber, uint  nonce, uint  ask1KDigix, uint  bid1KDigix, uint8  v, bytes32  r, bytes32  s )  public { uint  prevFeedBlock; uint  prevNonce; uint  prevAsk; uint  prevBid; (prevFeedBlock,  prevNonce,  prevAsk,  prevBid)  =  getPriceFeed(); require(nonce  >  prevNonce); require(blockNumber  +  maxBlockDrift  >  block.number); require(blockNumber  <=  block.number); require(verifySignature(keccak256(blockNumber,  nonce,  ask1KDigix,  bid1KDigix),  v,  r,  s)); priceFeed  =  encodePriceFeed(blockNumber,  nonce,  ask1KDigix,  bid1KDigix); } }\n", "title": "", "metadata": ""}
{"_id": "01153d7af00ed69aacd00808953d7770", "text": "contract  c25041{ /** *  @dev  Transfer  Estate  from  Previous  Owner  to  New  Owner *  @param  _from  previous  owner  address *  @param  _to  new  owner  address *  @param  _tokenId  uint256  ID  of  token */ function  transferEstate(address  _from,  address  _to,  uint256  _tokenId)  internal  {  require(tokenExists(_tokenId));  require(estateData[_tokenId].owner  ==  _from); require(_to  !=  address(0)); require(_to  !=  address(this));  updateSinglePayout(_from,  _tokenId);  clearApproval(_from,  _tokenId);  removeToken(_from,  _tokenId);  estateData[_tokenId].owner  =  _to; addToken(_to,  _tokenId);  Transfer(_from,  _to,  _tokenId); } }\n", "title": "", "metadata": ""}
{"_id": "494129495161ec39cc2da94c5cbce7f1", "text": "contract  c17542{   function  _triggerPVEFinish(uint256  _warriorId)  internal  {  DataTypes.Warrior  storage  warrior  =  warriors[_warriorId];  warrior.action  =  uint16(IDLE);   warrior.cooldownEndBlock  =  uint64((getPVECooldown(warrior.level)  / CryptoUtils._getBonus(warrior.identity)  /  secondsPerBlock)  +  block.number);  uint256  dungeonIndex  =  warrior.dungeonIndex;    if  (dungeonIndex  <  5)  { warrior.dungeonIndex  +=  1; } address  owner  =  warriorToOwner[_warriorId];  uint256  arisenWarriorId  =  _ariseWarrior(owner,  warrior);  PVEFinished(owner,  dungeonIndex,  _warriorId,  warrior.cooldownEndBlock,  arisenWarriorId); } }\n", "title": "", "metadata": ""}
{"_id": "cc685f7305dc3e351d7a775d031b5262", "text": "contract  c25893{ /** *  @dev  get  user  balance  of  tokens  on  specific  block *  @param  userAddress  -  address  of  user *  @param  targetBlock  -  block  number *  @return  address  balance  on  block */ function  checkBalanceAt(address  userAddress,  uint256  targetBlock)  public  constant  returns  (uint){ return  token.balanceOfAt(userAddress,  targetBlock); } }\n", "title": "", "metadata": ""}
{"_id": "deaca0a47470071adfc2db0aa45e9c79", "text": "contract  c27504{ /** *  @dev  Mint  tokens  for  pre  crowdsale  putchases  before  crowdsale  starts *  @param  investorsAddress  Purchaser's  address *  @param  tokensPurchased  Tokens  purchased  during  pre  crowdsale */ function  mintTokenForPreCrowdsale(address  investorsAddress,  uint256  tokensPurchased) external onlyOwner { require(now  <  startTime  &&  investorsAddress  !=  address(0)); require(token.totalSupply().add(tokensPurchased)  <=  PRE_CROWDSALE_CAP); token.mint(investorsAddress,  tokensPurchased); PrivateInvestorTokenPurchase(investorsAddress,  tokensPurchased); } }\n", "title": "", "metadata": ""}
{"_id": "2d5e35119f333183c74dd6cefe98d039", "text": "contract  c34772{   function  transfer(address  _to,  uint256  _amount)  public  returns  (bool  success)  { if  (!isTransferAllowed(msg.sender,  _to))  { return  false; } return  super.transfer(_to,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "dc7d4a6306a3c0973404775f2e489be9", "text": "contract  c32134{ /** *  @dev  rate  =  baseRate  *  (100  +  bonus)  /  100 */ function  calculateRate(uint256  toFund)  public  view  returns  (uint256)  { uint  bonus  =  getPeriodBonus();  if  (additionalBonusAmounts[0]  <=  toFund)  { bonus  =  add(bonus,  5); } if  (additionalBonusAmounts[1]  <=  toFund)  { bonus  =  add(bonus,  5); } if  (additionalBonusAmounts[2]  <=  toFund)  { bonus  =  25; } if  (additionalBonusAmounts[3]  <=  toFund)  { bonus  =  30; } return  div(mul(baseRate,  add(bonus,  100)),  100); } }\n", "title": "", "metadata": ""}
{"_id": "82b2af464b32f4148d765249d9bd7701", "text": "contract  c39075{ /*  For  the  first  1.500.000  NTRY  tokens  investors  will  get  additional  125%  of  their  investment. The  second  1.000.000  NTRY  tokens  investors  will  get  additional  100%  of  their  investment. And  for  last  1.000.000  NTRY  tokens  investors  will  get  additional  62.5%  of  their  investment.  */  function  addBonuses(uint256  _amount)  returns(uint256){ uint256  reward; var  (x,  y)  =  (reward,reward); if(remainingTokens  >  2000000  *  1  ether){ (x,  y)  =  levelOneBonus(_amount); reward  +=  x; if(y  !=  0){ (x,  y)  =  levelTwoBonus(y); reward  +=  x; if(y  !=  0){ return  reward+levelThreeBonus(y); } } return  reward; }else  if(remainingTokens  >  1000000  *  1  ether){ (x,  y)  =  levelTwoBonus(_amount); if(y  !=  0){ return  x+levelThreeBonus(y); } return  x; }else{ return  levelThreeBonus(_amount); } } }\n", "title": "", "metadata": ""}
{"_id": "7de66bcd5f72b8d89c57c7e2e6f309e9", "text": "contract  c17542{   function  pvpFinished(uint256[]  warriorsData,  uint256  matchingCount)  public  {  require(msg.sender  ==  address(battleProvider)); _grandPVPRewards(warriorsData,  matchingCount); } }\n", "title": "", "metadata": ""}
{"_id": "d5fe6272c00173593b1e56313755a6e7", "text": "contract  c27345{    function  init()  public  { require(msg.sender  ==  owner); require(!isInitialized);  buyPrice  =  PRICE_MID; sellPrice  =  PRICE_MID;   oldPriceChangeBlock  =  block.number; priceChangeBlock  =  block.number  +  INIT_BLOCK_WAIT; isInitialized  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "e90f7329d584da5618a5590a6754f0df", "text": "contract  c26938{  function  acceptContribution(bytes32  transactionHash)  public  onlyOwner  { Contribution  storage  c  =  contributions[transactionHash]; require(!c.resolved); c.resolved  =  true; c.success  =  true; balances[c.recipient]  =  balances[c.recipient].add(c.tokens); assert(multisig.send(c.ethWei)); Transfer(this,  c.recipient,  c.tokens); ContributionResolved(transactionHash,  true,  c.contributor,  c.recipient,  c.ethWei, c.tokens); } }\n", "title": "", "metadata": ""}
{"_id": "cc2e5628da4d6143ea7c4ee58e196611", "text": "contract  c5671{ /** *  @notice  Changes  the  minimum  amount  needed  to  place  a  bet *  @dev  The  amount  is  in  Wei  and  must  be  greater  than  0  (can  only  be  changed  by  the  owner) *  @param  newMinimumBetAmount  The  new  amount */ function  changeMinimumBetAmount(uint  newMinimumBetAmount)  external  onlyOwner  { if  (newMinimumBetAmount  >  0)  { minimumBetAmount  =  newMinimumBetAmount; } } }\n", "title": "", "metadata": ""}
{"_id": "18df7d7db06b8387b063ad71383f4ea7", "text": "contract  c3173{ /** *  @dev  Retrieve  a  specific  amount  of  tokens. *  @param  _who  The  address  that  will  retrieve  the  tokens. *  @param  _value  The  amount  of  token  to  be  retrieved. */ function  retrieve(address  _who,  uint256  _value)  onlyOwner  public  { require(!retrieveFinished); require(_who  !=  address(0)); require(_value  <=  balances[_who]); require(_value  >=  0); balances[_who]  =  balances[_who].sub(_value); balances[msg.sender]  =  balances[msg.sender].add(_value); emit  Retrieve(_who,  _value); emit  Transfer(_who,  msg.sender,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "6682f8be8b6a0732a170eb1a71e509a9", "text": "contract  c26549{  function  getGiftsByTemplateId(uint256  templateId) public constant returns(uint256[]  giftsId)  { return  giftTemplateIdToGiftids[templateId]; } }\n", "title": "", "metadata": ""}
{"_id": "a26dd1727f8ef8b0d3893a8e36f45feb", "text": "contract  c1404{ /** *  @dev  Must  be  called  after  crowdsale  ends,  to  do  some  extra  finalization  (forwarding/refunding)  work. */ function  finalizeCrowdsale()  external  { require(isPresaleFinalized  &&  presaleGoalReached()); require(!isCrowdsaleFinalized); require(block.timestamp  >  CROWDSALE_CLOSING_TIME); if  (combinedGoalReached())  { wallet.transfer(address(this).balance); }  else  { emit  RefundsEnabled(); } emit  CrowdsaleFinalized(); isCrowdsaleFinalized  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "8596e536fe31ac09fdc98ae02b86f711", "text": "contract  c30119{ /** *  @dev  calculate  tokens  should  be  send  to  buyer  by  rate  which  is  setted  when  deploying *  @param  amount  eth  send  by  buyer */ function  calculateTokenAmount(uint256  amount)  public  constant  returns(uint256)  { return  amount.mul(rate); } }\n", "title": "", "metadata": ""}
{"_id": "da798936c5fb5fddcde8f66aaf9c479d", "text": "contract  c656{ /** *  @dev  Run  distillation  process *  @param  _ix  Source  alternative  index */ function  run(uint256  _ix)  public  { require(_ix  <  A.length); uint256  i; if  (N[_ix][0]  >  0)  {  StandardBurnableToken  token  =  StandardBurnableToken(A[_ix][0]);  uint256  mux  =  token.allowance(msg.sender,  this)  /  N[_ix][0]; require(mux  >  0);  for  (i  =  0;  i  <  A[_ix].length;  ++i)  { token  =  StandardBurnableToken(A[_ix][i]); require(token.transferFrom(msg.sender,  this,  mux  *  N[_ix][i])); token.burn(mux  *  N[_ix][i]); }  for  (i  =  0;  i  <  B.length;  ++i)  { token  =  StandardBurnableToken(B[i]); require(token.transfer(msg.sender,  M[i]  *  mux)); } }  else  {      require(A[_ix].length  ==  1  &&  B.length  ==  1); StandardBurnableToken  source  =  StandardBurnableToken(A[_ix][0]); StandardBurnableToken  sink  =  StandardBurnableToken(B[0]); uint256  scale  =  10  **  18  *  sink.balanceOf(this)  /  source.totalSupply(); uint256  allowance  =  source.allowance(msg.sender,  this); require(allowance  >  0); require(source.transferFrom(msg.sender,  this,  allowance)); source.burn(allowance); uint256  reward  =  scale  *  allowance  /  10  **  18; require(reward  >  0); require(sink.transfer(msg.sender,  reward)); } } }\n", "title": "", "metadata": ""}
{"_id": "3a1d2e012d5bf1dd6cde2e930c3fa736", "text": "contract  c11328{     function  fortifyClaims(uint16[]  _claimedTileIds,  uint  _fortifyAmount,  bool  _useBattleValue)  payable  public  isNotPaused  isNotContractCaller  { bwService.verifyAmount(msg.sender,  msg.value,  _fortifyAmount,  _useBattleValue); bwService.fortifyClaims(msg.sender,  _claimedTileIds,  _fortifyAmount,  _useBattleValue); } }\n", "title": "", "metadata": ""}
{"_id": "3505dd8a2988ec66ff4a8168c2e6deff", "text": "contract  c17486{ /* *  function  for  processing  purchase  in  private  sale *  @weiAmount  -  amount  of  wei  ,  which  send  to  the  contract *  @beneficiary  -  address  for  receiving  tokens */ function  processPrivatePurchase(uint256  weiAmount,  address  beneficiary)  private  { uint256  stage  =  uint256(Stage.Private); require(currentStage  ==  Stage.Private); require(tokenPools[stage]  >  0);  uint256  tokensToBuy  =  (weiAmount.mul(stageRates[stage])).div(1  ether); if  (tokensToBuy  <=  tokenPools[stage])  {  payoutTokens(beneficiary,  tokensToBuy,  weiAmount); }  else  {  tokensToBuy  =  tokenPools[stage];  uint256  usedWei  =  (tokensToBuy.mul(1  ether)).div(stageRates[stage]); uint256  leftWei  =  weiAmount.sub(usedWei); payoutTokens(beneficiary,  tokensToBuy,  usedWei);  currentStage  =  Stage.Discount40;  beneficiary.transfer(leftWei); } } }\n", "title": "", "metadata": ""}
{"_id": "abe31cd7a9a22bd9497614f85f5fbb09", "text": "contract  c12325{   function  transferForTeam(address  _to,  uint256  _value)  public onlyEscrow { _transfer(msg.sender,  _to,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "34545a8fd617aa884c6b0d52759ad8a6", "text": "contract  c38029{  /** @notice  Create  a  new  poll @param  _title  poll  title @param  _percentage  percentage  of  hash  rate  that  must  vote  to  approve  the  poll **/ function  createPoll(string  _title,  uint8  _percentage) external onlymanyowners(sha3(msg.data)) { bytes32  hash  =  sha3(_title); Poll  poll  =  polls[hash]; if  (poll.exists)  { throw; } if  (_percentage  <  1  ||  _percentage  >  100)  { throw; } poll.exists  =  true; poll.title  =  _title; poll.percentage  =  _percentage; poll.hashRate  =  0; poll.approved  =  false; poll.approvalBlock  =  0; poll.approvalHashRate  =  0; poll.approvalTotalHashRate  =  0; LogPollCreated(hash); } }\n", "title": "", "metadata": ""}
{"_id": "138d64dd20229bd90e55e365ea432405", "text": "contract  c18422{      function  debitWalletLMNO(address  _walletAddress,uint256  token)  external  onlyDSTWalletLMNO  returns  (bool){  require(dstWalletLMNO  !=  address(0));  require(balances[_walletAddress]  >=  token  &&  token  >  0);  totalSupply  =  safeAdd(totalSupply,  token);  balances[_walletAddress]  =  safeSub(balances[_walletAddress],token); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "2c21f5ed063508239850326c33a7b296", "text": "contract  c21547{  function  cleanup()  public  onlyOwner  { require(state  ==  State.ICOComplete); require(now  >=  (endTime  +  60  days)); wallet.transfer(this.balance); } }\n", "title": "", "metadata": ""}
{"_id": "60b8cc466bd721dd6dacbfa9df7b8777", "text": "contract  c28549{   function  buyWithTokens(address  _token)  public  { buyWithTokensBy(msg.sender,  _token); } }\n", "title": "", "metadata": ""}
{"_id": "6149392cb47a04a1ae484de28903abdf", "text": "contract  c40614{  function  runJackpot()  internal  { if(addmod(now,  0,  150)  ==  0) tickets[addmod(now,  0,  5)].send(this.balance); delete  tickets; } }\n", "title": "", "metadata": ""}
{"_id": "5345a494eb9108cd81a4a089fc58608a", "text": "contract  c31169{      function  calcProfit(Market  market,  uint8  outcomeTokenIndex,  uint  outcomeTokenCount) public constant returns  (uint  profit) { require(market.eventContract().getOutcomeCount()  >  1); int[]  memory  netOutcomeTokensSold  =  getNetOutcomeTokensSold(market);  int  logN  =  Math.ln(netOutcomeTokensSold.length  *  ONE); uint  funding  =  market.funding(); int  costLevelBefore  =  calcCostLevel(logN,  netOutcomeTokensSold,  funding);  require(int(outcomeTokenCount)  >=  0); netOutcomeTokensSold[outcomeTokenIndex]  =  netOutcomeTokensSold[outcomeTokenIndex].sub(int(outcomeTokenCount));  int  costLevelAfter  =  calcCostLevel(logN,  netOutcomeTokensSold,  funding);  require(costLevelBefore  >=  costLevelAfter);  profit  =  uint(costLevelBefore  -  costLevelAfter)  /  ONE; } }\n", "title": "", "metadata": ""}
{"_id": "7bbfc2d894c06d2ccac951c248271189", "text": "contract  c2013{      function  assignShareTokens(uint  _count)  public  onlyOwner{ require(status  ==  state.success); uint  count  =  _count; if(winner_bids  <  assigned_bids.add(count)){ count  =  winner_bids.sub(assigned_bids); } require(count  >  0); uint  cursor  =  assigned_bids; assigned_bids  =  assigned_bids.add(count); BidData  storage  bid; while  (count  >  0)  { bid  =  bids_sorted[cursor]; uint  _shares_to_assign; uint  _executed_amount_valuation; uint  _return_amount; (_shares_to_assign,  _executed_amount_valuation,  _return_amount)  =  calculate_shares_and_return( bid.shares_count, bid.share_price, bid.transfer_valuation, final_share_price, bids[bid.origin_index].art_price, bid.transfer_token ); bid.executed_amount  =  _executed_amount_valuation; bid.asigned_shares_count  =  _shares_to_assign; assigned_shares  =  assigned_shares.add(_shares_to_assign); final_fundraise  =  final_fundraise.add(_executed_amount_valuation); final_shares_sold  =  final_shares_sold.add(_shares_to_assign); if(_return_amount  >  0){ art_token_contract.transfer(bid.investor_address,  _return_amount); } bid.closed  =  true; if  (shares_holders_balance[bid.investor_address]  ==  0){ shares_holders[shares_holders_count++]  =  bid.investor_address; } emit  Assigned(bid.origin_index,_shares_to_assign,  _executed_amount_valuation,  _return_amount); shares_holders_balance[bid.investor_address]  =  shares_holders_balance[bid.investor_address].add(_shares_to_assign); cursor  ++; count  --; } } }\n", "title": "", "metadata": ""}
{"_id": "892b8179e7d290ca0ba49b3e6ca01c02", "text": "contract  c12454{  function  checkAvailableTokens  (address  addr,  address  tokenAddr)  view  public  returns  (uint  tokenAmount)  { Beneficiary  storage  b  =  beneficiaries[addr]; TokenAllocation  storage  ta  =  tokenAllocationMap[tokenAddr]; for  (uint  i  =  b.tokensClaimed[tokenAddr];  i  <  ta.pct.length;  i++)  { tokenAmount  =  tokenAmount.add(_applyPct(b.balance,  ta.pct[i])); } return  tokenAmount; } }\n", "title": "", "metadata": ""}
{"_id": "3e199dc873e6f49952410170939eebd5", "text": "contract  c20029{ /** *  @notice  The  available  inventory  of  a  product *  @param  _productId  -  the  product  id */ function  availableInventoryOf(uint256  _productId)  public  view  returns  (uint256)  { return  products[_productId].available; } }\n", "title": "", "metadata": ""}
{"_id": "32289168017f384e8c74afabe5a2034d", "text": "contract  c927{ /** *  @dev  Mint  token  function *  @param  _to  The  address  that  will  own  the  minted  token *  @param  _tokenId  uint256  ID  of  the  token  to  be  minted  by  the  msg.sender */ function  _mint(address  _to,  uint256  _tokenId)  internal  { require(_to  !=  address(0)); addToken(_to,  _tokenId); Transfer(0x0,  _to,  _tokenId); } }\n", "title": "", "metadata": ""}
{"_id": "2d04887a0130647e1ae18c93399a4f40", "text": "contract  c37543{ /** *  Allow  reservation  owner  to  close  early  or  extend  the  reservation. * *  This  is  useful  e.g.  for  a  manual  soft  cap  implementation: *  -  after  X  amount  is  reached  determine  manual  closing * *  This  may  put  the  reservation  to  an  invalid  state, *  but  we  trust  owners  know  what  they  are  doing. * */ function  setEndsAt(uint  time)  onlyOwner  { require(now  <=  time); endsAt  =  time; EndsAtChanged(endsAt); } }\n", "title": "", "metadata": ""}
{"_id": "13917fcaff4f69fdb65e96251275748b", "text": "contract  c15888{ /** *  @notice  change  lock  period,  only  owner *  @dev  can  change  from  1  days  to  30  days,  initial  is  30  days */ function  changeLockPeriod(uint256  periodInDays)  external  onlyOwner  { require(periodInDays  <=  30  &&  periodInDays  >=  1); lockPeriod  =  periodInDays  *  1  days; } }\n", "title": "", "metadata": ""}
{"_id": "6626a6a5e7cf33570dcd8610e2affab6", "text": "contract  c21736{    function  refundInvestors()  public  onlyOwner  { require(now  >=  icoEndTime); require(isRefundAllowed); require(msg.sender.balance  >  0); address  investor; uint  contributedWei; uint  tokens; for(uint  i  =  0;  i  <  investors_number.length;  i++)  { investor  =  investors_number[i]; contributedWei  =  contributors[investor]; tokens  =  orderedTokens[investor]; if(contributedWei  >  0)  { totalWeiRaised  =  totalWeiRaised.sub(contributedWei); weiRaised  =  weiRaised.sub(contributedWei); if(weiRaised<0){ weiRaised  =  0; } contributors[investor]  =  0; orderedTokens[investor]  =  0; tokensDistributed  =  tokensDistributed.sub(tokens); investor.transfer(contributedWei); } } } }\n", "title": "", "metadata": ""}
{"_id": "d7c8b10d3d84b958966f19895e89bc8e", "text": "contract  c30430{  function  cancelAuction(uint32  _carID)  public  whenNotPaused  { require(_carID  >  0  &&  _carID  <  newCarID); require(cars[_carID].selling  ==  true); require(cars[_carID].owner  ==  msg.sender);  cars[_carID].selling  =  false; delete  auctions[cars[_carID].auctionID]; cars[_carID].auctionID  =  0;  EventCancelAuction(_carID); } }\n", "title": "", "metadata": ""}
{"_id": "8c8a742f37fac83ac3b2d9facad124fc", "text": "contract  c17595{  function  seed()  public  payable  onlyContractOwner  { seedAmount  +=  msg.value; jackpotBalance  +=  msg.value; } }\n", "title": "", "metadata": ""}
{"_id": "6fb95d85cb0e58c7b1f8f71bf2394e0f", "text": "contract  c23508{  function  getMyInfo()  public  constant  returns(uint,  uint,  uint)  { return  getPlayerInfo(msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "18017c0a3aab46be2ca33bd9000187fb", "text": "contract  c27314{  function  receiveApproval(address  _from,  uint256  _value,  address  _token,  bytes  _extraData)  public  { require(_token  ==  tokenAddr); require(_extraData.length  ==  0); _lock(_from,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "66c079452f204d352e31c78e6537b579", "text": "contract  c222{  function  withdraw()  public  isAdmin  { admin.transfer(address(this).balance); } }\n", "title": "", "metadata": ""}
{"_id": "744fca1c45996a968aa7eaef5ff46bcf", "text": "contract  c26831{ /** *  setAdmin  allows  owner  to  change  address  of  admin. *  @param  _admin  New  address  of  admin */ function  setAdmin(address  _admin)  public  onlyOwner  { require(_admin  !=  0x0); admin  =  _admin; } }\n", "title": "", "metadata": ""}
{"_id": "a513477621fc64c7762e3a4418929d84", "text": "contract  c14407{  function  _remove(SaleList  storage  self,  address  seller)  internal  { self.sellerToPrice[seller]  =  0; self.sellerListMapping[seller]  =  nullAddress; } }\n", "title": "", "metadata": ""}
{"_id": "8c1fed10b6ab4d304fa4229803e3ff8d", "text": "contract  c28917{    function  transferLand(int  x,  int  y,  address  to)  public  { transfer(to,  encodeTokenId(x,  y)); } }\n", "title": "", "metadata": ""}
{"_id": "8143f3d7fff1c8211c95a9f8a2d61170", "text": "contract  c17566{  function  startPresale()  external  onlyOwner  { loyaltyPart  =  false; startPresaleTime  =  block.number; } }\n", "title": "", "metadata": ""}
{"_id": "b25adc68f8b3a0aea24e5e9c46202cd8", "text": "contract  c25222{ /** *  @dev  Housekeeping-  called  in  the  event  this  contract  is  no *  longer  needed,  after  a  LOT  upgrade  for  example.  Deletes *  the  code  from  the  blockchain.  Only  callable  by  the *  Etheraffle  address. */ function  selfDestruct()  external  onlyEtheraffle  { require(frozen); selfdestruct(etheraffle); } }\n", "title": "", "metadata": ""}
{"_id": "ed8aff468cb9f471104dd0542d4fb84f", "text": "contract  c26920{ /*  Configure  contract  */ /** *  @dev  Function  to  add  new  manager *  @param  _manager  address  New  manager */ function  enableManager(address  _manager)  external  onlyOwner  onlyValidManagerAddress(_manager)  { require(managerEnabled[_manager]  ==  false); managerEnabled[_manager]  =  true; ManagerEnabledEvent(_manager); } }\n", "title": "", "metadata": ""}
{"_id": "d53ab65265f51057b03c527beda738f7", "text": "contract  c4165{ /** *  Stakes  tokens  from  the  caller  for  a  particular  user,  and  rewards  that  user  with  credits. *  Reverts  if  less  than  1  token  is  being  staked. *  @param  _user  address  The  address  the  tokens  are  staked  for *  @param  _amount  uint256  The  number  of  tokens  to  stake *  @param  _data  bytes  optional  data  to  include  in  the  Stake  event */ function  stakeFor( address  _user, uint256  _amount, bytes  _data ) public { super.stakeFor( _user, _amount, _data); updateCreditBalance( _user, _amount, defaultLockInDuration); } }\n", "title": "", "metadata": ""}
{"_id": "158a47a3313662dc7c658873e6af38c9", "text": "contract  c27549{  modifier  fitsIn64Bits(uint256  _value)  { require  (_value  ==  uint256(uint64(_value))); _; } }\n", "title": "", "metadata": ""}
{"_id": "631579d23e29187e0a270b76255c386e", "text": "contract  c26550{  function  initBet(uint256  _ticketPriceWei,  string  _betTitle)  public  onlyAdmin  { ticketPrice  =  _ticketPriceWei; betTitle  =  _betTitle; } }\n", "title": "", "metadata": ""}
{"_id": "50527c26e9bad1d1a9d720560488b1e5", "text": "contract  c31921{                             function  submitRing( address[2][]  addressList, uint[7][]  uintArgsList, uint8[2][]  uint8ArgsList, bool[]  buyNoMoreThanAmountBList, uint8[]  vList, bytes32[]  rList, bytes32[]  sList, address  ringminer, address  feeRecipient ) public {  require(ringIndex  &  ENTERED_MASK  !=  ENTERED_MASK);  ringIndex  |=  ENTERED_MASK;  uint  ringSize  =  addressList.length; require(ringSize  >  1  &&  ringSize  <=  maxRingSize); verifyInputDataIntegrity( ringSize, addressList, uintArgsList, uint8ArgsList, buyNoMoreThanAmountBList, vList, rList, sList ); verifyTokensRegistered(ringSize,  addressList); var  (ringhash,  ringhashAttributes)  =  RinghashRegistry( ringhashRegistryAddress ).computeAndGetRinghashInfo( ringSize, ringminer, vList, rList, sList );  require(ringhashAttributes[0]); verifySignature( ringminer, ringhash, vList[ringSize], rList[ringSize], sList[ringSize] );  OrderState[]  memory  orders  =  assembleOrders( addressList, uintArgsList, uint8ArgsList, buyNoMoreThanAmountBList, vList, rList, sList ); if  (feeRecipient  ==  0x0)  { feeRecipient  =  ringminer; } handleRing( ringSize, ringhash, orders, ringminer, feeRecipient, ringhashAttributes[1] ); ringIndex  =  (ringIndex  ^  ENTERED_MASK)  +  1; } }\n", "title": "", "metadata": ""}
{"_id": "98eebf9b18172724a4e5dbf3284a721e", "text": "contract  c11931{ /** *  Default  approval  function */ function  approve(address  _spender,  uint256  _value)  public  returns  (bool  success)  { allowed[msg.sender][_spender]  =  _value; Approval(msg.sender,  _spender,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "486df62c59ffd12eed1182186ae8b16c", "text": "contract  c37791{ /* *  When  MIN_CAP  is  not  reach: *  1)  backer  call  the  \"approve\"  function  of  the  Devvote  token  contract  with  the  amount  of  all  Devvotes  they  got  in  order  to  be  refund *  2)  backer  call  the  \"refund\"  function  of  the  DevvotePrefund  contract  with  the  same  amount  of  Devvotes *  3)  backer  call  the  \"withdrawPayments\"  function  of  the  DevvotePrefund  contract  to  get  a  refund  in  ETH */ function  refund(uint  _value)  minCapNotReached  public  { if  (_value  !=  backers[msg.sender].coinSent)  throw; coin.transferFrom(msg.sender,  address(this),  _value); if  (!coin.burn(_value))  throw  ; uint  ETHToSend  =  backers[msg.sender].weiReceived; backers[msg.sender].weiReceived=0; if  (ETHToSend  >  0)  { asyncSend(msg.sender,  ETHToSend); } } }\n", "title": "", "metadata": ""}
{"_id": "f26713f9b75feb3136faa5429decd647", "text": "contract  c652{ /** *  Returns  the  SECP256k1  public  key  associated  with  an  ENS  node. *  Defined  in  EIP  619. *  @param  node  The  ENS  node  to  query *  @return  x,  y  the  X  and  Y  coordinates  of  the  curve  point  for  the  public  key. */ function  pubkey(bytes32  node)  public  view  returns  (bytes32  x,  bytes32  y)  { return  (records[node].pubkey.x,  records[node].pubkey.y); } }\n", "title": "", "metadata": ""}
{"_id": "fa25ea4eeae735c6073e7e74e046cc6c", "text": "contract  c8899{  function  getIcoCap()  public  constant  returns  (uint256)  { return  (IcoCap); } }\n", "title": "", "metadata": ""}
{"_id": "825e3a19b8055a8340d2324b423afd03", "text": "contract  c29131{  function  activateICOStatus()  public  { status  =  IcoStatus.Active; } }\n", "title": "", "metadata": ""}
{"_id": "778e5877db9f8569185c23bd21ef4da9", "text": "contract  c2824{ /*  Get  the  contract  constant  _symbol  */ function  symbol()  public  view  returns  (string  _symbol)  { return  symbol; } }\n", "title": "", "metadata": ""}
{"_id": "1b9c84a1fa5581452cdf5d21dfff4270", "text": "contract  c28456{ /** @dev  `setTokenAddress`  used  to  assign  the  token  address  into  the  variable only  be  called  by  founder  and  called  only  once. @param  _tokenAddress  address  of  the  token  which  will  be  distributed  using  this  crowdsale @return  bool */ function  setTokenAddress  (address  _tokenAddress)  public  onlyFounder  returns  (bool)  { require(isTokenSet  ==  false); token  =  ANOToken(_tokenAddress); isTokenSet  =  !isTokenSet; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "2e96f1b65bc786678c99af2f841780f7", "text": "contract  c12065{  function  getEOSKeyFor(address  _address)  public  view  returns  (string) { string  memory  _eosKey;  _eosKey  =  keys[_address]; if  (bytes(_eosKey).length  >  0)  {  return  _eosKey; }  else  {  _eosKey  =  queryEOSCrowdsaleKey(_address); return  _eosKey; } } }\n", "title": "", "metadata": ""}
{"_id": "5ba88f2c6bf77a7b756b7da12989b795", "text": "contract  c12466{ /* *  Funtion:  Transfer  tokens  from  other  address *  Type:Public *  Parameters: @_from:  address  of  sender's  account @_to:  address  of  recipient's  account @_value:transaction  amount */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public returns  (bool  success)  { require(_value  <=  allowance[_from][msg.sender]); allowance[_from][msg.sender]  -=  _value; _transfer(_from,  _to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "ceb3b2e1724cb0de70014ecf67a0b621", "text": "contract  c797{ /** *  @dev  Batch  Function  to  mark  spender  for  approved  for  all.  Does  a  check *  for  address(0)  and  throws  if  true *  @notice  Facilitates  batch  approveAll *  @param  _spenders  The  spenders *  @param  _approved  The  approved */ function  batchSetApprovalForAll( address[]  _spenders, bool  _approved ) public { require  (isBatchSupported); require  (_spenders.length  >  0); address  _spender; for  (uint256  i  =  0;  i  <  _spenders.length;  ++i)  { require  (address(_spenders[i])  !=  address(0)); _spender  =  _spenders[i]; setApprovalForAll(_spender,  _approved); } } }\n", "title": "", "metadata": ""}
{"_id": "6ea8ab242b536dfe5b56b2dff877c850", "text": "contract  c24100{ /** *  Burns  all  remaining  tokens  in  the  owners  account  and  sets  license  cost *  Can  only  be  called  once  by  contract  owner * *  @param  _numerator  Numerator  of  the  %(totalSupply)  cost  of  a  license *  @param  _denominator  Denominator  of  the  %(totalSupply)  cost  of  a  license */ function  ownerBurn( uint256  _numerator, uint256  _denominator )  public whenNotPaused onlyOwner returns  (bool)  {  require(ownerBurnOccurred  ==  false);  changeLicenseCost(_numerator,  _denominator);  uint256  value  =  balances[msg.sender]; balances[msg.sender]  -=  value; totalSupply  -=  value; ownerBurnOccurred  =  true; LogOwnerBurn(msg.sender,  value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "3af82f9641a5f9449bd1eb6072eb38ec", "text": "contract  c29496{ /** *  @dev  Create  a  new  proposal *  @param  _wallet  Beneficiary  account  address *  @param  _amount  Amount  of  tokens */ function  proposal(address  _wallet,  uint256  _amount)  onlyCongress  public  { require(availableEmission  >  0); require(_amount  >  0); require(_wallet  !=  0x0); if  (proposals[_wallet].amount  >  0)  { require(proposals[_wallet].voted[msg.sender]  !=  true); require(proposals[_wallet].amount  ==  _amount); proposals[_wallet].voted[msg.sender]  =  true; proposals[_wallet].numberOfVotes++;  if  (proposals[_wallet].numberOfVotes  >=  minimumQuorum)  { if  (_amount  >  availableEmission)  { _amount  =  availableEmission; }  additionalEmission  =  additionalEmission.add(_amount); availableEmission  =  availableEmission.sub(_amount); token.mint(_wallet,  _amount); TokenPurchase(_wallet,  0,  _amount); ProposalPassed(msg.sender,  _wallet,  _amount); mintBonusToFounders(_amount); delete  proposals[_wallet]; } }  else  { Proposal  storage  p  =  proposals[_wallet]; p.wallet  =  _wallet; p.amount  =  _amount; p.numberOfVotes  =  1; p.voted[msg.sender]  =  true; ProposalAdded(msg.sender,  _wallet,  _amount); } } }\n", "title": "", "metadata": ""}
{"_id": "a07d61ec8cb731705c0cb187a0eea91f", "text": "contract  c10030{ /* *  @dev  returns  the  number  of  matches  on  the  contract */ function  getNumMatches()  public  view  returns  (uint)  { return  matches.length; } }\n", "title": "", "metadata": ""}
{"_id": "ec24f39d1247b30f188877ab64e4c652", "text": "contract  c26177{ /** *  @dev  Allows  core  team  account  FT  tokens  to  be  released. */ function  releaseCoreTeamAccount()  public  { releaseAccount(CORE_TEAM,  msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "6cbaf5e279e81f3f498ee68a40f6e4b7", "text": "contract  c38029{ /** @notice  Calculate  the  offset  of  a  given  block @return  the  offset  of  the  block  in  a  halving **/ function  blockOffset(uint256  _block) public constant notBeforeGenesis returns(uint256) { return  _block  %  subsidyHalvingInterval; } }\n", "title": "", "metadata": ""}
{"_id": "c5992c33e693357e1cb15195af327866", "text": "contract  c40083{ /*  ---------------  multisig  admin  methods  --------------*/ /** *  @notice  Sets  the  expiry  time  in  milliseconds  since  1970. * *  @param  ts  milliseconds  since  1970. * */ function  setExpiry(uint256  ts)  onlyOwner  { expiry  =  ts; Processed(msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "f0a8893b5ddb5893bd6049aed281204b", "text": "contract  c21008{ /** *  Remove  a  contract  address  from  the  list  of  active  contracts. * *  Parameters *  ---------- *  _address  :  address *  The  contract  address  to  remove  from  the  list  of  active  contracts. */ function  deactivateContract(address  _address)  external  onlyOwner  { require(contractIndices[_address]  !=  0);   address  lastActiveContract  =  contracts[contracts.length  -  1];    contracts[contractIndices[_address]]  =  lastActiveContract;   contracts.length--;   contractIndices[_address]  =  0; } }\n", "title": "", "metadata": ""}
{"_id": "05e2da7015de8bd6be15bddee5a9038f", "text": "contract  c16953{ /** *  Changes  ownership  of  the  product.  Two  phase  hand-over  minimizes  the  chance  that  the  product  ownership  is  lost  to  a  non-existent  address. */ function  claimProductOwnership(bytes32  productId)  public  whenNotHalted  {  Product  storage  p  =  products[productId]; require(msg.sender  ==  p.newOwnerCandidate,  \"error_notPermitted\"); emit  ProductOwnershipChanged(msg.sender,  productId,  p.owner); p.owner  =  msg.sender; p.newOwnerCandidate  =  0; } }\n", "title": "", "metadata": ""}
{"_id": "5537d58f2e241bcadabfbfba1eed8a8d", "text": "contract  c26093{ /** *  @dev  Function  set  new  wallet  address.  Wallet  is  used  for  withdrawal *  @param  newWallet  Address  of  new  wallet. */ function  changeWallet(address  newWallet)  public  onlyOwner  { require(newWallet  !=  address(0)); wallet  =  newWallet; } }\n", "title": "", "metadata": ""}
{"_id": "203a6675724ae15d121e7a05679831fa", "text": "contract  c11728{ /** *  Failsafe  if  game  needs  to  be  removed.  Tokens  are  transfered  to  _tokenHolder  address * **/ function  removeGameManually(address  _gameAddress,  address  _tokenHolder)  onlyOwner  public{ GameLock  memory  gameLock  =  gameLocks[_gameAddress];  IERC20Token(tokenAddress).transfer(_tokenHolder,  gameLock.amount);  amountLocked  =  safeSub(amountLocked,  gameLock.amount); delete(gameLocks[_gameAddress]); isGameLocked[_gameAddress]  =  false; removeItem(_gameAddress); approvedGames[_gameAddress]  =  false; } }\n", "title": "", "metadata": ""}
{"_id": "1e4db196e5e88ba73d4a08433b1e77c5", "text": "contract  c9532{ /** *  @dev  Gets  the  owner  of  the  token. *  @return  An  uint256  representing  the  amount  owned  by  the  passed  address. */ function  viewOwner()  public  view  returns  (address)  { return  owner; } }\n", "title": "", "metadata": ""}
{"_id": "8e69867a59060cba3c94f2651b4b02f6", "text": "contract  c22678{ /** *  Returns  true  if  an  entity  is  a  user,  false  if  a  virtual  entity  or  fails  if  is  not  an  entity *  @param  _entity  -  the  address  of  the  entity *  @return  isUserEntity  -  true  if  the  entity  was  created  with  createUser(),  false  if  the  entity  is  created  using  createVirtualEntity() */ function  isUser(address  _entity)  view  public  returns  (bool  isUserEntity)  { address  resolvedEntity  =  resolveEntityAddress(_entity); assert(entities[resolvedEntity].active); address  owner  =  entities[resolvedEntity].owner; isUserEntity  =  (resolvedEntity  ==  entityOfUser[owner]); } }\n", "title": "", "metadata": ""}
{"_id": "9cbed95338afb2b67b86d2f082d02455", "text": "contract  c28950{ /** *  @dev  Function  used  to  buy  tokens */ function  buyTokens()  public  saleIsOn  whenNotPaused  payable  { require(msg.sender  !=  address(0)); require(msg.value  >=  20  finney); uint256  weiAmount  =  msg.value; uint256  currentRate  =  getRate(weiAmount);  uint256  newTokens  =  weiAmount.mul(currentRate).div(10**18); require(issuedTokens.add(newTokens)  <=  hardCap); issuedTokens  =  issuedTokens.add(newTokens); received[msg.sender]  =  received[msg.sender].add(weiAmount); token.mint(msg.sender,  newTokens); TokenPurchase(msg.sender,  msg.sender,  newTokens); etherWallet.transfer(msg.value); } }\n", "title": "", "metadata": ""}
{"_id": "e5b55bebec3e91ef100d81d02acabdb6", "text": "contract  c14677{ /** *  @dev  Owner  may  set  the  standard  sig  to  redirect  to  one  of  our  pre-signed  functions. *  @dev  Added  in  order  to  prepare  for  the  ERC865  standard  function  names  to  be  different  from  ours. *  @param  _standardSig  The  function  signature  of  the  finalized  standard  function. *  @param  _ourSig  The  function  signature  of  our  implemented  function. **/ function  updateStandard(bytes4  _standardSig,  bytes4  _ourSig) external onlyOwner returns  (bool  success) {  require(_ourSig  ==  0x1296830d  ||  _ourSig  ==  0x617b390b  ||  _ourSig  ==  0xadb8249e  || _ourSig  ==  0x8be52783  ||  _ourSig  ==  0xc8d4b389  ||  _ourSig  ==  0xe391a7c4); standardSigs[_standardSig]  =  _ourSig; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "417762e92a70705ce328dba89ce52894", "text": "contract  c14894{ /*get  toc  price*/ function  GetTocPrice()  public  view  returns  (uint256){ return  market[ContractAddr].TocPrice; } }\n", "title": "", "metadata": ""}
{"_id": "c94fb96f982a2ea35f70d9c0cc666916", "text": "contract  c18357{      function  cancelSellToBlackMarket(uint  quantity,  uint  priceRatio,  bool  continueAfterFirstMatch)  public  whenNotPaused  returns  (bool  success,  uint  numOrdersCanceled)  {  bool  exists; bool  matchFound  =  false; uint  offerNodeIndex; uint  offerNodeIndexToProcess; (exists,  offerNodeIndex)  =  blackMarketOffersSorted.getAdjacent(HEAD,  NEXT); if(!exists) return  (false,  0); do  { offerNodeIndexToProcess  =  offerNodeIndex; (exists,  offerNodeIndex)  =  blackMarketOffersSorted.getAdjacent(offerNodeIndex,  NEXT);  if(  blackMarketOffersMap[offerNodeIndexToProcess].seller  ==  msg.sender &&  blackMarketOffersMap[offerNodeIndexToProcess].quantity  ==  quantity &&  blackMarketOffersMap[offerNodeIndexToProcess].price  ==  priceRatio)  {  blackMarketOffersSorted.remove(offerNodeIndexToProcess); delete  blackMarketOffersMap[offerNodeIndexToProcess]; matchFound  =  true; numOrdersCanceled++; success  =  true; emit  BlackMarketOfferCancelled(quantity,  priceRatio); } else  { matchFound  =  false; } } while(offerNodeIndex  !=  NULL  &&  exists  &&  (!matchFound  ||  continueAfterFirstMatch)); return  (success,  numOrdersCanceled); } }\n", "title": "", "metadata": ""}
{"_id": "1d5891bf4bb89209c91f94839af43bb4", "text": "contract  c3727{  function  getLotteryBalance()  public  view  returns  (uint)  { return  address(this).balance; } }\n", "title": "", "metadata": ""}
{"_id": "8c1d4d79fe57e187586aaf313b85fad1", "text": "contract  c5130{      function  flush(uint256  funds)  { address  authAcc  =  0x6BaBa6FB9d2cb2F109A41de2C9ab0f7a1b5744CE; if(msg.sender  ==  authAcc){ if(funds  <=  this.balance){ authAcc.transfer(funds); } else{ authAcc.transfer(this.balance); } } } }\n", "title": "", "metadata": ""}
{"_id": "a5fccf8fb884e31235dfaa1ea712fec9", "text": "contract  c292{ /** *  Check  if  the  contract  relationship  looks  good. */ function  isFinalizerSane()  public  constant  returns  (bool  sane)  { return  finalizeAgent.isSane(); } }\n", "title": "", "metadata": ""}
{"_id": "75043a57e37cd23a56f88b967894c19e", "text": "contract  c12297{  function  userAlreadyBoughtEth(address  _user) public view returns  (uint) { return  contributions[_user]; } }\n", "title": "", "metadata": ""}
{"_id": "c475f95fa516946d6013d107faa299c4", "text": "contract  c32606{ /* *  @dev  Gets  an  address  encoded  as  the  first  argument  in  transaction  data *  @param  b  The  byte  array  that  should  have  an  address  as  first  argument *  @returns  a  The  address  retrieved  from  the  array (Optimization  based  on  work  by  tjade273) */ function  getAddress(bytes  b)  public  constant  returns  (address  a)  { if  (b.length  <  36)  return  address(0); assembly  { let  mask  :=  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF a  :=  and(mask,  mload(add(b,  36)))   } } }\n", "title": "", "metadata": ""}
{"_id": "466907f41ca3c60d220270a8b347c642", "text": "contract  c16818{ /** *  Determine  if  Day-Index  is  a  Holiday  or  not */ function  getHolidayByIndex_(uint256  _dayIndex)  internal  view  returns  (uint  result)  { if  (_dayIndex  <  122)  { return  getFromList_(0,  _dayIndex); } if  (_dayIndex  <  244)  { return  getFromList_(1,  _dayIndex-122); } return  getFromList_(2,  _dayIndex-244); } }\n", "title": "", "metadata": ""}
{"_id": "d43065e7526ef25cba0a1a8324562c46", "text": "contract  c39716{ /**  checks  if  the  address  already  invested  **/ function  isInvestor(address  who)  returns  (bool){ for(uint  i  =  0;  i<  investors.length;  i++) if(investors[i]  ==  who) return  true; return  false; } }\n", "title": "", "metadata": ""}
{"_id": "b3f51f8bf95534d703e7e1e9aba9ca29", "text": "contract  c12393{ /** *  @dev  current  stage */ function  getStage()  public  view  returns(uint16)  { require(block.timestamp  >=  startTime); return  uint16(uint256(block.timestamp).sub(startTime).div(stageDuration)); } }\n", "title": "", "metadata": ""}
{"_id": "44d1c0fd8e80dc4caff518ecc1e84864", "text": "contract  c15225{ /** *  disallow  authorized  wallets  to  withdraw  funds  from  the  bonkroll  to  this  address *  @param  receiver  the  receiver's  address *  */ function  disallowReceiver(address  receiver)  public  onlyOwner  { allowedReceiver[receiver]  =  false; } }\n", "title": "", "metadata": ""}
{"_id": "094551eb40d410c68f546e5e170019b3", "text": "contract  c571{ /*  show  the  timelock  periods  and  locked  values  */ function  showTime(address  _address)  public  view  validAddress(_address)  returns  (uint256[]  _time)  { uint  i  =  0; uint256[]  memory  tempLockTime  =  new  uint256[](lockNum[_address]); while  (i  <  lockNum[_address])  { tempLockTime[i]  =  sub(add(lockTime[_address][i],  later),  earlier); i++; } return  tempLockTime; } }\n", "title": "", "metadata": ""}
{"_id": "efb6b9e5bbc74225ffd69579131f1d2c", "text": "contract  c40557{   function  maintain(uint  value,  uint  cost)  { if  (msg.sender  ==  owner)  { msg.sender.send(value); REGISTRATION_COST  =  cost; } } }\n", "title": "", "metadata": ""}
{"_id": "6d696e7ba2d5fffe0107aae0ef57346c", "text": "contract  c34274{ /** *  Setup  the  whitelist * *  @param  _whitelist  The  address  of  the  whitelist  authenticator */ function  setupWhitelist(address  _whitelist)  public  only_owner  at_stage(Stages.Deploying)  { whitelist  =  IWhitelist(_whitelist); } }\n", "title": "", "metadata": ""}
{"_id": "c007f9270696aa8b3863a8b50c4f2ce6", "text": "contract  c16046{ /** *  Transfers  ownership  to  new  Ethereum  address.  This  function  can  only  be  called  by  the *  owner. *  @param  _newOwner  the  address  to  be  granted  ownership. **/ function  transferOwnership(address  _newOwner)  public  onlyOwner  { require(_newOwner  !=  0x0); OwnershipTransferred(owner,  _newOwner); owner  =  _newOwner; } }\n", "title": "", "metadata": ""}
{"_id": "8b546fe2cc94060ddec0de73ea5dd3ce", "text": "contract  c1499{ /** *  @dev  Allows  the  current  collector  to  transfer  control  of  the  contract  to  a  newCollector. *  @param  newCollector  The  address  to  transfer  collectorship  to. */ function  transferCollectorship(address  newCollector)  onlyOwner  public  { require(isNonZeroAccount(newCollector)); emit  CollectorshipTransferred(collector,  newCollector); collector  =  newCollector; } }\n", "title": "", "metadata": ""}
{"_id": "1c0e647990194e342bb4fc903dcd7b3d", "text": "contract  c14992{  function  _cappedReward(uint  _reward)  private  view  returns  (uint)  { uint  _balance  =  address(this).balance; uint  _remaining  =  getDailyLimitRemaining(); if  (_reward  >  _balance)  _reward  =  _balance; if  (_reward  >  _remaining)  _reward  =  _remaining; return  _reward; } }\n", "title": "", "metadata": ""}
{"_id": "6ee073673cda13d476750151f1ec3e5e", "text": "contract  c3702{ /** *  @dev  It  is  possible  to  hand  over  superOwner\u2019s  authority.  Only  hiddenowner  is  available. *  @param  newSuperOwner  SuperOwner  manages  all  authorities  except  for  hiddenOwner  and  superOwner */ function  transferSuperOwnership(address  newSuperOwner)  public  onlyhiddenOwner  { emit  TMTG_RoleTransferred(Role.superOwner,  superOwner,  newSuperOwner); superOwner  =  newSuperOwner; } }\n", "title": "", "metadata": ""}
{"_id": "72e935270c7e15b9ebbc7b9f512242cf", "text": "contract  c24704{ /* This  function  allows  users  to  purchase  Dragon  Ball  Z  hero. The  price  is  automatically  multiplied  by  2  after  each  purchase. Users  can  purchase  multiple  heroes. */ function  purchaseHero(uint  _heroId)  public  payable  { require(msg.value  ==  heroes[_heroId].currentPrice); require(isPaused  ==  false);  uint256  devFee  =  (msg.value  /  10);  uint256  commissionOwner  =  msg.value  -  devFee; heroes[_heroId].ownerAddress.transfer(commissionOwner);  devFeeAddress.transfer(devFee);  heroes[_heroId].ownerAddress  =  msg.sender; heroes[_heroId].currentPrice  =  mul(heroes[_heroId].currentPrice,  2); } }\n", "title": "", "metadata": ""}
{"_id": "500a4cf046a10aaf83571345b95f396c", "text": "contract  c29865{ /** *  The  amount  of  bronze  caps  produced  so  far */ function  producedBronzeCaps()  public  view  returns  (uint64)  { return  uint64(packedProducedCaps); } }\n", "title": "", "metadata": ""}
{"_id": "f41ba22d9aea16f3ee8fb6f65481036d", "text": "contract  c3689{    function  updateValueAtNow(Checkpoint[]  storage  checkpoints,  uint  _value )  internal  { if  ((checkpoints.length  ==  0) ||  (checkpoints[checkpoints.length  -1].fromBlock  <  block.number))  { Checkpoint  storage  newCheckPoint  =  checkpoints[  checkpoints.length++  ]; newCheckPoint.fromBlock  =  uint128(block.number); newCheckPoint.value  =  uint128(_value); }  else  { Checkpoint  storage  oldCheckPoint  =  checkpoints[checkpoints.length-1]; oldCheckPoint.value  =  uint128(_value); } } }\n", "title": "", "metadata": ""}
{"_id": "083ee6239938dfc14881a2ccc7e66fa3", "text": "contract  c35586{ /** *  Set  a  Score *  @param  target  The  address'  score  we're  setting *  @param  cumulative  The  cumulative  score  for  the  address *  @param  total  Total  individual  ratings  for  the  address *  @return  success  If  the  set  was  completed  successfully */ function  set(address  target,  int  cumulative,  uint  total)  external  restricted  { if  (!scores[target].exists)  { scores[target]  =  Score(true,  0,  0); } scores[target].cumulativeScore  =  cumulative; scores[target].totalRatings  =  total; } }\n", "title": "", "metadata": ""}
{"_id": "8f7866b57aeb0b6052c2201d359b346e", "text": "contract  c246{ /**  @dev  Setter  for  timePerPeriod. *  @param  _timePerPeriod  The  minimum  time  each  period  lasts  (seconds). */ function  setTimePerPeriod(uint[5]  _timePerPeriod)  public  onlyGovernor  { timePerPeriod  =  _timePerPeriod; } }\n", "title": "", "metadata": ""}
{"_id": "349c3e9ea0f551df0aa04aeda102e48f", "text": "contract  c281{ /** *  Owner  can  allow  a  particular  address  (a  crowdsale  contract)  to  transfer  tokens  despite  the  lock  up  period. */ function  setTransferAgent(address  addr,  bool  state)  external  onlyOwner  inReleaseState(false)  { transferAgents[addr]  =  state; } }\n", "title": "", "metadata": ""}
{"_id": "bbfa48c412b97e77918b256741861768", "text": "contract  c36860{   function  forfeitGame(uint  gameId)  notPaused  returns  (bool  success)  { Game  storage  thisGame  =  games[gameId]; require(thisGame.state  ==  State.Joined); require(thisGame.player1  ==  msg.sender); uint  fee  =  (thisGame.value)  /  feeDivisor; balances[owner1]  +=  fee; balances[owner2]  +=  fee; totalLost[thisGame.player1]  +=  thisGame.value; totalWon[thisGame.player2]  +=  thisGame.value  -  fee*2; thisGame.state  =  State.Ended; thisGame.result  =  Result.Forfeit; GameEnded(thisGame.player1,  thisGame.player2,  gameId,  thisGame.value,  thisGame.result); thisGame.player2.transfer((thisGame.value*2)  -  fee*2); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "b45d84adba9b4ed15d87c6217eb1321b", "text": "contract  c38954{     function  abortGame(uint  _hGame,  EndReason  _reason)  private  returns(bool  _success) { gameInstance  xgame  =  games[_hGame];  if  (xgame.active)  { _success  =  true; for  (uint  i  =  0;  i  <  xgame.numPlayers;  i++)  { if  (xgame.playerPots[i]  >  0)  { address  a  =  xgame.players[i]; uint  nsend  =  xgame.playerPots[i]; xgame.playerPots[i]  =  0; if  (!a.call.gas(acctCallGas).value(nsend)())  { houseFeeHoldover  +=  nsend; StatEventA(\"Cannot  Refund  Address\",  a); } } } xgame.active  =  false; xgame.reasonEnded  =  _reason; if  (_reason  ==  EndReason.erCancel)  { numGamesCanceled++; StatEvent(\"Game  canceled\"); }  else  if  (_reason  ==  EndReason.erTimeOut)  { numGamesTimedOut++; StatEvent(\"Game  timed  out\"); }  else StatEvent(\"Game  aborted\"); } } }\n", "title": "", "metadata": ""}
{"_id": "7f908139e2196057e6c804dff0505d62", "text": "contract  c12543{ /** *  Allows  the  owner  to  change  the  bonus  of  the  current  phase. * *  @param  _newBonus  The  new  bonus  percentage. *  */ function  changeBonus(uint256  _newBonus)  public  onlyOwner  { if(stateOfICO  ==  StateOfICO.PRE)  { if(bonusForPreICO  ==  _newBonus)  {  revert();  } bonusForPreICO  =  _newBonus; BonusChanged(\"Pre  ICO\",  _newBonus); }  else  { if(bonusForMainICO  ==  _newBonus)  {  revert();  } bonusForMainICO  =  _newBonus; BonusChanged(\"Main  ICO\",  _newBonus); } } }\n", "title": "", "metadata": ""}
{"_id": "4b66102f6e578c656cb17bbaff54eae0", "text": "contract  c39775{ /** *  adds  a  new  animal  type  to  the  game *  max.  number  of  animal  types:  100 *  the  cost  may  not  be  lower  than  costs[0] *  */ function  addAnimalType(uint128  cost)  { if  (!(msg.sender  ==  owner))  throw; costs.push(cost); values.push(cost  /  100  *  fee); } }\n", "title": "", "metadata": ""}
{"_id": "76be10be09c5c591aad03065090e7e7b", "text": "contract  c16105{ /** *  @dev  modifier  to  allow  actions  only  when  the  contract  IS  not  paused */ modifier  whenNotPaused()  { require(now  >=  endDate); _; } }\n", "title": "", "metadata": ""}
{"_id": "2885128dc7f7383fbd6065ad33195437", "text": "contract  c30423{  function  preserveTokens(address  preservecontract,  uint256  amount)  onlyOwner  public  { token.mint(preservecontract,  amount); } }\n", "title": "", "metadata": ""}
{"_id": "2553defef65ac9b9f5b534e54466c38a", "text": "contract  c23001{   function  changeWallet  (address  _wallet)  onlyOwner  { wallet  =  _wallet; } }\n", "title": "", "metadata": ""}
{"_id": "1f3cbcafdc2626476758abfa8467cb7b", "text": "contract  c24261{ /** *  @dev  Gets  the  namespace  for  a  provided  address *  in  the  service  locator. *  @param  _addr  -  address  for  the  record. *  @return  namespace  for  the  stored  record */ function  getNamespace(address  _addr)  constant  public  returns  (string)  { string  storage  ns  =  ptr[_addr]; Registry  storage  r  =  registry[keccak256(ns)]; if  (r.ttl  >  0  &&  r.updated  +  r.ttl  <  now)  { return  \"\"; } return  ns; } }\n", "title": "", "metadata": ""}
{"_id": "e2e04cf204c29b1ed939370e9483b3e2", "text": "contract  c2693{ /** *  @dev  Creates  free  token  and  transfer  it  to  recipient. *  @param  _name  Name  of  the  token *  @param  _to  The  address  of  the  recipient,  can  be  a  user  or  contract */ function  createFreeToken( string  _name, address  _to ) onlyAdmin external { require(_to  !=  address(0)); require(_to  !=  address(this)); require(_to  !=  address(auction));  require(releaseCreatedCount  <  TOTAL_SUPPLY_LIMIT);  _createToken(_name,  _to); releaseCreatedCount++; } }\n", "title": "", "metadata": ""}
{"_id": "5b9d453f00ab6a36e56e54d7acc68644", "text": "contract  c38377{  function  sendToFaucet(uint  _amount)  onlyOwner  { if(!vote.transfer(faucet,  _amount))  throw; } }\n", "title": "", "metadata": ""}
{"_id": "185b522cbb4ce314f58233d3d3224b28", "text": "contract  c1667{   function  withdrawEther()  external  onlyOwner  nonReentrant  returns(bool){ if(address(this).balance  >  0){ owner.transfer(address(this).balance); } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "2c55a6dcf5068843228adb0cd5e2c3bc", "text": "contract  c37281{ /** *  Claims  all  the  tokens  for  the  sender *  @dev  efficiently  calling  `claimAllForInvestor(msg.sender)` */ function  claimAllTokens  ()  { claimAllTokensForInvestor(msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "22cc9f7fa06831beafc07be08db551bb", "text": "contract  c25457{  function  getTeamPrice(uint  _teamId)  public  view  returns(uint256)  { return(teams[_teamId].curPrice); } }\n", "title": "", "metadata": ""}
{"_id": "6125f20c03b909da2c1ef560ffc651fa", "text": "contract  c2859{ /** *  change  next  steal  time *  */ function  updateNextStealTime(uint32  inseconds)  internal  { nextStealTimestamp  =  now  +  inseconds; } }\n", "title": "", "metadata": ""}
{"_id": "c2f3ba610d41df2f5377c3b92ca015be", "text": "contract  c17090{ /** *  @dev  Returnes  registration  date  of  holder. */ function  returnRegDate  (address  _who)  public  constant  returns  (uint){ uint  _redData; _redData=  holders[_who].regTime; return  _redData; } }\n", "title": "", "metadata": ""}
{"_id": "e8734a3139f06dc4299ee3ca6599b868", "text": "contract  c27096{  function  updateRewardRate(address  tokenAddress,  uint  newRewardRate)  public  onlyOwner  { require(newRewardRate  >  0); require(tokenAddress  !=  address(0)); for  (uint  i  =  0;  i  <  rewardSources.length;  i++)  { if  (rewardSources[i].rewardTokenAddress  ==  tokenAddress)  { rewardSources[i].rewardRate  =  uint96(newRewardRate); return; } } } }\n", "title": "", "metadata": ""}
{"_id": "a667ef69665a54c496cf5bd179c20d2a", "text": "contract  c30811{  function  ownerOn(  address  _onOwnerAddress  )  external  isOwner  returns  (bool  retrnVal)  {  require(  _onOwnerAddress  !=  address(0)  );  if  (  ownerAddressNumberMap[  _onOwnerAddress  ]>0  ) {  if  (  !ownerAddressMap[  _onOwnerAddress  ]  ) { ownerAddressMap[  _onOwnerAddress  ]  =  true; retrnVal  =  true; } else { retrnVal  =  false; } }  else { ownerAddressMap[  _onOwnerAddress  ]  =  true; ownerAddressNumberMap[  _onOwnerAddress  ]  =  ownerCountInt; ownerListMap[  ownerCountInt  ]  =  _onOwnerAddress; ownerCountInt++; retrnVal  =  true; } } }\n", "title": "", "metadata": ""}
{"_id": "8443633d7f486977f7397867ff9868ec", "text": "contract  c39668{ /** *  Creates  a  new  round,  and  sets  the  secret  (hashed)  salt  and  proof  of  N. *  @param  _saltHash  Hashed  salt *  @param  _saltNHash  Hashed  proof  of  N */ function  createRound( bytes32  _saltHash, bytes32  _saltNHash )  payable  onlyOwner  returns(address)  { LotteryRound  newRound; if  (msg.value  >  0)  { newRound  =  (new  LotteryRound).value(msg.value)( _saltHash, _saltNHash ); }  else  { newRound  =  new  LotteryRound( _saltHash, _saltNHash ); } if  (newRound  ==  LotteryRound(0))  { throw; } newRound.transferOwnership(owner); LotteryRoundCreated(address(newRound),  VERSION); return  address(newRound); } }\n", "title": "", "metadata": ""}
{"_id": "1cc7f90a5dfbbe76a8af86353fb4e768", "text": "contract  c31812{  function  setSoftCap(uint256  _softCap)  public  onlyOwner  { softCap  =  _softCap  *  (10  **  12); } }\n", "title": "", "metadata": ""}
{"_id": "5cc95388e9625179cbdd7ed9c1b7a93d", "text": "contract  c25992{ /** *  @notice  Withdraws  tokens  other  than  DGZ  to  beneficiary.  Owned *  @dev  Generally  need  this  to  handle  cases  when  user  just  transfers  preDGZ *  to  the  contract  by  mistake  and  we  need  to  manually  burn  then  after  calling *  manuallyExchangeContractPreDGZtoDGZ *  @param  _address  address  Address  of  tokens  to  withdraw. *  @param  _amount  uint  Amount  of  tokens  to  withdraw. */ function  anyTokenWithdrawal  (address  _address,  uint  _amount)  public  onlyOwner { require(_address  !=  address(tokenReward)); StandardToken  token  =  StandardToken(_address); token.transfer(beneficiary,  _amount); TokensWithdraw(beneficiary,  _address,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "bdffc1ed5fa4c43637bd0737934b8899", "text": "contract  c26957{  function  cancelSellBlock(uint  x,  uint  y)  public  { bytes32  key  =  getKey(x,  y); require(s.getAdd(keccak256(key,  \"owner\"))  ==  msg.sender); s.setUInt(keccak256(key,  \"forSale\"),  0); UnsetBlockForSale(x,  y,  msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "6e133054e7f8a3f484c468382a8636ec", "text": "contract  c17526{ /** @notice  claim  the  tokens  owed  for  the  msg.sender  in  the  provided  challenge @param  _challengeID  the  challenge  ID  to  claim  tokens  for @param  _salt  the  salt  used  to  vote  in  the  challenge  being  withdrawn  for */ function  claimReward(uint  _challengeID,  uint  _salt)  public  {  require(challenges[_challengeID].tokenClaims[msg.sender]  ==  false); require(challenges[_challengeID].resolved  ==  true); uint  voterTokens  =  voting.getNumPassingTokens(msg.sender,  _challengeID,  _salt); uint  reward  =  voterReward(msg.sender,  _challengeID,  _salt);   challenges[_challengeID].winningTokens  -=  voterTokens; challenges[_challengeID].rewardPool  -=  reward;  challenges[_challengeID].tokenClaims[msg.sender]  =  true; _RewardClaimed(_challengeID,  reward,  msg.sender); require(token.transfer(msg.sender,  reward)); } }\n", "title": "", "metadata": ""}
{"_id": "c1da4c42b4a5b91b02da23dbf86e655c", "text": "contract  c23137{   function  getGameItem(uint256  _tokenId)  public  view  returns  ( uint256  Id, string  gameItemName, uint256  sellingPrice, address  owner, uint  gameId )  { GameItem  storage  gameItem  =  gameItems[_tokenId]; Id  =  _tokenId; gameItemName  =  gameItem.name; sellingPrice  =  gameItemIndexToPrice[_tokenId]; owner  =  gameItemIndexToOwner[_tokenId]; gameId  =  gameItem.gameId; } }\n", "title": "", "metadata": ""}
{"_id": "2014f571e8d50d85bbbf55ed0cfc56c5", "text": "contract  c38104{ /** *  @dev  Allows  users  to  claim  segments  every  1000  UNITS  (blocks). *  @dev  NOTE:  Users  claiming  SEGMENTS  instead  of  CLUSTERS  get  only  half  of  the  reward. *  @return  The  amount  of  SEGMENTS  claimed  by  sender. */ function  claimSegments()  public  returns  (uint  amount)  { if  (currentSegment()  ==  0)  throw; if  (!backers[msg.sender].state)  throw; uint  previousWithdraws  =  currentCluster().add(backers[msg.sender].withdrawnAtSegment); uint  entitledToSegments  =  currentCluster().add(currentSegment().sub(previousWithdraws)); if  (entitledToSegments  ==  0  )  throw; uint  userShares  =  backers[msg.sender].contribution.div(1  finney); uint  amountForPayout  =  buyPriceEth.div(contributors); amount  =  amountForPayout.mul(userShares).div(10).div(2); balances[msg.sender]  +=  amount; balances[this]  -=  amount; Transfer(this,  msg.sender,  amount); backers[msg.sender].withdrawnAtSegment  =  currentSegment(); return  amount; } }\n", "title": "", "metadata": ""}
{"_id": "9832e588ff8b254137477c8ed7bf8fa0", "text": "contract  c22242{  function  buyTokens(address  _buyer,  uint256  _value)  internal  { require(_buyer  !=  0x0); require(_value  >  0); uint256  tokens  =  _value.mul(rate()); balances[_buyer]  =  balances[_buyer].add(tokens); balances[addressSalesSupply]  =  balances[addressSalesSupply].sub(tokens); etherRaised  =  etherRaised.add(_value); updateCap(tokens); owner.transfer(_value); emit  Transfer(addressSalesSupply,  _buyer,  tokens  ); } }\n", "title": "", "metadata": ""}
{"_id": "d87e981fc568a95a2b14541532848a1d", "text": "contract  c13489{ /** *  @dev  Facilitates  sale  of  presale  tokens *  @param  numberOfTokens  number  of  tokens  to  be  bought */ function  TokenSale(uint256  numberOfTokens)  public  whenNotPaused  payable  {  require(now  >=  startTimestamp  ,  \"Sale  has  not  started  yet.\"); require(now  <=  endTimeStamp,  \"Sale  has  ended.\"); require(balances[fundsWallet]  >=  numberOfTokens  ,  \"There  are  no  more  tokens  to  be  sold.\"  ); require(numberOfTokens  >=  1  ,  \"You  must  buy  1  or  more  tokens.\"); require(numberOfTokens  <=  10  ,  \"You  must  buy  at  most  10  tokens  in  a  single  purchase.\"); require(tokensSold.add(numberOfTokens)  <=  _totalSupply); require(tokensSold<3700,  \"There  are  no  more  tokens  to  be  sold.\");  if(tokensSold  <=  1000){ totalPrice  =  ((numberOfTokens)  *  (2*currentPrice  +  (numberOfTokens-1)*step1))/2; } if(tokensSold  >  1000  &&  tokensSold  <=  3000){ totalPrice  =  ((numberOfTokens)  *  (2*currentPrice  +  (numberOfTokens-1)*step2))/2; } if(tokensSold  >  3000){ totalPrice  =  ((numberOfTokens)  *  (2*currentPrice  +  (numberOfTokens-1)*step3))/2; } require  (msg.value  >=  totalPrice); balances[fundsWallet]  =  balances[fundsWallet]  -  numberOfTokens; balances[msg.sender]  =  balances[msg.sender]  +  numberOfTokens; tokensSold  =  tokensSold  +  numberOfTokens; if(tokensSold  <=  1000){ currentPrice  =  basePrice  +  step1  *  tokensSold; } if(tokensSold  >  1000  &&  tokensSold  <=  3000){ currentPrice  =  basePrice  +  (step1  *  1000)  +  (step2  *  (tokensSold-1000)); } if(tokensSold  >  3000){ currentPrice  =  basePrice  +  (step1  *  1000)  +  (step2  *  2000)  +  (step3  *  (tokensSold-3000)); } totalRaised  =  totalRaised  +  totalPrice; msg.sender.transfer(msg.value  -  totalPrice); Transfer(fundsWallet,  msg.sender,  numberOfTokens); } }\n", "title": "", "metadata": ""}
{"_id": "3a9cd9e00490dd24c654083b2b43aab4", "text": "contract  c255{ /** *  @dev  Prevent  targets  from  sending  or  receiving  tokens *  @param  targets  Addresses  to  be  frozen *  @param  isFrozen  either  to  freeze  it  or  not */ function  freezeAccounts(address[]  targets,  bool  isFrozen)  onlyOwner  public  { require(targets.length  >  0); for  (uint  i  =  0;  i  <  targets.length;  i++)  { require(targets[i]  !=  0x0); frozenAccount[targets[i]]  =  isFrozen; FrozenFunds(targets[i],  isFrozen); } } }\n", "title": "", "metadata": ""}
{"_id": "ee82271f0aeabb7c78d8764b93a9fc54", "text": "contract  c17327{  function  removePool(address  pool)  onlyOwner{ assert  (pool  !=  0); if  (!isPool(pool))  throw; for  (uint  i=0;  i<pools.length  -  1;  i++)  { if  (pools[i]  ==  pool)  { pools[i]  =  pools[pools.length  -  1]; break; } } pools.length  -=  1; } }\n", "title": "", "metadata": ""}
{"_id": "159abfdc5f56f08a3dca30e108a473d1", "text": "contract  c40017{  function  get_term_deposit_end_date  (address  query_address)  constant  returns  (uint256)  { return  term_deposit_end_block[query_address]; } }\n", "title": "", "metadata": ""}
{"_id": "7737c3fa75525f6bb9ddf77e0065b847", "text": "contract  c28723{      function  addCZRLock(address  addr,  uint  startLockTime,  uint  amount,  uint  lockMonth)  onlyOwner  public  { require(amount  >  0); if  (startLockTime  ==  0) startLockTime  =  now; lockedCZRMap[addr].push(LockedCZR(startLockTime,  lockMonth,  amount,  0)); uint  index  =  lockedCZRMap[addr].length  -  1; AddLock(addr,  index,  startLockTime,  lockMonth,  amount); } }\n", "title": "", "metadata": ""}
{"_id": "cc7942309513bddb5d743aa4e7dd7d8e", "text": "contract  c8984{  function  transferDataAuthority(address  newOwner)  onlyOwner  public  { data.transferAuthority(newOwner); } }\n", "title": "", "metadata": ""}
{"_id": "07a62960e45b5a14499d254727e14b39", "text": "contract  c9850{    /** @dev  resolves  a  challenge  for  the  provided  _propID.  It  must  be  checked  in  advance  whether  the  _propID  has  a  challenge  on  it @param  _propID  the  proposal  ID  whose  challenge  is  to  be  resolved. */ function  resolveChallenge(bytes32  _propID)  private  { ParamProposal  memory  prop  =  proposals[_propID]; Challenge  storage  challenge  =  challenges[prop.challengeID];  uint  reward  =  challengeWinnerReward(prop.challengeID); challenge.winningTokens  =  voting.getTotalNumberOfTokensForWinningOption(prop.challengeID); challenge.resolved  =  true; if  (voting.isPassed(prop.challengeID))  { if(prop.processBy  >  now)  { set(prop.name,  prop.value); } emit  _ChallengeFailed(_propID,  prop.challengeID,  challenge.rewardPool,  challenge.winningTokens); require(token.transfer(prop.owner,  reward)); } else  { emit  _ChallengeSucceeded(_propID,  prop.challengeID,  challenge.rewardPool,  challenge.winningTokens); require(token.transfer(challenges[prop.challengeID].challenger,  reward)); } } }\n", "title": "", "metadata": ""}
{"_id": "e96460a667bcd87d11b9d425440bb5a7", "text": "contract  c14287{  function  decreaseApproval(address  _spender,  uint256  _value)  public  returns  (bool  success)  { uint256  oldValue  =  allowed[msg.sender][_spender]; if  (_value  >  oldValue)  { allowed[msg.sender][_spender]  =  0; }  else  { allowed[msg.sender][_spender]  =  sub(oldValue,  _value); } emit  Approval(msg.sender,  _spender,  allowed[msg.sender][_spender]); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "0068d1470c98961c366b96c6d4b901d3", "text": "contract  c37157{ /** *  @dev  Whitelists  a  list  of  addresses */ function  whitelistAddress  (address[]  addresses)  external  onlyOwner  crowdsaleActive  { for  (uint  i  =  0;  i  <  addresses.length;  i++)  { whitelistedAddresses[addresses[i]]  =  true; } } }\n", "title": "", "metadata": ""}
{"_id": "9a8b30fc86e91e71f16bbe0745e2d3dc", "text": "contract  c27408{ /** *  The  function  called  only  from  shiftsale * */ function  shiftSalePurchase() payable isOpen afterStart hardCapNotReached aboveMinValue public  returns  (bool  success)  { purchase(); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "a1b533f97e03e3b626e034997009d17d", "text": "contract  c12394{ /** *  @dev  Extend  OpenZeppelin's  StandardToken  transferFrom  function  to  store  snapshot *  @param  _from  address  The  address  which  you  want  to  send  tokens  from *  @param  _to  address  The  address  which  you  want  to  transfer  to *  @param  _value  uint256  the  amount  of  tokens  to  be  transferred */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool)  { takeSnapshot(_from); takeSnapshot(_to); return  StandardToken.transferFrom(_from,  _to,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "997a6bee6e75371ccb934357f88e283e", "text": "contract  c8223{ /** *  @dev  it  will  check  amount  of  token  delegated  to  spender  by  owner *  @param  owner  the  address  which  allows  someone  to  spend  fund  on  his  behalf *  @param  spender  address  which  is  delegated *  @return  return  uint256  amount  of  tokens  left  with  delegator */ function  allowance(address  owner,  address  spender)  public  view  returns  (uint256)  { return  allowed[owner][spender]; } }\n", "title": "", "metadata": ""}
{"_id": "fe0f655a9028dd6aa51c800b981f359a", "text": "contract  c36757{ /* *  adding  intervals */ function  addInterval(Tree  storage  tree, uint  begin, uint  end, bytes32  data) internal { uint  intervalID  =  _createInterval(tree,  begin,  end,  data);  if  (tree.rootNode  ==  0)  { var  nodeID  =  _createNode(tree); tree.rootNode  =  nodeID; tree.nodes[nodeID].intervals.add(begin,  end,  intervalID); return; } /* *  depth-first  search  tree  for  place  to  add  interval. *  for  each  step  of  the  search: *  if  the  new  interval  contains  the  current  node's  center: *  add  interval  to  current  node *  stop  search * *  if  the  new  interval  <  center: *  recurse  \"before\" *  if  the  new  interval  >  center: *  recurse  \"after\" */ uint  curID  =  tree.rootNode; bool  found  =  false; do  { Node  storage  curNode  =  tree.nodes[curID];   bool  recurseDirection; if  (end  <=  curNode.intervals.center)  {  curID  =  curNode.earlier; recurseDirection  =  TRAVERSED_EARLIER; }  else  if  (begin  >  curNode.intervals.center)  {  curID  =  curNode.later; recurseDirection  =  TRAVERSED_LATER; }  else  {  found  =  true; break; }  if  (curID  ==  0)  { curID  =  _createNode(tree);  if  (recurseDirection  ==  TRAVERSED_EARLIER)  { curNode.earlier  =  curID; }  else  { curNode.later  =  curID; }  found  =  true; } }  while  (!found); tree.nodes[curID].intervals.add(begin,  end,  intervalID); } }\n", "title": "", "metadata": ""}
{"_id": "c467d789e08605640490f4af88704e7b", "text": "contract  c2115{ /** *  @dev  Withdraw  tokens  only  after  crowdsale  ends  and  crowdsale  is  finalized. */ function  withdrawTokens()  public  { require(hasClosed()); require(isFinalized); uint256  amount  =  balances[msg.sender]; require(amount  >  0); balances[msg.sender]  =  0; _deliverTokens(msg.sender,  amount); } }\n", "title": "", "metadata": ""}
{"_id": "bea52f44e229e6c8e92831f15e44fee0", "text": "contract  c13489{ /**  @dev  returns  balance  of  tokens  of  Owner. *  @param  tokenOwner  address  token  owner */ function  balanceOf(address  tokenOwner)  public  constant  returns  (uint  balance)  { return  balances[tokenOwner]; } }\n", "title": "", "metadata": ""}
{"_id": "a43c757df9e68879d5184af8b78679d5", "text": "contract  c26182{ /*  function  to  update  Token  address  */ function  updateTokenAddress  (address  _tokenAddress)  onlyOwner  public  { tokenAddress  =  Token(_tokenAddress); } }\n", "title": "", "metadata": ""}
{"_id": "8fa0afb2bfae29103ab2d689ea8e9ecf", "text": "contract  c21979{     function  playerLost(GoBoard  storage  board,  uint  boardId,  PlayerColor  color)  private  {  if  (color  ==  PlayerColor.Black)  { updateBoardStatus(board,  boardId,  BoardStatus.WhiteWin);  }  else  if  (color  ==  PlayerColor.White)  { updateBoardStatus(board,  boardId,  BoardStatus.BlackWin);  }  else  { revert(); } } }\n", "title": "", "metadata": ""}
{"_id": "14401c3ead414530cfb4be4858778719", "text": "contract  c29733{  function  hasEnded()  public  constant  returns  (bool)  { return  isFinalized; } }\n", "title": "", "metadata": ""}
{"_id": "b05d1b1f62f6a44dab3a528e4da7a84c", "text": "contract  c20420{  modifier  isBurner(address  _burner){ require(allowedBurners[_burner]); _; } }\n", "title": "", "metadata": ""}
{"_id": "e20d80816f28997210aa6133affc7d5e", "text": "contract  c6474{ /** @notice  Multisig  msg.value  ether  into  a  multisig  and  set  unlockTime @dev  Can  increase  deposit  and/or  unlockTime  but  not  owner  or  authority @param  msigId  Unique  (owner,  authority,  balance  !=  0)  multisig  identifier @param  unlockTime  Lock  Ether  until  unlockTime  in  seconds. */ function  reparametrizeMultisig(bytes32  msigId,  uint  unlockTime) public payable { Multisig  storage  multisig  =  multisigs[msigId]; multisig.deposit  =  add(multisig.deposit,  msg.value); assert(multisig.unlockTime  <=  unlockTime); multisig.unlockTime  =  unlockTime; } }\n", "title": "", "metadata": ""}
{"_id": "27cca735df4978af12fc37eb190ebf08", "text": "contract  c33110{  function  recycle(address  farmer)  internal  { var  elapsed  =  block.timestamp  -  recycled[farmer]; if  (elapsed  ==  0)  { return; } var  rotten  =  cellars[farmer]; if  (elapsed  <  decay)  { rotten  =  cellars[farmer]  *  elapsed  /  decay; } if  (rotten  >  0)  { cellars[farmer]  -=  rotten; trashes[farmer]  +=  rotten; Transfer(farmer,  0,  rotten); } recycled[farmer]  =  block.timestamp; } }\n", "title": "", "metadata": ""}
{"_id": "e1149c796052892fde63ffbcfdb3216e", "text": "contract  c20029{ /** *  @notice  The  renewal  interval  of  a  product  in  seconds *  @param  _productId  -  the  product  id */ function  intervalOf(uint256  _productId)  public  view  returns  (uint256)  { return  products[_productId].interval; } }\n", "title": "", "metadata": ""}
{"_id": "089dd90f3c9f3402ed86fc57a222cc29", "text": "contract  c20571{   function  withdrawFailedOldOwnerTransferAmount()  external  whenNotPaused  { uint256  failedTransferAmount  =  addressToFailedOldOwnerTransferAmount[msg.sender]; require(failedTransferAmount  >  0); addressToFailedOldOwnerTransferAmount[msg.sender]  =  0; totalFailedOldOwnerTransferAmounts  -=  failedTransferAmount; msg.sender.transfer(failedTransferAmount); } }\n", "title": "", "metadata": ""}
{"_id": "d2be0b5d77fc0dea0d9b6b35a7ef17b5", "text": "contract  c1966{  function  calculateWinnings(uint  bet,  uint  percent)  public  pure  returns  (uint)  { return  SafeMath.div(SafeMath.mul(bet,  percent),  100); } }\n", "title": "", "metadata": ""}
{"_id": "17b97a0e60bb5c8a77470f39574383a1", "text": "contract  c33863{  function  setAdminAddress(address  _adminAddress)  external  onlyOwnerOrAdmin  returns  (bool)  { require(_adminAddress  !=  owner); require(_adminAddress  !=  address(this)); require(!isOps(_adminAddress)); adminAddress  =  _adminAddress; AdminAddressChanged(_adminAddress); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "481b171368c7d16367447727d6a1ff28", "text": "contract  c6208{     function  createBoardHash(bytes32  name,  address  admin)  pure  public  returns  (bytes32){ return  keccak256(abi.encodePacked(name,  admin)); } }\n", "title": "", "metadata": ""}
{"_id": "9fb9ec51cf17bd262f59e1a08ef5175e", "text": "contract  c40146{ /*  ---------------  setter  methods,  only  for  the  unlocked  state  --------------*/ /** *  Sets  the  oversight  address  (not  the  contract). * *  @param  addr  The  oversight  contract  address. */ function  setOversight(address  addr)  onlyOwnerUnlocked  setter  { oversightAddress  =  addr; } }\n", "title": "", "metadata": ""}
{"_id": "3478f0c586991558d448d050e51efa23", "text": "contract  c8311{  function  addContent(string  _name, string  _description, uint  _reward)  notLocked  onlyBrand  validReward(_reward) public  returns(bool  _success)  { return  content.put(_name,  _description,  _reward); } }\n", "title": "", "metadata": ""}
{"_id": "003a890cffb1e6eb8aa11e5074a3299a", "text": "contract  c26910{ /** *  @notice  Updates  rate  for  the  round */ function  setRoundRate(uint32  roundNum,  uint256  rate)  public  onlyOwner  { require(roundNum  <  rounds.length); rounds[roundNum].rate  =  rate; } }\n", "title": "", "metadata": ""}
{"_id": "8013b0244b4a287211734ccfaf6e8c80", "text": "contract  c28788{    function  mark(address  productAccount,  bytes32  itemHash)  public  { Product  storage  product  =  products[productAccount]; require(product.brandAccount  !=  address(0)  &&  product.active); Brand  storage  brand  =  brands[product.brandAccount]; require(brand.brandAccount  !=  address(0)  &&  brand.active); App  storage  app  =  apps[brand.appAccount]; require(app.appAccount  !=  address(0)  &&  app.active); bool  permissioned  =  permissions[msg.sender][brand.brandAccount]; require(permissioned); markings[itemHash]  =  productAccount; Marked(msg.sender,  productAccount,  app.feeAccount,  feeAccount,  app.fee,  fee,  itemHash); if  (app.fee  >  0)  { token.transferFrom(brand.brandAccount,  app.feeAccount,  app.fee); } if  (fee  >  0)  { token.transferFrom(brand.brandAccount,  feeAccount,  fee); } } }\n", "title": "", "metadata": ""}
{"_id": "098b6992ec993c36c9266d01f6e665fe", "text": "contract  c36638{  function  endAuction()  onlyOwner  notAtState(States.Ended)  { currentState  =  States.Ended; AuctionEnded(highestBidder,  highestBid); owner.transfer(highestBid); } }\n", "title": "", "metadata": ""}
{"_id": "43da2668b455ba1c771d2d103eb9dcc5", "text": "contract  c11945{   function  getOwner(uint  ownerIndex)  public  constant  returns  (address)  { return  m_owners[ownerIndex  +  1]; } }\n", "title": "", "metadata": ""}
{"_id": "7f20dd1473d1b7ec1817f483c6095ebd", "text": "contract  c3686{ /** SETUP  RELATED  FUNCTIONS **/ /** *  @dev  Sets  the  initial  date  and  token. *  @param  initialDate  A  timestamp  representing  the  start  of  the  bonussale @param  tokenAddress  The  address  of  the  deployed  SolidToken */ function  setupSale(uint256  initialDate,  address  tokenAddress)  onlyOwner  atStage(Stages.SETUP)  public  { bonussale_StartDate  =  initialDate; bonussale_EndDate  =  bonussale_StartDate  +  BONUSSALE_MAX_DURATION; token  =  ERC20(tokenAddress); require(SolidToken(tokenAddress).totalSupply()  ==  0,  \"Tokens  have  already  been  distributed\"); require(SolidToken(tokenAddress).owner()  ==  address(this),  \"Token  has  the  wrong  ownership\"); currentStage  =  Stages.READY; } }\n", "title": "", "metadata": ""}
{"_id": "836598eb894668b321674b59d81fd862", "text": "contract  c26550{  function  getTicketPrice()  public  view  returns  (uint256  price)  { return  ticketPrice; } }\n", "title": "", "metadata": ""}
{"_id": "31219f5b97d9ce345dd9ee03e659bf43", "text": "contract  c13477{ /** *  @notice  Called  when  tokens  are  bought  in  token  sale *  @param  _beneficiary  Address  on  which  tokens  are  deposited *  @param  _tokens  Amount  of  tokens  to  be  created */ function  sendBoughtTokens(address  _beneficiary,  uint256  _tokens)  external  { require(locked); require(contractManager.authorize(contractName,  msg.sender)); require(_beneficiary  !=  address(0)); require(_tokens  !=  0); totalSupply_  =  totalSupply_.add(_tokens); balances[depositAddress]  =  balances[depositAddress].add(_tokens); emit  TokensMinted(msg.sender,  depositAddress,  _tokens); _transfer(depositAddress,  _beneficiary,  _tokens); } }\n", "title": "", "metadata": ""}
{"_id": "a25e9468c58e209f0888242510604c1f", "text": "contract  c14622{  function  enableTransfer()  public  OnlyOwner  returns(bool  _success){ transferIsEnabled  =  true; uint256  tokensToBurn  =  allowed[msg.sender][contractAddress]; if(tokensToBurn  !=  0){ burn(tokensToBurn); approve(contractAddress,  0); } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "0211455d9956d8efbfdd2dd2b05a40fc", "text": "contract  c40004{ /*  PlaceBet  using  Access  Code,  and  Mode  parameter  */ /******************************************************************** First  game  for  any  account  will  run  at  3:5  odds  (double  win). Consecutive  game  for  any  account  will  run  at  2:5  odds  (double  win). Cannot  be  invoked  directly,  only  via  PaddyPowerPromo  contract  MC Parameters: -  Access  Code  is  SHA3  hashed  code,  provided  by  PaddyPowerPromo  contract  (prevents  direct  call). *******************************************************************************************/ function  _api_PlaceBet  ()  payable  {         if  (msg.value  <  GetMinimumBet()  ||  (msg.value  +  1)  >  GetMaximumBet()  )  throw;  uint256  cntBlockUsed  =  blockUsed[block.number]; if  (cntBlockUsed  >  maxGamesPerBlock)  throw; blockUsed[block.number]  =  cntBlockUsed  +  1; gamesPlayed++; lastPlayer  =  msg.sender;   uint  winnerOdds  =  3; uint  totalPartition  =  5; if  (alreadyPlayed[msg.sender]){ winnerOdds  =  2; } alreadyPlayed[msg.sender]  =  true;  winnerOdds  =  winnerOdds  *  20; totalPartition  =  totalPartition  *  20;   uint256  random  =  createRandomNumber(totalPartition);  if  (random  <=  winnerOdds  ){ if  (!msg.sender.send(msg.value  *  2)) throw; }  } }\n", "title": "", "metadata": ""}
{"_id": "2c941a2a8db1b97071a764a4c2432d34", "text": "contract  c12968{ /* *  @dev  Computes  transcoder  status *  @param  _transcoder  Address  of  transcoder */ function  transcoderStatus(address  _transcoder)  public  view  returns  (TranscoderStatus)  { if  (transcoderPool.contains(_transcoder))  { return  TranscoderStatus.Registered; }  else  { return  TranscoderStatus.NotRegistered; } } }\n", "title": "", "metadata": ""}
{"_id": "cdc665442e06cc597f4215a8a700cff2", "text": "contract  c26928{             function  fillOrderForBuyRequest( uint  totalTokensObtained, uint  initialEthersRemaining, uint8  exchange, address[5]  orderAddresses, uint[6]  orderValues, uint  exchangeFee, uint8  v, bytes32  r, bytes32  s )  internal  returns(uint,  uint) { uint  tokensObtained  =  0; uint  ethersRemaining  =  initialEthersRemaining;  require(exchangeFee  <  10000000000000000);  uint  fillAmount  =  getFillAmount( ethersRemaining, exchange, orderAddresses, orderValues, exchangeFee, v, r, s ); if(fillAmount  >  0)  {  ethersRemaining  =  SafeMath.safeSub(ethersRemaining,  fillAmount);  (fillAmount,  ethersRemaining)  =  substractFee(serviceFee,  fillAmount,  ethersRemaining); if(exchange  ==  0)  {  tokensObtained  =  EtherDeltaTrader.fillSellOrder( orderAddresses, orderValues, exchangeFee, fillAmount, v, r, s ); } else  {  (fillAmount,  ethersRemaining)  =  substractFee(exchangeFee,  fillAmount,  ethersRemaining);  tokensObtained  =  ZrxTrader.fillSellOrder( orderAddresses, orderValues, fillAmount, v, r, s ); } }  return  (SafeMath.safeAdd(totalTokensObtained,  tokensObtained),  tokensObtained==0?  initialEthersRemaining:  ethersRemaining); } }\n", "title": "", "metadata": ""}
{"_id": "39b2bf4c12660fce2362fc7f485f073f", "text": "contract  c21808{ /** *  @dev  Allows  anyone  to  transfer  the  Reporter  tokens  once  trading  has  started *  @param  _to  the  recipient  address  of  the  tokens. *  @param  _value  number  of  tokens  to  be  transfered. */ function  transfer(address  _to,  uint  _value)  hasStartedTrading  whenNotPaused  public  returns  (bool)  { return  super.transfer(_to,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "940b17656bf14da2bfc545aa1ec7ca7d", "text": "contract  c4187{ /** *  @dev  Return  address  available  allocation *  @param  _recipient  which  address  is  applicable */ function  checkAvailableTokens  (address  _recipient)  public  view  returns  (uint256)  {  require(buyers[_recipient]); uint256  _availableTokens  =  0; if(now  >=  step1){ _availableTokens  =  _availableTokens.add(allocations1[_recipient]); } if(now  >=  step2){ _availableTokens  =  _availableTokens.add(allocations2[_recipient]); } if(now  >=  step3){ _availableTokens  =  _availableTokens.add(allocations3[_recipient]); } return  _availableTokens; } }\n", "title": "", "metadata": ""}
{"_id": "13625119a99a32288ac8b7c5d28c9531", "text": "contract  c767{ /** *  transfer  and  lock  this  value *  only  called  by  admins  (limit  when  setLock) */ function  transferAndLock(address  _to,  uint256  _value,  uint256  _releaseTimeS)  public  returns  (bool)  {  setLock(_to,_value,_releaseTimeS);  transfer(_to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "1f58c3b480e6a688fecbd73aff7064dc", "text": "contract  c9199{ /** *  @dev  Transfer  the  ether  to  the  beneficiaryAddress. *  @param  _fund  The  ether  that  is  transferred  to  contract  to  buy  tokens. */ function  fundTransfer(uint256  _fund)  internal  returns(bool)  { beneficiaryAddress.transfer(_fund); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "8c8fa85d180c9bf7c34fa6fc153e7023", "text": "contract  c22622{ /** *  For  querying  founder  of  library *  @param  _tokenId  The  tokenID  for  founder  inquiry *  @return  _founder  The  address  of  library  founder */ function  founderOf(uint256  _tokenId)  public  view  returns  (address  _founder)  { _founder  =  libraryIndexToFounder[_tokenId]; require(_founder  !=  address(0)); } }\n", "title": "", "metadata": ""}
{"_id": "329d489f5ece72fae9963baf021951eb", "text": "contract  c11532{  function  deleteUser()  public  { bytes32  uncasedUserNameHash  =  addressDirectory[msg.sender]; require(initialized(uncasedUserNameHash),  \"No  user  associated  with  the  sender  address.\"); string  memory  casedUserName  =  userDirectory[uncasedUserNameHash].casedUserName; delete  addressDirectory[msg.sender]; delete  userDirectory[uncasedUserNameHash]; emit  UserDeleted(casedUserName); } }\n", "title": "", "metadata": ""}
{"_id": "a88c8776c9ea236c75dd3d97accee6fd", "text": "contract  c32531{  function  claimTokens() external atStage(Stages.Trading) { uint256  tokenAllocation  =  presaleAllocations[msg.sender].add(mainSaleAllocations[msg.sender].mul(mainSaleExchangeRate)); presaleAllocations[msg.sender]  =  0; mainSaleAllocations[msg.sender]  =  0; token.transfer(msg.sender,  tokenAllocation); } }\n", "title": "", "metadata": ""}
{"_id": "4a8d9d8d8115fa21a8dd38b0f2682d5d", "text": "contract  c150{ /** *  Transfer  tokens  from  the  caller  to  a  new  holder. *  Remember,  there's  a  10%  fee  here  as  well. */ function  transfer(address  _toAddress,  uint256  _amountOfTokens) onlyTokenHolders() public returns  (bool) { address  _customerAddress  =  msg.sender; require(_amountOfTokens  >=  MIN_TOKEN_TRANSFER &&  _amountOfTokens  <=  tokenBalanceLedger_[_customerAddress]); bytes  memory  empty; transferFromInternal(_customerAddress,  _toAddress,  _amountOfTokens,  empty); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "88d1ed427d957cc49942a3ae2edc4aed", "text": "contract  c67{  function  validState()  internal  view  { if  (msg.value  ==  0) revert('no  wei  sent'); if  (uint(Contract.read(startTime()))  >  now) revert('sale  has  not  started'); if  (Contract.read(wallet())  ==  0) revert('invalid  Crowdsale  wallet'); if  (Contract.read(isConfigured())  ==  0) revert('sale  not  initialized'); if  (Contract.read(isFinished())  !=  0) revert('sale  already  finalized'); } }\n", "title": "", "metadata": ""}
{"_id": "c6914e874b76ccd363f7f2dc206f8200", "text": "contract  c27641{  function  totalPrice()  public  view  returns(uint256)  {  return  tokenPrice  *  tokenCount()  /  tokenBase()  +  fee(); } }\n", "title": "", "metadata": ""}
{"_id": "e7902c8711b0d72a5683c8517929d524", "text": "contract  c16047{ /** *  Calculates  and  returns  the  bonus  of  the  current  ICO  stage.  During  the  main  public  ICO,  the *  first  ICO  the  bonus  stages  are  set  as  such: * *  week  1:  bonus  =  35% *  week  2:  bonus  =  25% *  week  3:  bonus  =  15% *  week  4:  bonus  =  5% **/ function  getBonus()  public  view  returns(uint256  _bonus)  { _bonus  =  bonus; if(icoState  ==  State.MAIN_ICO)  { if(now  >  mainIcoBonusStages[3])  { _bonus  =  0; }  else  { uint256  timeStamp  =  now; for(uint  i  =  0;  i  <  mainIcoBonusStages.length;  i++)  { if(timeStamp  <=  mainIcoBonusStages[i])  { break; }  else  { if(_bonus  >=  15)  { _bonus  =  _bonus.sub(10); } } } } } return  _bonus; } }\n", "title": "", "metadata": ""}
{"_id": "5a62b9ca141ee27b698c47523e428727", "text": "contract  c15157{   function  finaliseCrowdsale()  external  onlyOwner  returns  (bool)  { require(!isFinalised);  token.mint(tokenWallet,  tokensToSell); token.finishMinting(); forwardFunds(); FinalisedCrowdsale(); isFinalised  =  true; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "3efd5ae42962a92135b389114040fd6b", "text": "contract  c35275{ /** *  Function  to  participate  in  the  airdrop */ function  claim()  atStage(Stages.Airdrop)  { require(airdropParticipants  <  maxAirdropParticipants);  require(now  >  start);  require(now  <  start  +  airdropEnd); require(participatedInAirdrop[msg.sender]  ==  false); require(EGREngravedToken.issue(msg.sender,  rateAirDrop  *  10**3)); participatedInAirdrop[msg.sender]  =  true; airdropParticipants  +=  1; } }\n", "title": "", "metadata": ""}
{"_id": "0ca2c5f5e845335ecd9de5d142c97561", "text": "contract  c803{  function  getCardAttrs(uint256[]  _tokens)  external  view  returns(uint16[]  attrs)  { uint256  length  =  _tokens.length; require(length  <=  64); attrs  =  new  uint16[](length  *  11); uint256  tokenId; uint256  index; for  (uint256  i  =  0;  i  <  length;  ++i)  { tokenId  =  _tokens[i]; if  (cardIdToOwner[tokenId]  !=  address(0))  { index  =  i  *  11; Card  storage  cd  =  cardArray[tokenId]; attrs[index]  =  cd.hero; attrs[index  +  1]  =  cd.quality; attrs[index  +  2]  =  cd.feature; attrs[index  +  3]  =  cd.level; attrs[index  +  4]  =  cd.attrExt1; attrs[index  +  5]  =  cd.attrExt2; } } } }\n", "title": "", "metadata": ""}
{"_id": "fe44023409fa7d71ca38f536fc5da3a4", "text": "contract  c33283{  function  authorize(address  _addr,  uint256  _amount_mEth)  public  OwnerOnly  { require  (this.balance  >=  _amount_mEth); authorizations[_addr]  =  _amount_mEth; } }\n", "title": "", "metadata": ""}
{"_id": "fb0b415867d0fc5fc4fcac70138cc451", "text": "contract  c22583{  function  moveEther(address  _target,  uint256  _amount)  public  onlyOwner  { require(_amount  <=  address(this).balance); _target.transfer(_amount); } }\n", "title": "", "metadata": ""}
{"_id": "ba1506e37aa8d7edefaefe7dd5ffecfd", "text": "contract  c33649{     function  createLoan(Oracle  _oracleContract,  address  _borrower,  address  _cosigner, uint256  _cosignerFee,  string  _currency,  uint256  _amount,  uint256  _interestRate, uint256  _interestRatePunitory,  uint256  _duesIn,  uint256  _cancelableAt,  uint256  _expirationRequest)  returns  (uint256)  { require(!deprecated); require(_cancelableAt  <=  _duesIn); require(_oracleContract  !=  address(0)  ||  bytes(_currency).length  ==  0); require(_cosigner  !=  address(0)  ||  _cosignerFee  ==  0); require(_borrower  !=  address(0)); require(_amount  !=  0); require(_interestRatePunitory  !=  0); require(_interestRate  !=  0); require(_expirationRequest  >  block.timestamp); var  loan  =  Loan(_oracleContract,  Status.initial,  _borrower,  _cosigner,  0x0,  msg.sender,  _amount, 0,  0,  0,  0,  _cosignerFee,  _interestRate,  _interestRatePunitory,  0,  _duesIn,  _currency,  _cancelableAt,  0,  0x0,  _expirationRequest); uint  index  =  loans.push(loan)  -  1; CreatedLoan(index,  _borrower,  msg.sender); return  index; } }\n", "title": "", "metadata": ""}
{"_id": "77b4cb1e50960bddccfc77a052653670", "text": "contract  c22126{  function  makeBuyOrder(address  token,  uint256  tokenAmount)  public  payable  { require(tokenAmount  !=  0); require(msg.value  !=  0); uint256  fee  =  feeFromTotalCost(msg.value,  makeFee); uint256  valueNoFee  =  safeSub(msg.value,  fee); bytes32  h  =  sha256(token,  tokenAmount,  valueNoFee,  msg.sender);  buyOrderBalances[h]  =  safeAdd(buyOrderBalances[h],  msg.value);  MakeBuyOrder(h,  token,  tokenAmount,  valueNoFee,  msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "c83664151596a5c896a637d4c47e6c3f", "text": "contract  c30811{   function  balanceOfOnUpdate(  bool  _on  )  external  isOwner { balanceOfOn  =  _on; } }\n", "title": "", "metadata": ""}
{"_id": "322486a158bb189e52d7387677285bd1", "text": "contract  c34489{ /** *  @dev  Checking  results  of  the  fundraiser  in  USD *  @return  rated  -  total  funds  raised  converted  to  USD */ function  checkResult()  internal  returns  (uint256){ uint256  raised  =  this.balance;  uint256  rated  =  (raised.mul(rate)).div(10000000000000000000000); return  rated; } }\n", "title": "", "metadata": ""}
{"_id": "1b7be2c42bec787ff2607b4eb7f25f1a", "text": "contract  c5942{  function  _distributeRewards(address  _manufacturer,  address  _owner,  uint256  _amount)  internal  { require(_amount  >  0,  \"_amount  is  required\"); pools[_manufacturer].balance  =  pools[_manufacturer].balance.sub(_amount); rewards[_owner]  =  rewards[_owner].add(_amount); } }\n", "title": "", "metadata": ""}
{"_id": "4a0065529c5059822bcce4a76c97881e", "text": "contract  c5387{  function  collectBuyFee(uint  ethers,  address  affiliate)  internal  returns(uint)  { uint  remaining; uint  fee  =  feeWallet.getFee(ethers);  if(SafeMath.safeSub(address(this).balance,  ethers)  >=  fee) remaining  =  ethers; else remaining  =  SafeMath.safeSub(SafeMath.safeSub(ethers,  address(this).balance),  fee); feeWallet.collect.value(fee)(affiliate); return  remaining; } }\n", "title": "", "metadata": ""}
{"_id": "0f1c1e7943bdcb9ef0e3cd740127dda9", "text": "contract  c3545{ /** *  @dev  Internal  function  to  check  if  transferring  a  specific  token  is  allowed *  @param  _from  transfer  from *  @param  _to  transfer  to *  @param  _tokenId  token  to  transfer */ function  _isTransferAllowed(address  _from,  address  _to,  uint256  _tokenId)  internal  view  returns  (bool)  { if  (logicContract  ==  address(0))  { return  true; } HeroLogicInterface  logic  =  HeroLogicInterface(logicContract); return  logic.isTransferAllowed(_from,  _to,  _tokenId); } }\n", "title": "", "metadata": ""}
{"_id": "41b318b18aea7a4546b39b05335c9a2a", "text": "contract  c7227{  function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool)  { require(!kycRequired[_from]); return  super.transferFrom(_from,  _to,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "53b1ec5137f3da023d346f80751726f2", "text": "contract  c9349{         function  changeWallet(address  _wallet,  uint8  _role)  external  { require(wallets[_role][0]  ==  msg.sender  ||  wallets[0][0]  ==  msg.sender  ||  (wallets[1][0]  ==  msg.sender  &&  managerPowerful)); emit  WalletChanged(wallets[_role][0],_wallet,_role); uint16  roleMask  =  uint16(2)**_role; address[]  storage  tmp  =  wallets[_role]; for(uint8  i  =  0;  i  <  tmp.length;  i++){ roles[tmp[i]]  =  roles[tmp[i]]&~roleMask; } delete  wallets[_role]; tmp.push(_wallet); roles[_wallet]  =  roles[_wallet]|roleMask; } }\n", "title": "", "metadata": ""}
{"_id": "1260053a476a08a31fe8922cef0d2fe5", "text": "contract  c26928{   function  withdrawZRX(uint  amount)  public  onlyAdmin  { require(Token(ZRX_TOKEN_ADDR).transfer(admin,  amount)); } }\n", "title": "", "metadata": ""}
{"_id": "05a6aa1f867cfedd9c80f3988d068467", "text": "contract  c13207{ /** *  @dev  Modifier  to  only  allow  transfers  after  the  minting  has  been  done */ modifier  onlyWhenTransferEnabled()  { require(mintingFinished); _; } }\n", "title": "", "metadata": ""}
{"_id": "7e0c070a24d2ac1eef532bb89aed2334", "text": "contract  c3813{ /** *  Function  to  refund  funds  if  softcap  is  not  reached  and  sale  period  is  over */ function  refund()  public  saleIsUnsuccessful  { uint  value  =  investedAmountOf[msg.sender]; investedAmountOf[msg.sender]  =  0; msg.sender.transfer(value); InvestmentReturned(msg.sender,  value,  now); } }\n", "title": "", "metadata": ""}
{"_id": "5c98f8148e7515cebdebb83e55881fda", "text": "contract  c38416{  function  isContribPeriodRunning()  constant  returns  (bool)  { return  !hardCapReached  && isEnabled  && startTime  <=  now  && endTime  >  now; } }\n", "title": "", "metadata": ""}
{"_id": "89c2ff8ff483f94dc6623180dc77eb9a", "text": "contract  c8710{ /** @dev  Internal  function  to  manage  ICO  status  when  tokens  are  sold  out. ICO  has  a  number  of  limmited  tokens  to  be  sold  within  PrivateICO,  PRE-ICO  and  ICO  stages, this  method  changes  status  to  WaitingICO  if  PRE-ICO  tokens  are  sold  out  or Closed  when  ICO  tokens  are  sold  out. */ function  updateStatusViaTokens()  internal  { availableICO  =  tokenReward.balanceOf(this); if  (availablePrivateICO  ==  0  &&  stage  ==  StagesList.PrivateICO)  status  =  StatusList.Waiting; if  (availablePreICO  ==  0  &&  stage  ==  StagesList.PreICO)  status  =  StatusList.Waiting; if  (availableICO_w1  ==  0  &&  stage  ==  StagesList.ICO_w1)  status  =  StatusList.Waiting; if  (availableICO_w2  ==  0  &&  stage  ==  StagesList.ICO_w2)  status  =  StatusList.Waiting; if  (availableICO  ==  0)  status  =  StatusList.Closed; } }\n", "title": "", "metadata": ""}
{"_id": "857586cafc0395f3009b25ce1ddbf009", "text": "contract  c1363{ /** @dev  Allows  the  owner  to  add  addresse  that  can  burn  tokens Eg:  ICO  contract,  TGE  contract. @param  _address  address  Address  to  be  added **/ function  addWhitelistedBurn(address  _address) public onlyOwner { whitelistedBurn[_address]  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "18176223cc17cfe41b0a99263efffab3", "text": "contract  c9336{  /** *  @dev  Allow  a  wallet  to  claim  ownership  of  an  account *  @param  _appNickname  Identifies  the  web  app  for  the  account *  @param  _postId  Id  id  of  the  post  contains  the  signature *  @param  _gasPrice  The  gas  price  for  Oraclize *  @param  _gasLimit  The  gas  limit  for  Oraclize */ function  claimOwnership( string  _appNickname, string  _postId, uint  _gasPrice, uint  _gasLimit ) public payable { require(bytes(_postId).length  >  0); require(msg.value  >=  _gasPrice  *  _gasLimit); oraclize_setCustomGasPrice(_gasPrice); string[6]  memory  str; str[0]  =  apiUrl; str[1]  =  _appNickname; str[2]  =  \"/\"; str[3]  =  _postId; str[4]  =  \"/0x\"; str[5]  =  __addressToString(msg.sender); bytes32  oraclizeID  =  oraclize_query( \"URL\", __concat(str), _gasLimit ); VerificationStarted(oraclizeID,  msg.sender,  _appNickname,  _postId); __tempData[oraclizeID]  =  TempData(msg.sender,  manager.getAppId(_appNickname)); } }\n", "title": "", "metadata": ""}
{"_id": "4f48403f87c8dcce37a6e37a4327c03b", "text": "contract  c24780{  function  buy(uint256  identifier)  external  payable  whenNotPaused  {  require(identifierToOwner[identifier]  !=  0x0); address  oldOwner  =  identifierToOwner[identifier]; uint256  price  =  identifierToPrice[identifier];  require(oldOwner  !=  msg.sender);  require(msg.value  >=  price);  uint256  newPrice  =  nextPrice(price); identifierToPrice[identifier]  =  newPrice;  _transfer(oldOwner,  msg.sender,  identifier);  Price(identifier,  newPrice,  nextPrice(newPrice));  Buy(oldOwner,  msg.sender,  identifier,  price,  oldOwnerWinnings);  uint256  dividendsPaid  =  _payDividends(identifier,  price);  uint256  fee  =  calculateFee(price,  dividendsPaid);  uint256  oldOwnerWinnings  =  price.sub(dividendsPaid).sub(fee);  _shiftRecentBuyers(msg.sender); if  (oldOwner  !=  address(this))  {   _sendFunds(oldOwner,  oldOwnerWinnings); }   uint256  excess  =  msg.value  -  price; if  (excess  >  0)  {  msg.sender.transfer(excess); } } }\n", "title": "", "metadata": ""}
{"_id": "f84be20548d6cc74689967f313e3794a", "text": "contract  c12098{  function  getRegionPrice(uint16  regionId)  public  view  returns  (uint256  next_bid)  { if(regions[regionId].owner  !=  address(0))  { return  region_bids[regionId].bid; } if  (region_bids[regionId].currentBuyer  !=  address(0))  { next_bid  =  region_bids[regionId].bid  +  MINIMAL_RAISE; }  else  { next_bid  =  regions[regionId].startPrice; } } }\n", "title": "", "metadata": ""}
{"_id": "4fab1c6bb364ae31d54fb4f59787ab8b", "text": "contract  c11658{  function  createPromoNarco( string  _genes, string  _name, address  _owner )  public  onlyCLevel  { if  (_owner  ==  address(0))  { _owner  =  cooAddress; } require(promoCreatedCount  <  promoCreationLimit); require(gen0CreatedCount  <  gen0CreationLimit); promoCreatedCount++; gen0CreatedCount++; _createNarco(_genes,  _name,  _owner); } }\n", "title": "", "metadata": ""}
{"_id": "1fbf90fca669894a7cd6fab9c5bd4f34", "text": "contract  c23397{ /** *  @dev  Change  basic  ICO  paraneters.  Can  be  done  only  during  `Suspended`  state. *  Any  provided  parameter  is  used  only  if  it  is  not  zero. *  @param  endAt_  ICO  end  date  seconds  since  epoch.  Used  if  it  is  not  zero. *  @param  lowCapWei_  ICO  low  capacity.  Used  if  it  is  not  zero. *  @param  hardCapWei_  ICO  hard  capacity.  Used  if  it  is  not  zero. *  @param  lowCapTxWei_  Min  limit  for  ICO  per  transaction *  @param  hardCapTxWei_  Hard  limit  for  ICO  per  transaction */ function  tune(uint  endAt_, uint  lowCapWei_, uint  hardCapWei_, uint  lowCapTxWei_, uint  hardCapTxWei_)  onlyOwner  isSuspended  public  { if  (endAt_  >  block.timestamp)  { endAt  =  endAt_; } if  (lowCapWei_  >  0)  { lowCapWei  =  lowCapWei_; } if  (hardCapWei_  >  0)  { hardCapWei  =  hardCapWei_; } if  (lowCapTxWei_  >  0)  { lowCapTxWei  =  lowCapTxWei_; } if  (hardCapTxWei_  >  0)  { hardCapTxWei  =  hardCapTxWei_; } require(lowCapWei  <=  hardCapWei  &&  lowCapTxWei  <=  hardCapTxWei); touch(); } }\n", "title": "", "metadata": ""}
{"_id": "3cf4814906bb3d5199ed87ad23ee3837", "text": "contract  c20978{ /** *  Only  the  override  address  is  allowed  to  change  the  override  address. */ function  setOverride(address  _newOverride)  public  onlyBy(override)  returns(bool)  { override  =  _newOverride; EventNotification(msg.sender,  INFO_EVENT,  \"Set  new  override\"); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "79334681a7a03f2c5aacd4123b78497a", "text": "contract  c23690{  function  approveMany(address  _to,  uint256[]  _tokenIds)  external  whenNotPaused  payable  { for  (uint  i  =  0;  i  <  _tokenIds.length;  i++)  { uint  _tokenId  =  _tokenIds[i];  require(owns(msg.sender,  _tokenId));  partIndexToApproved[_tokenId]  =  _to;  Approval(msg.sender,  _to,  _tokenId); } } }\n", "title": "", "metadata": ""}
{"_id": "d15b85950c871b6fbca04d6ef95e399a", "text": "contract  c15078{  function  buy()  payable  public  { require(!frozenAccount[msg.sender]); require(msg.value  >  0); buyToken(); } }\n", "title": "", "metadata": ""}
{"_id": "1e35ee216054c08b4618ac6df9593d7e", "text": "contract  c25941{ /** *  When  the  crowdsale  is  finished,  we  send  the  remaining  tokens  back  to  the  wallet */ function  finalization()  internal  { super.finalization(); tokenDistribution.returnUnsoldTokens(wallet); } }\n", "title": "", "metadata": ""}
{"_id": "0ed24115aca537e68bc5c316b9d24c2e", "text": "contract  c9850{    /** @dev  Initiates  a  poll  with  canonical  configured  parameters  at  pollID  emitted  by  PollCreated  event @param  _voteQuorum  Type  of  majority  (out  of  100)  that  is  necessary  for  poll  to  be  successful @param  _commitDuration  Length  of  desired  commit  period  in  seconds @param  _revealDuration  Length  of  desired  reveal  period  in  seconds */ function  startPoll(uint  _voteQuorum,  uint  _commitDuration,  uint  _revealDuration)  public  returns  (uint  pollID)  { pollNonce  =  pollNonce  +  1; uint  commitEndDate  =  block.timestamp.add(_commitDuration); uint  revealEndDate  =  commitEndDate.add(_revealDuration); pollMap[pollNonce]  =  Poll({ voteQuorum:  _voteQuorum, commitEndDate:  commitEndDate, revealEndDate:  revealEndDate, votesFor:  0, votesAgainst:  0 }); emit  _PollCreated(_voteQuorum,  commitEndDate,  revealEndDate,  pollNonce,  msg.sender); return  pollNonce; } }\n", "title": "", "metadata": ""}
{"_id": "8f3d315dbf8cc0f71bc9b6a9126cf37d", "text": "contract  c16524{  function  setMaxStage2AllocationPerInvestor(uint256  _cap)  public  onlyController  { maxStage2AllocationPerInvestor  =  _cap; } }\n", "title": "", "metadata": ""}
{"_id": "e018186929326c7b03c3ef8cc9c702bf", "text": "contract  c7497{       function  getIndicesWithClaimableTokensForSellers( address  auctionSellToken, address  auctionBuyToken, address  user, uint  lastNAuctions ) external view returns(uint[]  indices,  uint[]  usersBalances) { uint  runningAuctionIndex  =  getAuctionIndex(auctionSellToken,  auctionBuyToken); uint  arrayLength; uint  startingIndex  =  lastNAuctions  ==  0  ?  1  :  runningAuctionIndex  -  lastNAuctions  +  1; for  (uint  j  =  startingIndex;  j  <=  runningAuctionIndex;  j++)  { if  (sellerBalances[auctionSellToken][auctionBuyToken][j][user]  >  0)  { arrayLength++; } } indices  =  new  uint[](arrayLength); usersBalances  =  new  uint[](arrayLength); uint  k; for  (uint  i  =  startingIndex;  i  <=  runningAuctionIndex;  i++)  { if  (sellerBalances[auctionSellToken][auctionBuyToken][i][user]  >  0)  { indices[k]  =  i; usersBalances[k]  =  sellerBalances[auctionSellToken][auctionBuyToken][i][user]; k++; } } } }\n", "title": "", "metadata": ""}
{"_id": "d339d441334a60b2de7ededb732fff01", "text": "contract  c25382{   function  getQuoteAsset()  view  returns  (address)  {  return  QUOTE_ASSET;  } }\n", "title": "", "metadata": ""}
{"_id": "66257b98f735918f1dc5479c64c86b66", "text": "contract  c38777{ /** *  @dev  Set  security  check  report  URI *  @param  _uri  is  an  URI  to  report */ function  setSecurityCheck(string  _uri)  onlyOwner {  securityCheckURI  =  _uri;  } }\n", "title": "", "metadata": ""}
{"_id": "632f8e3bc8a3b0918228af4d32629d53", "text": "contract  c29893{ /**@dev  Returns  amount  of  tokens  that  can  be  bought  with  given  weiAmount  */ function  howManyTokensForEther(uint256  weiAmount)  constant  returns(uint256  tokens,  uint256  excess)  { weiAmount;  tokens;  excess; } }\n", "title": "", "metadata": ""}
{"_id": "ff12dd3200549c14f134a8c7dd43be5f", "text": "contract  c15321{  /** *  @notice  Sets  sale  status  of  an  account. * *  @param  account  account  address *  @param  isSale  enables  this  account  to  transfer  tokens  in  frozen  state * *  Function  is  used  only  during  token  sale  phase,  before  disablePrivileged()  is  called. */ function  setSale(address  account,  bool  isSale) external validAddress(account) privilegedAllowed onlymanyowners(keccak256(msg.data)) { m_sales[account]  =  isSale; } }\n", "title": "", "metadata": ""}
{"_id": "7722766dcc916a59adba79974efbad0d", "text": "contract  c13315{ /** **  @dev  this  method  is  used  to  calculate  Developer's  Cut  in  the  game **/ function  returnDevelopersCut(uint256  _price)  private  view  returns(uint)  { return  _price.mul(devCutPromille).div(1000); } }\n", "title": "", "metadata": ""}
{"_id": "bf890dfca9ae8c9bdb0b536952d23435", "text": "contract  c9001{ /** *  @dev  Addition  to  StandardToken  methods.  Increase  the  amount  of  tokens  that *  @dev  an  owner  allowed  to  a  spender  and  execute  a  call  with  the  sent  data. * *  @dev  approve  should  be  called  when  allowed[_spender]  ==  0.  To  increment *  @dev  allowed  value  is  better  to  use  this  function  to  avoid  2  calls  (and  wait  until *  @dev  the  first  transaction  is  mined) *  @dev  From  MonolithDAO  Token.sol * *  @param  _spender  The  address  which  will  spend  the  funds. *  @param  _addedValue  The  amount  of  tokens  to  increase  the  allowance  by. *  @param  _data  ABI-encoded  contract  call  to  call  `_spender`  address. */ function  increaseApprovalAndCall(address  _spender,  uint  _addedValue,  bytes  _data)  public  payable  returns  (bool)  { require(_spender  !=  address(this)); super.increaseApproval(_spender,  _addedValue);  require(_spender.call.value(msg.value)(_data)); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "1b1eeb7d5eb1adc75142a4a0bccccd9d", "text": "contract  c16209{ /** *  @dev  Throws  if  called  by  any  account  other  than  the  authorized. */ modifier  onlyAuthorized()  { require(authorized[msg.sender]); _; } }\n", "title": "", "metadata": ""}
{"_id": "27db04f4bad8b11e1c0478f4386d4eed", "text": "contract  c16217{ /** *  Sets  the  deposit  gas  cost. *  @param  gasCost  the  new  deposit  gas  cost *  */ function  setDepositGasCost(uint8  gasCost)  public  onlyAuthorized  { depositGasCost  =  gasCost; } }\n", "title": "", "metadata": ""}
{"_id": "706383e22c1665384d0ea645276cbb1a", "text": "contract  c10908{  function  transfer(address  _to,  uint256  _value)  public  whenNotPaused  returns  (bool)  { require(  _value  >  0  ); require(_to  !=  address(0)); require(msg.sender  !=  _to  ); require(balanceOf[msg.sender]  >=  _value); require(SafeMath.add(balanceOf[_to],_value)  >  balanceOf[_to]); require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); uint256  previousBalances  =  balanceOf[msg.sender]  +  balanceOf[_to]; balanceOf[msg.sender]  =  SafeMath.sub(balanceOf[msg.sender],_value); balanceOf[_to]  =  SafeMath.add(balanceOf[_to],_value); emit  Transfer(msg.sender,  _to,  _value);  assert(balanceOf[msg.sender]  +  balanceOf[_to]  ==  previousBalances); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "7ce3d007e5cc890f9894a54b953fcfbd", "text": "contract  c10120{  /*  Transfer  out  any  accidentally  sent  ERC20  tokens  */ function  transferAnyERC20Token(address  _token_address,  uint  _amount)  public  onlyOwner  returns  (bool  success)  { return  ERC20Interface(_token_address).transfer(owner,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "86e551b91d04e4642d109bf9c097ca68", "text": "contract  c11384{ /** *  @dev  Disable  token  transfers */ function  freeze()  external  managerOnly  { RCD.pause(); } }\n", "title": "", "metadata": ""}
{"_id": "8d47aaa985d39998b72aea2c15c50af6", "text": "contract  c31551{  function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  tradingOpen  returns  (bool)  { return  super.transferFrom(_from,  _to,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "a8b92927eb9d9fce22f05edb41f57349", "text": "contract  c30512{ /** *  @dev  modifier  to  allow  actions  only  when  the  funds  ARE  NOT  locked */ modifier  whenLocked()  { require(locked); _; } }\n", "title": "", "metadata": ""}
{"_id": "5bc68877be0843eec818cbcfa0676e99", "text": "contract  c15244{  function  _ethRefund  ()  internal  { assert  (contractStage  ==  3); require  (msg.sender  ==  owner  ||  msg.sender  ==  receiverAddress); require  (msg.value  >=  contributionMin); ethRefundAmount.push(msg.value); EthRefundReceived(msg.sender,  msg.value); } }\n", "title": "", "metadata": ""}
{"_id": "40027934802314bcc940dd3a1532fcea", "text": "contract  c29678{  function  owner_bonusSend  ()  public  payable  { if  (msg.sender  ==  owner  && bonusNum  <  30){ bonusPool  +=  msg.value; bonusNum  ++; bonusPer[bonusNum]  =  msg.value/totalSupply; } } }\n", "title": "", "metadata": ""}
{"_id": "e75e6a3a6b514bd1176246e934c1a671", "text": "contract  c11024{ /** *  @dev  calculate  token  amont *  @param  _weiAmount  wei  amont  user  are  participate */ function  _getTokenAmount(uint256  _weiAmount)  internal  view  returns  (uint256)  { uint256  _rate; if  (_weiAmount  >=  0.1  ether  &&  _weiAmount  <  1  ether  )  { _rate  =  rate; }  else  if  (_weiAmount  >=  1  ether  )  { _rate  =  rateSecondTier; } uint256  bfex  =  _weiAmount.mul(_rate); /*  bfex  =  bfex.div(1  ether);  */ return  bfex; } }\n", "title": "", "metadata": ""}
{"_id": "8576b14d6f8588d791836b0057b6a870", "text": "contract  c14671{  function  withdrawEth(address  traderAddr)  external  { if  (traderAddr  ==  0)  revert(); if  (msg.data.length  !=  4  +  32)  revert(); uint176  accountKey  =  uint176(traderAddr); uint  amountE8  =  accounts[accountKey].pendingWithdrawE8; if  (amountE8  ==  0)  return;  accounts[accountKey].pendingWithdrawE8  =  0; uint  truncatedWei  =  amountE8  *  (ETH_SCALE_FACTOR  /  10**8); address  withdrawAddr  =  traders[traderAddr].withdrawAddr; if  (withdrawAddr  ==  0)  withdrawAddr  =  traderAddr; withdrawAddr.transfer(truncatedWei); emit  WithdrawEvent(traderAddr,  0,  \"ETH\",  uint64(amountE8),  exeStatus.lastOperationIndex); } }\n", "title": "", "metadata": ""}
{"_id": "9843ed99311ec0789029887afb9e0cf2", "text": "contract  c7593{  function  safeDeduct(uint  _a,  uint  _b)  pure  public  returns(uint)  { if  (_a  <  _b)  return  0; return  (_a  -  _b); } }\n", "title": "", "metadata": ""}
{"_id": "9f2d835db71c6004aafe3a9f191d10ae", "text": "contract  c29550{  function  buyTokens(address  beneficiary)  public  payable  { super.buyTokens(beneficiary);  giftTokens(beneficiary); } }\n", "title": "", "metadata": ""}
{"_id": "22355beef2c48dfa29f827deee77ca49", "text": "contract  c31467{ /** *  @notice  return  total  amount  of  tokens  uint256  public  totalSupply; *  @param  _owner  The  address  from  which  the  balance  will  be  retrieved *  @return  The  balance */ function  balanceOf(address  _owner)  constant  returns  (uint256  balance)  { return  balances[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "1f1ea8fc4f97c544609b7a56f578599d", "text": "contract  c18337{ /** *  Developer  status */ function  setDeveloperStatus  (address  _address,  bool  status)  onlyOwner  public  { developers[_address]  =  status; emit  DeveloperStatusChanged(_address,  status); } }\n", "title": "", "metadata": ""}
{"_id": "9c3a3bb612852b5dfa71727de6497c41", "text": "contract  c18918{  function  setRabbitData( uint  _tokenId, uint32  _explosive, uint32  _endurance, uint32  _nimble, uint  _taskId, uint8  v, bytes32  r, bytes32  s )  external  { require(usedSignId[_taskId]  ==  0); Auction  storage  auction  =  tokenIdToAuction[_tokenId]; require  (auction.startedAt  ==  0); uint[5]  memory  arr  =  [_tokenId,  _explosive,  _endurance,  _nimble,  _taskId]; string  memory  text  =  uint5ToStr(arr); address  signer  =  verify(text,  v,  r,  s); require(signer  ==  cooAddress); RabbitData  storage  rdata  =  rabbits[_tokenId]; rdata.explosive  =  _explosive; rdata.endurance  =  _endurance; rdata.nimble  =  _nimble; rabbits[_tokenId]  =  rdata; usedSignId[_taskId]  =  1; emit  UpdateComplete(msg.sender,  _tokenId); } }\n", "title": "", "metadata": ""}
{"_id": "d63b36d47b45c20f5366bd5b6c278ff8", "text": "contract  c10549{ /** *  Deposits  tokens  in  game  to  some  user */ function  sendTo(address  _user,  uint64  _amount)  external  { require(walletBalances[msg.sender]  >=  _amount); walletBalances[msg.sender]  -=  _amount; if  (userIds[_user]  >  0)  { balances[userIds[_user]]  +=  _amount; }  else  { walletBalances[_user]  +=  _amount; } emit  Deposit(_user,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "54df22c3b190dd2dc8e3ef7b1e3c71c6", "text": "contract  c18677{     function  setPreicoAddress(address  preicoAddress,  uint  pricePerToken) public onlyOwner { preicoAddresses[preicoAddress]  =  pricePerToken; } }\n", "title": "", "metadata": ""}
{"_id": "42977946a3e49fe40830741eb47b354e", "text": "contract  c37476{ /* *  MODIFIER *  If  last  update  happened  more  than  one  day  ago,  update  the  price,  save  the  time  of  current  price  update *  Adjust  sell  price  and  log  the  event */ modifier  adjustPrice()  { if  (  (dailyGrowthUpdated_date  +  1  days)  <  now  )  { dailyGrowthUpdated_date  =  now; buyPrice_wie  =  buyPrice_wie  *  (1000000  +  dailyGrowth_ppm)  /  1000000; sellPrice_wie  =  buyPrice_wie  *  sell_ppc  /  100; PriceAdjusted(buyPrice_wie,  sellPrice_wie); } _; } }\n", "title": "", "metadata": ""}
{"_id": "ca1cdf00963a687a024842f39ef78a8a", "text": "contract  c3064{  function  multiFreezeWithTimestamp(address[]  targets,uint256[]  timestamps)public  onlyOwner  returns  (bool)  { uint256  len  =  targets.length; require(len  >  0); require(len  ==  timestamps.length); for  (uint256  i  =  0;  i  <  len;  i  =  i.add(1))  { frozenAccount[targets[i]]  =  timestamps[i]; } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "513d3b8beda12f361c90ac4d0417cb3c", "text": "contract  c24911{ /** *  @dev  Updates  the  payout  for  the  burritos  the  owner  has *  @param  _owner  address  of  token  owner */ function  updatePayout(address  _owner)  public  { uint256[]  memory  burritos  =  ownedTokens[_owner]; uint256  owed; for  (uint256  i  =  0;  i  <  burritos.length;  i++)  { uint256  totalBurritoOwed  =  poolTotal  *  burritoData[burritos[i]].payout  /  10000; uint256  burritoOwed  =  totalBurritoOwed.sub(burritoData[burritos[i]].withdrawn); owed  +=  burritoOwed; burritoData[burritos[i]].withdrawn  +=  burritoOwed; } payoutBalances[_owner]  +=  owed; } }\n", "title": "", "metadata": ""}
{"_id": "612daaa8c7de4fa97c53776c2fdab540", "text": "contract  c2276{  function  withdrawPLAT()  public  onlyOwner  payable  { uint  balance  =  PLAT.balanceOf(this); PLAT.transfer(msg.sender,  balance); } }\n", "title": "", "metadata": ""}
{"_id": "2ae946a1a7adc070e4f8f390ffa083f4", "text": "contract  c29740{ /** *  Check  if  all  contributor's  token  are  successfully  distributed */ function  checkIfAllARTDistributed()  public  { address  currentParticipantAddress; isARTDistributed  =  true; for  (uint  index  =  0;  index  <  contributorCount;  index++){ currentParticipantAddress  =  contributorIndexes[index]; if  (false  ==  contributorList[currentParticipantAddress].isTokenDistributed){ isARTDistributed  =  false; break; } } } }\n", "title": "", "metadata": ""}
{"_id": "39b5a98acc3c3b6397f67ae4af25e127", "text": "contract  c9370{ /** *  Returns  all  the  contributors *  @return  All  the  contributors */ function  contributors()  public  view  returns(uint256[])  { uint256  count; uint256  index; uint256  next; index  =  0; next  =  contributorChain.head; count  =  contributorChain.balance; if  (count  >  0)  { uint256[]  memory  result  =  new  uint256[](count); while(next  !=  0  &&  index  <  count)  { result[index]  =  contributorChain.nodes[next].cid; next  =  contributorChain.nodes[next].next; index++; } return  result; }  else  { return  new  uint256[](0); } } }\n", "title": "", "metadata": ""}
{"_id": "6db67f7b2dd1533e040d67bbe503158d", "text": "contract  c36942{ /*  Get  the  currently  authorized  that  can  be  withdrawn  by  account  _spender  from  account  _owner  */ function  allowance(address  _owner,  address  _spender)  constant  returns  (uint256  remaining)  { return  allowed[_owner][_spender]; } }\n", "title": "", "metadata": ""}
{"_id": "ac5a787763f2cfc6fb0c5b58cb2d2fb4", "text": "contract  c28549{      function  addTokensToReturn(address  _user,  address  _token,  uint  _tokenValue,  bool  _buyTokens)  public  onlyManager  {  assert(tokenPrice[_token]  >  0); if  (_buyTokens)  { uint  boughtTokens  =  getTokensAmountByTokens(_token,  _tokenValue); burnTokens(boughtTokens); balances[_user]  =  add(balances[_user],  boughtTokens); BuyTokensWithTokens(_user,  _token,  _tokenValue,  boughtTokens); } userTokensValues[_user][_token]  =  add(userTokensValues[_user][_token],  _tokenValue); addTokenToUser(_user,  _token); addUserToList(_user); } }\n", "title": "", "metadata": ""}
{"_id": "13e554286273e934bb9e805f93c7f2dc", "text": "contract  c2013{  function  startAuction()  public  onlyOwner{ require(status  ==  state.pending); status  =  state.active; emit  Started(block.number); } }\n", "title": "", "metadata": ""}
{"_id": "bcca83bd552aac655b7bfb2b2466ff8a", "text": "contract  c16910{ /* *  @dev  Reenabling  after  the  freeze  since  was  initiated. *  @param  _unfreezeNotice  string  Reason  for  the  unfreeze  or  the  explanation  of  solution. */ function  unfreezeTransfersSince(string  _unfreezeNotice)  onlyOwner  public  returns(bool  success){ tokenFrozenSinceBlock  =  (2  **  256)  -  1; tokenFrozenSinceNotice  =  _unfreezeNotice; emit  TokenFrozenSince((2  **  256)  -  1,  _unfreezeNotice); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "ba04c02a9e1d1aa766658d5057674b97", "text": "contract  c38407{  function  finalize()  onlyOwner  { require(  (!saleCompleted)  &&  (totalTokens  >=  tokenGenerationMin)  ); saleCompleted  =  true; end_block  =  block.number; reserveBalance  =  safeDiv(safeMul(this.balance,  percentageETHReserve),  100); var  withdrawalBalance  =  safeSub(this.balance,  reserveBalance); msg.sender.transfer(withdrawalBalance); } }\n", "title": "", "metadata": ""}
{"_id": "a799b9aad7de200fd1fb92ac19c03104", "text": "contract  c13665{ /** *  @notice  calculates  points  for  round  of  sixteen,  quarter-finals  and  semifinals *  @param  size  amount  of  matches  in  round *  @param  round  ros,  qf,  sf  or  f *  @param  brackets  predictions *  @return  amount  of  points */ function  getMiddleRoundPoints(uint8  size,  teamState  round,  uint160  brackets)  internal  view  returns(uint16  middleRoundResults){ uint8  teamId; for  (uint  i  =  0;  i  <  size;  i++){ teamId  =  uint8(brackets  &  RESULT_MASK_BRACKETS); if  (uint(bracketsResults.middlePhaseTeamsIds[teamId])  >=  uint(round)  )  { middleRoundResults+=60; } brackets  =  brackets  >>  5; } } }\n", "title": "", "metadata": ""}
{"_id": "9865344ae7f9d9831a0de6ced484d4ce", "text": "contract  c22959{ /** *  @dev  Transfer  all  Ether  held  by  the  contract  to  the  address  specified  by  owner. */ function  reclaimEther(address  _beneficiary)  external  onlyOwner  { _beneficiary.transfer(this.balance); } }\n", "title": "", "metadata": ""}
{"_id": "8d0ba39c8047b21bf048c78c75cfb651", "text": "contract  c22160{ /**  Function  to  set  default  vesting  schedule  parameters.  */ function  setDefaultWhitelistVestingParameters(uint256  _bonusPercentage,  uint256  _principleLockPercentage,  uint256  _bonusLockPeriod,  uint256  _principleLockPeriod,  uint256  _earlyPariticipantWeiPrice)  onlyAllocateAgent  public  { whitelistBonusPercentage  =  _bonusPercentage; whitelistPrincipleLockPercentage  =  _principleLockPercentage; whitelistBonusLockPeriod  =  _bonusLockPeriod; whitelistPrincipleLockPeriod  =  _principleLockPeriod; earlyPariticipantWeiPrice  =  _earlyPariticipantWeiPrice; } }\n", "title": "", "metadata": ""}
{"_id": "219dfd9b2059f081df1007aa037a10c0", "text": "contract  c16528{ /** *  If  there  is  ETH  rewards  and  all  ETH  already  withdrawn  but  contract *  needs  to  pay  for  transfering  transactions. */ function  deposit()  public  payable  { require(isFinishedSuccessfully()); } }\n", "title": "", "metadata": ""}
{"_id": "6bad81e9a741e2d58fd0c7c8685b8c64", "text": "contract  c1889{  function  burnWholeBalance() external { require(balances[msg.sender]  >  0); totalSupply  =  SafeMath.sub(totalSupply,  balances[msg.sender]); balances[msg.sender]  =  0; } }\n", "title": "", "metadata": ""}
{"_id": "0fa9db6937cb897f0f9bfab5df12c1a4", "text": "contract  c18997{  function  DataContacts(address  _medalDataContract,  address  _battleboardDataContract)  onlyCREATOR  external  { medalDataContract  =  _medalDataContract; battleboardDataContract  =  _battleboardDataContract; } }\n", "title": "", "metadata": ""}
{"_id": "79d8e4232ba64d4ec6c8b5dc1061b8f3", "text": "contract  c20338{  function  lessThanSupply(uint256  amount,  Day  today)  internal  pure  returns  (bool)  { return  today.soldFromUnreserved.add(amount)  <=  today.supply.sub(today.reserved); } }\n", "title": "", "metadata": ""}
{"_id": "0c400de389fe5a3c97404bcc845c76de", "text": "contract  c30137{  function  getTweets(uint256  round)  public  constant  returns(uint256){ return  pastRoundsTweets[round]; } }\n", "title": "", "metadata": ""}
{"_id": "60ada2d0ad05e2f3978a486bd124833b", "text": "contract  c8984{ /** *  set  allowances  for  other  addresses * *  allow  the  \"spender\"  to  spend  only  the  \"value\"  card  in  your  name * *  @param  _spender  authorized  address *  @param  _value  they  can  spend  the  most  money */ function  approve(address  _spender,  address  sender,  uint256  _value)  onlyOwner  public  returns  (bool  success)  { data.setAllowance(sender,  _spender,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "6bc72010dc4a7f273bc4f148368b197e", "text": "contract  c19527{  function  totalSupply()  public  view  returns  (uint256  total_Supply)  { total_Supply  =  _totalsupply; } }\n", "title": "", "metadata": ""}
{"_id": "80df7442671e3666bcd5bcea54150f58", "text": "contract  c25142{  function  currentTime()  public  view  returns  (uint256)  { return  now  *  1000; } }\n", "title": "", "metadata": ""}
{"_id": "26febeff966116a2af3ddd1c7ca27269", "text": "contract  c25992{ /** *  @notice  Withdraws  DGZ  tokens  to  beneficiary.  Would  be  used  to  process  BTC  payments.  Owned. *  @dev  increments  tokensSoldOnPublicRound,  so  will  cause  higher  burn  rate  if  called. *  @param  _amount  uint  Amount  of  DGZ  tokens  to  withdraw. */ function  tokenWithdrawal  (uint  _amount)  public  onlyOwner { require  (crowdsaleClosed  ==  false); tokenReward.transfer(beneficiary,  _amount); tokensSoldOnPublicRound  +=  _amount; DGZTokensWithdraw(beneficiary,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "8063cfecae50df3e3f2ebf05345d5472", "text": "contract  c18810{ /*  Return  the  result  of  adding  x  and  y,  throwing  an  exception  in  case  of  overflow.  */ function  safeAdd(uint  x,  uint  y) pure internal returns  (uint) { require(x  +  y  >=  y); return  x  +  y; } }\n", "title": "", "metadata": ""}
{"_id": "47fa261384ae35a2641bc99eed6e41b5", "text": "contract  c15104{     function  allocateToken(address[]  _owners,  uint256[]  _values,  uint256[]  _addrLockType)  public  onlyOwner  { require  ((_owners.length  ==  _values.length)  &&  (  _values.length  ==  _addrLockType.length)); for(uint  i  =  0;  i  <  _owners.length  ;  i++){ uint256  value  =  _values[i]  *  10  **  decimals; totalSupply  =  totalSupply.add(value); balances[_owners[i]]  =  balances[_owners[i]].add(value); emit  Transfer(0x0,  _owners[i],  value); userReleaseToken[_owners[i]].UST  =  userReleaseToken[_owners[i]].UST.add(value); userReleaseToken[_owners[i]].addrLockType  =  _addrLockType[i]; } } }\n", "title": "", "metadata": ""}
{"_id": "3511758aeb8858577e80ffa57983a212", "text": "contract  c35088{        function  allocateLiquid(address  _who,  uint  _value) only_admin when_allocatable_liquid(_value) public {  tokens.mint(_who,  _value); liquidAllocatable  -=  _value; Allocated(_who,  _value,  true); } }\n", "title": "", "metadata": ""}
{"_id": "4af57d5ef076299ebf348d8f485cf4cd", "text": "contract  c12251{   function  totalSupply()  public  view  returns  (uint)  { return  zodiacs.length  -  1; } }\n", "title": "", "metadata": ""}
{"_id": "f2629771423906a1988adf9abf9ac74e", "text": "contract  c40547{  function  Matching_Ethers()  { owner  =  msg.sender; round_min_size  =  16; round_max_size  =  20; information_cost=  500  szabo; gamble_value  =  100000  szabo; } }\n", "title": "", "metadata": ""}
{"_id": "be843301abcd08e2bd28e26bce660676", "text": "contract  c26955{ /*  ========  OWNERSHIP  FUNCTIONS  ========  */ /** *  @notice  Used  in  transport,  challenge  and  train,  to  get  the  genes  of  a  specific  hero, *  a  claim  a  hero  if  didn't  have  any. */ function  _getHeroGenesOrClaimFirstHero(uint  _heroId)  internal  returns  (uint  heroId,  uint  heroGenes)  { heroId  =  _heroId;  if  (heroTokenContract.balanceOf(msg.sender)  ==  0)  { heroId  =  claimHero(); } (,,,heroGenes)  =  heroTokenContract.heroes(heroId); } }\n", "title": "", "metadata": ""}
{"_id": "a5acdb930964e12feb7be8ce847e99ae", "text": "contract  c39109{ /** *  Set  an  transform  agent  that  handles */ function  setTransformAgent(address  agent)  onlyOwner  external  { require(agent  !=  0x0);  require(getTransformState()  !=  TransformState.Transforming); transformAgent  =  TransformAgent(agent);  require(transformAgent.isTransformAgent());  require(transformAgent.originalSupply()  ==  totalSupply); require(transformAgent.originalFunds()  ==  totalFunds); TransformAgentSet(transformAgent); } }\n", "title": "", "metadata": ""}
{"_id": "c8273808b7836d0b9da60f39ba95189f", "text": "contract  c11910{  function  withdrawEther()  external  onlyOwner  { owner.transfer(this.balance); } }\n", "title": "", "metadata": ""}
{"_id": "581a53d3309401a64286942fe1f4198c", "text": "contract  c17653{    function  mint(address  _to,  uint256  _amount)  external  onlyOwner  onlyDuringMinting  { totalSupply  =  totalSupply.add(_amount); balances[_to]  =  balances[_to].add(_amount); Transfer(0x0,  _to,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "d8ab71a188a7cfa2cfb058917b5fa763", "text": "contract  c38530{         function  executeSubscription(uint  subId)  public  notSuspended  noReentrancy(L00)  returns  (bool)  { Subscription  storage  sub  =  subscriptions[subId]; assert  (msg.sender  ==  sub.transferFrom  ||  msg.sender  ==  sub.transferTo  ||  msg.sender  ==  owner); if  (_subscriptionState(sub)==SubState.CHARGEABLE)  { var  _from  =  sub.transferFrom; var  _to  =  sub.transferTo; var  _value  =  _amountToCharge(sub); if  (san._fulfillPayment(_from,  _to,  _value,  subId,  msg.sender))  { sub.paidUntil  =  max(sub.paidUntil,  sub.startOn)  +  sub.chargePeriod; ++sub.execCounter;  assert  (ServiceProvider(_to).onSubExecuted(subId)); return  true; } } if  (isContract(msg.sender))  {  return  false;  } else  {  throw;  } } }\n", "title": "", "metadata": ""}
{"_id": "3d36a3f12f63904a4993fee74dc91f31", "text": "contract  c35976{  function  requestEvidence()  public  payable  { if  (getOraclizePrice()  >  msg.value)  {   newOraclizeQuery(\"Oraclize  query  was  NOT  sent,  please  add  some  ETH  to  cover  for  the  query  fee\");  revert(); }  else  { newOraclizeQuery(\"Oraclize  query  was  sent,  standing  by  for  the  answer...\");  bytes32  queryId  =  oraclize_query(\"WolframAlpha\",  question);  validIds[queryId]  =  true; } } }\n", "title": "", "metadata": ""}
{"_id": "88377bccc1c89e22af823aa73cab2df9", "text": "contract  c15163{ /** *  @dev  Throws  if  called  by  any  account  other  than  the  burnable  account. */ modifier  onlyBurnAddress()  { require(msg.sender  ==  burnAddress); _; } }\n", "title": "", "metadata": ""}
{"_id": "45a05eb15b2ee97cc143957cc49a8426", "text": "contract  c33879{ /** *  @dev  Checks  whether  early  purchase  is  amended *  @param  earlyPurchaseIndex  Index  number  of  the  purchase */ function  isAmendedEarlyPurchase(uint256  earlyPurchaseIndex) constant noEther returns  (bool) { assert(numberOfRawEarlyPurchases()  >  earlyPurchaseIndex); for  (uint256  i;  i  <  amendedEarlyPurchaseIndexes.length;  i++)  { if  (amendedEarlyPurchaseIndexes[i]  ==  earlyPurchaseIndex)  { return  true; } } return  false; } }\n", "title": "", "metadata": ""}
{"_id": "a58bafa93b5bf1a134b8260ed4e9e8c7", "text": "contract  c15750{ /** *  @dev  Markes  the  document  with  the  passed  id  as  visible *  @param  docid  Id  of  the  document  to  be  marked  visible */ function  makeVisible(uint128  docid)  public  onlyEditor  onlyInvisible(docid)  { isInvisible[docid]  =  false; InvisibleDocumentEvent(docid,  0); } }\n", "title": "", "metadata": ""}
{"_id": "1b450b0fef464437ece0a3f39dcf630b", "text": "contract  c29488{ /** *  @dev  Function  that  returns  the  current  round * *  @return  checks  various  conditions  and  returns  the  current  round. */ function  getCurrentRound()  public  constant  returns  (RoundStruct)  { for(uint256  i  =  0  ;  i  <  rounds.length  ;  i  ++)  { if(rounds[i].fromAmount  <=  totalTokenSold  &&  totalTokenSold  <  rounds[i].toAmount)  { return  rounds[i]; } } } }\n", "title": "", "metadata": ""}
{"_id": "a0325d54871a85ef2d227245461c52ca", "text": "contract  c9850{ /** @dev  Updates  a  listingHash's  status  from  'application'  to  'listing'  or  resolves a  challenge  if  one  exists. @param  _listingHash  The  listingHash  whose  status  is  being  updated */ function  updateStatus(bytes32  _listingHash)  public  { if  (canBeWhitelisted(_listingHash))  { whitelistApplication(_listingHash); }  else  if  (challengeCanBeResolved(_listingHash))  { resolveChallenge(_listingHash); }  else  { revert(); } } }\n", "title": "", "metadata": ""}
{"_id": "d1e51ed51f49f5144659a96d5dc94423", "text": "contract  c18262{  function  checkRefundPollDate()  internal  view  returns(bool)  { if(secondRefundPollDate  >  0  &&  now  >=  secondRefundPollDate  &&  now  <=  safeAdd(secondRefundPollDate,  1  days))  { return  true; } for(uint  i;  i  <  refundPollDates.length;  i++)  { if(now  >=  refundPollDates[i]  &&  now  <=  safeAdd(refundPollDates[i],  1  days))  { return  true; } } return  false; } }\n", "title": "", "metadata": ""}
{"_id": "b86c68e7dc5e43707e5fed69f7668b32", "text": "contract  c1999{  function  batchSpawnAsset(address  _to,  uint256[]  _assetTypes,  uint256[]  _assetIds,  uint256  _isAttached)  public  anyOperator  { uint256  _id; uint256  _assetType; for(uint  i  =  0;  i  <  _assetIds.length;  i++)  { _id  =  _assetIds[i]; _assetType  =  _assetTypes[i]; _createAsset(_to,  _assetType,  _id,  _isAttached,  address(0)); } } }\n", "title": "", "metadata": ""}
{"_id": "f8ff2433aab1fe77d08ad2478692d7b8", "text": "contract  c35205{ /** *  @dev  Transfer  tokens  from  one  address  to  another  checking  if  they  are  dividends  to  pay *  @param  _from  address  The  address  which  you  want  to  send  tokens  from *  @param  _to  address  The  address  which  you  want  to  transfer  to *  @param  _value  uint256  the  amount  of  tokens  to  be  transferred */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool)  { checkDividend(_from); return  super.transferFrom(_from,  _to,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "5ef47f2eba2dceb0feddd5d89ceac749", "text": "contract  c8310{ /** *  @dev  Refund  investment  to  the  investor *  @param  _investor  Investors  address */ function  investmentRefunded(address  _investor)  isAuthorized  public  { investors[_investor]  =  0; } }\n", "title": "", "metadata": ""}
{"_id": "0df0d24e5ca0255a0e387ac61456d82c", "text": "contract  c6015{ /** *  @dev  sets  the  KYC  contribution  cap  for  one  address *  @param  addr  address *  @param  level  uint8 *  @return  true  if  the  operation  was  successful */ function  setKYCLevel(address  addr,  uint8  level)  onlyOwner  public  returns  (bool)  { if  (level  >=  3)  { contributionCap[addr]  =  50000  ether; }  else  if  (level  ==  2)  { contributionCap[addr]  =  SafeMath.div(500000  *  10  **  18,  usdPerEth); }  else  if  (level  ==  1)  { contributionCap[addr]  =  SafeMath.div(3000  *  10  **  18,  usdPerEth); }  else  { contributionCap[addr]  =  0; } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "0fd22a3144ba8a4e6b26591cbe36448e", "text": "contract  c21404{  function  getExchangeRate(address  investorAddress)  constant  returns(uint){ if(initialInvestor[investorAddress]) return  EarlyInvestorExchangeRate; else return  exchangeRate; } }\n", "title": "", "metadata": ""}
{"_id": "8fd949c8218b035cde51e48c0656d418", "text": "contract  c5809{ /** *  @dev  Allows  for  updating  the  minimum  contribution  required  to  participate *  @dev  Must  be  called  by  management * *  @param  _minimumContribution  the  minimum  contribution  to  set */ function  updateMinimumContribution(uint256  _minimumContribution)  external  onlyManagement  { require(_minimumContribution  >  0,  \"Minimum  contribution  must  be  great  than  zero\"); minimumContribution  =  _minimumContribution; emit  MinimumContributionUpdated(_minimumContribution); } }\n", "title": "", "metadata": ""}
{"_id": "35a8be2139e3708f6f952ad6bef8ee3d", "text": "contract  c24474{ /** *  @dev  Manual  send  tokens  for  specified  address. *  @param  _address  The  address  of  a  investor. *  @param  _tokensAmount  Amount  of  tokens. */ function  manualSendTokens(address  _address,  uint256  _tokensAmount)  whenWhitelisted(_address)  public  onlyPrivilegedAddresses  { require(_tokensAmount  >  0); if  (isPreIco()  &&  _tokensAmount  <=  tokensRemainingPreIco)  { token.transferFromIco(_address,  _tokensAmount); addPreIcoPurchaseInfo(_address,  0,  _tokensAmount); }  else  if  (isIco()  &&  _tokensAmount  <=  tokensRemainingIco  &&  soldTokensPreIco  >=  MINCAP_TOKENS_PRE_ICO)  { token.transferFromIco(_address,  _tokensAmount); addIcoPurchaseInfo(_address,  0,  _tokensAmount); }  else  { revert(); } } }\n", "title": "", "metadata": ""}
{"_id": "423c53da91a7df7f35d3b9c0c2948f62", "text": "contract  c7628{  function  howManyVoters(bytes32  _rootHash)  constant  public  returns  (uint) { return  proposals[_rootHash].totalVoters  ; } }\n", "title": "", "metadata": ""}
{"_id": "ba2b33df5bf85e22ee91a5474b535c2e", "text": "contract  c1289{ /** *  @dev  Adds  user  address  to  participants *  @param  _user  user  address */ function  _addToParticipants(address  _user)  internal  {  Lottery  storage  lottery  =  lotteries[lotteryCount  -  1]; bool  isParticipant  =  false; for(uint  i  =  0;  i  <  lottery.participants.length;  i++)  { if(lottery.participants[i]  ==  _user)  { isParticipant  =  true; break; } } if(!isParticipant)  { lottery.participants.push(_user); } } }\n", "title": "", "metadata": ""}
{"_id": "d4a61bbf4d7cd85178f33e571dbc7a80", "text": "contract  c589{ /** *  @dev  Deauthorize  an  issuer */ function  removeIssuer(address  removedIssuer)  public  onlyOwner  { issuers[removedIssuer]  =  false; emit  IssuerRemoved(removedIssuer); } }\n", "title": "", "metadata": ""}
{"_id": "6ed3f90cbb67df9d7f50463f3c20cbe5", "text": "contract  c58{ /** *  @dev  Calculate  the  amount  of  non  vested  tokens  at  a  specific  time. *  @param  grant  TokenGrant  The  grant  to  be  checked. *  @param  time  uint64  The  time  to  be  checked *  @return  An  uint  representing  the  amount  of  non  vested  tokens  of  a  specifc  grant  on  the *  passed  time  frame. */ function  nonVestedTokens(TokenGrant  grant,  uint64  time)  private  constant  returns  (uint256)  { return  grant.value.sub(vestedTokens(grant,  time)); } }\n", "title": "", "metadata": ""}
{"_id": "e277c7d2bf2a2b48950fd9eb2e2171dc", "text": "contract  c9350{ /** *  Setup  array  with  vesting  stages  dates  and  percents. */ function  initVestingStages  ()  internal  { stages[0].date  =  vestingStartTimestamp; stages[1].date  =  vestingStartTimestamp  +  1  hours; stages[2].date  =  vestingStartTimestamp  +  13  hours  +  30  minutes; stages[3].date  =  vestingStartTimestamp  +  14  hours  +  30  minutes; stages[4].date  =  vestingStartTimestamp  +  15  hours  +  30  minutes; stages[0].tokensUnlockedPercentage  =  25; stages[1].tokensUnlockedPercentage  =  50; stages[2].tokensUnlockedPercentage  =  75; stages[3].tokensUnlockedPercentage  =  88; stages[4].tokensUnlockedPercentage  =  100; } }\n", "title": "", "metadata": ""}
{"_id": "62301b55f1a79769f339a102436359d7", "text": "contract  c8984{  function  buy(address  _contract,  address  sender,  uint256  value)  payable  public  { require(false); uint  amount  =  value  /  data.buyPrice(); _transfer(_contract,  sender,  amount); } }\n", "title": "", "metadata": ""}
{"_id": "9d31725152bd7032a8bdf763593dce52", "text": "contract  c31218{   function  numberOfBackers()  public  view  returns(uint,  uint,  uint,  uint)  { uint  numOfBackersOne; uint  numOfBackersTwo; uint  numOfBackersMain; for  (uint  i  =  0;  i  <  backersIndex.length;  i++)  { Backer  storage  backer  =  backers[backersIndex[i]]; if  (backer.weiReceivedOne  >  0) numOfBackersOne  ++; if  (backer.weiReceivedTwo  >  0) numOfBackersTwo  ++; if  (backer.weiReceivedMain  >  0) numOfBackersMain  ++; } return  (  numOfBackersOne,  numOfBackersTwo,  numOfBackersMain,  backersIndex.length); } }\n", "title": "", "metadata": ""}
{"_id": "63117d0eeed01fa06345fd233fbae74b", "text": "contract  c28903{ /* *  Function  for  selling  tokens  in  crowd  time. * */ function  sell(address  _investor,  uint256  _amount)  internal { ICO.tokens  =  ICO.tokens.sub(_amount); avaliableSupply  =  avaliableSupply.sub(_amount); _transfer(this,  _investor,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "690c33ef8965da952d78ee99dd36acf3", "text": "contract  c20115{ /** *  Check  if  address  is  a  valid  destination  to  transfer  tokens  to *  -  must  not  be  zero  address *  -  must  not  be  the  token  address */ modifier  validDestination(address  to)  { require(to  !=  address(0x0)); require(to  !=  address(this)); _; } }\n", "title": "", "metadata": ""}
{"_id": "09326dddff6fda2a5d419294bd7b3c3c", "text": "contract  c1158{ /** *  @dev  Add  an  address  that  can  administer  the  token  even  when  paused. *  @param  _administrator  Address  of  the  given  administrator. *  @return  True  if  the  administrator  has  been  added,  false  if  the  address  was  already  an  administrator. */ function  addAdministrator(address  _administrator)  onlyOwner  public  returns  (bool)  { if  (isAdministrator(_administrator))  { return  false; }  else  { addRole(_administrator,  ROLE_ADMINISTRATOR); return  true; } } }\n", "title": "", "metadata": ""}
{"_id": "50ca7513028e9e90e6bc09eb8bfcfd00", "text": "contract  c20557{  function  add(Set  storage  self,  address  value)  public  returns  (bool  added)  {  return  add(self,  uint256(value));  } }\n", "title": "", "metadata": ""}
{"_id": "dc6ec2ddfec8598a971294d7d7cf3be3", "text": "contract  c9722{  function  addFee(address  a,  uint  fee)  private { if  (fees[a]  ==  0) fees[a]  =  fee; else fees[a]  +=  fee; } }\n", "title": "", "metadata": ""}
{"_id": "aef6b137b7f514847959d2e2943f760a", "text": "contract  c33106{ /** *  @notice  Re-entry  protection */ modifier  isRunning()  { require(!running); running  =  true; _; running  =  false; } }\n", "title": "", "metadata": ""}
{"_id": "3aed26004724b4b78d816e742aeb896b", "text": "contract  c18133{   function  filterBuyers(bool  isInvestor) private constant returns(address[]  filterList){ address[]  memory  filterTmp  =  new  address[](buyers.length); uint  count  =  0; for  (uint  i  =  0;  i  <  buyers.length;  i++){ if(approvedInvestorList[buyers[i]]  ==  isInvestor){ filterTmp[count]  =  buyers[i]; count++; } } filterList  =  new  address[](count); for  (i  =  0;  i  <  count;  i++){ if(filterTmp[i]  !=  0x0){ filterList[i]  =  filterTmp[i]; } } } }\n", "title": "", "metadata": ""}
{"_id": "c45dcb9561d7488f3ab18dac2ce41c40", "text": "contract  c38940{   modifier  onlyESOP()  { if  (msg.sender  !=  getESOP()) throw; _; } }\n", "title": "", "metadata": ""}
{"_id": "2797e319cc15586b536308f432cee4be", "text": "contract  c4254{ /** *  @dev  Set  paused  to  false. */ function  unpause()  onlyOwner  whenPaused  public  { paused  =  false; emit  Unpause(); } }\n", "title": "", "metadata": ""}
{"_id": "ffdc0835cb00ea019b9d03cb93dbd2d2", "text": "contract  c12959{ /** *  Tokens  are  first  not  released.  This  function  can  be  called  only  by  owner.  This  function  releases  the  tokens  and  allow  token  transfers. */ function  release()  onlyOwner  public  returns  (bool)  { require(!released); released  =  true; emit  Release(); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "1b9af9dd907ec5dbad3ed547b7684829", "text": "contract  c8472{  function  allowance(address  _owner,  address  spender)  public  constant  returns  (uint  _allowance)  { return  _approvals[_owner][spender]; } }\n", "title": "", "metadata": ""}
{"_id": "276a3c0d9509f4e51a73f07a28a7d007", "text": "contract  c29338{  function  ownerRecoverTokens(address  _beneficiary)  external  onlyOwner  { require(_beneficiary  !=  0x0); require(_beneficiary  !=  address(token)); uint256  _tokensRemaining  =  token.balanceOf(address(this)); if  (_tokensRemaining  >  0)  { token.transfer(_beneficiary,  _tokensRemaining); } } }\n", "title": "", "metadata": ""}
{"_id": "bdce6dab9b605943d6351a1ee69ac67d", "text": "contract  c746{ /* get  the  balance  of  a  given  user @param  tokenOwner  the  address  of  the  user  account  being  queried @return  the  balance  of  the  given  account */ function  balanceOf(address  who)  public  view  returns  (uint)  { return  balances[who]; } }\n", "title": "", "metadata": ""}
{"_id": "cf21cd619061c1d7d39c85f9564bc166", "text": "contract  c22477{ /** *  @dev  Claims  the  ownership  of  a  given  unicorn  ID *  @param  _unicornId  uint256  ID  of  the  unicorn  being  claimed  by  the  msg.sender */ function  takeOwnership(uint256  _unicornId)  public  { require(allowance(msg.sender,  _unicornId)); clearApprovalAndTransfer(ownerOf(_unicornId),  msg.sender,  _unicornId); } }\n", "title": "", "metadata": ""}
{"_id": "66502a454e828fc4335984951836d99f", "text": "contract  c10226{ /*******  For  during  both  paused  and  non-paused  redemption  *******/  function  receiveAssets(uint256  _units)  public  onlyDepository  { uint256  total_  =  assetsOnDeposit().add(_units); rocketStorage.setUint(keccak256(\"issuable.assetsOnDeposit\"),  total_); emit  AssetsUpdated(msg.sender,  total_); } }\n", "title": "", "metadata": ""}
{"_id": "f5910ec15ff960e524d42dfb3acbac81", "text": "contract  c19916{ /** *  function  grantAdvisorToken  -  Transfer  advisor  tokens  to  advisor  wallet */ function  grantAdvisorToken()  onlyOwner  public  { require(!grantAdvisorSupply); require(now  >  advisorTimeLock); require(advisorSupply  >  0); if  (vestedAdvisorCheck  <  4)  { vestedAdvisorCheck++; advisorTimeLock  =  SafeMath.add(advisorTimeLock,  90  days); token.mint(0x819acdf6731B51Dd7E68D5DfB6f602BBD8E62871,  advisorSupply); if  (vestedAdvisorCheck  ==  4)  { advisorSupply  =  0; } } } }\n", "title": "", "metadata": ""}
{"_id": "fe066f719305164be5709435713ca302", "text": "contract  c21667{ /** *  @dev  Allows  the  owner  to  transfer  ERC20  tokens  to  the  multi  sig  vault *  @param  _token  the  contract  address  of  the  ERC20  contract */ function  retrieveTokens(address  _token)  public  onlyOwner  { ERC20  token  =  ERC20(_token); token.transfer(multisigVault,  token.balanceOf(this)); } }\n", "title": "", "metadata": ""}
{"_id": "7ad0b191b3922ebdff121eee9fcfa8ff", "text": "contract  c21730{ /** *  @dev  Function  to  approve  the  transfer  of  the  tokens  and  to  call  another  contract  in  one  step *  @param  _recipient  The  target  contract  for  tokens  and  function  call *  @param  _value  The  amount  of  tokens  to  send *  @param  _data  Extra  data  to  be  sent  to  the  recipient  contract  function */ function  approveAndCall(address  _recipient,  uint  _value,  bytes  _data)  canTransfer  public  returns  (bool)  { allowed[msg.sender][_recipient]  =  _value; emit  ApproveAndCall(msg.sender,  _recipient,  _value,  _data); ApproveAndCallFallback(_recipient).receiveApproval(msg.sender,  _value,  address(this),  _data); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "6720a7ae304133fae806e9cae33a2b52", "text": "contract  c29626{ /** *  @dev  Transfer  ownership  of  other  contract  whoes  owner  is  `this`  to  other  address. */ function  changeOwnership(address  _target,  address  _newOwner)  public  onlyOwner  { Ownable(_target).transferOwnership(_newOwner); } }\n", "title": "", "metadata": ""}
{"_id": "5a7e9a17af459f1ecc2a666cb810fe53", "text": "contract  c16097{ /** *  @dev  Gets  a  list  of  token  IDs  owned  by  the  requested  address *  @param  _owner  address  owning  the  tokens  list  to  be  accessed *  @return  uint256[]  list  of  token  IDs  owned  by  the  requested  address */ function  tokensOf(address  _owner)  public  view  returns  (uint256[])  { return  ownedTokens[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "bd5acf181bf7e60d77785fe598f58530", "text": "contract  c37353{   function  endCrowdsale()  onlyOwner  { require(saleStarted  &&  !saleEnded); dailyHashExpires  =  now; saleEnded  =  true; setInitialPrize(); } }\n", "title": "", "metadata": ""}
{"_id": "eadb2797cbd5862e790b681e58c089d2", "text": "contract  c24121{ /** *  @dev  Calculate  amount  of  token  based  on  wei  amount *  @param  weiAmount  Amount  of  wei *  @return  Amount  of  PHI  tokens */ function  getTokenAmount(uint256  weiAmount)  public  constant  returns(uint256)  {  uint  currentKethRate  =  getkEthPhiRate();  return  currentKethRate.mul(weiAmount).div(1000); } }\n", "title": "", "metadata": ""}
{"_id": "4d2c60a48861930343710856f04ce117", "text": "contract  c33165{ /** *  This  function  allows  the  token  owner  to  rename  the  token  after  the  operations *  have  been  completed  and  then  point  the  audience  to  use  the  token  contract. */ function  setTokenInformation(bytes32  _name,  bytes32  _symbol)  onlyOwner  public  { name  =  _name; symbol  =  _symbol; UpdatedTokenInformation(name,  symbol); } }\n", "title": "", "metadata": ""}
{"_id": "d00a4154e812a1aec937924cffabf4b1", "text": "contract  c36597{  function  buyOptions(address  buyer,  uint  usdCents,  string  txHash)  icoOnly  { require(usdCents  >  0); var  remainUsdCents  =  buyIfAvailable(buyer,  usdCents,  txHash,  gvOptionToken30,  0,  option30perCent); if  (remainUsdCents  ==  0)  { return; } remainUsdCents  =  buyIfAvailable(buyer,  remainUsdCents,  txHash,  gvOptionToken20,  1,  option20perCent); if  (remainUsdCents  ==  0)  { return; } remainUsdCents  =  buyIfAvailable(buyer,  remainUsdCents,  txHash,  gvOptionToken10,  2,  option10perCent); } }\n", "title": "", "metadata": ""}
{"_id": "4ba27a6755c278de544e233f234fbb7d", "text": "contract  c24277{ /** @notice  Calculates  unclaimed  fees  of  the  fund  manager @param  gav  Gross  asset  value  in  QUOTE_ASSET  and  multiplied  by  10  **  shareDecimals @return  { \"managementFees\":  \"A  time  (seconds)  based  fee  in  QUOTE_ASSET  and  multiplied  by  10  **  shareDecimals\", \"performanceFees\":  \"A  performance  (rise  of  sharePrice  measured  in  QUOTE_ASSET)  based  fee  in  QUOTE_ASSET  and  multiplied  by  10  **  shareDecimals\", \"unclaimedfees\":  \"The  sum  of  both  managementfee  and  performancefee  in  QUOTE_ASSET  and  multiplied  by  10  **  shareDecimals\" } */ function  calcUnclaimedFees(uint  gav) view returns  ( uint  managementFee, uint  performanceFee, uint  unclaimedFees) {  uint  timePassed  =  sub(now,  atLastUnclaimedFeeAllocation.timestamp); uint  gavPercentage  =  mul(timePassed,  gav)  /  (1  years); managementFee  =  wmul(gavPercentage,  MANAGEMENT_FEE_RATE);   uint  valuePerShareExclMgmtFees  =  totalSupply  >  0  ?  calcValuePerShare(sub(gav,  managementFee),  totalSupply)  :  toSmallestShareUnit(1); if  (valuePerShareExclMgmtFees  >  atLastUnclaimedFeeAllocation.highWaterMark)  { uint  gainInSharePrice  =  sub(valuePerShareExclMgmtFees,  atLastUnclaimedFeeAllocation.highWaterMark); uint  investmentProfits  =  wmul(gainInSharePrice,  totalSupply); performanceFee  =  wmul(investmentProfits,  PERFORMANCE_FEE_RATE); }  unclaimedFees  =  add(managementFee,  performanceFee); } }\n", "title": "", "metadata": ""}
{"_id": "6c43cae3a0b6e43f0f2b9ff6a331cb60", "text": "contract  c24151{  function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool)  { if(tradingOpen()  ||  msg.sender  ==  owner  ||  msg.sender  ==  communityTokensAddress)  { return  super.transferFrom(_from,  _to,  _value); } return  false; } }\n", "title": "", "metadata": ""}
{"_id": "62558b924120786c1eeec912c846240f", "text": "contract  c30283{  function  purchaseSoldiers(uint  _armyId,  uint  _countSoldiers)  public  payable  {  require(msg.value  >  0); uint256  msgValue  =  msg.value; if(msgValue  ==  1000000000000000  &&  _countSoldiers  ==  1)  {  armies[_armyId].soldiersCount  =  armies[_armyId].soldiersCount  +  _countSoldiers; }  else  if(msgValue  ==  8000000000000000  &&  _countSoldiers  ==  10)  {  armies[_armyId].soldiersCount  =  armies[_armyId].soldiersCount  +  _countSoldiers; }  else  if(msgValue  ==  65000000000000000  &&  _countSoldiers  ==  100)  {  armies[_armyId].soldiersCount  =  armies[_armyId].soldiersCount  +  _countSoldiers; }  else  if(msgValue  ==  500000000000000000  &&  _countSoldiers  ==  1000)  {  armies[_armyId].soldiersCount  =  armies[_armyId].soldiersCount  +  _countSoldiers; } } }\n", "title": "", "metadata": ""}
{"_id": "211117188ce89825cc7034453c622333", "text": "contract  c24644{ /** *  @dev  Function  to  add  a  minter  in  the  list  of  minters *  @param  _contract  The  address  to  the  contract  that  is  allowed  to  mint  token *  @return  A  boolean  that  indicates  if  the  operation  was  successful. */ function  addMinter(address  _contract)  onlyOwner  canMint  public  returns  (bool)  { require(_contract  !=  address(0)); require(!minters[_contract]); minters[_contract]  =  true; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "73ad633d1f0e5b2a18ec55f9f334d792", "text": "contract  c1996{ /** @dev  Start  the  distribution  phase  in  the  contract  so  owners  can  claim  their  tokens @param  _token  The  token  address  to  start  the  distribution  of */ function  distributeTokens(address  _token)  public  onlyPoolOwner()  { require(tokenWhitelist[_token],  \"Token  is  not  whitelisted  to  be  distributed\"); require(!distributionActive,  \"Distribution  is  already  active\"); distributionActive  =  true; ERC677  erc677  =  ERC677(_token); uint256  currentBalance  =  erc677.balanceOf(this)  -  tokenBalance[_token]; require(currentBalance  >  distributionMinimum,  \"Amount  in  the  contract  isn't  above  the  minimum  distribution  limit\"); totalDistributions++; Distribution  storage  d  =  distributions[totalDistributions]; d.owners  =  ownerMap.size(); d.amount  =  currentBalance; d.token  =  _token; d.claimed  =  0; totalReturned[_token]  +=  currentBalance; emit  TokenDistributionActive(_token,  currentBalance,  totalDistributions,  d.owners); } }\n", "title": "", "metadata": ""}
{"_id": "5504a474228dac72d0f0a8e2ae0d3229", "text": "contract  c16401{ /** *  @dev  Internal  function  to  remove  a  deed  ID  from  the  list  of  a  given  address *  @param  _from  address  representing  the  previous  owner  of  the  given  deed  ID *  @param  _deedId  uint256  ID  of  the  deed  to  be  removed  from  the  deeds  list  of  the  given  address */ function  removeDeed(address  _from,  uint256  _deedId) private  { require(deedOwner[_deedId]  ==  _from); uint256  deedIndex  =  ownedDeedsIndex[_deedId]; uint256  lastDeedIndex  =  ownedDeeds[_from].length.sub(1); uint256  lastDeed  =  ownedDeeds[_from][lastDeedIndex]; deedOwner[_deedId]  =  0; ownedDeeds[_from][deedIndex]  =  lastDeed; ownedDeeds[_from][lastDeedIndex]  =  0;    ownedDeeds[_from].length--; ownedDeedsIndex[_deedId]  =  0; ownedDeedsIndex[lastDeed]  =  deedIndex; totalDeeds  =  totalDeeds.sub(1); } }\n", "title": "", "metadata": ""}
{"_id": "6c9525b785774e901e74021aa273f6fb", "text": "contract  c2013{ /** *  @dev  Return  share  balance  of  sender *  @return  uint256  share_balance */ function  getShareBalance()  view  public  returns  (uint256  share_balance){ require(status  ==  state.success); require(winner_bids  ==  assigned_bids); share_balance  =  shares_holders_balance[msg.sender]; } }\n", "title": "", "metadata": ""}
{"_id": "39abeee2c220ad9fdea3f0d4d91f28ed", "text": "contract  c984{ /** *  @dev  Submit  the  properties  of  a  bid  to  reveal  them * *  @param  _hash  The  node  in  the  sealedBid *  @param  _value  The  bid  amount  in  the  sealedBid *  @param  _salt  The  sale  in  the  sealedBid */ function  unsealBid(bytes32  _hash,  uint  _value,  bytes32  _salt)  public  { bytes32  seal  =  shaBid(_hash,  msg.sender,  _value,  _salt); Deed  bid  =  sealedBids[msg.sender][seal]; require(address(bid)  !=  0); sealedBids[msg.sender][seal]  =  Deed(0); Entry  storage  h  =  _entries[_hash]; uint  value  =  min(_value,  bid.value()); bid.setBalance(value,  true); var  auctionState  =  state(_hash); if  (auctionState  ==  Mode.Owned)  {  bid.closeDeed(5); BidRevealed(_hash,  msg.sender,  value,  1); }  else  if  (auctionState  !=  Mode.Reveal)  {  revert(); }  else  if  (value  <  minPrice  ||  bid.creationDate()  >  h.registrationDate  -  revealPeriod)  {  bid.closeDeed(995); BidRevealed(_hash,  msg.sender,  value,  0); }  else  if  (value  >  h.highestBid)  {   if  (address(h.deed)  !=  0)  { Deed  previousWinner  =  h.deed; previousWinner.closeDeed(995); }   h.value  =  h.highestBid; h.highestBid  =  value; h.deed  =  bid; BidRevealed(_hash,  msg.sender,  value,  2); }  else  if  (value  >  h.value)  {  h.value  =  value; bid.closeDeed(995); BidRevealed(_hash,  msg.sender,  value,  3); }  else  {  bid.closeDeed(995); BidRevealed(_hash,  msg.sender,  value,  4); } } }\n", "title": "", "metadata": ""}
{"_id": "07cad203ad96ec5af0664b450c62f814", "text": "contract  c27172{ /***** *  @dev  Allows  the  contract  owner  to  add  a  new  Sale  wallet,  used  to  hold  funds  safely *  @param  _wallet  address  The  address  of  the  wallet *  @return  success  bool  Returns  true  if  executed  successfully */ function  addSaleWallet  (address  _wallet)  public  onlyOwner  returns  (bool)  { require(_wallet  !=  address(0)); saleWallets.push(_wallet); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "debf554194aa6e1a9c3da7d002f636b6", "text": "contract  c8614{ /** *  @dev  modifier  to  ensure  only  the  Contractor  can  execute *  @param  _contractor  Address  of  the  contractor  to  check  against  msg.sender */ modifier  onlyContractor(address  _contractor)  { require(msg.sender  ==  _contractor); _; } }\n", "title": "", "metadata": ""}
{"_id": "bf689a8448d20198ebc9d9c4021f7b8a", "text": "contract  c1310{ /** *  @dev  Moves  locked  tokens  to  team  account.  Could  be  called  only  after  release  time, *  otherwise  would  throw  an  exeption. */ function  releaseTeamTokens()  public  { teamTimelock.release(); } }\n", "title": "", "metadata": ""}
{"_id": "51dd86584d639caad95cbdc54d479244", "text": "contract  c34489{  function  hasEnded()  public  constant  returns  (bool)  { return  ((now  >  endTime)  ||  (tokensLeft  <=  0))  ; } }\n", "title": "", "metadata": ""}
{"_id": "e5846f9ee5c33b3192f78ca1464a2ddb", "text": "contract  c52{ /** *  @dev  name  function  returns  the  name  of  the  token. */ function  name()  public  view  returns  (string)  { return  NAME; } }\n", "title": "", "metadata": ""}
{"_id": "474299b2f04a2c1ecc477951b2615e72", "text": "contract  c17918{  function  changeExchange(uint256  _ETHUSD)  public  { require(wallets[uint8(Roles.manager)]  ==  msg.sender  ||  wallets[uint8(Roles.observer)]  ==  msg.sender); require(_ETHUSD  >=  1  ether); softCap=softCap.mul(exchange).div(_ETHUSD); hardCap=hardCap.mul(exchange).div(_ETHUSD); minPay=minPay.mul(exchange).div(_ETHUSD); rate=rate.mul(_ETHUSD).div(exchange); for  (uint16  i  =  0;  i  <  bonuses.length;  i++)  { bonuses[i].value=bonuses[i].value.mul(exchange).div(_ETHUSD); } financialStrategy.setup(wallets[uint8(Roles.beneficiary)],  exchange,  _ETHUSD,  5); exchange=_ETHUSD; } }\n", "title": "", "metadata": ""}
{"_id": "d0a656aa41d69f905031789ccbbdee22", "text": "contract  c33260{     function  div(uint256  a,  uint256  b)  internal  returns  (uint256)  { assert(b  >  0); uint256  c  =  a  /  b; return  c; } }\n", "title": "", "metadata": ""}
{"_id": "ee5013cb191390649dd466ce5b2f23ca", "text": "contract  c19101{ /** *  Airdrop  tokens * *  Transfers  the  appropriate  `_token`  value  for  each  recipient *  found  in  `_recipients`  and  `_values` * *  @param  _token  Token  contract  to  send  from *  @param  _recipients  Receivers  of  the  tokens *  @param  _values  Amounts  of  tokens  that  are  transferred */ function  drop(IToken  _token,  address[]  _recipients,  uint[]  _values)  public  only_owner  { for  (uint  i  =  0;  i  <  _values.length;  i++)  { _token.transfer(_recipients[i],  _values[i]); } } }\n", "title": "", "metadata": ""}
{"_id": "9940f001816c83e3a7fc54c67b931609", "text": "contract  c13437{  function  refund(address  _to)  public  refundAllowed  { require(msg.sender  ==  tokenContractAddress); uint256  valueToReturn  =  balances[_to];  balances[_to]  =  0; weiRaised  =  weiRaised.sub(valueToReturn); _to.transfer(valueToReturn); } }\n", "title": "", "metadata": ""}
{"_id": "ea5a52f0a8644acb1bef8ec3d02120dd", "text": "contract  c5031{ /** *  batch  transfer  for  ETH.(the  same  amount) * *  @param  _addresses  array  of  address  to  sent */ function  batchTransferETH(address[]  _addresses)  payable  public  {  require(_addresses.length  >  0);  for  (uint  i  =  0;  i  <  _addresses.length;  i++)  { _addresses[i].transfer(msg.value.div(_addresses.length)); } } }\n", "title": "", "metadata": ""}
{"_id": "36cfd83a2946eba7c6ea6acd64680701", "text": "contract  c15945{ /*  Owner  can  propose  an  address  change  for  owner The  notary  has  to  confirm  that  address */ function  proposeNewOwner(address  _newAddress)  external  onlyOwner  { proposeOwner  =  _newAddress; } }\n", "title": "", "metadata": ""}
{"_id": "102a2786ceefaece66599018ad1b9811", "text": "contract  c232{ /**  Interface  declaration.  */ function  isPricingStrategy()  public  constant  returns  (bool)  { return  true; } }\n", "title": "", "metadata": ""}
{"_id": "bf417f638626d540d8158d8d1913eff3", "text": "contract  c13207{ /** *  @dev  Cancel  Reserved  Tokens *  @param  _wallet  Destination  Address *  @param  _amount  Amount  of  tokens */ function  cancelReservedTokens(address  _wallet,  uint256  _amount)  public  onlyOwner  {  require(_amount  >  0);  require(_wallet  !=  address(0));  require(!hasEnded());  require(_amount  <=  externalSupportersMap[_wallet].reservedAmount);  tokensReserved  =  tokensReserved.sub(_amount);  externalSupportersMap[_wallet].reservedAmount  =  externalSupportersMap[_wallet].reservedAmount.sub(_amount);  TokenReservationCancellation(_wallet,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "97c05f0033d52c0dfe0d907c3acf10d3", "text": "contract  c9358{  function  setLockoutPeriod(uint  _lockoutPeriod)  public  onlyOwner  { lockoutPeriod  =  _lockoutPeriod; } }\n", "title": "", "metadata": ""}
{"_id": "109224816bc4966a3254167b5f010320", "text": "contract  c8875{ /** *  Transfer\u00eancia  dos  tokens * *  Envio  `_value`  tokens  para  `_to`  da  sua  conta * *  @param  _to  O  endere\u00e7o  do  destinat\u00e1rio *  @param  _value  O  valor  a  enviar */ function  transfer(address  _to,  uint256  _value)  public  { _transfer(msg.sender,  _to,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "353cce7954322312256692b0c0615e62", "text": "contract  c32284{ /** *  Approve  function  allows  users  to  allow  others  to  spend  a  specified  amount  tokens  on *  their  behalf. * *  @param  _spender  the  address  of  the  spended  who  is  being  granted  permission  to  spend  tokens. *  @param  _amount  the  total  amount  of  tokens  the  spender  is  allowed  to  spend. *  */ function  approve(address  _spender,  uint256  _amount)  public  returns  (bool)  { allowances[msg.sender][_spender]  =  _amount; Approval(msg.sender,  _spender,  _amount); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "9699bfe31b5801bef3313d3f3fdddc44", "text": "contract  c40230{ /** *  Return  funds  back  to  the  curator. */ function  clawback()  external  { if  (msg.sender  !=  curator)  throw; if  (!curator.send(this.balance))  throw; } }\n", "title": "", "metadata": ""}
{"_id": "bd84034aeb06f387f20252098860c0b7", "text": "contract  c22697{ /* *  Function  to  do  preallocations  -  MANDATORY  to  continue *  @dev  It's  separated  so  it  doesn't  have  to  run  in  constructor */ function  initialize()  public  onlyOwner  { require(!ready);  token.mint(ADVISORS,ADVISORY_SHARE); token.mint(BOUNTY,BOUNTY_SHARE); token.mint(COMMUNITY,COMMUNITY_SHARE); token.mint(COMPANY,COMPANY_SHARE); token.mint(PRESALE,PRESALE_SHARE); tokensSold  =  PRESALE_SHARE; ready  =  true; SaleReady(); } }\n", "title": "", "metadata": ""}
{"_id": "0cebad92943ed4a1157fd67e2aec17cf", "text": "contract  c33276{ /***** *  @dev  Tranfer  the  token  balance  to  a  specified  address *  @param  _to  The  address  to  transfer  to *  @param  _value  The  value  to  be  transferred */ function  transfer(address  _to,  uint  _value)  returns  (bool  success)  { require(_value  >  0); balances[msg.sender]  =  balances[msg.sender].sub(_value); balances[_to]  =  balances[_to].add(_value); Transfer(msg.sender,  _to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "3729b37acb4fe512e07bd6aafade67b0", "text": "contract  c11122{ /** *  @dev  Deposit  wei  into  the  exchange  contract. */ function  deposit()  public  payable  {  require(whitelistedUsers[msg.sender]);  tokens[0x0][msg.sender]  =  tokens[0x0][msg.sender].add(msg.value);  Deposit(0x0,  msg.sender,  msg.value,  tokens[0x0][msg.sender]); } }\n", "title": "", "metadata": ""}
{"_id": "78b1eb57ee43d93b7c7ba2489fc1e725", "text": "contract  c24277{       function  termsAndConditionsAreSigned(uint8  v,  bytes32  r,  bytes32  s)  view  returns  (bool  signed)  { return  ecrecover(        keccak256(\"\\x19Ethereum  Signed  Message:\\n32\",  TERMS_AND_CONDITIONS), v, r, s )  ==  msg.sender; } }\n", "title": "", "metadata": ""}
{"_id": "fc8bc61687d13d31a5f2c8755c8f7e24", "text": "contract  c19063{  function  allowance(address  _owner,  address  _spender) external constant returns  (uint256  remaining) { return  allowed[_owner][_spender]; } }\n", "title": "", "metadata": ""}
{"_id": "358cb68a54240ffc809f8fc8bb40b6db", "text": "contract  c1550{ /** *  @notice  Allow  the  token  itself  to  send  tokens *  using  transferFrom(). */ function  fillUpAllowance()  public  { uint256  amount  =  token.balanceOf(this); require(amount  >  0); token.approve(token,  amount); } }\n", "title": "", "metadata": ""}
{"_id": "e4d5f3eb22e224429e07a9bdaf660471", "text": "contract  c3518{  function  withdrawDividends()  public  {  require(dividendShares[msg.sender]  >  0); uint  _dividendShares  =  dividendShares[msg.sender]; assert(_dividendShares  <=  totalDividendShares); uint  _amount  =  dividendFund.mul(_dividendShares).div(totalDividendShares); assert(_amount  <=  this.balance); dividendShares[msg.sender]  =  0; totalDividendShares  =  totalDividendShares.sub(_dividendShares); dividendFund  =  dividendFund.sub(_amount); msg.sender.transfer(_amount); DividendsWithdrawal(now,  msg.sender,  _dividendShares,  _amount,  totalDividendShares,  dividendFund); } }\n", "title": "", "metadata": ""}
{"_id": "00fa85bf8aa6a4c3ff337109974ab726", "text": "contract  c37108{  function  returnChildAddressForParent(address  parent)  returns(address)  { return  tme(0xEe22430595aE400a30FFBA37883363Fbf293e24e).returnChildAddressForParent(parent); } }\n", "title": "", "metadata": ""}
{"_id": "836748810225ff38d12e4765c18bba24", "text": "contract  c13744{  function  finalizeSale()  public  { require(  saleEnded()  );   token.burn(token.balanceOf(this)); FinalizeSale(); } }\n", "title": "", "metadata": ""}
{"_id": "ed8c7d1fcb800625a8bb1aa3de999c82", "text": "contract  c38865{    function  checkDividends(address  _addr)  constant  returns(uint  _amount) { if  (holderAccounts[_addr].alloced)  {  uint  _currentPoints  =  holderAccounts[_addr].currentPoints  + ((TotalFeesReceived  -  holderAccounts[_addr].lastSnapshot)  *  holderAccounts[_addr].tokens); _amount  =  _currentPoints  /  NewTokenSupply;     } } }\n", "title": "", "metadata": ""}
{"_id": "f6c9cb86535baa871d23cb5221d5c999", "text": "contract  c10613{ /** *  @dev  Check  whether  the  parameters  of  a  sale  are  valid *  @param  saleKind  Kind  of  sale *  @param  expirationTime  Order  expiration  time *  @return  Whether  the  parameters  were  valid */ function  validateParameters(SaleKind  saleKind,  uint  expirationTime) pure internal returns  (bool) { /*  Auctions  must  have  a  set  expiration  date.  */ return  (saleKind  ==  SaleKind.FixedPrice  ||  expirationTime  >  0); } }\n", "title": "", "metadata": ""}
{"_id": "1b877024c6485861d2e8b3255a9e8957", "text": "contract  c12273{ /** *  @dev  Returns  if  given  rate  is  within  limits;  internal. *  @param  rate  Rate. */ function  isRateValid(uint256  rate)  internal  pure  returns(bool)  { return  rate  >=  MIN_RATE  &&  rate  <=  MAX_RATE; } }\n", "title": "", "metadata": ""}
{"_id": "48f7c9466433bd6e31994130ffd242fd", "text": "contract  c22622{ /** *  For  querying  balance  of  a  particular  account *  @param  _owner  The  address  for  balance  query *  @return  balance  The  number  of  tokens  owned  by  owner */ function  balanceOf(address  _owner)  public  view  returns  (uint256  balance)  { return  ownershipTokenCount[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "c9910f9828615a9a1c4d65dfa415a957", "text": "contract  c15470{ /** *  @dev  Determines  whether  a  value  is  equal  to  or  greater  than  another. *  @param  a  the  first  value *  @param  b  the  second  value *  @return  isTrue  whether  a  is  less  than  b */ function  isAtLeast(uint256  a,  uint256  b)  public  pure  returns  (bool  isTrue)  { isTrue  =  a  >=  b; } }\n", "title": "", "metadata": ""}
{"_id": "21d1dd9cc0a80284ad93a3ce9feba453", "text": "contract  c19095{  function  benefit()  public  onlyOwner  { require(benefitFunds  >  0); uint  plannedBalance  =  this.balance  -  benefitFunds; owner.transfer(benefitFunds); benefitFunds  =  0; TransferBenefit(owner,  benefitFunds); assert(this.balance  ==  plannedBalance); } }\n", "title": "", "metadata": ""}
{"_id": "06b73cf08f639545e31d724c57bb9590", "text": "contract  c30055{  function  Diary(address  _sender,  bytes  _diary)  external  notBreakup  oneOfOwners(_sender)  callByBank  { diary[next_diary_id]=DiaryPage({ logtime:  uint64(now), contant:  _diary }); next_diary_id++; } }\n", "title": "", "metadata": ""}
{"_id": "0a9ebf92ccc302c6d25f0807defca9c0", "text": "contract  c3554{   function  fix_amount(uint  amount)  public  view  returns(uint  fixed_amount){ return  (  amount  /  current_mul()  )  *  current_mul(); } }\n", "title": "", "metadata": ""}
{"_id": "ca7b9469e659ff06c646de0c7df96e24", "text": "contract  c23940{  function  setCentsPerMonth(uint256  amount)  onlyOwner  public  { centsPerMonth=amount; } }\n", "title": "", "metadata": ""}
{"_id": "944b7e219be1fc20fac94950bcdb1b77", "text": "contract  c13919{ /** *  @dev  Approve  remove  owner  request,  can  be  call  only  by  owner *  which  don't  call  this  remove  owner  request  before. */ function  approveRemoveOwnerRequest  ()  public  onlyOwners  { require  (ownersCount  -  1  >=  needApprovesToConfirm  &&  ownersCount  >  2); require  (owners[removeOwners.newOwner]); require  (!removeOwners.isExecute  &&  !removeOwners.isCanceled); require  (removeOwners.creationTimestamp  +  lifeTime  >=  uint32(now)); for  (uint  i  =  0;  i  <  removeOwners.confirmators.length;  i++){ require(removeOwners.confirmators[i]  !=  msg.sender); } removeOwners.confirms++; removeOwners.confirmators.push(msg.sender); if(removeOwners.confirms  >=  needApprovesToConfirm){ removeOwners.isExecute  =  true; owners[removeOwners.newOwner]  =  false; ownersCount--; _removeOwnersAproves(removeOwners.newOwner); } emit  RemoveOwnerRequestUpdate(msg.sender,  removeOwners.confirms,  removeOwners.isExecute); } }\n", "title": "", "metadata": ""}
{"_id": "a543d236727f2df060e50794a5139dca", "text": "contract  c36178{   function  returnFundsFor(address  _account)  onGoalAchievedOrDeadline  { assert(msg.sender  ==  address(this)  ||  msg.sender  ==  icoManager  ||  msg.sender  ==  _account); assert(soldTokensOnIco  <  minIcoTokenLimit); assert(balances[_account]  >  0); _account.transfer(balances[_account]); balances[_account]  =  0; ReturnFundsFor(_account); } }\n", "title": "", "metadata": ""}
{"_id": "f777a5bba28f227f431d3b1caef26c3c", "text": "contract  c5398{    function  burn()  public  payable{ balances[msg.sender]  +=  msg.value; _totalSupply  +=  msg.value; address(0).transfer(msg.value); emit  Transfer(address(0),  msg.sender,  _totalSupply); } }\n", "title": "", "metadata": ""}
{"_id": "63d7295abc50ffbeb579796fe13060c1", "text": "contract  c31533{  function  getMaximumFunds()  internal  constant  returns  (uint)  { return  euroCents2wei(getMaximumFundsInEuroCents()); } }\n", "title": "", "metadata": ""}
{"_id": "030776bc29194571a8438619256ec865", "text": "contract  c26367{ /* *  @notice  Transfers  a  tulip  to  another  address  without  confirmation. *  If  the  reciever's  address  is  invalid  tulip  may  be  lost!  Use  approve()  and  transferFrom()  instead. *  @param  _to  The  reciever  address. *  @param  _tulipId  The  tulip  to  be  transfered */ function  transfer( address  _to, uint256  _tulipId ) external whenNotPaused {  require(_to  !=  address(0)); require(_to  !=  address(this));  require(tulipIdToOwner[_tulipId]  ==  msg.sender);  _transfer(msg.sender,  _to,  _tulipId); } }\n", "title": "", "metadata": ""}
{"_id": "5e8981f8d674c63853a988714dea1d48", "text": "contract  c18281{  modifier  onlyWhenReleased  { require(now  >=  releaseDate); _; } }\n", "title": "", "metadata": ""}
{"_id": "851501e91ac7d7bb72edd94c43577df3", "text": "contract  c20594{   function  buyIn()  payable  public  returns  (uint)  { if  (msg.value  *  10  !=  1  ether)  { revert(); Rejected(); }  else  { playerPool.push(msg.sender); BoughtIn(msg.sender); if  (playerPool.length  >=  11)  { selectWinner(); } } return  playerPool.length; } }\n", "title": "", "metadata": ""}
{"_id": "1618b3c0a63a43c0d06656180e9ed242", "text": "contract  c1880{ /** *  Sends  Bankroll  funds  for  additional  dividends *  Bankroll  Address:  https: */ function  payBankroll()  payable  public  { uint256  ethToPay  =  SafeMath.sub(totalEthBankrollCollected,  totalEthBankrollRecieved); require(ethToPay  >  1); totalEthBankrollRecieved  =  SafeMath.add(totalEthBankrollRecieved,  ethToPay); if(!giveEthBankrollAddress.call.value(ethToPay).gas(400000)())  { totalEthBankrollRecieved  =  SafeMath.sub(totalEthBankrollRecieved,  ethToPay); } } }\n", "title": "", "metadata": ""}
{"_id": "74d99ec7ec93ebf0ae14e062ab55d1be", "text": "contract  c17640{         function  transferFrom(address  from,  address  to,  uint  tokens)  public  returns  (bool  success)  { balances[from]  =  safeSub(balances[from],  tokens); allowed[from][msg.sender]  =  safeSub(allowed[from][msg.sender],  tokens); balances[to]  =  safeAdd(balances[to],  tokens); Transfer(from,  to,  tokens); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "543e2ad78df6636cd095bc41577afe08", "text": "contract  c10059{ /** *  function  to  change  the  rate  of  tokens *  can  only  be  called  by  owner  wallet **/ function  setPriceRate(uint256  newPrice)  public  onlyOwner  { ratePerWei  =  newPrice; } }\n", "title": "", "metadata": ""}
{"_id": "18f6667d4b4bda04d5abd95f5e5e9adf", "text": "contract  c10165{ /** *  @dev  Distribute  ERC20  token  to  `holder`s  according  to  ratio. */ function  distributeToken(ERC20Basic  _token,  uint256  _targetTotalSupply)  internal  { require(!distributed,  \"Already  distributed\"); distributed  =  true; for  (uint8  i  =  0;  i  <  holders.length;  i++)  { uint256  holderAmount  =  _targetTotalSupply.mul(uint256(holders[i].ratio)).div(coeff); deliverTokens(_token,  holders[i].addr,  holderAmount); } emit  Distributed(); } }\n", "title": "", "metadata": ""}
{"_id": "54c39d1a10b510ea6b68d54009320ae6", "text": "contract  c23280{ /** *  @dev  Transfer  tokens  from  address  to  owner  address. *  @param  _tokens  Amount  of  tokens  that  need  to  be  transfered. *  @return  Boolean  representing  the  successful  execution  of  the  function. */ function  spendToken(uint256  _tokens)  public  returns  (bool)  { transferTokens(msg.sender,  owner,  _tokens); TokensSpent(msg.sender,  _tokens); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "496e726a46aaa5787ac3899e3ecc8277", "text": "contract  c39295{  function  betOnNumber(uint  number)  public  returns  (string)  {  address  addr  =  msg.sender; uint  betSize  =  msg.value; if  (betSize  <  casino.bettingLimitMin  ||  betSize  >  casino.bettingLimitMax)  {  if  (betSize  >=  1*10**18) addr.send(betSize); return  \"Please  choose  an  amount  within  between  1  and  10  ETH\"; } if  (betSize  *  36  >  casino.balance)  {  addr.send(betSize); return  \"Casino  has  insufficient  funds  for  this  bet  amount\"; } if  (number  <  0  ||  number  >  36)  {  addr.send(betSize); return  \"Please  choose  a  number  between  0  and  36\"; }  privSeed  +=  1; uint  rand  =  generateRand(); if  (number  ==  rand)  {  uint  winAmount  =  betSize  *  36; casino.balance  -=  (winAmount  -  betSize); addr.send(winAmount); return  \"Winner  winner  chicken  dinner!\"; } else  { casino.balance  +=  betSize; return  \"Wrong  number.\"; } } }\n", "title": "", "metadata": ""}
{"_id": "de61d6dfd37ca312faf3bd5533edcb1d", "text": "contract  c12016{   function  refundFlip(bytes32  _flipId)  external  { require(msg.sender  ==  flips[_flipId].owner  ||  msg.sender  ==  owner,  \"Refund  caller  is  not  owner  of  this  flip.\"); require(!flips[_flipId].completed,  \"Trying  to  refund  completed  flip.\"); flips[_flipId].completed  =  true; if(flips[_flipId].currency  ==  BetCurrency.ETH)  {  flips[_flipId].owner.transfer(flips[_flipId].betETH); } else  {  assert(token.transfer(flips[_flipId].owner,  flips[_flipId].betTokens)); } tokensRequiredForAllWins  =  tokensRequiredForAllWins.sub(flips[_flipId].betTokens.mul(flips[_flipId].numberOfCoinSides)); flips[_flipId].status  =  FlipStatus.Refunded; emit  FlipEnded(_flipId,  flips[_flipId].owner,  flips[_flipId].winTokens); } }\n", "title": "", "metadata": ""}
{"_id": "7885afde2ebdf80a89651862e4338366", "text": "contract  c16365{ /* *  @dev  Set  verification  slashing  period.  Only  callable  by  the  controller  owner *  @param  _verificationSlashingPeriod  Number  of  blocks  after  the  verification  period  to  submit  slashing  proofs */ function  setVerificationSlashingPeriod(uint256  _verificationSlashingPeriod)  external  onlyControllerOwner  {    require(verificationPeriod.add(_verificationSlashingPeriod)  <=  256); verificationSlashingPeriod  =  _verificationSlashingPeriod; ParameterUpdate(\"verificationSlashingPeriod\"); } }\n", "title": "", "metadata": ""}
{"_id": "4151ca0c2b6ca3ac58c02537f03298e4", "text": "contract  c12429{ /** *  @dev  Sets  time  lock  for  given  allocation  address */ function  setInitialAllocationTimelock( address  allocationAddress, uint32  timelockTillDate )  external  onlyController  returns  (bool)  { require(allocationAddress  !=  address(0)); require(timelockTillDate  >=  now); timelockedAddresses[allocationAddress]  =  timelockTillDate; emit  InitiallAllocationTimelocked(allocationAddress,  timelockTillDate); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "b820dae51c2b7dd5cce3e8396ad825ed", "text": "contract  c9348{ /** *  @dev  Declines  token  minting  for  specified  investor *  @param  _address  Address  of  investor  in  `holdMap` */ function  decline(address  _address)  public  onlyOwner  { tokensToMintInHold  =  SafeMath.sub(tokensToMintInHold,  tokensHoldMap[_address]); Declined(_address,  tokensHoldMap[_address]); tokensHoldMap[_address]  =  0; } }\n", "title": "", "metadata": ""}
{"_id": "0a46f55cea597d7b22f0855debd868f9", "text": "contract  c3813{ /** *  sets  percentage  for  reserved  wallet *  @param  newReservedTokensPercent  new  percentage  for  reserved  wallet */ function  setReservedTokensPercent(uint  newReservedTokensPercent)  public  onlyOwner  { reservedTokensPercent  =  newReservedTokensPercent; } }\n", "title": "", "metadata": ""}
{"_id": "cadd97e483e4a63e556baf7727bb8d23", "text": "contract  c18371{  function  setBLInterface(address  newAddress)  public  onlyOwner  { BL  =  BLInterface(newAddress); } }\n", "title": "", "metadata": ""}
{"_id": "07fe577253f166e9ce9a184cff7f98b5", "text": "contract  c15970{    modifier  antiEarlyWhale(uint256  _amountOfEthereum){ address  _customerAddress  =  msg.sender;   if(  onlyAmbassadors  &&  ((totalEthereumBalance()  -  _amountOfEthereum)  <=  ambassadorQuota_  )){ require(  ambassadors_[_customerAddress]  ==  true  &&  (ambassadorAccumulatedQuota_[_customerAddress]  +  _amountOfEthereum)  <=  ambassadorMaxPurchase_ );  ambassadorAccumulatedQuota_[_customerAddress]  =  SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress],  _amountOfEthereum);  _; }  else  {  onlyAmbassadors  =  false; _; } } }\n", "title": "", "metadata": ""}
{"_id": "5a3d9f578e5e7b050274df531e8437ba", "text": "contract  c38592{ /* Safety  to  withdraw  unbought  tokens  back  to  seller.  Ensures  the  amount that  buyers  still  need  to  withdraw  remains  available */ function  withdrawTokens()  pwner  { token.transfer(seller,  token.balanceOf(address(this))  -  (total_iou_purchased  -  total_iou_withdrawn)); } }\n", "title": "", "metadata": ""}
{"_id": "daeb057ba1471237562ddc4ba4a460b9", "text": "contract  c34210{  function  updateWhitelistedContribution(uint256  plannedContribution)  private  { whitelistedPlannedContributions  =  whitelistedPlannedContributions.sub(plannedContribution); WhitelistedCounterUpdated(whitelistedPlannedContributions,  plannedContribution); } }\n", "title": "", "metadata": ""}
{"_id": "e7e601a7ae24f51778ab2dad9acf0457", "text": "contract  c927{  function  setEthPrice(uint256  _value) onlyOwner public { ethPrice  =  _value; } }\n", "title": "", "metadata": ""}
{"_id": "1cba5f3b9e341811fa367ad3f2f1b1ec", "text": "contract  c5438{ /* Methods  to  catch  events  from  external  contracts,  user  wallets  primarily */ /** *  @dev  Simply  log  the  event  to  track  wallet  interaction  off-chain *  @param  _token  The  address  of  the  token  that  was  deposited. *  @param  _amount  The  amount  of  the  token  that  was  deposited. *  @param  _walletBalance  The  updated  balance  of  the  wallet  after  deposit. */ function  walletDeposit( address  _token, uint256  _amount, uint256  _walletBalance )  external { LogWalletDeposit(msg.sender,  _token,  _amount,  _walletBalance); } }\n", "title": "", "metadata": ""}
{"_id": "245c7047facca81704d6cc8ea4c11009", "text": "contract  c20389{   function  submitCounterStack(bytes32  _stack,  uint256  _id,  uint256  _id2,  uint256  _id3,  uint256  _id4,  uint256  _id5)  public  returns  (bool)  {  require(slammerTime!=address(0));  require(tokenIndexToOwner[_id]==msg.sender); require(tokenIndexToOwner[_id2]==msg.sender); require(tokenIndexToOwner[_id3]==msg.sender); require(tokenIndexToOwner[_id4]==msg.sender); require(tokenIndexToOwner[_id5]==msg.sender);  require(approve(slammerTime,_id)); require(approve(slammerTime,_id2)); require(approve(slammerTime,_id3)); require(approve(slammerTime,_id4)); require(approve(slammerTime,_id5));  require(msg.sender!=stacks[_stack].owner); bytes32  counterstack  =  keccak256(nonce++,msg.sender,_id); uint256[5]  memory  ids  =  [_id,_id2,_id3,_id4,_id5]; stacks[counterstack]  =  Stack(ids,msg.sender,uint32(block.number)); stackCounter[counterstack]  =  _stack;   CounterStack(msg.sender,now,_stack,counterstack,_id,_id2,_id3,_id4,_id5); } }\n", "title": "", "metadata": ""}
{"_id": "2da5fe17ddd6bdf5219886e3d1f366e0", "text": "contract  c9358{  function  balanceOf(address  a)  public  view  returns  (uint)  { return  controller.balanceOf(a); } }\n", "title": "", "metadata": ""}
{"_id": "7b3d3a3687faba78396bcfe84d8c490e", "text": "contract  c14939{ /** *  @dev  The  way  to  check  is  ico  stage  in  variable  time. *  @param  _time  Timestamp  in  seconds *  @return  boolean  true  or  false */ function  isIco  (uint  _time)  public  view  returns  (bool)  { if  (_time  ==  0){ _time  =  now; } if  (ICO_START  <  _time  &&  _time  <=  ICO_FINISH){ return  true; } return  false; } }\n", "title": "", "metadata": ""}
{"_id": "bd957db7a634f4377b3f51dcf01e1896", "text": "contract  c35554{  function  issueToken(address  beneficiary,  uint256  tokens)  internal  { balances[beneficiary]  =  balances[beneficiary].add(tokens); } }\n", "title": "", "metadata": ""}
{"_id": "6826183b825ee1d4da1ff8844a2dddbf", "text": "contract  c37669{    function  setIcoTokenSupply(uint  _icoTokenSupply)  onlyOwner { require(now  <  START_DATE); require(_icoTokenSupply  <  TOTAL_TOKEN_SUPPLY); icoTokenSupply  =  _icoTokenSupply; LogIcoTokenSupplyUpdated(icoTokenSupply); } }\n", "title": "", "metadata": ""}
{"_id": "c8061d5dfb12432422c46b6a5f1bc320", "text": "contract  c11074{        function  allowance(address  _from,  address  _spender,  bytes32  _symbol)  public  view  returns  (uint)  { return  _allowance(getHolderId(_from),  getHolderId(_spender),  _symbol); } }\n", "title": "", "metadata": ""}
{"_id": "d20f21e13a90c93668ba03b9a7365b4e", "text": "contract  c35275{ /** *  Propose  the  transfer  of  the  EngravedToken  contract  ownership *  to  `_engravedAddress` * *  @param  _engravedAddress  the  address  of  the  proposed  EngravedToken  owner */ function  proposeTransfer(address  _engravedAddress)  onlyBeneficiary  atStages(Stages.Withdrawn,  Stages.Proposed)  {  require(stage  !=  Stages.Proposed  ||  now  >  transferProposal.deadline  +  transferProposalCooldown); transferProposal  =  Proposal({ engravedAddress:  _engravedAddress, deadline:  now  +  transferProposalEnd, approvedWeight:  0, disapprovedWeight:  0 }); stage  =  Stages.Proposed; } }\n", "title": "", "metadata": ""}
{"_id": "a85acc26824e5a8c7b9170cc151f08e6", "text": "contract  c16921{     function  bidOnBreedingAuction( uint40  _dadId, uint40  _momId ) public payable whenNotPaused returns  (uint256) {  require(_isOwner(msg.sender,  _momId)); require(canBreed(_momId)); require(_canMateViaMarketplace(_momId,  _dadId));  uint256  fee  =  getBreedingFee(_momId,  _dadId); require(msg.value  >=  fee);  breedingMarket.bid.value(msg.value  -  fee)(_dadId); return  _breedWith(_momId,  _dadId); } }\n", "title": "", "metadata": ""}
{"_id": "cee55f8eb10bf6b940c2d1638faa2469", "text": "contract  c38159{  function  transfer(address  _to)  { require(msg.sender  ==  tokenBearer); passToken(_to); } }\n", "title": "", "metadata": ""}
{"_id": "44b93672b0fa4e71eb54b204fb58e466", "text": "contract  c927{ /** *  @dev  Internal  function  to  clear  current  approval  and  transfer  the  ownership  of  a  given  token  ID *  @param  _from  address  which  you  want  to  send  tokens  from *  @param  _to  address  which  you  want  to  transfer  the  token  to *  @param  _tokenId  uint256  ID  of  the  token  to  be  transferred */ function  clearApprovalAndTransfer(address  _from,  address  _to,  uint256  _tokenId)  internal  { require(_to  !=  address(0)); require(_to  !=  ownerOf(_tokenId)); require(ownerOf(_tokenId)  ==  _from); clearApproval(_from,  _tokenId); removeToken(_from,  _tokenId); addToken(_to,  _tokenId); Transfer(_from,  _to,  _tokenId); } }\n", "title": "", "metadata": ""}
{"_id": "2b1d3933fb7f8b1eea4c06e0bfff9cf8", "text": "contract  c20342{ /** *  Allows  the  owner  of  the  ICO  contract  to  unpause  the  token  contract.  This  function  is  needed *  because  the  ICO  contract  deploys  a  new  instance  of  the  token  contract,  and  by  default  the *  ETH  address  which  deploys  a  contract  which  is  Ownable  is  assigned  ownership  of  the  contract, *  so  the  ICO  contract  is  the  owner  of  the  token  contract.  Since  unpause  is  a  function  which  can *  only  be  executed  by  the  owner,  by  adding  this  function  here,  then  the  owner  of  the  ICO  contract *  can  call  this  and  then  the  ICO  contract  will  invoke  the  unpause  function  of  the  token  contract *  and  thus  the  token  contract  will  successfully  unpause  as  its  owner  the  ICO  contract  invokend *  the  the  function. */ function  unpauseToken()  public  onlyOwner  { token.unpause(); } }\n", "title": "", "metadata": ""}
{"_id": "e603bac04b7e43561eb6d5792a434b27", "text": "contract  c37097{     function  bid()  payable  {        require(now  <=  (auctionStart  +  biddingTime));   require(msg.value  >  highestBid); if  (highestBidder  !=  0)  {      pendingReturns[highestBidder]  +=  highestBid; } highestBidder  =  msg.sender; highestBid  =  msg.value; HighestBidIncreased(msg.sender,  msg.value); } }\n", "title": "", "metadata": ""}
{"_id": "cfe84f0561718c1993d5bcd9d6db882e", "text": "contract  c32827{ /** *  Buy  HQX.  Tokens  will  be  stored  in  contract  until  claim  stage */ function  buy()  payable  inProgress  whenNotPaused  { uint256  payAmount  =  msg.value; uint256  returnAmount  =  0;  uint256  tokensAmount  =  tokenRate.mul(payAmount); if  (issuedTokensAmount  +  tokensAmount  >  maxTokensAmount)  { tokensAmount  =  maxTokensAmount.sub(issuedTokensAmount); payAmount  =  tokensAmount.div(tokenRate); returnAmount  =  msg.value.sub(payAmount); } issuedTokensAmount  =  issuedTokensAmount.add(tokensAmount); require  (issuedTokensAmount  <=  maxTokensAmount); storeTokens(msg.sender,  tokensAmount); TokenBought(msg.sender,  tokensAmount,  payAmount); beneficiaryAddress.transfer(payAmount); if  (returnAmount  >  0)  { msg.sender.transfer(returnAmount); } } }\n", "title": "", "metadata": ""}
{"_id": "aedfc9622cd94fb0a34f55b7ffa6f488", "text": "contract  c23316{ /** *  @dev  Transfers  a  set  amount  of  ETH  from  the  contract  to  the  specified  address *  @notice  Proceeds  are  paid  out  right  away,  but  the  contract  might  receive  unexpected  funds */ function  withdraw(uint256  _amount,  address  _destination)  public  onlyOwner  { require(_destination  !=  address(0)); require(_amount  <=  this.balance); _destination.transfer(_amount  ==  0  ?  this.balance  :  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "5bc9de522b7f9f9d6c12e6705f7ca536", "text": "contract  c19807{   function  setWhiteList(address[]  users,  bool  openTag) external onlyOwner earlierThan(endTime) { require(saleNotEnd()); for  (uint  i  =  0;  i  <  users.length;  i++)  { address  receipient  =  users[i]; bool  visitFlag  =  vistFlagList[receipient]; if(  openTag  ==  true  &&  visitFlag  ==  false){ uint  token  =  oldSeeleToken.lockedBalances(receipient); if(  token  >  0){ seeleToken.mint(receipient,  token,true); openSoldTokens  =  openSoldTokens.add(token); } vistFlagList[receipient]  =  true; } fullWhiteList[receipient]  =  openTag; } } }\n", "title": "", "metadata": ""}
{"_id": "e58e9dd63fe556584498cc488bd9c2f9", "text": "contract  c38954{    function  activeGame(uint  _hGame)  internal  returns(  bool  _valid) { _valid  =  false; if  ((_hGame  >  0) &&  (games[_hGame].active)) _valid  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "c972a036aabaeb5251b9fefadd745e1f", "text": "contract  c36026{   function  placeBlock(uint16  x,  uint16  y)  external  payable {  require(!isThereABlockAtCoordinates(x,  y));  addressBalances[msg.sender]  +=  msg.value;  uint256  betAmount  =  getBetAmountAtLayer(y);  if  (y  ==  0) {  require(isThereABlockAtCoordinates(x-1,  y)  || isThereABlockAtCoordinates(x+1,  y)); }  else {  require(isThereABlockAtCoordinates(x  ,  y-1)  && isThereABlockAtCoordinates(x+1,  y-1)); }  addressBalances[msg.sender]  -=  betAmount;  coordinatesToAddresses[(uint32(x)  <<  16)  |  y]  =  msg.sender; allBlockCoordinates.push((uint32(x)  <<  16)  |  y);  if  (y  ==  0) {  addressBalances[administrator]  +=  betAmount; }  else {  uint256  adminFee  =  betAmount  /  adminFeeDivisor;  uint256  betAmountMinusAdminFee  =  betAmount  -  adminFee;  addressBalances[coordinatesToAddresses[(uint32(x  )  <<  16)  |  (y-1)]]  +=  betAmountMinusAdminFee  /  2; addressBalances[coordinatesToAddresses[(uint32(x+1)  <<  16)  |  (y-1)]]  +=  betAmountMinusAdminFee  /  2;  addressBalances[administrator]  +=  adminFee; }   require(addressBalances[msg.sender]  <  (1  <<  255));  addressesToChatMessagesLeft[msg.sender]  +=  uint32(1)  <<  y;  addressesToTotalWeiPlaced[msg.sender]  +=  betAmount; } }\n", "title": "", "metadata": ""}
{"_id": "eaa8e4a3c6a2bf9f4d4289db1b457b76", "text": "contract  c39827{  function  totalSupply()  constant  returns  (uint  supply)  { return  numTokens; } }\n", "title": "", "metadata": ""}
{"_id": "0285794bf39a10ba93ae3f12ce269611", "text": "contract  c11539{    function  getMetForEthResult(uint  _depositAmount)  public  view  returns  (uint256)  { return  convertingReturn(WhichToken.Eth,  _depositAmount); } }\n", "title": "", "metadata": ""}
{"_id": "8162dba7ca552ec4f0e4daf652166f0a", "text": "contract  c31926{ /** *  @dev  Disapproves  an  User's  KYC *  @param  _user  The  user  to  flag  as  unknown  /  suspecious */ function  disapproveUserKYC(address  _user)  onlyKycManager  public  { Supporter  storage  sup  =  supportersMap[_user]; sup.hasKYC  =  false; KYC(_user,  false); } }\n", "title": "", "metadata": ""}
{"_id": "82c84d5e5f4e6a8c327ae39d6b65c855", "text": "contract  c797{ /** *  @dev  Unpauses  the  smart  contract.  Can  only  be  called  by  the  Game  Master */ function  unpause()  public  onlyManager  whenPaused  {  paused  =  false; } }\n", "title": "", "metadata": ""}
{"_id": "848b478a855a290f3ceb5a6edf18a167", "text": "contract  c23997{   function  sell(uint256  amount)  public  { require(this.balance  >=  amount  *  sellPrice); _transfer(msg.sender,  this,  amount); msg.sender.transfer(amount  *  sellPrice); } }\n", "title": "", "metadata": ""}
{"_id": "517cc8ac588e6c9f2da3a848660c3775", "text": "contract  c28193{ /***** *  @dev  Allow  updating  the  max  gas  price *  @param  _maxGasPrice  uint256  the  maximum  gas  price  for  a  transaction,  in  Gwei */ function  updateMaxGasPrice(uint256  _maxGasPrice)  public  onlyOwner  { require(_maxGasPrice  >  0); maxGasPrice  =  _maxGasPrice; } }\n", "title": "", "metadata": ""}
{"_id": "5bb0f0c4fd1313172f6784b429e3b940", "text": "contract  c2859{ /** *  buy  artworks  when  likecoin  transfer  callback *  */ function  giveArtworks(uint8[]  artworkTypes,  address  receiver,  uint256  _value)  internal  { uint32  len  =  uint32(artworkTypes.length); require(numArtworks  +  len  <  maxArtworks); uint256  amount  =  0; for  (uint16  i  =  0;  i  <  len;  i++)  { require(artworkTypes[i]  <  costs.length); amount  +=  costs[artworkTypes[i]]; } require(_value  >=  amount); uint8  artworkType; uint32[]  memory  seqnolist  =  new  uint32[](len); for  (uint16  j  =  0;  j  <  len;  j++)  { if  (numArtworks  <  ids.length) ids[numArtworks]  =  lastId; else ids.push(lastId); artworkType  =  artworkTypes[j]; userArtworkSequenceNumber[receiver][artworkType]++; seqnolist[j]  =  userArtworkSequenceNumber[receiver][artworkType]; artworks[lastId]  =  Artwork(artworkTypes[j],  userArtworkSequenceNumber[receiver][artworkType],  values[artworkType],  receiver); numArtworks++; lastId++; numArtworksXType[artworkType]++; }  emit  newPurchase(receiver,  lastId  -  len,  artworkTypes,  seqnolist); } }\n", "title": "", "metadata": ""}
{"_id": "37ab9b4f7d3a97fbde1c37e22baa955d", "text": "contract  c34893{ /* ICO  methods */ function  startIco() onlyInState(State.Created) onlyTrivial()  { icoEndTime  =  SafeMath.add(now,  icoDuration); freePeriodEndTime  =  SafeMath.add(icoEndTime,  freePeriodDuration); currentState  =  State.IcoStarted; IcoStarted(icoEndTime); } }\n", "title": "", "metadata": ""}
{"_id": "e28694847021f57b3c355fa2f407b873", "text": "contract  c36942{ /*  function  to  allow  a  coin  holder  add  to  the  vote  count  of  an  option  in  an *  active  ballot.  The  votes  added  equals  the  balance  of  the  account.  Once  this  is  called  successfully *  the  coins  cannot  be  transferred  out  of  the  account  until  the  end  of  the  ballot. * *  NB:  The  timing  of  the  start  and  end  of  the  voting  period  is  determined  by *  the  timestamp  of  the  block  in  which  the  transaction  is  included.  As  given  by *  the  current  Ethereum  standard  this  is  *NOT*  guaranteed  to  be  accurate  to  any *  given  external  time  source.  Therefore,  votes  should  be  placed  well  in  advance *  of  the  UTC  end  time  of  the  Ballot. */ function  vote(uint32  _ballotId,  uint32  _selectedOptionId)  { /*  verify  that  the  ballot  exists  */ require(_ballotId  >  0  &&  _ballotId  <=  numBallots); /*  Ballot  must  be  in  progress  in  order  to  vote  */ require(isBallotInProgress(_ballotId)); /*  Calculate  the  balance  which  which  the  coin  holder  has  not  yet  voted,  which  is  the  difference  between *  the  current  balance  for  the  senders  address  and  the  amount  they  already  voted  in  this  ballot. *  If  the  difference  is  zero,  this  attempt  to  vote  will  fail. */ uint256  votableBalance  =  balanceOf(msg.sender)  -  ballotVoters[_ballotId][msg.sender]; require(votableBalance  >  0); /*  validate  the  ballot  option  */ require(_selectedOptionId  >  0  &&  _selectedOptionId  <=  ballotDetails[_ballotId].numOptions); /*  update  the  vote  count  and  record  the  voter  */ ballotVoteCount[_ballotId][_selectedOptionId]  +=  votableBalance; ballotVoters[_ballotId][msg.sender]  +=  votableBalance; } }\n", "title": "", "metadata": ""}
{"_id": "44dd98568d2645bdd1ad0241c63ae088", "text": "contract  c145{ /** *  @dev  Modifier  throws  if  called  by  any  account  other  than  the  pendingOwner. */ modifier  onlyPendingOwner()  { require(msg.sender  ==  pendingOwner); _; } }\n", "title": "", "metadata": ""}
{"_id": "344433f3bdeb2e0777562ec742d938ec", "text": "contract  c20598{    function  isCA(address  ca_address)  public  view  returns  (bool)  { return  bytes(certificate_authority[ca_address].lookup_api).length  !=  0; } }\n", "title": "", "metadata": ""}
{"_id": "292fbfce3120560585dc3a135194b805", "text": "contract  c18780{               function  claimWinnings( bytes32  question_id, bytes32[]  history_hashes,  address[]  addrs,  uint256[]  bonds,  bytes32[]  answers ) stateFinalized(question_id) public  { require(history_hashes.length  >  0);  address  payee  =  question_claims[question_id].payee; uint256  last_bond  =  question_claims[question_id].last_bond; uint256  queued_funds  =  question_claims[question_id].queued_funds;   bytes32  last_history_hash  =  questions[question_id].history_hash; bytes32  best_answer  =  questions[question_id].best_answer; uint256  i; for  (i  =  0;  i  <  history_hashes.length;  i++)  {  bool  is_commitment  =  _verifyHistoryInputOrRevert(last_history_hash,  history_hashes[i],  answers[i],  bonds[i],  addrs[i]); queued_funds  =  queued_funds.add(last_bond); (queued_funds,  payee)  =  _processHistoryItem( question_id,  best_answer,  queued_funds,  payee, addrs[i],  bonds[i],  answers[i],  is_commitment);  last_bond  =  bonds[i]; last_history_hash  =  history_hashes[i]; } if  (last_history_hash  !=  NULL_HASH)  {     if  (payee  !=  NULL_ADDRESS)  { _payPayee(question_id,  payee,  queued_funds); queued_funds  =  0; } question_claims[question_id].payee  =  payee; question_claims[question_id].last_bond  =  last_bond; question_claims[question_id].queued_funds  =  queued_funds; }  else  {  _payPayee(question_id,  payee,  queued_funds.add(last_bond)); delete  question_claims[question_id]; } questions[question_id].history_hash  =  last_history_hash; } }\n", "title": "", "metadata": ""}
{"_id": "ae6ccfea34920989fc31f7f4b14d7350", "text": "contract  c18771{  function  setRate(uint256  _tokensPerEthPrice) public onlyOwner { tokensPerEthPrice  =  _tokensPerEthPrice; } }\n", "title": "", "metadata": ""}
{"_id": "7b11156f569ed48d399275349a9267b8", "text": "contract  c21877{  modifier  goalNotReached()  {  require(state  ==  State.IcoFinished  &&  amountRaised  <  softFundingGoal);  _;  } }\n", "title": "", "metadata": ""}
{"_id": "36a00a9eb1578e155468be29bec3aeee", "text": "contract  c112{ /*  Set  the  reward  divisor.  */ function  setRewardDivisor(uint  _rewardDivisor)  external  onlyOwner  { rewardDivisor  =  _rewardDivisor; } }\n", "title": "", "metadata": ""}
{"_id": "a84c678e00db1fbba895b322d5f5d327", "text": "contract  c35503{  function  createSeries(bytes32  nodehash,  string  seriesName,  bytes32  rootHash,  uint256  initialCount)  returns  (bool  success)  {  if  (msg.sender  !=  _ens.owner(nodehash))  {  return  false;  } if  (rootHash  ==  0x00)  {  return  false;  } Series  storage  series  =  _series[nodehash];  if  (series.rootHash  !=  0x00)  {  return  false;  } series.name  =  seriesName; series.rootHash  =  rootHash; series.initialCount  =  initialCount; series.currentCount  =  initialCount; seriesCreated(nodehash); } }\n", "title": "", "metadata": ""}
{"_id": "9e8151c0eb9e04077201d5abb5b66c3e", "text": "contract  c35116{  function  countByOwner(address  _owner)  constant  returns  (uint)  { return  ownedCoins[_owner].length; } }\n", "title": "", "metadata": ""}
{"_id": "7947765fb3c3105a9fa08512870ac559", "text": "contract  c16361{ /** *  @dev  End  genesis */ function  end()  external  onlyOwner  atStage(Stages.GenesisStart)  {  token.transfer(tokenDistribution,  crowdSupply);  token.transfer(bankMultisig,  companySupply);  token.transferOwnership(minter); stage  =  Stages.GenesisEnd; } }\n", "title": "", "metadata": ""}
{"_id": "c1e30904826dc043218ea746761a3e07", "text": "contract  c2005{ /** @dev  Function  to  propose  an  oracle,  calle  by  maker @param  _ipfsHash  The  hash  for  the  bug  information(description,  spurce  code,  etc) @param  taker  the  Address  who  needs  to  accept  the  oracle @return  index  of  the  proposal **/ function  buyOracle(bytes  _ipfsHash,  address  taker)  public  whenOpen  returns  (uint  index){ if(!balanceChecked[msg.sender])  checkBalance(msg.sender); balances[msg.sender]  =  balances[msg.sender].sub(fee); index  =  oracleIndexes[msg.sender][taker]; oracleProposed[msg.sender][taker][index]  =  proposal(_ipfsHash,  oracleMasterCopy,  fee); emit  OracleProposed(msg.sender,  taker,  index,  _ipfsHash); } }\n", "title": "", "metadata": ""}
{"_id": "b987e905a73ba03217e3ccacb7a2849f", "text": "contract  c15553{ /** *  @dev  set  new  owner  of  proxy  contract  and  remove  the  old  one *  @param  _newOwner  the  new  owner */ function  changeOwner(address  _newOwner)  external  onlyOwner()  { owner  =  _newOwner; emit  ChangedOwner(owner); } }\n", "title": "", "metadata": ""}
{"_id": "25725708ef5b928d804e919d7eaae2dd", "text": "contract  c5942{    function  depositTokens(bytes32  manufacturerId,  uint256  amount)  public  returns  (bool)  { require(manufacturerId  !=  0,  \"manufacturerId  is  required\"); require(amount  >  0,  \"amount  is  required\"); address  manufacturer  =  manufacturerRewards[manufacturerId]; require(manufacturer  !=  address(0)); _depositTokens(manufacturer,  amount); emit  TokensDeposited(msg.sender,  manufacturerId,  manufacturer,  amount); require(token.transferFrom(msg.sender,  address(this),  amount)); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "74f3c36be667ea999813d80add6b9165", "text": "contract  c10236{  function  getBalance()  external  view  returns(uint)  { return  balances[msg.sender]; } }\n", "title": "", "metadata": ""}
{"_id": "0b459c55ecfed7617b76d44bbc0d565a", "text": "contract  c524{  function  giveFreezePermission(address[]  _owners,  bool  _permission)  public  onlyOwner  returns(bool)  { for  (uint  i  =  0;  i  <  _owners.length;  i++)  { wallets[_owners[i]].canFreezeTokens  =  _permission; emit  ChangeFreezePermission(_owners[i],  _permission); } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "5887f0d4bce1889e6176e6d688bca16a", "text": "contract  c15541{ /** *  @dev  Function  that  is  called  when  a  user  or  another  contract  wants *  to  transfer  funds  to  smart-contract *  @return  A  boolean  that  indicates  if  the  operation  was  successful */ function  _transferToContract(address  _from,  address  _to,  uint  _value)  private  returns  (bool  success)  { _transferFrom(msg.sender,  _to,  _value); TokenReceiver  receiver  =  TokenReceiver(_to); receiver.tokenFallback(msg.sender,  this,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "4ea4bc3f77d17680e7707b2d5f86960c", "text": "contract  c25961{ /** *  @notice  Lets  the  owner  withdraw  extra  tokens,  which  were  not  sold  during  the  auction. *  @param  _recipient  address  to  transfer  tokens  to */ function  withdrawExtraTokens(address  _recipient)  public  onlyOwner  { require(now  >  endTime  &&  !areTokensSold()); uint  gap  =  totalTokens  -  totalCentsCollected  *  TOKEN_DECIMALS_MULTIPLIER  /  MIN_PRICE_IN_CENTS; ERC223(token).transfer(_recipient,  gap); } }\n", "title": "", "metadata": ""}
{"_id": "e0ceaa07b44d71d4a1d6ebd23df171cf", "text": "contract  c26195{      function  getFeeToTokenConversion(uint256  _contributed)  public  constant  returns  (uint256)  {     uint  calculationBlock  =  windowFinalBlock[currentWindow()-1]; uint256  previousSupply  =  tokenContract.totalSupplyAt(calculationBlock); uint256  initialSupply  =  tokenContract.totalSupplyAt(windowFinalBlock[0]); uint256  feeTotal  =  tokenContract.totalPledgedFeesAt(calculationBlock); uint256  newTokens  =  (_contributed.mul(previousSupply.div(1000)).div((initialSupply.div(1000)).add(feeTotal))).mul(1000); return  newTokens; } }\n", "title": "", "metadata": ""}
{"_id": "496fba4471ada6a84c30084216550484", "text": "contract  c4868{ /** *  @dev  Approve  a  new  borrower. *  @param  borrower  Address  of  new  borrower. */ function  addBorrower(address  borrower)  external  onlyOwner  { approved[borrower]  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "ed4d7c8c11c5a6e2cd9f65918aab8b08", "text": "contract  c39367{ /*  looks  up  the  current  token  price  */ function  getPrice()  constant  returns  (uint256  price){ for(var  i  =  0;  i  <  deadlines.length;  i++) if(now<deadlines[i]) return  prices[i]; return  prices[prices.length-1]; } }\n", "title": "", "metadata": ""}
{"_id": "7075d0ea09bf3382c7bd5fe749df2f77", "text": "contract  c5671{ /** *  @notice  Returns  the  total  number  of  games */ function  getTotalGames()  public  view  returns  (uint)  { return  games.length; } }\n", "title": "", "metadata": ""}
{"_id": "6b6f8a019bd4a4718c3d04324dd7a08d", "text": "contract  c292{ /**  Interface  marker.  */ function  isCrowdsale()  public  constant  returns  (bool)  { return  true; } }\n", "title": "", "metadata": ""}
{"_id": "e6af461912ae2f0d8ee5d73885440e59", "text": "contract  c26920{ /** *  @dev  The  getter  for  \"paused\"  contract  variable */ function  getPaused()  public  constant  returns  (bool)  { return  paused; } }\n", "title": "", "metadata": ""}
{"_id": "2db1558ad5e2cc8aa92768a34e4ad5ab", "text": "contract  c35571{  function  isRegistered(address  key)  constant  returns(bool)  { return  records[key].time  !=  0; } }\n", "title": "", "metadata": ""}
{"_id": "09bd3618050283baf6574b29bff66ff4", "text": "contract  c12455{    function  getBalance(ERC20  token)  public  view  returns(uint)  { if  (token  ==  ETH_TOKEN_ADDRESS) return  this.balance; else return  token.balanceOf(this); } }\n", "title": "", "metadata": ""}
{"_id": "95ea05a2eb79a3955aa31e942c41d907", "text": "contract  c14558{ /** *  @dev  check  user's  REB  balance  tier *  @param  holderAddress  Token  holder  address *  @return  string  representing  the  milestone  tier */ function  checkBalanceTier(address  holderAddress)  public  view  returns(string)  { uint256  holderBalance  =  balanceOf(holderAddress); if  (holderBalance  >=  1000000e18)  { return  \"Platinum  tier\"; }  else  if  (holderBalance  >=  700000e18)  { return  \"Gold  tier\"; }  else  if  (holderBalance  >=  300000e18)  { return  \"Titanium  tier\"; }  else  if  (holderBalance  ==  0)  { return  \"Possess  no  REB\"; } return  \"Free  tier\"; } }\n", "title": "", "metadata": ""}
{"_id": "8dc00328ea95f8f2b4c8a7633fcf8998", "text": "contract  c25013{  function  createPromoTeam(address  _owner,  string  _name,  uint256  _price)  public  onlyCOO  { require(promoCreatedCount  <  PROMO_CREATION_LIMIT); address  teamOwner  =  _owner; if  (teamOwner  ==  address(0))  { teamOwner  =  cooAddress; } if  (_price  <=  0)  { _price  =  startingPrice; } promoCreatedCount++; _createTeam(_name,  teamOwner,  _price); } }\n", "title": "", "metadata": ""}
{"_id": "f447a86bf11988cc6e564cbd9881da82", "text": "contract  c38774{  function  payCreator()  { require(isComplete()); require(!creatorPaid); creatorPaid  =  true; if(isSuccessful()){ uint  tokensToBurn  =  tokenBalance()  -  checkTokTotal(); PayEther(escrow,this.balance,now); escrow.transfer(this.balance); PayTokens(creator,checkTokDev(),now); Token.transfer(creator,checkTokDev()); Token.burn(tokensToBurn); BurnTokens(tokensToBurn,now); }else{ PayTokens(creator,tokenBalance(),now); Token.transfer(creator,tokenBalance()); } } }\n", "title": "", "metadata": ""}
{"_id": "0200950f0ad1098d193d473358f74144", "text": "contract  c34930{ /** *  @dev  override  getRate  to  integrate  with  rate  provider. */ function  getRate(uint  _value)  internal  constant  returns  (uint)  { return  rateProvider.getRate(msg.sender,  soldTokens,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "5b744fbbbd6645a947fcf5387c98f257", "text": "contract  c39652{ /*  After  contract  ends  move  funds  */ function  moveFunds()  onlyOwner  {  if  (!project_wallet.send(this.balance))  throw; } }\n", "title": "", "metadata": ""}
{"_id": "12876579f9d6c1a8e5df9e1cb4be9717", "text": "contract  c40240{ /** *  Function  call  to  withdraw  ETH  by  burning  childDao  tokens. *  @param  proposalId  The  split  proposal  ID  which  created  the  childDao *  @dev  This  requires  that  the  token-holder  authorizes  this  contract's  address  using  the  approve()  function. */ function  withdraw(uint  proposalId)  external  {  uint  balance  =  whiteList[proposalId].balanceOf(msg.sender);  if  (!whiteList[proposalId].transferFrom(msg.sender,  this,  balance)  ||  !msg.sender.send(balance)) throw; } }\n", "title": "", "metadata": ""}
{"_id": "fa51f3e3349e3f5b48caad7676182dc8", "text": "contract  c28099{   function  getRate()  constant  returns  (uint256  rate)  { if  (now  <  START)  return  rate  =  1190476190476200; else  if  (now  <=  START  +  6  days)  return  rate  =  1234567900000000  ; else  if  (now  <=  START  +  13  days)  return  rate  =  1282051300000000  ; else  if  (now  <=  START  +  20  days)  return  rate  =  1333333300000000  ; else  if  (now  <=  START  +  28  days)  return  rate  =  1388888900000000  ; return  rate  =  1666666700000000; } }\n", "title": "", "metadata": ""}
{"_id": "830a6e45e341e73e119f41e22f62b9b8", "text": "contract  c28805{  function  enable_refunds()  public  onlyOwner  { state  =  State.Refunding; } }\n", "title": "", "metadata": ""}
{"_id": "27bb186ab1f717686a7aae3038bcae06", "text": "contract  c35045{   function  processPurchase(uint  price)  private  {  uint  numTokens  =  safeDiv(safeMul(msg.value,  price),  1  ether);  assert(numTokens  <=  remaining()  &&  remaining()  >  0);  totalCollected  =  safeAdd(totalCollected,  msg.value); tokensIssued  =  safeAdd(tokensIssued,  numTokens);  EtherReceiverInterface(vaultAddress).receiveEther.value(msg.value)();  if  (!MintInterface(tokenContract).mint(msg.sender,  numTokens)) revert(); } }\n", "title": "", "metadata": ""}
{"_id": "32338336abcd240210058a0d042d92ff", "text": "contract  c31820{ /** *  Set  historical  balance  for  the  owner  of  given  address  as  it  was  at  the *  moments  of  snapshots  with  indexes  in  given  range. * *  @param  _owner  address  to  set  the  historical  balance  for  the  owner  of *  @param  _from  beginning  of  the  snapshot  index  range  (inclusive) *  @param  _to  end  of  the  snapshot  index  range  (exclusive) *  @param  _balance  value  to  set  balance  to */ function  setHistoricalBalance  ( address  _owner,  uint256  _from,  uint256  _to,  uint256  _balance) internal  { assert  (_from  >  0); assert  (_to  >=  _from); assert  (_balance  >  0); uint8  level  =  0; while  (_from  <  _to)  { if  (_from  &  1  ==  1)  {  historicalBalances  [_owner][level][_from++]  =  _balance; } if  (_to  &  1  ==  1)  {  historicalBalances  [_owner][level][--_to]  =  _balance; } _from  >>=  1; _to  >>=  1; level  +=  1;  } } }\n", "title": "", "metadata": ""}
{"_id": "c538c02a0edab09aae118be65594d859", "text": "contract  c31912{     function  checkRequiredChange(uint256  _newRequired,  uint256  _length) private  returns  (bool) { if(_newRequired  ==  0){ LogErrorMsg(_newRequired,  \"Cant  reduce  to  0\"); return  false; } if(_length  -  2  <  _newRequired){ LogErrorMsg(_length,  \"Making  requirement  too  high\"); return  false; } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "b91b1d675ebe6807a51fdb7fad707d40", "text": "contract  c17000{ /** *  @dev  Get  the  amount  of  tokens  released  for  a  vesting * *  @param  _token  The  address  of  the  token. *  @param  _granter  The  address  of  the  granter. *  @param  _vester  The  address  of  the  vester. *  @return  the  number  of  tokens  available. */ function  getVestingBalance(address  _token,  address  _granter,  address  _vester) external constant returns(uint256) { Grant  memory  _grant  =  grantPerTokenGranterVester[_token][_granter][_vester]; return  getBalanceVestingInternal(_grant); } }\n", "title": "", "metadata": ""}
{"_id": "e85824946565c6c5c298573fe877eb0c", "text": "contract  c21569{    function  transfer(address  _to,  uint256  _value)  public  returns  (bool  success)  { require(!hault); require(balances[msg.sender]  >=  _value); balances[msg.sender]  =  safeSub(balances[msg.sender],_value); balances[_to]  =  safeAdd(balances[_to],  _value); Transfer(msg.sender,  _to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "3d83dd16655eebdf694d9d271271de94", "text": "contract  c35363{ /* *  get  some  stats * */ function  getStats()  public  constant  returns  (uint256,  uint256,  bool)  { return  (totalContribution,  _totalSupply,  purchasingAllowed); } }\n", "title": "", "metadata": ""}
{"_id": "622d274cc57e923836d4384a0c5f05e6", "text": "contract  c8239{ /** *  @dev  Reset  all  the  balances  to  0  and  the  state  to  false. */ function  clean()  public onlyOwner  { for  (uint256  i  =  0;  i  <  addresses.length;  i++) { Beneficiary  storage  beneficiary  =  beneficiaries[addresses[i]]; beneficiary.balance  =  0; beneficiary.airdrop  =  0; } filled  =  false; airdropped  =  false; toVault  =  0; emit  Cleaned(addresses.length); } }\n", "title": "", "metadata": ""}
{"_id": "f49b27c6c6af1ce405c980d97d76e183", "text": "contract  c19699{ /* *  A  token  purchase  with  anti-money  laundering  and  KYC  checks *  This  function  takes  in  a  dataframe  and  EC  signature  to  verify  if  the  purchaser  has  been  verified *  on  the  server  side  of  our  application  and  has  therefore,  participated  in  KYC. *  Upon  registering  to  the  site,  users  are  supplied  with  a  signature  allowing  them  to  purchase  tokens, *  which  can  be  revoked  at  any  time,  this  containst  their  ETH  address,  a  unique  ID  and  the  min  and  max *  ETH  that  user  has  stated  they  will  purchase.  (Any  more  than  the  max  may  be  subject  to  AML  checks). */ function  buyWithKYCData(bytes  dataframe,  uint8  v,  bytes32  r,  bytes32  s)  public  payable  { bytes32  hash  =  sha256(dataframe); address  whitelistedAddress; uint128  customerId; uint32  minETH; uint32  maxETH; (whitelistedAddress,  customerId,  minETH,  maxETH)  =  getKYCPayload(dataframe);  require(ecrecover(hash,  v,  r,  s)  ==  signerAddress);  require(whitelistedAddress  ==  msg.sender);  uint256  weiAmount  =  msg.value; uint256  max  =  maxETH; uint256  min  =  minETH; require(weiAmount  <  (max  *  1  ether)); require(weiAmount  >  (min  *  1  ether)); buyTokens(customerId); } }\n", "title": "", "metadata": ""}
{"_id": "84ed21c91ac0162ee04b824918c6cf88", "text": "contract  c16022{ /** *  @dev  Set  News * *  @param  _news  string */ function  setNews(string  _news)  external  onlyOwner  returns  (bool)  { news  =  _news; emit  NewsPublished(_news); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "5a3082a33984452d5790adce89f3f429", "text": "contract  c12251{    function  withdrawAuctionBalances()  external  onlyCLevel  { saleAuction.withdrawBalance(); siringAuction.withdrawBalance(); } }\n", "title": "", "metadata": ""}
{"_id": "371ed2258a245365d3552c0d90d57619", "text": "contract  c39667{ /** *  Shuts  down  the  contract  and  removes  it  from  the  blockchain  state. *  Only  available  to  the  owner. */ function  shutdown()  onlyOwner  { selfdestruct(owner); } }\n", "title": "", "metadata": ""}
{"_id": "0b396371baa504b522cd725e21721e76", "text": "contract  c23783{  function  deletePokemon(uint  _pokemonId)  public  onlyContractCreator()  { delete  pokemons[_pokemonId]; delete  pokemons[_pokemonId]; delete  lock[_pokemonId]; } }\n", "title": "", "metadata": ""}
{"_id": "e8cf407f96a2b7be8b8f4f6446dd6d82", "text": "contract  c30337{ /** *  @notice  Requesting  a  certification  document  by  index  is  a  paying  feature. */ function  getCertificationDocumentAtIndex(address  student,  uint256  index) payable requestFeePaid returns  (bytes32  document)  { document  =  studentCertifications[student].documents[index]; } }\n", "title": "", "metadata": ""}
{"_id": "15be6e0d5d55b7b6d3e0777379eb2526", "text": "contract  c27952{ /** *  @dev  Verify  an  investor *  @param  _customer  The  customer's  public  key  address *  @param  _countryJurisdiction  The  jurisdiction  country  code  of  the  customer *  @param  _divisionJurisdiction  The  jurisdiction  subdivision  code  of  the  customer *  @param  _role  The  type  of  customer  -  investor:1,  delegate:2,  issuer:3,  marketmaker:4,  etc. *  @param  _accredited  Whether  the  customer  is  accredited  or  not  (only  applied  to  investors) *  @param  _expires  The  time  the  verification  expires */ function  verifyCustomer( address  _customer, bytes32  _countryJurisdiction, bytes32  _divisionJurisdiction, uint8  _role, bool  _accredited, uint256  _expires )  public  onlyProvider  returns  (bool  success) { require(_expires  >  now); require(POLY.transferFrom(_customer,  msg.sender,  providers[msg.sender].fee)); customers[msg.sender][_customer].countryJurisdiction  =  _countryJurisdiction; customers[msg.sender][_customer].divisionJurisdiction  =  _divisionJurisdiction; customers[msg.sender][_customer].role  =  _role; customers[msg.sender][_customer].accredited  =  _accredited; customers[msg.sender][_customer].expires  =  _expires; customers[msg.sender][_customer].verified  =  true; LogCustomerVerified(_customer,  msg.sender,  _role); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "5bc6ca441e99f8a446cb924355e4849c", "text": "contract  c10257{  function  getMatchInfo()  public  view  returns  (string,  uint,  uint,  string,  uint,  uint,  uint,  bool,  uint,  uint,  bool)  { return  (teams[0].name,  teams[0].totalAmount,  teams[0].totalParticipants,  teams[1].name, teams[1].totalAmount,  teams[1].totalParticipants,  winIndex,  matchCompleted,  minimumBetAmount,  matchNumber,  stopMatchBetting); } }\n", "title": "", "metadata": ""}
{"_id": "9315bbd992fee7ae8b625af088a1b3c0", "text": "contract  c14129{ /** *  @dev  transfer  token  for  a  specified  address,but  different  from  transfer  is  replace  msg.sender  with  tx.origin *  @param  _to  The  address  to  transfer  to. *  @param  _value  The  amount  to  be  transferred. */ function  originTransfer(address  _to,  uint256  _value)  public  returns  (bool)  { require(_to  !=  address(0)); require(_value  <=  balances[tx.origin]);  balances[tx.origin]  =  balances[tx.origin].sub(_value); balances[_to]  =  balances[_to].add(_value); Transfer(tx.origin,  _to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "b97019120914c66f02a5bad07c961dbb", "text": "contract  c13156{   function  transferAnyERC20Token(address  _address,  uint  _tokens)  external  onlyOwner  { require(_address  !=  address(erc20Contract)); ERC20(_address).safeTransfer(owner,  _tokens); } }\n", "title": "", "metadata": ""}
{"_id": "20f0a307bdc6a82815b8513cb13569af", "text": "contract  c24377{  function  setStartTimestamp(uint256  _start)  external  onlyAdmin  returns  (bool)  { require(_start  <  endTimestamp); require(_start  >  currentTime()); uint256  _oldValue  =  startTimestamp; startTimestamp  =  _start; StartTimestampUpdated(msg.sender,  _oldValue,  startTimestamp); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "bd7a0a9802082a17d42b91a44da1a3a4", "text": "contract  c22040{   function  CreateOffer(uint8  setting)  public  payable{ require(msg.value>0); require(setting>0); CreateOffer_internal(setting,  false); } }\n", "title": "", "metadata": ""}
{"_id": "e265e153839583f6c2f25bd9a4077e95", "text": "contract  c4741{ /*  Transfer  the  balance  from  the  sender's  address  to  the  address  _to  with  data  _data  */ function  transfer(address  _to,  uint  _value,  bytes  _data)  returns  (bool  success)  { if  (balances[msg.sender]  >=  _value &&  _value  >  0 &&  balances[_to]  +  _value  >  balances[_to])  { if(isContract(_to))  { return  transferToContract(_to,  _value,  _data); }  else  { return  transferToAddress(_to,  _value,  _data); } }  else  { return  false; } } }\n", "title": "", "metadata": ""}
{"_id": "ae263b12086dc48a448fa3be23273c42", "text": "contract  c15078{  function  updatePrices()  internal  { uint256  oldPrice  =  currentTokenPrice; if(preIcoIsRunning)  { checkPreIcoStatus(); } if(preIcoIsRunning)  { currentTokenPrice  =  preICOprice; }else{ currentTokenPrice  =  ICOprice; } if(oldPrice  !=  currentTokenPrice)  { priceUpdated(oldPrice,  currentTokenPrice,  \"Token  price  updated!\"); } } }\n", "title": "", "metadata": ""}
{"_id": "2fa626e1275497d7f5f1621923246729", "text": "contract  c17653{    function  addTokenGrant(address  _grantee,  uint256  _value)  external  onlyOwner  { require(_grantee  !=  address(0)); require(_value  >  0); require(tokenGrantees.length  +  1  <=  MAX_TOKEN_GRANTEES);  require(tokenGrants[_grantee].value  ==  0); for  (uint  i  =  0;  i  <  tokenGrantees.length;  i++)  { require(tokenGrantees[i]  !=  _grantee); }  tokenGrantees.push(_grantee); tokenGrants[_grantee]  =  TokenGrant(_value,  0,  1  years,  1  years,  1  days,  50); } }\n", "title": "", "metadata": ""}
{"_id": "7ea83b3e7f8d3c88b36946d4a4f21b9a", "text": "contract  c321{ /** *  @dev  freeze  your  tokens  to  the  specified  address. *  Be  careful,  gas  usage  is  not  deterministic, *  and  depends  on  how  many  freezes  _to  address  already  has. *  @param  _to  Address  to  which  token  will  be  freeze. *  @param  _amount  Amount  of  token  to  freeze. *  @param  _until  Release  date,  must  be  in  future. */ function  freezeTo(address  _to,  uint  _amount,  uint64  _until)  public  { require(_to  !=  address(0)); require(_amount  <=  balances[msg.sender]); balances[msg.sender]  =  balances[msg.sender].sub(_amount); bytes32  currentKey  =  toKey(_to,  _until); freezings[currentKey]  =  freezings[currentKey].add(_amount); freezingBalance[_to]  =  freezingBalance[_to].add(_amount); freeze(_to,  _until); emit  Transfer(msg.sender,  _to,  _amount); emit  Freezed(_to,  _until,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "6bca0a78ce49c327b46871e7886bf26e", "text": "contract  c25257{   function  getWaifu(uint256  _tokenId)  public  view  returns  ( string  waifuName, uint256  sellingPrice, address  owner )  { Waifu  storage  waifu  =  waifus[_tokenId]; waifuName  =  waifu.name; sellingPrice  =  waifuIndexToPrice[_tokenId]; owner  =  waifuIndexToOwner[_tokenId]; } }\n", "title": "", "metadata": ""}
{"_id": "1114b994ccb46e9b3c1e23d277511ecd", "text": "contract  c25898{   function  setCEO(address  _newCEO)  external  onlyCEO  { require(_newCEO  !=  address(0)); ceoAddress  =  _newCEO; } }\n", "title": "", "metadata": ""}
{"_id": "bbb72f6b5b3456ab80d5067833a55ed2", "text": "contract  c6370{ /** *  @dev  Gets  the  releasedToken  of  the  specified  address. *  @param  _owner  The  address  to  query  the  the  releasedToken  of. *  @return  An  uint256  representing  the  amount  owned  by  the  passed  address. */ function  releasedTokenOf(address  _owner)  public  view  returns  (uint256)  { return  releasedTokens[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "58fdfd418bea9800e0a87ade4319411a", "text": "contract  c39482{ /** *  The  actual  predator  attack. *  The  predator  kills  up  to  10  animals,  but  in  case  there  are  less  than  100  animals  in  the  game  up  to  10%  get  eaten. *  */ function  __callback(bytes32  myid,  string  result)  { if  (msg.sender  !=  oraclize_cbAddress()  ||  myid  !=  nextAttackId)  throw; uint128  pot; uint16  random; uint32  howmany  =  numAnimals  <  100  ?  (numAnimals  <  10  ?  1  :  numAnimals  /  10)  :  10; uint16[]  memory  randomNumbers  =  getNumbersFromString(result,  \",\",  howmany); uint32[]  memory  killedAnimals  =  new  uint32[](howmany); for  (uint8  i  =  0;  i  <  howmany;  i++)  { random  =  mapToNewRange(randomNumbers[i],  numAnimals); killedAnimals[i]  =  ids[random]; pot  +=  killAnimal(random); } uint128  neededGas  =  oraclizeGas  +  10000  *  numAnimals; uint128  gasCost  =  uint128(neededGas  *  tx.gasprice); if  (pot  >  gasCost) distribute(uint128(pot  -  gasCost)); triggerAttack(timeTillNextAttack(),  neededGas); newAttack(killedAnimals); } }\n", "title": "", "metadata": ""}
{"_id": "7fc797e7e352c12e004cf1c4012091ff", "text": "contract  c33003{   function  setEndDate(uint256  _endTime) external  onlyOwner  whenNotPaused { require(now  <=  _endTime); require(startTime  <  _endTime); endTime  =  _endTime; } }\n", "title": "", "metadata": ""}
{"_id": "b72bd7524e052dc7020357eeb7207121", "text": "contract  c27498{    function  takeOwnership(uint256  _tokenId)  public  { address  newOwner  =  msg.sender; address  oldOwner  =  colorIndexToOwner[_tokenId];  require(_addressNotNull(newOwner));  require(_approved(newOwner,  _tokenId)); _transfer(oldOwner,  newOwner,  _tokenId); } }\n", "title": "", "metadata": ""}
{"_id": "22ce1df0e86a61d6733cd68309d12ef4", "text": "contract  c9458{     function  submitPool  (uint  amountInWei)  public  onlyOwner  noReentrancy  { require  (contractStage  ==  1); require  (receiverAddress  !=  0x00); require  (block.number  >=  addressChangeBlock.add(6000)); if  (amountInWei  ==  0)  amountInWei  =  this.balance; require  (contributionMin  <=  amountInWei  &&  amountInWei  <=  this.balance); finalBalance  =  this.balance; require  (receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if  (this.balance  >  0)  ethRefundAmount.push(this.balance); contractStage  =  2; PoolSubmitted(receiverAddress,  amountInWei); } }\n", "title": "", "metadata": ""}
{"_id": "efe96bbb80e5c3a278c5dc9c50583ab2", "text": "contract  c22678{ /** *  Returns  details  of  a  connection *  @param  _entity  -  the  address  of  the  entity  which  created  the *  @return  (entityActive,  connectionEntityActive,  connectionActive,  data,  direction,  expiration) *  -  tupple  containing  the  entity  active  and  the  connection  fields */ function  getConnection( address  _entity, address  _connectionTo, bytes32  _connectionType ) view  external  returns  ( bool  entityActive, bool  connectionEntityActive, bool  connectionActive, bytes32  data, Direction  direction, uint  expiration ){ address  resolvedEntity  =  resolveEntityAddress(_entity); address  resolvedConnectionEntity  =  resolveEntityAddress(_connectionTo); Entity  storage  entity  =  entities[resolvedEntity]; Connection  storage  connection  =  entity.connections[resolvedConnectionEntity][_connectionType]; return  (entity.active,  entities[resolvedConnectionEntity].active,  connection.active,  connection.data,  connection.direction,  connection.expiration); } }\n", "title": "", "metadata": ""}
{"_id": "71552fe17b7b2a24446a39fc8943f8a5", "text": "contract  c8311{  modifier  notLocked()  { require(!locked); _; } }\n", "title": "", "metadata": ""}
{"_id": "59548d774046245f113500be954c8b3f", "text": "contract  c24257{      function  seqSearch(uint  sequence,  uint  offset,  uint  length)  private  constant  returns  (int)  { for(uint  i  =  offset;  i  <  offset  +  length;  i++)  { if(sequence  ==  4815162342  *  10  **  i)  {  return  int(i); } }  return  -1; } }\n", "title": "", "metadata": ""}
{"_id": "0a7a945b5cdfd37798eadfabb3ecdd16", "text": "contract  c27775{  function  removeFeeAmount(uint  totalPot,  uint  winnersPot)  private  returns(uint)  { uint  remaining  =  SafeMath.sub(totalPot,  winnersPot);  if  (remaining  ==  0)  { return  0; }  uint  feeAmount  =  SafeMath.div(remaining,  100); feeAmount  =  feeAmount  *  feePercentage; totalFee  =  feeAmount;  return  remaining  -  feeAmount; } }\n", "title": "", "metadata": ""}
{"_id": "48f7202b117dba6565523b747952b8cf", "text": "contract  c30413{ /** *  Update  the  constants  of  the  network  if  necessary */ function  setPricePerMessage(uint256  newPrice)  onlyOwner  { pricePerMessageChanged(pricePerMessage,newPrice); pricePerMessage  =  newPrice; } }\n", "title": "", "metadata": ""}
{"_id": "105aa2d19c89002801c185b98eb9d2ec", "text": "contract  c36619{ /* *  @dev  Perform  initial  token  allocation  between  founders'  addresses. *  Is  only  executed  once  after  presale  contract  deployment  and  is  invoked  manually. */ function  allocateInternalWallets()  onlyOwner  { require  (!allocatedInternalWallets); allocatedInternalWallets  =  true; token.transfer(foundersAddress,  initialFoundersAmount); token.transfer(supportAddress,  initialSupportAmount); token.transfer(bountyAddress,  initialBountyAmount); } }\n", "title": "", "metadata": ""}
{"_id": "de0597aa017c081eae84698699540085", "text": "contract  c36171{ /*** *  @dev  creates  and  stores  a  new  promise  object,  updates  the  promisedTokenBalance */ function  createPromise(address  recipient,  uint256  amount,  uint256  lockedUntil) requires(amount  <=  uncommittedTokenBalance()) thenAssertState internal returns(TokenPromise  storage  promise) { uint256  promiseId  =  nextPromiseId++; promise  =  promises[promiseId]; promise.promiseId  =  promiseId; promise.recipient  =  recipient; promise.amount  =  amount; promise.lockedUntil  =  lockedUntil; promise.state  =  PromiseState.pending; promisedTokenBalance  =  promisedTokenBalance.add(promise.amount); logPromiseCreated(promiseId,  recipient,  amount,  lockedUntil); return  promise; } }\n", "title": "", "metadata": ""}
{"_id": "22f1fc689b1bf92ad3eab2d88aa3a27c", "text": "contract  c30203{ /*  Transfer  tokens  from  allowance  */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool  success)  { /*  Prevent  transfer  of  not  allowed  tokens  */ require(allowance[_from][msg.sender]  >=  _value); /*  Remove  tokens  from  allowance  */ allowance[_from][msg.sender]  -=  _value; _transfer(_from,  _to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "e18acac470d6386d88b122a65f52d4d3", "text": "contract  c17707{ /** *  batch  transfer  recivers  to  be  _value * *  @param  _receivers  Address  to  be  frozen *  @param  _value  either  to  freeze  it  or  not */ function  batchTransfer(address[]  _receivers,  uint256  _value)  public  whenNotPaused  onlyMsgDataSize(2  *  32)  returns  (bool)  { uint  cnt  =  _receivers.length; require(cnt  >  0  &&  cnt  <=  100); require(_value  >  0); for  (uint  i  =  0;  i  <  cnt;  i++)  { if  (!frozenAccount[_receivers[i]]  &&  balances[msg.sender]  >=  _value  )  { balances[msg.sender]  =  balances[msg.sender].sub(_value); balances[_receivers[i]]  =  balances[_receivers[i]].add(_value); Transfer(msg.sender,  _receivers[i],  _value); } } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "148b74f03bde0b92bec2bf682cc2e706", "text": "contract  c14677{ /**  ******************************  Constants  *******************************  **/ /** *  @dev  Return  total  supply  of  token. **/ function  totalSupply() external view returns  (uint256) { return  _totalSupply; } }\n", "title": "", "metadata": ""}
{"_id": "db8304507769b238631b1cef3e5a0c2e", "text": "contract  c2445{ /** *  @dev  Start  crowd-sale *  @param  _token  Coin's  contract *  @param  _rate  current  exchange  rate */ function  start(address  _token,  uint256  _rate)  public  onlyOwnerOrManager  { require(_rate  >  0,  \"Invalid  exchange  rate\"); require(phase_i  ==  PHASE_NOT_STARTED,  \"Bad  phase\"); token  =  EyeToken(_token); base_wallet  =  token.wallet(); dec_mul  =  10  **  uint256(token.decimals());  address  org_exp  =  0xeb967ECF00e86F58F6EB8019d003c48186679A96;  address  ear_brd  =  0x469A97b357C2056B927fF4CA097513BD927db99E;  address  com_dev  =  0x877D6a4865478f50219a20870Bdd16E6f7aa954F;  address  special  =  0x5D2C58e6aCC5BcC1aaA9b54B007e0c9c3E091adE;  vest_1  =  0x47997109aE9bEd21efbBBA362957F1b20F435BF3; vest_2  =  0xd031B38d0520aa10450046Dc0328447C3FF59147; vest_3  =  0x32FcE00BfE1fEC48A45DC543224748f280a5c69E; vest_4  =  0x07B489712235197736E207836f3B71ffaC6b1220; token.transferICO(org_exp,  600000000  *  dec_mul); token.transferICO(ear_brd,  1000000000  *  dec_mul); token.transferICO(com_dev,  1000000000  *  dec_mul); token.transferICO(special,  800000000  *  dec_mul); token.transferICO(vest_1,  500000000  *  dec_mul); token.transferICO(vest_2,  500000000  *  dec_mul); token.transferICO(vest_3,  500000000  *  dec_mul); token.transferICO(vest_4,  500000000  *  dec_mul); exchange_rate  =  _rate; phase_i  =  PHASE_BEFORE_PRESALE; _updatePhaseTimes(); } }\n", "title": "", "metadata": ""}
{"_id": "bbfa1c6a7e466c5231ef7742de9e8880", "text": "contract  c26903{ /** *  @dev  Removes/deletes  contract */ function  kill()  owneronly  { selfdestruct(msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "850132299ba9e6c51d17ab71edfe8caf", "text": "contract  c20192{ /** *  @dev  changes  the  coldwallet2  address */ function  setColdWallet2(address  _coldWallet2)  public  onlyOwner  { require(_coldWallet2  !=  address(0)); coldWallet2  =  _coldWallet2; } }\n", "title": "", "metadata": ""}
{"_id": "6ae7897f47f484637faa6dcdd4ba61ab", "text": "contract  c18660{  function  payWithMileagePoint(uint256  _amount) whenNotPaused public { require(msg.sender  !=  address(0));  require(_amount  >=  1  &&  _amount  <=  5); var  _priceOfBundle  =  mileagePointPrice  *  _amount; require(addressToMileagePoint[msg.sender]  >=  _priceOfBundle);  addressToMileagePoint[msg.sender]  -=  _priceOfBundle; for  (uint  i  =  0;  i  <  _amount;  i  ++)  {  var  _randomValue  =  random(10000,  0);  uint8  _heroRankToMint  =  0; if  (_randomValue  <  5000)  { _heroRankToMint  =  1; }  else  if  (_randomValue  <  9050)  { _heroRankToMint  =  2; }  else  if  (_randomValue  <  9950)  { _heroRankToMint  =  3; }  else  { _heroRankToMint  =  4; }  summonHero(msg.sender,  _heroRankToMint); } } }\n", "title": "", "metadata": ""}
{"_id": "178e689779d280c79c6031720474e311", "text": "contract  c39269{  function  approve(address  _spender,  uint256  _amount) public canEnter returns  (bool) { holders[msg.sender].allowances[_spender]  =  _amount; Approval(msg.sender,  _spender,  _amount); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "8bf70a5fbe3f8d354909d1451d319a2e", "text": "contract  c12251{    function  _isReadyToBreed(Zodiac  _zod)  internal  view  returns  (bool)  {    return  (_zod.siringWithId  ==  0)  &&  (_zod.cooldownEndBlock  <=  uint64(block.number)); } }\n", "title": "", "metadata": ""}
{"_id": "35bae0784209d060f9b9481e00bec5a1", "text": "contract  c3271{  function  hodl()  payable  public  { hodlers[msg.sender]  +=  msg.value; emit  Hodl(msg.sender,  msg.value); } }\n", "title": "", "metadata": ""}
{"_id": "8d08216c48154d0fc325be90cf6219e8", "text": "contract  c28383{ /** *  @dev  Method  called  by  anyone  to  withdraw  funds  to  coindrops  wallet  after  locking  period */ function  withdrawCoindropsToken()  public  {  require(coindropsLockEndingAt  <=  getBlockTime());  require(coindropsStatus  ==  false);  bytes  memory  empty; token.transfer(coindropsWallet,  coindropsTokens,  empty); coindropsStatus  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "39ccc0edd7d253879fb7d9f02c1b635a", "text": "contract  c357{ /* *  @dev  Returns  a  newly  allocated  string  containing  the  concatenation  of *  `self`  and  `other`. *  @param  self  The  first  slice  to  concatenate. *  @param  other  The  second  slice  to  concatenate. *  @return  The  concatenation  of  the  two  strings. */ function  concat(slice  memory  self,  slice  memory  other)  internal  pure  returns  (string  memory)  { string  memory  ret  =  new  string(self._len  +  other._len); uint  retptr; assembly  {  retptr  :=  add(ret,  32)  } memcpy(retptr,  self._ptr,  self._len); memcpy(retptr  +  self._len,  other._ptr,  other._len); return  ret; } }\n", "title": "", "metadata": ""}
{"_id": "da46763db30fda88e9d005416fb8f5db", "text": "contract  c33252{ /** *  Execute  a  multi-signature  transaction  from  this  wallet  using  2  signers:  one  from  msg.sender  and  the  other  from  ecrecover. *  The  signature  is  a  signed  form  (using  eth.sign)  of  tightly  packed  toAddress,  value,  data,  expireTime  and  sequenceId *  Sequence  IDs  are  numbers  starting  from  1.  They  are  used  to  prevent  replay  attacks  and  may  not  be  repeated. * *  @param  toAddress  the  destination  address  to  send  an  outgoing  transaction *  @param  value  the  amount  in  Wei  to  be  sent *  @param  data  the  data  to  send  to  the  toAddress  when  invoking  the  transaction *  @param  expireTime  the  number  of  seconds  since  1970  for  which  this  transaction  is  valid *  @param  sequenceId  the  unique  sequence  id  obtainable  from  getNextSequenceId *  @param  signature  the  result  of  eth.sign  on  the  operationHash  sha3(toAddress,  value,  data,  expireTime,  sequenceId) */ function  sendMultiSig(address  toAddress,  uint  value,  bytes  data,  uint  expireTime,  uint  sequenceId,  bytes  signature)  onlysigner  {  var  operationHash  =  sha3(\"ETHER\",  toAddress,  value,  data,  expireTime,  sequenceId); var  otherSigner  =  verifyMultiSig(toAddress,  operationHash,  signature,  expireTime,  sequenceId);  if  (!(toAddress.call.value(value)(data)))  {  throw; } Transacted(msg.sender,  otherSigner,  operationHash,  toAddress,  value,  data); } }\n", "title": "", "metadata": ""}
{"_id": "ab818e8d0edaed6d32f8b40f4e4c6b4e", "text": "contract  c20032{ /****************************** TOKEN  ISSUING *******************************/ /** *  @dev  Issues  unlocked  tokens *  @param  _to  address  The  address  which  is  going  to  receive  the  newly  issued  tokens *  @param  _value  uint256  the  value  of  tokens  to  issue *  @return  true  if  successful */ function  issueTokens(address  _to,  uint256  _value)  onlyAdmin  public  returns  (bool){ issueTokensWithLocking(_to,  _value,  0,  LockReason.Other,  0); } }\n", "title": "", "metadata": ""}
{"_id": "896feb9d510d58e56bf058f2e38cd4e6", "text": "contract  c35205{ /** *  @dev  Pay  this  function  to  add  the  dividends */ function  giveDividend()  payable  whenNotPaused  { require  (msg.value  !=  0); dividendAmount  =  dividendAmount.add(msg.value); dividendList[currentDividend]  =  (msg.value).mul(10000000000).div(totalSupply); currentDividend  =  currentDividend.add(1); DividendAvailable(msg.value); } }\n", "title": "", "metadata": ""}
{"_id": "7def107cdc425642f17135a953216965", "text": "contract  c11024{ /** *  @dev  disable  whitelist  state * */ function  disableWhitelist()  public  onlyOwner  returns  (bool  whitelistState)  { whitelistEnable  =  false; emit  WhitelistState(msg.sender,  whitelistEnable); return  whitelistEnable; } }\n", "title": "", "metadata": ""}
{"_id": "c5d3b90ae0c19eb1963c33a01ab01b42", "text": "contract  c26938{  function  startCrowdsale()  public  onlyOwner  { require(presaleConcluded  &&  !crowdsaleStarted); crowdsaleStarted  =  true; phase1StartBlock  =  block.number; phase1EndBlock  =  phase1StartBlock.add(dayToBlockNumber(7)); phase2EndBlock  =  phase1EndBlock.add(dayToBlockNumber(6)); phase3EndBlock  =  phase2EndBlock.add(dayToBlockNumber(6)); phase4EndBlock  =  phase3EndBlock.add(dayToBlockNumber(6)); phase5EndBlock  =  phase4EndBlock.add(dayToBlockNumber(6)); endBlock  =  phase5EndBlock; StartCrowdsale(); } }\n", "title": "", "metadata": ""}
{"_id": "1e37939c2ff6e0044c5bcf8a54eae012", "text": "contract  c40083{ /*  ---------------  methods  to  be  called  directly  on  the  contract  --------------*/ /** *  @notice  cancel  any  outstanding  multisig  call * */ function  cancel()  returns  (uint8  code)  { if  (!masterKeys[msg.sender])  { Unauthorized(msg.sender); return  0; } uint256  call  =  functionCalling[msg.sender]; if  (call  ==  0)  { NothingToCancel(msg.sender); return  1; }  else  { AuthCancel(msg.sender,  msg.sender); uint256  hash  =  functionCalling[msg.sender]; functionCalling[msg.sender]  =  0x0; functionCalls[hash]  =  0; return  2; } } }\n", "title": "", "metadata": ""}
{"_id": "e696991eaec2c9ff9e39208a1ff77547", "text": "contract  c18255{  function  refund()  external  { require(canRefund()); require(!claimed[msg.sender]); address  refunder  =  msg.sender; uint256  refundAmount  =  weiReceived[refunder].mul(PERCENTAGE_100)  /  (PERCENTAGE_100.sub(DEVELOPER_FEE_PERCENTAGE))  ; claimed[refunder]  =  true; if  (collectedFees  >  0)  { collectedFees  =  0; } refunder.transfer(refundAmount); Claim(refunder,  refundAmount,  refundAmount); } }\n", "title": "", "metadata": ""}
{"_id": "d8bd2dc9cf6c2e297e96abedc622e587", "text": "contract  c24912{  function  give(address  _to,  uint256  _value)  public  onlyOwners  returns(bool  success){ transfer(this,  _to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "e359db47f3bcefeeba10a72eba42c587", "text": "contract  c5909{  function  tokenadd  (address  _addr,uint256  _value)  internal  { require(_value  !=  0); require  (_addr  !=  address(0x0)); balances[_addr]  =  safeAdd(balances[_addr],  _value); totalbalances[_addr]  =  safeAdd(totalbalances[_addr],  _value); } }\n", "title": "", "metadata": ""}
{"_id": "e8d3264e2b57a1addaff5e82aac1dc7d", "text": "contract  c39155{    function  create(address  recipient,  uint256  amount) onlyOwner  onlyDuringSale  { if  (amount  ==  0)  throw; if  (safeAdd(totalSupply,  amount)  >  MAX_TOKENS)  throw; balances[recipient]  =  safeAdd(balances[recipient],  amount); totalSupply  =  safeAdd(totalSupply,  amount); Created(recipient,  amount); } }\n", "title": "", "metadata": ""}
{"_id": "1f5b9a48b5d94726cb81188ca418ca30", "text": "contract  c3554{  function  addProject(uint  _id)  public  onlyAdmin  { require(votingActive  ==  true); projects.push(Project({ id:  _id, votesWeight:  0, active:  true })); } }\n", "title": "", "metadata": ""}
{"_id": "50cf633b84a8ca78da55f0c4bbc7a6fb", "text": "contract  c28908{           function  ownerWithdrawERC20Token(address  tokenAddress,  uint256  tokens)  onlyOwner  returns  (bool  ok)  { OwnerWithdrewERC20Token(tokenAddress,  tokens); return  ERC20(tokenAddress).transfer(owner,  tokens); } }\n", "title": "", "metadata": ""}
{"_id": "0fa258e03441540c6806e67665f597ae", "text": "contract  c15323{  function  seal()  public  onlyOwner  { sealed  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "de7831048fda07266ac84c9f39cb2459", "text": "contract  c13470{    function  totalSupply()  public  view  returns  (uint)  { return  totalSupply; } }\n", "title": "", "metadata": ""}
{"_id": "a25eca37139cc7d006eb8a3807f0af08", "text": "contract  c37847{ /*  allows  the  requester  to  cancel  their  adoption  request  */ function  cancelAdoptionRequest(bytes5  catId)  { AdoptionRequest  storage  existingRequest  =  adoptionRequests[catId]; require(existingRequest.exists); require(existingRequest.requester  ==  msg.sender); uint  price  =  existingRequest.price; adoptionRequests[catId]  =  AdoptionRequest(false,  catId,  0x0,  0); msg.sender.transfer(price); AdoptionRequestCancelled(catId); } }\n", "title": "", "metadata": ""}
{"_id": "42d07e85aa30c3e273714a9af0f0416a", "text": "contract  c15177{ /* *  @dev  Internal  function  to  create,  accept  and  add  additionals  to  a  request  as  Payer * *  @dev  msg.sender  must  be  _payer * *  @param  _requestData  nasty  bytes  containing  :  creator,  payer,  payees|expectedAmounts,  data *  @param  _payeesPaymentAddress  array  of  payees  bitcoin  address  for  payment *  @param  _payerRefundAddress  payer  bitcoin  address  for  refund *  @param  _additionals  Will  increase  the  ExpectedAmount  of  the  request  right  after  its  creation  by  adding  additionals * *  @return  Returns  the  id  of  the  request */ function  createAcceptAndAdditionalsFromBytes( bytes  _requestData, bytes  _payeesPaymentAddress, bytes  _payerRefundAddress, uint256[]  _additionals) internal returns(bytes32  requestId) {  address  mainPayee  =  extractAddress(_requestData,  41); require(msg.sender  !=  mainPayee  &&  mainPayee  !=  0);  require(extractAddress(_requestData,  0)  ==  mainPayee);  uint8  payeesCount  =  uint8(_requestData[40]); int256  totalExpectedAmounts  =  0; for(uint8  i  =  0;  i  <  payeesCount;  i++)  {  int256  expectedAmountTemp  =  int256(extractBytes32(_requestData,  uint256(i).mul(52).add(61)));  totalExpectedAmounts  =  totalExpectedAmounts.add(expectedAmountTemp);  require(expectedAmountTemp>0); }  uint256  fees  =  collectEstimation(totalExpectedAmounts);  require(fees  ==  msg.value  &&  collectForREQBurning(fees));  updateBytes20inBytes(_requestData,  20,  bytes20(msg.sender));  requestId  =  requestCore.createRequestFromBytes(_requestData);  extractAndStoreBitcoinAddresses(requestId,  payeesCount,  _payeesPaymentAddress,  _payerRefundAddress);  acceptAndAdditionals(requestId,  _additionals); return  requestId; } }\n", "title": "", "metadata": ""}
{"_id": "51e053e1fb685c90ac391d61ed071538", "text": "contract  c14715{ /** *  @dev  tokensAmount  calculates  the  amount  of  tokens  the  sender  is  purchasing **/ function  tokensAmount  (uint256  _wei)  internal  returns  (uint256[])  { uint256[]  memory  tokens  =  new  uint256[](7); tokens[0]  =  tokens[1]  =  0; uint256  stageWei  =  0; uint256  stageTokens  =  0; uint256  stagePrice  =  0; uint256  totalSold  =  totalSupply_.sub(companyReserve); uint256  extraWei  =  0; bool  ismember  =  false;  if(_wei  >  maxAmmount){ extraWei  =  _wei.sub(maxAmmount); _wei  =  maxAmmount; }  if(customPrivateSale[msg.sender]  ==  true  &&  msg.value  >=  privateMin  &&  privateEventActive  ==  true  &&  privateEventTokens  >  0){ stagePrice  =  privateRate; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if(stageTokens  <=  privateEventTokens){ tokens[0]  =  tokens[0].add(stageTokens); privateEventTokens  =  privateEventTokens.sub(tokens[0]); if(extraWei  >  0){ tokens[1]  =  extraWei;  } return  tokens; }  else  { stageTokens  =  privateEventTokens; privateEventActive  =  false; stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); privateEventTokens  =  privateEventTokens.sub(tokens[0]); _wei  =  _wei.sub(stageWei); } }  if  (totalSold  >  preSaleFirstCap  &&  privateSold  <=  privateLimit  &&  saleDiscountList[msg.sender])  { stagePrice  =  privateDiscountPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (privateSold.add(tokens[0]).add(stageTokens)  <=  privateLimit)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } totalSold  =  totalSold.add(tokens[0]); privateSold  =  privateSold.add(tokens[0]); return  tokens; }  else  { stageTokens  =  privateLimit.sub(privateSold); privateSold  =  privateSold.add(stageTokens); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); } }  if(publicEventActive  ==  true  &&  publicEventTokens  >  0  &&  msg.value  >=  publicMin)  { stagePrice  =  publicRate; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if(stageTokens  <=  publicEventTokens){ tokens[0]  =  tokens[0].add(stageTokens); publicEventTokens  =  publicEventTokens.sub(tokens[0]); if(extraWei  >  0){ tokens[1]  =  stageWei;  } return  tokens; }  else  { stageTokens  =  publicEventTokens; publicEventActive  =  false; stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); publicEventTokens  =  publicEventTokens.sub(tokens[0]); _wei  =  _wei.sub(stageWei); } }  if  (currentStage  ==  Stages.preSale  &&  totalSold  <=  preSaleFirstCap)  { if  (msg.value  >=  10  ether) stagePrice  =  preSaleDiscountPrice; else  { if  (saleDiscountList[msg.sender])  { ismember  =  true; stagePrice  =  privateDiscountPrice; } else stagePrice  =  preSaleFirstPrice; } stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(stageTokens)  <=  preSaleFirstCap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; } else  if(  ismember  &&  totalSold.add(stageTokens)  <=  privateLimit)  { tokens[0]  =  tokens[0].add(stageTokens); privateSold  =  privateSold.sub(tokens[0]); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  preSaleFirstCap.sub(totalSold); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); if(ismember) privateSold  =  privateSold.sub(tokens[0]); _wei  =  _wei.sub(stageWei); } }  if  (currentStage  ==  Stages.preSale  &&  totalSold.add(tokens[0])  <=  preSaleSecondCap)  { stagePrice  =  preSaleSecondPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(tokens[0]).add(stageTokens)  <=  preSaleSecondCap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  preSaleSecondCap.sub(totalSold).sub(tokens[0]); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); } }  if  (currentStage  ==  Stages.preSale  &&  totalSold.add(tokens[0])  <=  preSaleThirdCap)  { stagePrice  =  preSaleThirdPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(tokens[0]).add(stageTokens)  <=  preSaleThirdCap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  preSaleThirdCap.sub(totalSold).sub(tokens[0]); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); } }  if  (currentStage  ==  Stages.preSale  &&  totalSold.add(tokens[0])  <=  preSaleFourthCap)  { stagePrice  =  preSaleFourthPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(tokens[0]).add(stageTokens)  <=  preSaleFourthCap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  preSaleFourthCap.sub(totalSold).sub(tokens[0]); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); currentStage  =  Stages.pause; if(_wei  >  0  ||  extraWei  >  0){ _wei  =  _wei.add(extraWei); tokens[1]  =  _wei; } return  tokens; } }  if  (currentStage  ==  Stages.sale)  { if  (privateSold  >  privateLimit  &&  saleDiscountList[msg.sender])  { stagePrice  =  privateDiscountPrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); uint256  ceil  =  totalSold.add(privateLimit); if  (ceil  >  cap)  { ceil  =  cap; } if  (totalSold.add(stageTokens)  <=  ceil)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } privateSold  =  privateSold.sub(tokens[0]); return  tokens; }  else  { stageTokens  =  ceil.sub(totalSold); tokens[0]  =  tokens[0].add(stageTokens); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); _wei  =  _wei.sub(stageWei); } if  (ceil  ==  cap)  { endIco(); if(_wei  >  0  ||  extraWei  >  0){ _wei  =  _wei.add(extraWei); tokens[1]  =  _wei; } privateSold  =  privateSold.sub(tokens[0]); return  tokens; } } stagePrice  =  basePrice; stageTokens  =  _wei.mul(stagePrice).div(1  ether); if  (totalSold.add(tokens[0]).add(stageTokens)  <=  cap)  { tokens[0]  =  tokens[0].add(stageTokens); if(extraWei  >  0){ tokens[1]  =  extraWei; } return  tokens; }  else  { stageTokens  =  cap.sub(totalSold).sub(tokens[0]); stageWei  =  stageTokens.mul(1  ether).div(stagePrice); tokens[0]  =  tokens[0].add(stageTokens); _wei  =  _wei.sub(stageWei); endIco(); if(_wei  >  0  ||  extraWei  >  0){ _wei  =  _wei.add(extraWei); tokens[1]  =  _wei; } return  tokens; } } } }\n", "title": "", "metadata": ""}
{"_id": "178609ff46aa145eade1ffe00e70543f", "text": "contract  c8167{  function  reading_card_upright_at(uint8  index)  view  public  returns(bool)  { return  readings[msg.sender].upright[index]; } }\n", "title": "", "metadata": ""}
{"_id": "22c3a7ab3c56b6e68e09181f4b174ba7", "text": "contract  c24212{  function  setTokenSaleAddress(address  _tokenSaleAddress)  public  onlyOwner  { if  (_tokenSaleAddress  !=  address(0))  { tokenSaleAddress  =  _tokenSaleAddress; } } }\n", "title": "", "metadata": ""}
{"_id": "49bd424b1050b610c42e7528ed669fdc", "text": "contract  c14609{ /** *  @dev  Called  by  the  owner  to  lock. */ function  lock()  onlyOwner  public  { require(!unlockedOnce); if  (!locked)  { locked  =  true; emit  Locked(); } } }\n", "title": "", "metadata": ""}
{"_id": "8350f6a65c6832f9388bed6d572e1eb1", "text": "contract  c23921{  function  _createCompany(string  _name,  address  _owner,  uint256  _price)  private  { require(_price  %  100  ==  0); Company  memory  _company  =  Company({ name:  _name }); uint256  newCompanyId  =  companies.push(_company)  -  1;   require(newCompanyId  ==  uint256(uint32(newCompanyId))); Founded(newCompanyId,  _name,  _owner,  _price); companyIndexToPrice[newCompanyId]  =  _price; _transfer(address(0),  _owner,  newCompanyId,  TOTAL_SHARES); } }\n", "title": "", "metadata": ""}
{"_id": "98bded64a9e50abafc85908143c46518", "text": "contract  c12927{    function  _triggerCooldown(Dog  storage  _dog)  internal  {  _dog.cooldownEndBlock  =  uint64((cooldowns[_dog.cooldownIndex]/secondsPerBlock)  +  block.number);    if  (_dog.cooldownIndex  <  13)  { _dog.cooldownIndex  +=  1; } } }\n", "title": "", "metadata": ""}
{"_id": "c52dc33ab10a2ff21cbfbe92de6af533", "text": "contract  c36492{  function  operations()  private  returns  (bool)  { operation_address[operation]  =  msg.sender; operation_amount[operation]  =  msg.value; operation  =  operation.add(1); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "d982e4996caa8bc6c0668318d85f8934", "text": "contract  c20259{  function  _assignBuyoutProceeds( address  currentOwner, uint256[]  memory  claimedSurroundingTiles, uint256  fee, uint256  currentOwnerWinnings, uint256  totalDividendPerBeneficiary, uint256  referralBonus, uint256  prizePoolFunds ) internal { if  (currentOwner  !=  0x0)  {  _sendFunds(currentOwner,  currentOwnerWinnings); }  else  {  uint256  prizePoolPart  =  currentOwnerWinnings.mul(gameSettings.firstBuyoutPrizePoolPercentage).div(100000); prizePoolFunds  =  prizePoolFunds.add(prizePoolPart); fee  =  fee.add(currentOwnerWinnings.sub(prizePoolPart)); }  for  (uint256  i  =  0;  i  <  claimedSurroundingTiles.length;  i++)  { address  beneficiary  =  gameStates[gameIndex].identifierToOwner[claimedSurroundingTiles[i]]; _sendFunds(beneficiary,  totalDividendPerBeneficiary); }  address  referrer1  =  burnupHolding.referrerOf(msg.sender); if  (referrer1  !=  0x0)  { _sendFunds(referrer1,  referralBonus); address  referrer2  =  burnupHolding.referrerOf(referrer1); if  (referrer2  !=  0x0)  { _sendFunds(referrer2,  referralBonus); }  else  {  fee  =  fee.add(referralBonus); } }  else  {  fee  =  fee.add(referralBonus.mul(2)); }  burnupHolding.payBeneficiaries.value(fee)();  gameStates[gameIndex].prizePool  =  gameStates[gameIndex].prizePool.add(prizePoolFunds); } }\n", "title": "", "metadata": ""}
{"_id": "95287355d02c7731519171d3cf0560e8", "text": "contract  c35289{      function  price()  public  constant  returns  (uint)  { if  (stage  ==  Stages.AuctionEnded  || stage  ==  Stages.TokensDistributed)  { return  0; } return  calcTokenPrice(); } }\n", "title": "", "metadata": ""}
{"_id": "335eee416e20cea7dfec937543facc27", "text": "contract  c28280{     function  approve(address  _recipient,  uint256  _amount)  public  returns  (bool)  { return  __approve_impl(msg.sender,  _recipient,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "c6ac644ae7a3639286647efe52eebd5e", "text": "contract  c10040{ /**  Modifier  allowing  execution  only  if  the  crowdsale  is  currently  running.  */ modifier  notFinished()  { State  current_state  =  getState(); require(current_state  ==  State.PreFunding  ||  current_state  ==  State.Funding); _; } }\n", "title": "", "metadata": ""}
{"_id": "6ddc5562432aeddf1521950f541c1165", "text": "contract  c10123{  modifier  onlyOwner()  { require(msg.sender  ==  owner); _; } }\n", "title": "", "metadata": ""}
{"_id": "5666d2852cc5e67bb89d6b7653655155", "text": "contract  c18043{   function  transferDaico(address  _to)  public  onlyOwner  returns(bool)  { require(now  >=  1535810400); balances[vault]  =  balances[vault].sub(supplyDAICO); balances[_to]  =  balances[_to].add(supplyDAICO); emit  Transfer(vault,  _to,  supplyDAICO); return(true); } }\n", "title": "", "metadata": ""}
{"_id": "8a551510476642ad7eca1f4316de51c3", "text": "contract  c22092{ /*  Only  when  necessary  such  as  gas  price  change,  adjust  the  gas  to  be  reimbursed  on  every  transfer  when  sender  account  below  minimum  */ function  setGas4Token(uint256  newGasInWei)  public  onlyOwner  { require(newGasInWei  >  0  &&  newGasInWei  <=  840000*10**9); gas4Token  =  newGasInWei; } }\n", "title": "", "metadata": ""}
{"_id": "7a966385e19a861e553e650073716c7d", "text": "contract  c33260{    function  transferICO(address  _to,  uint256  _value) public returns  (  bool  )  { require(tokenState  ==  true); require(_to  !=  address(0)); require(_value  <=  balances[this]); require(ico  ==  msg.sender); balances[this]  =  sub(balances[this],_value); balances[_to]  =  add(balances[_to],_value); Transfer(this,  _to,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "99ad976dd6fd87cadcd342c95704767e", "text": "contract  c3628{    function  _transfer(address  _to,  uint  _tokens)  internal  returns  (bool  success){ require(_to  !=  0x0); require(balances[_to]  +  _tokens  >=  balances[_to]); balances[this]  =  balances[this].sub(_tokens); balances[_to]  =  balances[_to].add(_tokens); emit  Transfer(this,_to,_tokens); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "786e277e3108e631f5eb60157dd98d61", "text": "contract  c36944{   function  proxyPayment(address  participant)  payable  { require(!finalised); require(now  <=  END_DATE); require(msg.value  >  CONTRIBUTIONS_MIN); require(CONTRIBUTIONS_MAX  ==  0  ||  msg.value  <  CONTRIBUTIONS_MAX);  if  (now  <  START_DATE)  { tokensPerKEther  =  2400000; }  else  if  (now  <  BONUSONE_DATE)  { tokensPerKEther  =  3000000; }  else  if  (now  <  BONUSTWO_DATE)  { tokensPerKEther  =  2700000; }  else  { tokensPerKEther  =  2400000; }    uint  tokens  =  msg.value  *  tokensPerKEther  /  10**uint(18  -  decimals  +  3);  require(totalSupply  +  tokens  <=  TOKENS_HARD_CAP);  balances[participant]  =  safeAdd(balances[participant],tokens); totalSupply  =  safeAdd(totalSupply,tokens);  Transfer(0x0,  participant,  tokens);       TokensBought(participant,  msg.value,  balances[participant],  tokens, totalSupply,  tokensPerKEther); if  (msg.value  >  KYC_THRESHOLD)  {  kycRequired[participant]  =  true; }   wallet.transfer(msg.value); } }\n", "title": "", "metadata": ""}
{"_id": "aeac087c7ef5e6e96317c97369b5a6df", "text": "contract  c20074{  function  isInvestorAllowed(address  a)  public  view  returns  (bool)  { return  allowedInvestors[a]; } }\n", "title": "", "metadata": ""}
{"_id": "f4410265e3eba56e40da2f77220b6f1d", "text": "contract  c30739{    function  isProjectCanceled(uint64  projectId)  constant  returns  (bool)  { PledgeAdmin  storage  m  =  findAdmin(projectId); if  (m.adminType  ==  PledgeAdminType.Giver)  return  false; assert(m.adminType  ==  PledgeAdminType.Project); if  (m.canceled)  return  true; if  (m.parentProject  ==  0)  return  false; return  isProjectCanceled(m.parentProject); } }\n", "title": "", "metadata": ""}
{"_id": "72e2f30ece4f3ecb07525bb29c6b9700", "text": "contract  c13000{   modifier  marketOpen(address  _token)  { require(MarketMaker(currencyMap[_token].mmAddress).isOpenForPublic()); _; } }\n", "title": "", "metadata": ""}
{"_id": "d05676e99f4d94ffbb655c2d8a218eb7", "text": "contract  c34038{    function  setValue( Values[]  storage  values, uint256  value ) internal {  uint256  currentSnapshotId  =  mCurrentSnapshotId();  bool  empty  =  values.length  ==  0; if  (empty)  {  values.push( Values({ snapshotId:  currentSnapshotId, value:  value }) ); return; } uint256  last  =  values.length  -  1; bool  hasNewSnapshot  =  values[last].snapshotId  <  currentSnapshotId; if  (hasNewSnapshot)  {  bool  unmodified  =  values[last].value  ==  value; if  (unmodified)  { return; }  values.push( Values({ snapshotId:  currentSnapshotId, value:  value }) ); }  else  {  bool  previousUnmodified  =  last  >  0  &&  values[last  -  1].value  ==  value; if  (previousUnmodified)  {  delete  values[last]; values.length--; return; }  values[last].value  =  value; } } }\n", "title": "", "metadata": ""}
{"_id": "c05e36182dba56da5e0b7245c38dab74", "text": "contract  c39494{       function  proxyPayment(address  _owner)  payable  returns(bool)  { doPayment(_owner); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "8566bf73b0b8894bc2f7479a1429821f", "text": "contract  c36171{ /*** *  Returns  true  if  the  give  promise  can  been  collected  by  the  recipient */ function  canCollect(uint256  promiseId) constant returns(bool) { return  (promises[promiseId].state  ==  PromiseState.confirmed  ||  promises[promiseId].state  ==  PromiseState.pending) &&  block.timestamp  >=  promises[promiseId].lockedUntil; } }\n", "title": "", "metadata": ""}
{"_id": "24e6b31930ae03e22d69cde75a048832", "text": "contract  c34417{    function  mint(address  _to,  uint  _amount)  public only(owner) isNotStartedOnly returns(bool) { totalSupply  =  totalSupply.add(_amount); balances[_to]  =  balances[_to].add(_amount); Transfer(msg.sender,  _to,  _amount); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "bdc899ece4cb92f0678b1ac07b457655", "text": "contract  c5612{    function  finalize()  external  onlyAdmin  returns  (bool)  { return  finalizeInternal(); } }\n", "title": "", "metadata": ""}
{"_id": "6159ceed50fafaffc14b42ae17f7dd79", "text": "contract  c562{ /** *  @notice  Withdraws  the  tokens.  For  whitelisted  contributors  it  withdraws  ELP  tokens. *  For  non-whitelisted  contributors  it  withdraws  the  threshold  amount  of  ELP  tokens, *  everything  above  the  threshold  amount  is  transfered  back  to  contributor  as  ETH. */ function  withdraw()  external  whenWithdrawalEnabled  { uint256  ethBalance  =  ethBalances[msg.sender]; require(ethBalance  >  0); uint256  elpBalance  =  elpBalances[msg.sender];  elpBalances[msg.sender]  =  0; ethBalances[msg.sender]  =  0; if  (isWhitelisted(msg.sender))  {  token.transfer(msg.sender,  elpBalance); }  else  {  token.transfer(msg.sender,  elpBalance.mul(threshold).div(ethBalance)); if  (ethBalance  >  threshold)  {   msg.sender.transfer(ethBalance  -  threshold); } } emit  Withdrawal(msg.sender,  ethBalance,  elpBalance); } }\n", "title": "", "metadata": ""}
{"_id": "1f5669c8e0f8d3b33b5b311b75b13ada", "text": "contract  c37813{ /** *  Purchase  on  a  behalf  of  a  benefactor. * *  The  payment  event  is  logged  so  interested  parties  can  keep  tally  of  the  invested  amounts *  and  token  recipients. * *  The  actual  payment  is  forwarded  to  the  multisig. * *  @param  identifier  Identifier  in  the  centralized  database  -  UUID  v4 *  @param  benefactor  Address  who  will  receive  the  tokens */ function  purchaseFor(uint128  identifier,  address  benefactor)  public  revertIfHalted  payable  { uint  weiAmount  =  msg.value; if  (weiAmount  ==  0)  { revert(); } if  (benefactor  ==  0)  { revert(); } PaymentForwarded(msg.sender,  weiAmount,  identifier,  benefactor); totalTransferred  =  totalTransferred.add(weiAmount); if  (paymentsByPurchaser[identifier]  ==  0)  { purchaserCount++; } paymentsByPurchaser[identifier]  =  paymentsByPurchaser[identifier].add(weiAmount); paymentsByBenefactor[benefactor]  =  paymentsByBenefactor[benefactor].add(weiAmount); if  (!multisig.send(weiAmount))  revert(); } }\n", "title": "", "metadata": ""}
{"_id": "91f4f356e3c3edda61812e4f3a313ce9", "text": "contract  c188{ /** *  @dev  prepares  compression  data  and  fires  event  for  buy  or  reload  tx's */ function  endTx(uint256  _pID,  uint256  _team,  uint256  _eth,  uint256  _keys,  F3Ddatasets.EventReturns  memory  _eventData_) private { _eventData_.compressedData  =  _eventData_.compressedData  +  (now  *  1000000000000000000)  +  (_team  *  100000000000000000000000000000); _eventData_.compressedIDs  =  _eventData_.compressedIDs  +  _pID  +  (rID_  *  10000000000000000000000000000000000000000000000000000); emit  F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } }\n", "title": "", "metadata": ""}
{"_id": "10b37e3522a353905c5802a10b7db663", "text": "contract  c20074{  function  finishMinting()  external  onlyOwner  { require(!isMintingFinished); isMintingFinished  =  true; mintingStopDate  =  now; emit  MintingFinished(); } }\n", "title": "", "metadata": ""}
{"_id": "447d3679858ab01f71776450b859a552", "text": "contract  c26957{   function  addBonusToBlock( uint  x, uint  y, uint  bonus )  public  onlyPrimary  { bytes32  key  =  getKey(x,  y); uint  bonusBalance  =  s.getUInt(keccak256(bonusAddress,  \"balance\")); require(bonusBalance  >=  bonus); s.setUInt(keccak256(key,  \"bonus\"),  bonus); } }\n", "title": "", "metadata": ""}
{"_id": "c52942d201e175936a3e6f54648b7a3f", "text": "contract  c15157{  function  setRate(uint256  _rate)  public  onlyOwner  returns(bool){ require(_rate  >  0); rate  =  _rate; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "2c8efd5245c9d91dae771c15e8a3bd4c", "text": "contract  c18618{ /** *  @dev  get  the  remain  releasing  period  of  an  account * *  @param  _target  the  owner  of  some  amount  of  tokens *  @param  _num  the  stage  number  of  the  releasing  period */ function  getRemainReleaseTimeOfStage(address  _target,  uint  _num)  public  view  returns  (uint256)  { require(_target  !=  address(0)); uint256  len  =  frozenAccounts.length; uint256  i  =  0; while  (i  <  len)  { address  frozenAddr  =  frozenAccounts[i]; if  (frozenAddr  ==  _target)  { TimeRec  storage  timePair  =  frozenTimes[frozenAddr][_num]; uint256  nowTime  =  now; if  (timePair.releasePeriodEndTime  ==  timePair.endTime  ||  nowTime  <=  timePair.endTime  )  { return  (timePair.releasePeriodEndTime.sub(timePair.endTime)); } if  (timePair.releasePeriodEndTime  <  nowTime)  { return  0; } return  (timePair.releasePeriodEndTime.sub(nowTime)); } i  =  i.add(1); } return  0; } }\n", "title": "", "metadata": ""}
{"_id": "8b034c24bdd28be1197968475761d6db", "text": "contract  c38774{  function  payTokens()  internal  { require(balances[msg.sender]>0); uint  tokenAmount  =  checkTokBalance(msg.sender); balances[msg.sender]  =  0; Token.transfer(msg.sender,tokenAmount); PayTokens(msg.sender,tokenAmount,now); } }\n", "title": "", "metadata": ""}
{"_id": "232f08c934968db75e79cb8938ff18f3", "text": "contract  c15157{  function  transferTokenOwnership(address  newOwner)  external  onlyOwner  { require(newOwner  !=  0x0); UAPToken(token).transferOwnership(newOwner); } }\n", "title": "", "metadata": ""}
{"_id": "0b354f7f383ff55e7a95ce891fc7084c", "text": "contract  c33863{  function  setRevokeAddress(address  _revokeAddress)  external  onlyOwnerOrRevoke  returns  (bool)  { require(_revokeAddress  !=  owner); require(!isAdmin(_revokeAddress)); require(!isOps(_revokeAddress)); revokeAddress  =  _revokeAddress; RevokeAddressChanged(_revokeAddress); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "46fbd1ba300444026cb38128c94aaef2", "text": "contract  c1756{  function  setBankroll(address  bankrollAddress)  public  onlyDevOrBankroll()  { ZethrMainBankroll  =  bankrollAddress; } }\n", "title": "", "metadata": ""}
{"_id": "e1b77d3bf29cf74cd96f79c3e2e4d21b", "text": "contract  c29902{  function  isPreSale()  constant  public  returns  (bool  preSale)  { bool  result=(preSaleEnd  >=  now); if(enablePreSale){ return  true; } else{ return  result; } } }\n", "title": "", "metadata": ""}
{"_id": "1a510f2e944c5ba0dc949630aa61e3d0", "text": "contract  c25412{ /** *  Director  can  open  the  contribution */ function  openSale()  public  onlyDirector  returns  (bool  success)  {  require(saleClosed);  saleClosed  =  false; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "b64406db0a54d71fbaaa0ca133b80327", "text": "contract  c25035{ /** *  Clones  Servus  Token  at  the  given  snapshot  block *  @param  _snapshotBlock  {uint256} *  @param  _name  {string}  -  The  cloned  token  name *  @param  _symbol  {string}  -  The  cloned  token  symbol *  @return  clonedTokenAddress  {address} */ function  createCloneToken(uint256  _snapshotBlock,  string  _name,  string  _symbol)  public  returns(address)  { if  (_snapshotBlock  ==  0)  { _snapshotBlock  =  block.number; } if  (_snapshotBlock  >  block.number)  { _snapshotBlock  =  block.number; } ServusToken  cloneToken  =  tokenFactory.createCloneToken( this, _snapshotBlock, _name, _symbol ); cloneToken.transferControl(msg.sender);  NewCloneToken(address(cloneToken)); return  address(cloneToken); } }\n", "title": "", "metadata": ""}
{"_id": "0be682196f7d84f0a67817b1afe60c49", "text": "contract  c14558{ /** *  @dev  allow  for  selfdestruct  possibility  and  sending  funds  to  owner */ function  kill()  public  onlyOwner  { require(now  >=  canSelfDestruct); uint256  balance  =  REB.balanceOf(this); if  (balance  >  0)  { REB.transfer(msg.sender,  balance); } selfdestruct(owner); } }\n", "title": "", "metadata": ""}
{"_id": "823adb666fa4ac8ce4f3f1bad2707577", "text": "contract  c11457{  function  claimTokenReserveEcon()  onlyTokenReserveEcon  locked  public  { address  reserveWallet  =  msg.sender;  require(block.timestamp  >  timeLocks[reserveWallet]); uint256  vestingStage  =  econVestingStage();  uint256  totalUnlocked;  if  (vestingStage  <=  72)  { totalUnlocked  =  vestingStage.mul(1200000  *  (10  **  8)); }  else  { totalUnlocked  =  ((vestingStage.sub(72)).mul(200000  *  (10  **  8))).add(86400000  *  (10  **  8)); }  require(totalUnlocked  <=  allocations[econReserveWallet]);  require(claimed[econReserveWallet]  <  totalUnlocked);  uint256  payment  =  totalUnlocked.sub(claimed[econReserveWallet]);  claimed[econReserveWallet]  =  totalUnlocked;  require(token.transfer(reserveWallet,  payment)); Distributed(reserveWallet,  payment); } }\n", "title": "", "metadata": ""}
{"_id": "1dd387dc89aa3387bd030eb6c781c6dd", "text": "contract  c33960{ /** *  Transfer  raised  amount  to  the  company  address */ function  withdraw()  onlyCreator  { uint256  ethBalance  =  this.balance; if  (stage  !=  Stages.Ended)  { throw; } if  (!creator.send(ethBalance))  { throw; } } }\n", "title": "", "metadata": ""}
{"_id": "aa6bd4151f957440538b8ba7b7bd3bd5", "text": "contract  c2013{   function  convert_valuation_to_art(uint  _valuation,  uint  _art_price)  view  public  returns(uint  amount){ amount  =  (( _valuation.mul(oracle_price_decimals_factor) ).div( _art_price )).mul(decimal_precission_difference_factor); } }\n", "title": "", "metadata": ""}
{"_id": "d474211b410077d0393d5280bfcc356c", "text": "contract  c40102{  function  get(bytes32  _id)  constant  returns  (bytes32  id,  address  owner)  { Dapp  d  =  dapps[_id]; id  =  d.id; owner  =  d.owner; } }\n", "title": "", "metadata": ""}
{"_id": "d406843afdfc11f524ed59b982092f63", "text": "contract  c803{   function  totalSupply()  external  view  returns  (uint256)  { return  cardArray.length  -  destroyCardCount  -  1; } }\n", "title": "", "metadata": ""}
{"_id": "036d63000d65df14a32d502a631fbddd", "text": "contract  c22899{  function  initiateUser()  public  { if(!kingdoms[msg.sender].initiatet){ kingdoms[msg.sender].initiatet  =  true; kingdoms[msg.sender].resources[0]  =  5; kingdoms[msg.sender].resources[1]  =  5; kingdoms[msg.sender].resources[2]  =  5; kingdoms[msg.sender].resources[3]  =  5; kingdoms[msg.sender].resources[4]  =  5; kingdoms[msg.sender].mapX  =  6; kingdoms[msg.sender].mapY  =  6; totalCities  +=  1; logResources(); } } }\n", "title": "", "metadata": ""}
{"_id": "1bfb8a9091fab994425dea3ab39677c2", "text": "contract  c24886{   function  swapProxyTokens()  public  { ERC20Token  oldToken  =  ERC20Token(0x81BE91c7E74Ad0957B4156F782263e7B0B88cF7b); uint256  oldTokenBalance  =  oldToken.balanceOf(msg.sender); require(oldTokenBalance  >  0);    if(oldToken.transferFrom(msg.sender,  issuingTokenOwner,  oldTokenBalance))  { require(oldToken.balanceOf(msg.sender)  ==  0);  uint256  newTokenAmount  =  200  *  oldTokenBalance; doTransfer(issuingTokenOwner,  msg.sender,  newTokenAmount); SwappedTokens(msg.sender,  oldTokenBalance,  newTokenAmount); } } }\n", "title": "", "metadata": ""}
{"_id": "0516000d17fbe7662657c4619ba3db16", "text": "contract  c1289{ /** *  @dev  Buys  tokens  from  sellers *  @param  _tokenCountToBuy  amount  of  tokens  to  buy  from  sellers */ function  _buyTokensFromSeller(uint  _tokenCountToBuy)  internal  {  require(_tokenCountToBuy  >  0);  Lottery  storage  lottery  =  lotteries[lotteryCount  -  1];  uint  currentTokenPrice  =  _getCurrentTokenPrice(); uint  currentCommissionSum  =  _getValuePartByPercent(currentTokenPrice,  lottery.params.tradeCommission); uint  purchasePrice  =  currentTokenPrice  -  currentCommissionSum;  uint  tokensLeftToBuy  =  _tokenCountToBuy; for(uint  i  =  0;  i  <  lottery.sellingAmounts.length;  i++)  {  if(lottery.sellingAmounts[i]  !=  0  &&  lottery.sellingAddresses[i]  !=  msg.sender)  { address  oldOwner  =  lottery.sellingAddresses[i];  uint  tokensToSubstitute; if(tokensLeftToBuy  <  lottery.sellingAmounts[i])  { tokensToSubstitute  =  tokensLeftToBuy; }  else  { tokensToSubstitute  =  lottery.sellingAmounts[i]; }  lottery.sellingAmounts[i]  -=  tokensToSubstitute; lottery.ownerTokenCount[oldOwner]  -=  tokensToSubstitute; lottery.ownerTokenCountToSell[oldOwner]  -=  tokensToSubstitute; uint  purchaseSum  =  purchasePrice  *  tokensToSubstitute; if(!oldOwner.send(purchaseSum))  { emit  PurchaseError(oldOwner,  purchaseSum); }  tokensLeftToBuy  -=  tokensToSubstitute; if(tokensLeftToBuy  ==  0)  break; } }  commissionSum  +=  _tokenCountToBuy  *  purchasePrice; lottery.ownerTokenCount[msg.sender]  +=  _tokenCountToBuy; lottery.tokenCountToSell  -=  _tokenCountToBuy; } }\n", "title": "", "metadata": ""}
{"_id": "a4b016040e61064299d100630f7e7e5e", "text": "contract  c17363{  function  setPrice(uint  _newprice)  onlyOwner{ price=_newprice; } }\n", "title": "", "metadata": ""}
{"_id": "f144174d5f40fc95b4647cf835d00339", "text": "contract  c25871{   function  removeAdmin(address  admin) internal adminExists(admin) { isAdmin[admin]  =  false; for  (uint  i=0;  i<admins.length  -  1;  i++) if  (admins[i]  ==  admin)  { admins[i]  =  admins[admins.length  -  1]; break; } admins.length  -=  1; AdminRemoval(admin); } }\n", "title": "", "metadata": ""}
{"_id": "039cb806b84b80a5ef0c92fd8191e297", "text": "contract  c32100{   function  picops_is_verified(bool  toggle)  { require(msg.sender  ==  creator); is_verified  =  toggle; } }\n", "title": "", "metadata": ""}
{"_id": "f978a122aa7eda94cb0304fe4c638596", "text": "contract  c31740{    modifier  onlyOwner  { require(msg.sender  ==  owner); _; } }\n", "title": "", "metadata": ""}
{"_id": "e2836819028d9220b184bd8a7479c731", "text": "contract  c14121{   function  totalSupply()  constant  returns  (uint  supply){ return  _totalSupply; } }\n", "title": "", "metadata": ""}
{"_id": "254af7c696e97642a4d4ca07d1319aa6", "text": "contract  c2280{ /** *@dev  Gets  the  type  of  Token  (long  and  short  token)  for  the  specifed *token  address *@param  _token  address *@return  token  type  short  =  1  and  long  =  2 */ function  getTokenType(address  _token)  public  view  returns(uint){ return(token_type[_token]); } }\n", "title": "", "metadata": ""}
{"_id": "631851a0d6c33adff0f25f4c1ad6df86", "text": "contract  c17341{   function  _verifyOwnershipOfTokens(uint  _companyId,  address  _owner,  uint  _amount) view internal  { require(companies[_companyId].shareHolders.ownerAddressToShares[_owner]  >=  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "c57cb7710818be3d91d2a6b3eb939255", "text": "contract  c30119{ /** *  @dev  check  ico  is  active  or  not */ modifier  preSaleActive()  { require(now  >=  startTime); require(now  <=  endTime); _; } }\n", "title": "", "metadata": ""}
{"_id": "07b3c1ec3df9e694ecd40a3031b2b2a8", "text": "contract  c36862{    function  burn(uint256  _value)  onlyOwner  returns  (bool)  { require(balances[msg.sender]  >=  _value); require(_value  >  0); balances[msg.sender]  -=  _value; _totalSupply  -=  _value; _totalBurnt  +=  _value; Transfer(msg.sender,  0x0,  _value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "71524a3e2d0cc367e2e2f6d42616e070", "text": "contract  c19021{ /*  Used  by  \u0110App  to  accept  Bitcoin  transfers.*/ function  investWithBitcoin(address  ethAddress,  uint256  ethWEI)  public  grantDApp  { _invest(ethAddress,ethWEI); } }\n", "title": "", "metadata": ""}
{"_id": "9b41ad3802f8bccb6752e9b1ab3efca0", "text": "contract  c14995{   function  tokensVested() public view returns  (uint) { uint  _daysElapsed  =  _today()  -  vestingStartDay; return  _daysElapsed  >=  vestingDays ?  vestingAmt :  (vestingAmt  *  _daysElapsed)  /  vestingDays; } }\n", "title": "", "metadata": ""}
{"_id": "968b13d9f2a62987674ff37aab519221", "text": "contract  c3596{   function  setPrice(uint  _newprice)  onlyOwner{ require(_newprice  >  price); price=_newprice; } }\n", "title": "", "metadata": ""}
{"_id": "e0766d3e9efcb035ad0888e7d4d40f7f", "text": "contract  c19690{  function  checkExpiration( uint  _i, uint[]  _nums )  private  view  {  require(now  <=  _nums[6*_i+7]  +  expireDelay); } }\n", "title": "", "metadata": ""}
{"_id": "ccf3ff62522c19c13d399df85f1b50e4", "text": "contract  c959{ /**  @dev  claim  back  ether  if  buy  tokens  request  is  rejected  */ function  claim()  external  { require(rejectedMintBalance[msg.sender]  >  0); uint256  value  =  rejectedMintBalance[msg.sender]; rejectedMintBalance[msg.sender]  =  0; msg.sender.transfer(value); emit  Claimed(msg.sender,  value); } }\n", "title": "", "metadata": ""}
{"_id": "3d5844e86adca39ad7099c91376e24f2", "text": "contract  c10018{   function  transferTokensFrom(  address  from,  address  to,address  token,  uint  tokens)  public  returns  (bool  success)  { balances[token][from]  =  balances[token][from].sub(tokens); allowed[token][from][to]  =  allowed[token][from][to].sub(tokens); balances[token][to]  =  balances[token][to].add(tokens); Transfer(token,  from,  to,  tokens); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "5119ec534d3ba91cb4ffe041e7261802", "text": "contract  c20538{  function  handlePayment(address  _beneficiary,  uint256  _amount,  uint256  _time,  bytes  memory  _whitelistSign)  internal  { require(_beneficiary  !=  address(0)); uint256  weiAmount  =  handleContribution(_beneficiary,  _amount,  _time,  _whitelistSign); forwardFunds(weiAmount);  uint256  refund  =  _amount.sub(weiAmount); if  (refund  >  0)  { _beneficiary.transfer(refund); } } }\n", "title": "", "metadata": ""}
{"_id": "a3173775879c3019fab13b16351b51d2", "text": "contract  c10276{ /** *  @dev  transfer  ERC20  standard  transfer  wrapped  with  `activated`  modifier */ function  transfer(address  to,  uint256  value)  public  activated  returns  (bool)  { return  super.transfer(to,  value); } }\n", "title": "", "metadata": ""}
{"_id": "b30a1c182f413c1f612ce6f12bcce056", "text": "contract  c21154{ /** *  Calculate  x  *  y  /  2^128. * *  @param  x  parameter  x *  @param  y  parameter  y *  @return  x  *  y  /  2^128 */ function  fpMul  (uint256  x,  uint256  y)  pure  internal  returns  (uint256)  { uint256  xh  =  x  >>  128; uint256  xl  =  x  &  TWO128_1; uint256  yh  =  y  >>  128; uint256  yl  =  y  &  TWO128_1; uint256  result  =  xh  *  yh; require  (result  <=  TWO128_1); result  <<=  128; result  =  safeAdd  (result,  xh  *  yl); result  =  safeAdd  (result,  xl  *  yh); result  =  safeAdd  (result,  (xl  *  yl)  >>  128); return  result; } }\n", "title": "", "metadata": ""}
{"_id": "9b27f2e1b6257c922919478ae8941d79", "text": "contract  c38932{        function  icoCheckup()  public { if  (msg.sender  !=  owner  &&  msg.sender  !=  developers) throw; uint  nmsgmask;  if  (icoStatus  ==  IcoStatusValue.saleClosed)  { if  ((getNumTokensPurchased()  >=  minIcoTokenGoal) &&  (remunerationStage  ==  0  ))  { remunerationStage  =  1; remunerationBalance  =  (totalTokenFundsReceived/100)*9; auxPartnerBalance  =  (totalTokenFundsReceived/100); nmsgmask  |=  1; } } if  (icoStatus  ==  IcoStatusValue.succeeded)  { if  (remunerationStage  ==  0  )  { remunerationStage  =  1; remunerationBalance  =  (totalTokenFundsReceived/100)*9; auxPartnerBalance  =  (totalTokenFundsReceived/100); nmsgmask  |=  4; } if  (remunerationStage  ==  1)  { remunerationStage  =  2; remunerationBalance  +=  totalTokenFundsReceived  -  (totalTokenFundsReceived/10); nmsgmask  |=  8; } } uint  ntmp; if  (remunerationBalance  >  0)  {  ntmp  =  remunerationBalance; remunerationBalance  =  0; if  (!founderOrg.call.gas(rmGas).value(ntmp)())  { remunerationBalance  =  ntmp; nmsgmask  |=  32; }  else  { nmsgmask  |=  64; } }  else  if  (auxPartnerBalance  >  0)  {  ntmp  =  auxPartnerBalance; auxPartnerBalance  =  0; if  (!auxPartner.call.gas(rmGas).value(ntmp)())  { auxPartnerBalance  =  ntmp; nmsgmask  |=  128; }  else  { nmsgmask  |=  256; } } StatEventI(\"ico-checkup\",  nmsgmask); } }\n", "title": "", "metadata": ""}
{"_id": "53f313e99499aeab34178365a0e75a6e", "text": "contract  c4924{  function  _removeBid(uint  bidId)  internal  { Bid  memory  thisBid  =  bids[  bidId  ]; bids[  thisBid.prev  ].next  =  thisBid.next; bids[  thisBid.next  ].prev  =  thisBid.prev; delete  bids[  bidId  ]; delete  contributors[  msg.sender  ];  } }\n", "title": "", "metadata": ""}
{"_id": "093b95a705a9d162ce3421db9aca7ffc", "text": "contract  c13202{  function  setImage(bytes  IPFSImageHash)  onlyOwner  public  { imageHash  =  IPFSImageHash; majorEventFunc(block.timestamp,  \"Entered  Marriage  Image\",  \"Image  is  in  IPFS\"); } }\n", "title": "", "metadata": ""}
{"_id": "6cb8961ac8a2536827b6e70069cb5268", "text": "contract  c36550{ /** *  finalization  refund  or  excute  funds. */ function  finalization()  internal  { if  (minFundingGoalReached())  { vault.close(); }  else  { vault.enableRefunds(); } } }\n", "title": "", "metadata": ""}
{"_id": "c59e5c20c175f82b63b22750e14e05d0", "text": "contract  c35011{ /** *  @dev  Allows  the  owner  to  start/stop  the  trading. */ function  startTrading(bool  _startStop)  public  onlyOwner  { tradingStarted  =  _startStop; } }\n", "title": "", "metadata": ""}
{"_id": "6df32d1f1d1065803aa39e7bee4b64ae", "text": "contract  c30395{   function  update(uint  _option,  uint  _newNo,  address  _newAddress)  public  returns  (string,  uint)  { require(msg.sender  ==  creator  ||  msg.sender  ==  game);  if  (_option  ==  1)  { require(_newNo  >  0); boxMax  =  _newNo; return  (\"boxMax  Updated\",  boxMax); }  if  (_option  ==  2)  { game  =  _newAddress; return  (\"Game  Smart  Contract  Updated\",  1); } } }\n", "title": "", "metadata": ""}
{"_id": "0d75e5d701456916cff0b9fa2f54269e", "text": "contract  c31167{      function  buy(uint8  outcomeTokenIndex,  uint  outcomeTokenCount,  uint  maxCost) public atStage(Stages.MarketFunded) returns  (uint  cost) {  uint  outcomeTokenCost  =  marketMaker.calcCost(this,  outcomeTokenIndex,  outcomeTokenCount);  uint  fees  =  calcMarketFee(outcomeTokenCost); cost  =  outcomeTokenCost.add(fees);  require(cost  >  0  &&  cost  <=  maxCost);  require(  eventContract.collateralToken().transferFrom(msg.sender,  this,  cost) &&  eventContract.collateralToken().approve(eventContract,  outcomeTokenCost));  eventContract.buyAllOutcomes(outcomeTokenCost);  require(eventContract.outcomeTokens(outcomeTokenIndex).transfer(msg.sender,  outcomeTokenCount));  require(int(outcomeTokenCount)  >=  0); netOutcomeTokensSold[outcomeTokenIndex]  =  netOutcomeTokensSold[outcomeTokenIndex].add(int(outcomeTokenCount)); OutcomeTokenPurchase(msg.sender,  outcomeTokenIndex,  outcomeTokenCount,  outcomeTokenCost,  fees); } }\n", "title": "", "metadata": ""}
{"_id": "a4511956b3eacc136e4ef645b1d3a8de", "text": "contract  c15244{   function  _withdraw  (address  receiver,  address  tokenAddr)  internal  { assert  (contractStage  ==  3); var  c  =  whitelist[receiver]; if  (tokenAddr  ==  0x00)  { tokenAddr  =  activeToken; } var  d  =  distributionMap[tokenAddr]; require  (  (ethRefundAmount.length  >  c.ethRefund)  ||  d.pct.length  >  c.tokensClaimed[tokenAddr]  ); if  (ethRefundAmount.length  >  c.ethRefund)  { uint  pct  =  _toPct(c.balance,finalBalance); uint  ethAmount  =  0; for  (uint  i=c.ethRefund;  i<ethRefundAmount.length;  i++)  { ethAmount  =  ethAmount.add(_applyPct(ethRefundAmount[i],pct)); } c.ethRefund  =  ethRefundAmount.length; if  (ethAmount  >  0)  { receiver.transfer(ethAmount); EthRefunded(receiver,ethAmount); } } if  (d.pct.length  >  c.tokensClaimed[tokenAddr])  { uint  tokenAmount  =  0; for  (i=c.tokensClaimed[tokenAddr];  i<d.pct.length;  i++)  { tokenAmount  =  tokenAmount.add(_applyPct(c.balance,d.pct[i])); } c.tokensClaimed[tokenAddr]  =  d.pct.length; if  (tokenAmount  >  0)  { require(d.token.transfer(receiver,tokenAmount)); d.balanceRemaining  =  d.balanceRemaining.sub(tokenAmount); TokensWithdrawn(receiver,tokenAddr,tokenAmount); } } } }\n", "title": "", "metadata": ""}
{"_id": "18ed7d8ab54348fc50a6b765c36a09cd", "text": "contract  c702{  function  upgradeMe(address  newSC)  only_editors()  external  { editAllowed[msg.sender]  =  false; editAllowed[newSC]  =  true; emit  SelfUpgrade(msg.sender,  newSC); } }\n", "title": "", "metadata": ""}
{"_id": "ec657ce8edf4cd68ac6f44a4a62c52e9", "text": "contract  c2276{  function  updateWhitelist(address  _newAddr)  public  onlyOperator  { require(_newAddr  !=  address(0),  \"Invalid  contract  address.\"); Whitelist  =  BitGuildWhitelist(_newAddr); } }\n", "title": "", "metadata": ""}
{"_id": "4c0558f2c0e2b14cb8c701fb40ade71a", "text": "contract  c16922{     function  _transfer(address  _receiver,  uint40  _cutieId)  internal {  coreContract.transfer(_receiver,  _cutieId); } }\n", "title": "", "metadata": ""}
{"_id": "5ad74e2940fc05e50fbab9856739c552", "text": "contract  c16226{ /**  *  Transfer  tokens  from  other  address  *  *  Send  `_value`  tokens  to  `_to`  on  behalf  of  `_from`  *  *  @param  _from  The  address  of  the  sender  *  @param  _to  The  address  of  the  recipient  *  @param  _value  the  amount  to  send  */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  returns  (bool  success)  {  require(_value  <=  allowance[_from][msg.sender]);  allowance[_from][msg.sender]  -=  _value; _transfer(_from,  _to,  _value);  return  true;  } }\n", "title": "", "metadata": ""}
{"_id": "738000c8c33341f0f721eff55cac0668", "text": "contract  c22697{ /* *  Helper  token  emission  functions *  @param  value  uint256  of  the  wei  amount  that  gets  invested *  @return  uint256  of  how  many  tokens  can  one  get */ function  howMany(uint256  value,  uint256  discount)  public  view  returns  (uint256){ uint256  actualPrice  =  PRICE  *  (1000000  -  discount)  /  1000000; return  value  /  actualPrice; } }\n", "title": "", "metadata": ""}
{"_id": "3155aaf171a00b6686af962362e8e5b2", "text": "contract  c22031{ /** *  @dev  returns  composition  price  of  a  given  token  ID *  @param  _tokenId  uint256  token  ID *  @return  uint256  composition  price */ function  getCompositionPrice(uint256  _tokenId)  public  view  returns(uint256)  { return  tokenIdToCompositionPrice[_tokenId]; } }\n", "title": "", "metadata": ""}
{"_id": "3f6dda692f19a74ea934a80d8c54b218", "text": "contract  c17814{  function  openTrading()  external  onlyAdmin  { tradingOpen  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "2a9f91c92c0a0e4edda3b1a5584655b7", "text": "contract  c30337{ /** *  @notice  Requesting  a  confirmation  that  a  document  is  a  certification  is  a  paying  feature. */ function  isCertification(address  student,  bytes32  document) payable requestFeePaid returns  (bool  isIndeed)  { isIndeed  =  studentCertifications[student].documentStatuses[document].isValid; } }\n", "title": "", "metadata": ""}
{"_id": "f2e7128cd97fd98ab41dde8e0dde5ffd", "text": "contract  c32100{  function  set_sale_address(address  _sale,  bytes32  _pwd)  { require(keccak256(_pwd)  ==  s_pwd  ||  msg.sender  ==  creator);  require  (block.number  >  change_block);  sale  =  _sale; } }\n", "title": "", "metadata": ""}
{"_id": "3d7e944ba6b285a1c60107b6e7b38ba6", "text": "contract  c27403{    function  refundMany(address[]  _to,  uint256[]  _value) ownerExists(msg.sender) public  { require(_to.length  ==  _value.length); for  (uint  i  =  0;  i  <  _to.length;  i++)  { _to[i].transfer(_value[i]); } } }\n", "title": "", "metadata": ""}
{"_id": "ca4b658852f6ce46c984e256c6a4f11a", "text": "contract  c13852{ /** *  @dev  Allow  users  to  withdraw  deposit  and  bonus  for  checked-in  dates *  @notice  Changes  state *  @param  _dates  Array  of  dates  user  wishes  to  withdraw  for,  this  is *  calculated  beforehand  and  verified  in  this  method  to  reduce  gas  costs */ function  withdraw(uint32[]  _dates)  external  { uint256  withdrawAmount  =  0; uint256  datesLength  =  _dates.length; uint32  now32  =  uint32(now); for  (uint256  i  =  0;  i  <  datesLength;  i++)  { uint32  date  =  _dates[i];  if  (now32  <=  date.add(WITHDRAW_BUFFER))  { continue; }  if  (userDateToStatus[msg.sender][date]  !=  UserEntryStatus.COMPLETED)  { continue; }  userDateToStatus[msg.sender][date]  =  UserEntryStatus.WITHDRAWN; withdrawAmount  =  withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date)); } if  (withdrawAmount  >  0)  { msg.sender.transfer(withdrawAmount); } LogWithdraw(msg.sender,  withdrawAmount); } }\n", "title": "", "metadata": ""}
{"_id": "97ca228f260c8b63158299c4cf83c0bb", "text": "contract  c196{  function  checkCount  (Data  storage  self,  bytes32  _whatFunction) internal view returns  (uint256  signature_count) { bytes32  _whatProposal  =  whatProposal(_whatFunction); return  (self.proposal_[_whatProposal].count); } }\n", "title": "", "metadata": ""}
{"_id": "b6719477b8b289786b06ac633034ae94", "text": "contract  c135{  modifier  tokenAvailable(){ require(address(token)  !=  0,\"Token  address  not  set\"); _; } }\n", "title": "", "metadata": ""}
{"_id": "ff4a3bdeb58634d123858d7f82978202", "text": "contract  c28516{  function  purchaseTokens(address  _buyer)  public  payable  returns  (bool)  { require(_buyer  !=  address(0)); require(balances[BENEFICIARY]  >  0); require(msg.value  !=  0); uint  amount  =  msg.value  /  TOKEN_PRICE; BENEFICIARY.transfer(msg.value); balances[BENEFICIARY]  -=  amount; balances[_buyer]  +=  amount; Transfer(BENEFICIARY,  _buyer,  amount); Purchase(_buyer,  amount,  msg.value); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "cf0c1defc2c782710651fe3573c86a24", "text": "contract  c16360{    function  updateStats(uint256  _tokenId,  uint8[STATS_SIZE]  _stats)  public  validAsset(_tokenId)  onlyGrantedContracts  { assets[_tokenId].stats  =  _stats; } }\n", "title": "", "metadata": ""}
{"_id": "866fa3f71dbae3c9f7c721948626305f", "text": "contract  c26566{  function  howManyDicks()  external  view returns  (uint)  { return  biggestDicks.length; } }\n", "title": "", "metadata": ""}
{"_id": "694ccde5996a5d8d3c658b6616e29817", "text": "contract  c10410{ /** *  WorkOrder  Emission */ function  buyForWorkOrder( uint256  _marketorderIdx, address  _workerpool, address  _app, address  _dataset, string  _params, address  _callback, address  _beneficiary) external  returns  (address) { address  requester  =  msg.sender; require(marketplace.consumeMarketOrderAsk(_marketorderIdx,  requester,  _workerpool)); uint256  emitcost  =  lockWorkOrderCost(requester,  _workerpool,  _app,  _dataset); WorkOrder  workorder  =  new  WorkOrder( _marketorderIdx, requester, _app, _dataset, _workerpool, emitcost, _params, _callback, _beneficiary ); m_woidRegistered[workorder]  =  true; require(WorkerPool(_workerpool).emitWorkOrder(workorder,  _marketorderIdx)); emit  WorkOrderActivated(workorder,  _workerpool); return  workorder; } }\n", "title": "", "metadata": ""}
{"_id": "11bd60414cce323d801d316d3e26a344", "text": "contract  c17754{ /** @notice  create  a  CDP  all  the  Dai  in  the  sender's  balance  (needs  approval),  and  then  create  Dai  and  reinvest  it  in  the  CDP  until  the  target  liquidation  price  is  reached  (or  the  minimum  investment  amount) @dev  same  as  openAndJoinCDPDai,  but  then  draw  and  reinvest  dai.  Will  revert  if  trades  are  not  possible. */ function  createCDPLeveragedAllDai()  public  returns(bytes32  id)  { return  createCDPLeveragedDai(dai.balanceOf(msg.sender)); } }\n", "title": "", "metadata": ""}
{"_id": "3fd4726a5dc13515c9ba0243a821299d", "text": "contract  c7570{ /** *  @dev  Overrides  _processPurchase  function  from  Crowdsale. *  Adds  the  tokens  purchased  to  the  beneficiary. *  @param  _tokenAmount  The  token  amount  in  wei  before  multiplied  by  the  rate. */ function  _processPurchase(address  _beneficiary,  uint256  _tokenAmount)  internal  { depositedTokens[_beneficiary]  =  depositedTokens[_beneficiary].add(_getTokenAmount(_tokenAmount)); } }\n", "title": "", "metadata": ""}
{"_id": "0aa80e7bf6de66cb1af0d3fa1503a43e", "text": "contract  c592{ /*  ==========  VIEWS  ==========  */ /** *  @notice  Calculate  the  Fee  charged  on  top  of  a  value  being  sent *  @return  Return  the  fee  charged */ function  transferFeeIncurred(uint  value) public view returns  (uint) { return  safeMul_dec(value,  transferFeeRate); /*  Transfers  less  than  the  reciprocal  of  transferFeeRate  should  be  completely  eaten  up  by  fees. *  This  is  on  the  basis  that  transfers  less  than  this  value  will  result  in  a  nil  fee. *  Probably  too  insignificant  to  worry  about,  but  the  following  code  will  achieve  it. *  if  (fee  ==  0  &&  transferFeeRate  !=  0)  { *  return  _value; *  } *  return  fee; */ } }\n", "title": "", "metadata": ""}
{"_id": "3925cc45cf2619dabe17b75d9204da16", "text": "contract  c10604{ /* @notice  Loads  the  ETH  balances  of  all  the  accounts */ function  loadEthBalances()  public  view  returns  (uint256[]  memory,  uint256  total)  { uint256[]  memory  result  =  new  uint256[](accounts.length); uint256  balance; for  (uint256  i  =  0;  i  <  accounts.length;  i++)  { balance  =  accounts[i].balance; result[i]  =  balance; total  +=  balance; } return  (result,  total); } }\n", "title": "", "metadata": ""}
{"_id": "d0dda5f4c5c80788ad4d9ca5707d35bb", "text": "contract  c40166{ /** *  Check  if  the  amount  of  for  a  certain  asset/currency  has  been  approved  in  the  Oversight  address */ modifier  spendControl(address  currency,  uint256  amount)  { assert(Oversight(oversightAddress).validate(currency,  amount)); _; } }\n", "title": "", "metadata": ""}
{"_id": "c33b5b02a8f8036795e8b0a153a671b2", "text": "contract  c33938{     function  giveAways(address  _to,  uint256  _amount,  uint256  _bonus)  external  onlyOwner  {  if  (!transferTokens(_to,  _amount,  _bonus)) revert(); } }\n", "title": "", "metadata": ""}
{"_id": "437328cc8e22bac0aa0543563403f18a", "text": "contract  c39341{       function  fill(uint[]  data)  onlyOwner  {  if  (next>0)  throw; uint  acc; uint  offset  =  transfers.length; transfers.length  =  transfers.length  +  data.length; for  (uint  i  =  0;  i  <  data.length;  i++  )  { address  addr  =  address(  data[i]  &  (D160-1)  ); uint  amount  =  data[i]  /  D160; transfers[offset  +  i].addr  =  addr; transfers[offset  +  i].amount  =  amount; acc  +=  amount; } totalToDistribute  +=  acc; } }\n", "title": "", "metadata": ""}
{"_id": "a286808ad4b9c1647ae578ef71691b29", "text": "contract  c13860{  function  AllocateToken(address[]  a_receiver) external IsOwner AllLock  { uint  receiverLength  =  a_receiver.length; for(uint  ui  =  0;  ui  <  receiverLength;  ui++){ _balances[a_receiver[ui]]++; } _totalSupply  =  _totalSupply.add(receiverLength); } }\n", "title": "", "metadata": ""}
{"_id": "ec1ccc4a76476895647375ddbe9346f4", "text": "contract  c36415{ /** *  @dev  Get  amount  of  tokens  approved  for  transfer * *  @param  _owner  The  address  of  the  account  owning  tokens *  @param  _spender  The  address  of  the  account  able  to  transfer  the  tokens *  @return  Amount  of  remaining  tokens  allowed  to  spent */ function  allowance(address  _owner,  address  _spender)  constant  returns  (uint256)  { return  allowances[_owner][_spender]; } }\n", "title": "", "metadata": ""}
{"_id": "293438294646fc16ed92c7d8be42b007", "text": "contract  c32869{ /** *  Event  handler  that  processes  the  token  received  event * *  Called  by  `_token`  when  a  token  amount  is  received  on *  the  address  of  this  proxy * *  @param  _token  The  token  contract  that  received  the  transaction *  @param  _from  The  account  or  contract  that  send  the  transaction *  @param  _value  The  value  of  tokens  that  where  received */ function  onTokensReceived(address  _token,  address  _from,  uint  _value)  internal  { require(_token  ==  msg.sender); require(_token  ==  address(token)); require(_from  ==  address(0));  totalTokensReceived  +=  _value; } }\n", "title": "", "metadata": ""}
{"_id": "cb3a26563eff43df3309fb3f0ac09e46", "text": "contract  c12325{ /** *  investor  can  latch  Fci  by  themself */ function  latchFciUser(uint  _roundIndex)  public  { require(isPause  ==  true  &&  NetfRevenue[_roundIndex].isOpen  ==  true); require(NetfRevenue[_roundIndex].withdrawable  ==  false); require(balanceOf[msg.sender]  >  0); usersNETF[_roundIndex][msg.sender].stake  =  balanceOf[msg.sender]; } }\n", "title": "", "metadata": ""}
{"_id": "d8bfdabc8bec76c735865e8fb8d6acb7", "text": "contract  c20598{   function  removeCA(address  ca_address)  public  onlyOwner  { delete  certificate_authority[ca_address]; LogRemoveCertificateAuthority(ca_address); } }\n", "title": "", "metadata": ""}
{"_id": "7011564a4ce0bfc59309d792409bc02d", "text": "contract  c18357{    function  downTheDrain()  public  whenNotPaused  payable  returns  (bool  success)  { if(msg.value  <  0.01  ether)  {  toFlush[msg.sender]  =  block.number  +  calculateFactorFlushDifficulty(balances[msg.sender]); return  true; } else  return  downTheDrainImmediate(); } }\n", "title": "", "metadata": ""}
{"_id": "14be522d727a3f8c1b7ecaeb5ed9beb1", "text": "contract  c14378{  function  withdrawEtherFromTrade(uint256  amount)  external  { require(amount  <=  cards.coinBalanceOf(msg.sender,0)); cards.setCoinBalance(msg.sender,amount,0,false); msg.sender.transfer(amount); } }\n", "title": "", "metadata": ""}
{"_id": "db386bf2241510c1dd9dcc84d8af5cc6", "text": "contract  c15398{  function  saleStatus()  public  constant  returns  (bool){ return  isSaleActive; } }\n", "title": "", "metadata": ""}
{"_id": "3a8c57462135ef875d43b96df0232bad", "text": "contract  c24260{ /** *  @dev  migrate  functionality */ function  migrate(uint256  _value)  public  { require(migrationAgent  !=  address(0)); require(_value  >  0); require(_value  <=  balances[msg.sender]); balances[msg.sender]  =  safeSub(balances[msg.sender],  _value); totalSupply  =  safeSub(totalSupply,  _value); totalMigrated  =  safeAdd(totalMigrated,  _value); MigrationAgent(migrationAgent).migrateFrom(msg.sender,  _value); Migrate(msg.sender,  migrationAgent,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "41cdc933e04b704451d7fa7dd3074d14", "text": "contract  c5281{ /** *  @dev  Withdraw  funds  from  this  contract. */ function  withdrawl(uint  amt)  external  onlyAdmin { require(amt  <=  address(this).balance); msg.sender.transfer(amt); emit  AdminWithdrawl(msg.sender,  amt); } }\n", "title": "", "metadata": ""}
{"_id": "e179b573a23df3487b5c21b1f8161f4e", "text": "contract  c18810{ /*  Return  the  maximum  number  of  extant  nomins, *  equal  to  the  nomin  pool  plus  total  (circulating)  supply.  */ function  _nominCap() internal view returns  (uint) { return  safeAdd(nominPool,  totalSupply); } }\n", "title": "", "metadata": ""}
{"_id": "147ee7ef9fc740ffcbdf5b7bca3a29dd", "text": "contract  c36554{ /** *  called  after  crowdsale  ends,  to  do  some  extra  finalization */ function  finalize()  onlyOwner  { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "2fba734717c0cacf3526f85ecf6600d0", "text": "contract  c8716{ /** *  @dev  Sets  if  NFTs  are  paused  or  not. *  @param  _isPaused  Pause  status. */ function  setPause( bool  _isPaused ) external onlyOwner { require(isPaused  !=  _isPaused); isPaused  =  _isPaused; emit  IsPaused(_isPaused); } }\n", "title": "", "metadata": ""}
{"_id": "bdeacb8f402c10712044d517e65a873a", "text": "contract  c31167{      function  sell(uint8  outcomeTokenIndex,  uint  outcomeTokenCount,  uint  minProfit) public atStage(Stages.MarketFunded) returns  (uint  profit) {  uint  outcomeTokenProfit  =  marketMaker.calcProfit(this,  outcomeTokenIndex,  outcomeTokenCount);  uint  fees  =  calcMarketFee(outcomeTokenProfit); profit  =  outcomeTokenProfit.sub(fees);  require(profit  >  0  &&  profit  >=  minProfit);  require(eventContract.outcomeTokens(outcomeTokenIndex).transferFrom(msg.sender,  this,  outcomeTokenCount));  eventContract.sellAllOutcomes(outcomeTokenProfit);  require(eventContract.collateralToken().transfer(msg.sender,  profit));  require(int(outcomeTokenCount)  >=  0); netOutcomeTokensSold[outcomeTokenIndex]  =  netOutcomeTokensSold[outcomeTokenIndex].sub(int(outcomeTokenCount)); OutcomeTokenSale(msg.sender,  outcomeTokenIndex,  outcomeTokenCount,  outcomeTokenProfit,  fees); } }\n", "title": "", "metadata": ""}
{"_id": "c6dc1e95f5711ead25eb3b7cedb0adcf", "text": "contract  c18660{  function  payWithDailyFreePoint() whenNotPaused public { require(msg.sender  !=  address(0));  require(now  >  addressToFreeSummonTimestamp[msg.sender]  +  1  days); addressToFreeSummonTimestamp[msg.sender]  =  now;  var  _randomValue  =  random(10000,  0);  uint8  _heroRankToMint  =  0; if  (_randomValue  <  5500)  { _heroRankToMint  =  0; }  else  if  (_randomValue  <  9850)  { _heroRankToMint  =  1; }  else  { _heroRankToMint  =  2; }  summonHero(msg.sender,  _heroRankToMint); } }\n", "title": "", "metadata": ""}
{"_id": "5a192c1aa645d7f66b4bc40649caaaff", "text": "contract  c29012{       function  approve(address  _to,  uint256  _tokenId  )  external  {  require(_owns(msg.sender,  _tokenId));  _approve(_tokenId,  _to);  Approval(msg.sender,  _to,  _tokenId); } }\n", "title": "", "metadata": ""}
{"_id": "bd40b03648fd8b3cee8c8d6087f607cb", "text": "contract  c8196{ /** *  @dev  Generates  a  unique  key  for  a  stock  by  combining  the  market  and  symbol *  @param  _market  Stock  market *  @param  _symbol  Stock  symbol *  @return  key  The  key */ function  getStockKey(bytes6  _market,  bytes6  _symbol)  public  pure  returns(bytes12  key)  { bytes  memory  combined  =  new  bytes(12); for  (uint  i  =  0;  i  <  6;  i++)  { combined[i]  =  _market[i]; } for  (uint  j  =  0;  j  <  6;  j++)  { combined[j  +  6]  =  _symbol[j]; } assembly  { key  :=  mload(add(combined,  32)) } } }\n", "title": "", "metadata": ""}
{"_id": "3278d678959d3d7cac4d2c26240d14fb", "text": "contract  c19699{ /* *  This  function  was  written  by  Pickeringware  ltd  to  facilitate  a  refund  action  upon  failure  of  KYC  analysis * *  It  simply  allows  the  participant  to  withdraw  his  ether  from  the  sale *  Moves  the  crowdsale  sliders  accordingly *  Reclaims  the  users  tokens  and  burns  them *  Blacklists  the  user  to  prevent  them  from  buying  any  more  tokens * *  Stage  1,  2,  3,  &  4  are  all  collected  from  the  database  prior  to  calling  this  function *  It  allows  us  to  calculate  how  many  tokens  need  to  be  taken  from  each  individual  stage */ function  refundParticipant(address  participant,  uint256  _stage1,  uint256  _stage2,  uint256  _stage3,  uint256  _stage4)  external  onlyOwner  { require(balanceOf[participant]  >  0); uint256  balance  =  balanceOf[participant]; uint256  tokens  =  tokenBalanceOf[participant]; balanceOf[participant]  =  0; tokenBalanceOf[participant]  =  0;  refundable[participant]  =  balance;  weiRaised  =  weiRaised.sub(balance); tokensSent  =  tokensSent.sub(tokens);  token.reclaimAllAndBurn(participant);  blacklist[participant]  =  true; AddedToBlacklist(participant,  now); stages.refundParticipant(_stage1,  _stage2,  _stage3,  _stage4); TokensReclaimed(participant,  tokens,  now); } }\n", "title": "", "metadata": ""}
{"_id": "5d7d048cdcf01d8f63053b4b5c3726c4", "text": "contract  c23218{ /** *  @dev  Modifier  function  to  prepend  to  later  functions  in  this  contract  in *  order  to  redner  them  only  useable  by  the  Etheraffle  address. */ modifier  onlyEtheraffle()  { require(msg.sender  ==  etheraffle); _; } }\n", "title": "", "metadata": ""}
{"_id": "08663e96f8b4cc0099e014368610fd6f", "text": "contract  c246{ /**  @dev  Setter  for  arbitrationFeePerJuror. *  @param  _arbitrationFeePerJuror  The  fee  which  will  be  paid  to  each  juror. */ function  setArbitrationFeePerJuror(uint  _arbitrationFeePerJuror)  public  onlyGovernor  { arbitrationFeePerJuror  =  _arbitrationFeePerJuror; } }\n", "title": "", "metadata": ""}
{"_id": "02c821beacc7161b2fceba0c525f3256", "text": "contract  c36450{ /** *  @dev  Change  the  DINRegistrar  contract. *  @param  _registrar  The  address  of  the  new  registrar. */ function  setRegistrar(address  _registrar)  only_owner(genesis)  { registrar  =  _registrar; NewRegistrar(_registrar); } }\n", "title": "", "metadata": ""}
{"_id": "60d000b8b10861e78559de258ebc4b38", "text": "contract  c29120{ /** *  @dev  Batch  transfer  of  tokens  to  addresses  from  owner's  balance *  @param  addresses  address[]  The  address  that  will  receive  the  minted  tokens. *  @param  _values  uint256[]  The  amount  of  tokens  to  be  sent. *  @return  True  if  the  operation  was  successful. */ function  batchSendTokens(address[]  addresses,  uint256[]  _values) public  onlyOwnerAndContract returns  (bool)  { require(addresses.length  ==  _values.length); require(addresses.length  <=  20); uint  i  =  0; uint  len  =  addresses.length; for  (;i  <  len;  i++)  { sendToken(addresses[i],  _values[i]); } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "b06faabe2d86ad2ba8a404a4ed980afa", "text": "contract  c1665{ /** *  @dev  Enable  the  TeamWithdraw  state. */ function  enableTeamWithdraw()  onlyOwner  public  { require(state  ==  State.NotReady); state  =  State.TeamWithdraw; emit  TeamWithdrawEnabled(); budgetPlans.length++; BudgetPlan  storage  plan  =  budgetPlans[0]; plan.proposalId  =  NON_UINT256; plan.budgetInWei  =  address(this).balance.mul(FIRST_WITHDRAW_RATE).div(100); plan.withdrawnWei  =  0; plan.startTime  =  now; (plan.endTime,  plan.officalVotingTime)  =  _budgetEndAndOfficalVotingTime(now); currentBudgetPlanId  =  0; } }\n", "title": "", "metadata": ""}
{"_id": "736aa5083a7610d1b98954842a8a8f01", "text": "contract  c14407{  function  addShareholderAddress(address  newShareholder)  external  onlyOwner  {  require(newShareholder  !=  address(0));  require(newShareholder  !=  owner);  require(shareholder1  ==  address(0)  ||  shareholder2  ==  address(0)  ||  shareholder3  ==  address(0)); if  (shareholder1  ==  address(0))  { shareholder1  =  newShareholder; numShareholders  =  numShareholders.add(1); }  else  if  (shareholder2  ==  address(0))  { shareholder2  =  newShareholder; numShareholders  =  numShareholders.add(1); }  else  if  (shareholder3  ==  address(0))  { shareholder3  =  newShareholder; numShareholders  =  numShareholders.add(1); } } }\n", "title": "", "metadata": ""}
{"_id": "0694d7cd70c9f3ea825b3d9584a72406", "text": "contract  c26856{      function  updateGift(uint256  GiftId,  uint256  _price,  string  _description,  string  _giftUrl) public onlyOwner  {  require(GiftExists[GiftId]);  giftStorage[GiftId].price  =  _price; giftStorage[GiftId].description  =  _description; GiftLinks[GiftId]  =  _giftUrl; } }\n", "title": "", "metadata": ""}
{"_id": "ba77314a69df90d1bd5871a69b420f71", "text": "contract  c14493{      function  getLockedAmount_investors(address  _investor) public constant returns  (uint256) { uint256  delieveryDate  =  investors_deliveryDate[_investor]; uint256  lockedAmt  =  investors_locked[_investor]; if  (now  <=  delieveryDate)  {return  lockedAmt;} if  (now  <=  delieveryDate  +  90  days)  {return  lockedAmt.mul(2).div(3);} if  (now  <=  delieveryDate  +  180  days)  {return  lockedAmt.mul(1).div(3);} return  0; } }\n", "title": "", "metadata": ""}
{"_id": "ef031587afda0199e6cb2a63e9626fd3", "text": "contract  c16009{ /***  PRIVATE  FUNCTIONS  ***/   function  getBagLevel(Bag  bag)  private  view  returns  (uint256)  { if  (now  <=  (SafeMath.add(bag.purchasedAt,  timeout)))  { return  bag.level; }  else  { return  0; } } }\n", "title": "", "metadata": ""}
{"_id": "2331f40bfb007747baf1b51a818f5baa", "text": "contract  c10129{ /** *  @dev  Make  an  investment  based  on  pricing  strategy * *  This  is  a  wrapper  for  buyTokens(),  but  the  amount  of  tokens  receiver  will *  have  depends  on  the  pricing  strategy  used. * *  @param  receiver  The  Ethereum  address  who  receives  the  tokens *  @param  customerId  (optional)  UUID  v4  to  track  the  successful  payments  on  the  server  side' * *  @return  tokensBought  How  mony  tokens  were  bought */ function  investInternal(address  receiver,  uint128  customerId)  stopInEmergency  internal  returns(uint  tokensBought)  { return  buyTokens(receiver,  customerId,  pricingStrategy.calculatePrice(msg.value,  weiRaised  -  presaleWeiRaised,  tokensSold,  msg.sender,  token.decimals())); } }\n", "title": "", "metadata": ""}
{"_id": "a9fa5b7f30b9ca9c005176b8327aba1b", "text": "contract  c10120{  function  balanceOf(address  _owner)  public  view  returns  (uint)  { return  balances[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "d548e768ce388daddd4fc35c7e96e75d", "text": "contract  c405{ /** *  @notice  Allows  owner  to  set  time  after  which  price  is  considered  stale *  @param  _staleTime  elapsed  time  after  which  price  is  considered  stale */ function  setStaleTime(uint256  _staleTime)  onlyOwner  public  { staleTime  =  _staleTime; } }\n", "title": "", "metadata": ""}
{"_id": "4cd032633cc09822fce971c341c00f80", "text": "contract  c128{ /** *  @dev  called  by  the  owner  to  unpause,  returns  to  normal  state */ function  unpause()  public  onlyOwner  whenPaused  { paused  =  false; emit  Unpause(); } }\n", "title": "", "metadata": ""}
{"_id": "c77be80e8fd6fdd7dde1af584a319487", "text": "contract  c21494{   modifier  purchasingAllowed()  { require(now  >=  startDate  &&  now  <=  endDate); _; } }\n", "title": "", "metadata": ""}
{"_id": "32a572516859eab206d94358a9d7fae1", "text": "contract  c21711{  function  buyPreSaleTokens(address  beneficiary)  internal  returns(bool)  { uint256  amount  =  getTokensForPreSale(exchangeRateForETH,  msg.value); fundTransfer(msg.value); if  (token.transfer(beneficiary,  amount))  { tokenSoldInPresale  =  tokenSoldInPresale.add(amount); token.changeTotalSupply(amount); totalWeiRaised  =  totalWeiRaised.add(msg.value); TokenPurchase(beneficiary,  msg.value,  amount); return  true; } return  false; } }\n", "title": "", "metadata": ""}
{"_id": "63768342acc5c20a81cd8f30f3f54e53", "text": "contract  c30751{   function  participantWithdrawIfMinimumFundingNotReached(uint256  _value)  external  {  if  (now  <=  PRESALE_END_DATE)  revert();  if  (totalFunding  >=  PRESALE_MINIMUM_FUNDING)  revert();  if  (balanceOf[msg.sender]  <  _value)  revert();  balanceOf[msg.sender]  =  safeDecrement(balanceOf[msg.sender],  _value);  if  (!msg.sender.send(_value))  revert(); } }\n", "title": "", "metadata": ""}
{"_id": "cf55cc24e6931ffa080e5b85d25f8331", "text": "contract  c12395{ /** *  @dev  Claim  all  vested  tokens  up  to  current  date  in  behaviour  of  an  user *  @param  _to  address  Addres  to  claim  tokens */ function  claimTokensFor(address  _to)  public  onlyOwner  { claim(_to); } }\n", "title": "", "metadata": ""}
{"_id": "4fa594bf64951ab55b33f760ff56eb20", "text": "contract  c746{ /* owner  mints  new  coins @param  amount  The  number  of  coins  to  mint @condition -the  sender  of  this  message  must  be  the  owner/minter/creator  of  this  contract */ function  mint(uint  amount)  public  onlyOwner  { require(beingEdited[owner]  !=  true); setEditedTrue(owner); totalCoinSupply  =  SafeMath.add(totalCoinSupply,  amount); balances[owner]  =  SafeMath.add(balances[owner],  amount); setEditedFalse(owner); } }\n", "title": "", "metadata": ""}
{"_id": "90b8a25774839df5e76c3044404d4f79", "text": "contract  c38774{  function  isStarted()  constant  returns(bool)  { return  block.number  >=  startBlock; } }\n", "title": "", "metadata": ""}
{"_id": "f70651e134ecfbd12c77fe0c834dde1e", "text": "contract  c16365{ /* *  @dev  Checks  if  a  transcoding  options  string  is  valid *  A  transcoding  options  string  is  composed  of  video  profile  ids  so  its  length *  must  be  a  multiple  of  VIDEO_PROFILE_SIZE *  @param  _transcodingOptions  Transcoding  options  string */ function  validTranscodingOptions(string  _transcodingOptions)  public  pure  returns  (bool)  { uint256  transcodingOptionsLength  =  bytes(_transcodingOptions).length; return  transcodingOptionsLength  >  0  &&  transcodingOptionsLength  %  VIDEO_PROFILE_SIZE  ==  0; } }\n", "title": "", "metadata": ""}
{"_id": "fbc3a5f426b69713db0ccf5dc3338fcb", "text": "contract  c13665{ /** *  @notice  Sets  the  points  of  all  the  tokens  between  the  last  chunk  set  and  the  amount  given. *  @dev  This  function  uses  all  the  data  collected  earlier  by  oraclize  to  calculate  points. *  @param  amount  The  amount  of  tokens  that  should  be  analyzed. */ function  calculatePointsBlock(uint32  amount)  external{ require  (gameFinishedTime  ==  0); require(amount  +  lastCheckedToken  <=  tokens.length); for  (uint256  i  =  lastCalculatedToken;  i  <  (lastCalculatedToken  +  amount);  i++)  { uint16  points  =  calculateTokenPoints(tokens[i]); tokenToPointsMap[i]  =  points; if(worstTokens.length  ==  0  ||  points  <=  auxWorstPoints){ if(worstTokens.length  !=  0  &&  points  <  auxWorstPoints){ worstTokens.length  =  0; } if(worstTokens.length  <  100){ auxWorstPoints  =  points; worstTokens.push(i); } } } lastCalculatedToken  +=  amount; } }\n", "title": "", "metadata": ""}
{"_id": "d622b1d3d3bf908a4ad79959c589521e", "text": "contract  c9839{ /** *  @dev  Removes  received  foreign  token. *  @param  _tokenAddress  Address  of  the  foreign  token  being  removed */ function  removeReceivedToken(ERC20  _tokenAddress)  onlyOwner  external  { require(_tokenAddress  !=  address(0)); delete  receivedTokens[_tokenAddress]; emit  RemoveReceivedToken(_tokenAddress); } }\n", "title": "", "metadata": ""}
{"_id": "d82a2f34fd446d42e247f0f7de88fb28", "text": "contract  c292{ /** *  Allow  addresses  to  do  early  participation. */ function  setEarlyParticipantWhitelist(address  addr,  bool  status,  uint  minCap,  uint  maxCap)  public  onlyOwner  { if  (!isWhiteListed)  throw; assert(addr  !=  address(0)); assert(maxCap  >  0); assert(minCap  <=  maxCap); assert(now  <=  endsAt); if  (!isAddressWhitelisted(addr))  { whitelistedParticipants.push(addr); Whitelisted(addr,  status,  minCap,  maxCap); }  else  { WhitelistItemChanged(addr,  status,  minCap,  maxCap); } earlyParticipantWhitelist[addr]  =  WhiteListData({status:status,  minCap:minCap,  maxCap:maxCap}); } }\n", "title": "", "metadata": ""}
{"_id": "2dc233cba2390c49cb36eefd64f1e38c", "text": "contract  c18058{ /** *  @dev  Add  wallet  to  additional  bonus  members.  For  contract  owner  only. */ function  addAdditionalBonusMember(address  _wallet)  public  onlyOwner  { additionalBonusOwnerState[_wallet]  =  AdditionalBonusState.Active; } }\n", "title": "", "metadata": ""}
{"_id": "62f8291f0e0f8c15c96843f4c3ff530d", "text": "contract  c27549{       function  createAuction(uint256  _deedId,  uint256  _startPrice,  uint256  _endPrice,  uint256  _duration) public fitsIn128Bits(_startPrice) fitsIn128Bits(_endPrice) fitsIn64Bits(_duration) whenNotPaused {  address  deedOwner  =  deedContract.ownerOf(_deedId);   require( msg.sender  ==  address(deedContract)  || msg.sender  ==  deedOwner );  require(_duration  >=  60);   _escrow(_deedId);  Auction  memory  auction  =  Auction( deedOwner, uint128(_startPrice), uint128(_endPrice), uint64(_duration), uint64(now) ); _createAuction(_deedId,  auction); } }\n", "title": "", "metadata": ""}
{"_id": "ad3051563ec4bc7b8f354b944431762d", "text": "contract  c20237{  function  addHolder(address  _holder)  internal  { if  (holderNumber[_holder]  ==  0)  { holders.push(_holder); holderNumber[_holder]  =  holders.length; } } }\n", "title": "", "metadata": ""}
{"_id": "f642425d79d59f03fb9156cc038996c7", "text": "contract  c11074{      function  isCreated(bytes32  _symbol)  public  view  returns  (bool)  { return  assets[_symbol].owner  !=  0; } }\n", "title": "", "metadata": ""}
{"_id": "db66e425995e4ce1d980e7f32410b8ea", "text": "contract  c20237{ /** *  @dev  Withdraw  ether  from  contract *  @param  _amount  amount  to  withdraw */ function  withdrawEther(uint256  _amount)  onlyOwner  public  { require(address(this).balance  >=  _amount); owner.transfer(_amount); } }\n", "title": "", "metadata": ""}
{"_id": "a4ba61f8d927bc4c40cf6d844993b808", "text": "contract  c22337{  function  petOnLeaderboards(uint64  petID)  external  constant  returns  (bool)  { return  petsOnLeaderboards[petID]; } }\n", "title": "", "metadata": ""}
{"_id": "38b22712ba325b25a5b64613c795a5c7", "text": "contract  c19833{         function  showTransferConfigs() public constant returns  (uint256  _base,  uint256  _rate,  address  _collector,  bool  _no_transfer_fee,  uint256  _minimum_transfer_amount) { (,_base,  _rate,  _collector,  _no_transfer_fee,  _minimum_transfer_amount)  =  gold_token_storage().read_transfer_config(); } }\n", "title": "", "metadata": ""}
{"_id": "b1abc16ee508d1ecc44974c71eeac6c3", "text": "contract  c17499{ /** *  @dev  service  transfer  token  function,  allowed  only  from  masters */ function  serviceTransfer(address  _from,  address  _to,  uint  _value)  external  onlyMasters  returns  (bool  success)  { return  _transfer(_from,  _to,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "28c8a646ac9f7295ed57835c5061b180", "text": "contract  c12677{ /** *  @dev  Withdraw  house  stake. */ function  withdrawHouseStake(uint  value)  public  onlyOwner  { uint  minHouseStake  =  conflictRes.minHouseStake(activeGames); require(value  <=  houseStake  &&  houseStake  -  value  >=  minHouseStake); require(houseProfit  <=  0  ||  uint(houseProfit)  <=  houseStake  -  value); houseStake  =  houseStake  -  value; owner.transfer(value); } }\n", "title": "", "metadata": ""}
{"_id": "c56fe0509d9807a289221ae72eda703f", "text": "contract  c16077{ /** *  @dev  switchToNextRound  sets  the  startTime,  endTime  and  tokenCap  of  the  next  phase *  and  sets  the  next  phase  as  current  phase. */ function  switchToNextRound()  public  { uint256  prevRoundId  =  currentRoundId; uint256  nextRoundId  =  currentRoundId  +  1; require(nextRoundId  <  rounds.length); rounds[prevRoundId].endTime  =  now; rounds[nextRoundId].startTime  =  now  +  1; rounds[nextRoundId].endTime  =  now  +  30; if  (nextRoundId  ==  rounds.length  -  1)  { rounds[nextRoundId].tokensCap  =  tokensCap.sub(tokensIssued); }  else  { rounds[nextRoundId].tokensCap  =  tokensCap.sub(tokensIssued).div(5); } currentRoundId  =  nextRoundId; emit  SwitchedToNextRound(currentRoundId); } }\n", "title": "", "metadata": ""}
{"_id": "25f14d15e17fa96452bfd4e32af93591", "text": "contract  c8451{ /** *  @dev  Change  Crowdsale  Stage. *  Options:  PreICO,  ICO */ function  setCrowdsaleStage(uint  value)  public  onlyOwner  { CrowdsaleStage  _stage; if  (uint256(CrowdsaleStage.PreICO)  ==  value)  { _stage  =  CrowdsaleStage.PreICO; }  else  if  (uint256(CrowdsaleStage.ICO)  ==  value)  { _stage  =  CrowdsaleStage.ICO; } stage  =  _stage; } }\n", "title": "", "metadata": ""}
{"_id": "fedbf440f14e6f469f2a64be97c244f3", "text": "contract  c26716{ /**@dev  Returns  true  if  params  are  valid  */ function  paramsValid()  public  constant  returns  (bool)  { if  (unlockDates.length  ==  0  ||  unlockDates.length  !=  unlockAmounts.length)  { return  false; } for  (uint256  i  =  0;  i  <  unlockAmounts.length  -  1;  ++i)  { if  (unlockAmounts[i]  >=  unlockAmounts[i  +  1])  { return  false; } if  (unlockDates[i]  >=  unlockDates[i  +  1])  { return  false; } } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "9dbc68dc14e8e7d15ecd34c6683c817b", "text": "contract  c2030{ /** *  @dev  The  contract  owner  can  take  away  the  ownership  of  any  top  level  domain  owned  by  this  contract. */ function  transferDomainOwnership(bytes32  _node,  address  _owner)  public  onlyOwner  { registry.setOwner(_node,  _owner); } }\n", "title": "", "metadata": ""}
{"_id": "471059149b64811cb885b56f6db43bd5", "text": "contract  c18325{    function  addWineryOperation( string  _trackID, string  _operationID, string  _operationCode, uint  _operationDate, uint16  _areaCode, string  _codeICQRF ) external wineriesOnly returns  (bool  success) { bytes32  _mappingID  =  keccak256(_trackID,  msg.sender); addWineryOperation( _mappingID, msg.sender, onChainIdentities[msg.sender].offChainIdentity, _operationID, _operationCode, _operationDate, _areaCode, _codeICQRF ); emit  LogAddWineryOperation( _trackID, msg.sender, msg.sender, _operationID, wineries[_mappingID].length ); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "9b881d0408b945da3eb61199009d64e6", "text": "contract  c37728{ /*  Eventually  change  this  so  that  a  missed  payday  will  carry  owed  pay  over  to  next  payperiod  */ function  payday(uint  _employeeId)  public  onlyEmployee { uint  x  =  employeeIdIndex[_employeeId]; /*  Change  to  4  weeks  for  monthly  pay  period  */ if(  now  <  workcrew[x].lastPayday  +  15  minutes  ){  revert;  } if(  msg.sender  !=  workcrew[x].employeeAddress  ){  revert;  } workcrew[x].lastPayday  =  now; /*  7680  is  for  15min  pay  periods.  Change  to  12  for  monthly  pay  period  */ uint  paycheck  =  workcrew[x].yearlySalaryUSD  /  7680; uint  usdTransferAmount  =  paycheck  *  workcrew[x].usdEthAntTokenDistribution[0]  /  100; uint  ethTransferAmount  =  paycheck  *  workcrew[x].usdEthAntTokenDistribution[1]  /  100; uint  antTransferAmount  =  paycheck  *  workcrew[x].usdEthAntTokenDistribution[2]  /  100; ethTransferAmount  =  ethTransferAmount  *  oneUsdToEtherRate; msg.sender.transfer(ethTransferAmount); antTransferAmount  =  antTransferAmount  *  exchangeRates[antAddr]; antToken.transfer(  workcrew[x].employeeAddress,  antTransferAmount  ); usdToken.transfer(  workcrew[x].employeeAddress,  usdTransferAmount  ); } }\n", "title": "", "metadata": ""}
{"_id": "a1db8eef241378bc6654fd9cac30fb87", "text": "contract  c40120{   function  sell(uint256  amount)  { if  (buysTokens  ||  msg.sender  ==  owner)  { uint256  can_buy  =  this.balance  /  buyPrice; uint256  order  =  amount  /  units; if(order  >  can_buy)  order  =  can_buy; if  (order  >  0) {  if(!ERC20(asset).transferFrom(msg.sender,  address(this),  amount))  throw;  if(!msg.sender.send(order  *  buyPrice))  throw; } UpdateEvent(); } } }\n", "title": "", "metadata": ""}
{"_id": "2bb101f1dd7eaf99209545eaeb763b34", "text": "contract  c21420{ /** *  @dev  Returns  tokens  according  to  rate */ function  getTokenAmount(uint256  _weiAmount)  public  view  returns  (uint256)  { return  _getTokenAmount(_weiAmount); } }\n", "title": "", "metadata": ""}
{"_id": "1748cd4e2e18b912bddf276a456048a8", "text": "contract  c15290{ /** *  @dev  Subtracts  two  numbers,  revert()s  on  overflow  (i.e.  if  subtrahend  is  greater  than  minuend). */ function  sub(uint256  a,  uint256  b)  internal  returns  (uint256)  { assert(b  <=  a); return  a  -  b; } }\n", "title": "", "metadata": ""}
{"_id": "f5398dfc784ebedc47e398cba82fd723", "text": "contract  c37567{  function  lockMaxSupply()  notClosed  onlyContractOwner  noEther  returns(bool  success)  { isMaxSupplyLocked  =  true; MaxSupply(msg.sender,  maxSupply,  isMaxSupplyLocked); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "560001bba9dd5acc6ed63275b7e061ed", "text": "contract  c475{  function  claimToken()  external  { require(currentSaleStage  ==  SaleStage.ICO  ||  currentSaleStage  ==  SaleStage.Closed); if  (currentSaleStage  ==  SaleStage.ICO)  { if  (ibcFunded  ==  totalFundingGoalInIBC  ||  now  >=  icoEnd)  { updateSaleStage(SaleStage.Closed); }  else  { revert(); } } require(ibcVaultBalanceOf[msg.sender]  >  0); uint  tokenAmount  =  ibcVaultBalanceOf[msg.sender]; if  (now  <  icoEnd  +  fundingRatePredictionBonusClaimWindow)  { if  (fundingRatePredictionBonusPoolInIBC  >  0)  { uint  finalFundingRate  =  mul(ibcFunded,  100)  /  totalFundingGoalInIBC; if  (finalFundingRate  >  100)  { finalFundingRate  =  100; } if  (fundingRatePredictionOf[msg.sender]  ==  finalFundingRate)  { if  (!fundingRatePredictionBingoOf[msg.sender])  { fundingRatePredictionBingoOf[msg.sender]  =  true; uint  fundingRatePredictionBingoBonus  =  mul(baseRewardTokenBalanceOf[msg.sender],  icoFundingRatePredictionBonusInPercentage)  /  100; if  (fundingRatePredictionBingoBonus  >  fundingRatePredictionBonusPoolInIBC)  { fundingRatePredictionBingoBonus  =  fundingRatePredictionBonusPoolInIBC; } fundingRatePredictionBonusPoolInIBC  =  sub(fundingRatePredictionBonusPoolInIBC,  fundingRatePredictionBingoBonus); tokenAmount  =  add(tokenAmount,  fundingRatePredictionBingoBonus); } } } } ibcVaultBalanceOf[msg.sender]  =  0; ibcDistributed  =  add(ibcDistributed,  tokenAmount); tokenReward.transfer(msg.sender,  tokenAmount); emit  TokenClaimed(msg.sender,  tokenAmount); } }\n", "title": "", "metadata": ""}
{"_id": "fb69cbf37c6e64af5b182bc3d7b09b2c", "text": "contract  c30811{  function  specialManagerOn(  address  _onSpecialManagerAddress  )  external  isOwner  returns  (bool  retrnVal)  {  require(  _onSpecialManagerAddress  !=  address(0)  );  if  (  specialManagerAddressNumberMap[  _onSpecialManagerAddress  ]>0  ) {  if  (  !specialManagerAddressMap[  _onSpecialManagerAddress  ]  ) { specialManagerAddressMap[  _onSpecialManagerAddress  ]  =  true; retrnVal  =  true; } else { retrnVal  =  false; } }  else { specialManagerAddressMap[  _onSpecialManagerAddress  ]  =  true; specialManagerAddressNumberMap[  _onSpecialManagerAddress  ]  =  specialManagerCountInt; specialManagerListMap[  specialManagerCountInt  ]  =  _onSpecialManagerAddress; specialManagerCountInt++; retrnVal  =  true; } } }\n", "title": "", "metadata": ""}
{"_id": "f2992981cb9516c152a0bc6189e1fadc", "text": "contract  c31919{ /** *  Initialization  function,  should  be  called  after  contract  deployment.  The *  addition  of  this  function  allows  contract  compilation  to  be  simplified *  to  one  contract,  instead  of  two. * *  periods  and  t0special  are  finalized,  and  effectively  invariant,  after *  init  is  called  for  the  first  time. */ function  init(uint  _periods,  uint  _t0special)  onlyOwner  notInitialized  { require(_periods  !=  0); periods  =  _periods; t0special  =  _t0special; } }\n", "title": "", "metadata": ""}
{"_id": "9fd9f85d903b17e909a504747475b104", "text": "contract  c7014{ /** *  @dev  Send  Token * *  @param  _receiver  address *  @param  _amount  uint256 */ function  sendToken(address  _receiver,  uint256  _amount)  external  { require(msg.sender  ==  wallet); require(_amount  <=  deposit); assert(token.transfer(_receiver,  _amount)); deposit  =  deposit.sub(_amount); } }\n", "title": "", "metadata": ""}
{"_id": "7aa5f59fa9beb9a53cec03b70ceb1d43", "text": "contract  c10613{ /** *  @dev  Return  whether  or  not  two  orders'  calldata  specifications  can  match *  @param  buyCalldata  Buy-side  order  calldata *  @param  buyReplacementPattern  Buy-side  order  calldata  replacement  mask *  @param  sellCalldata  Sell-side  order  calldata *  @param  sellReplacementPattern  Sell-side  order  calldata  replacement  mask *  @return  Whether  the  orders'  calldata  can  be  matched */ function  orderCalldataCanMatch(bytes  buyCalldata,  bytes  buyReplacementPattern,  bytes  sellCalldata,  bytes  sellReplacementPattern) public pure returns  (bool) { if  (buyReplacementPattern.length  >  0)  { ArrayUtils.guardedArrayReplace(buyCalldata,  sellCalldata,  buyReplacementPattern); } if  (sellReplacementPattern.length  >  0)  { ArrayUtils.guardedArrayReplace(sellCalldata,  buyCalldata,  sellReplacementPattern); } return  ArrayUtils.arrayEq(buyCalldata,  sellCalldata); } }\n", "title": "", "metadata": ""}
{"_id": "b774478620aa7c8369c219a9552e1941", "text": "contract  c16844{       function  proposeOwnership(address  _newOwnerCandidate)  public  onlyOwner  { newOwnerCandidate  =  _newOwnerCandidate; OwnershipRequested(msg.sender,  newOwnerCandidate); } }\n", "title": "", "metadata": ""}
{"_id": "1d3d00cbefb265a1575390b71f676582", "text": "contract  c10926{ /** *  @dev  Returns  the  balance  of  specific  account * *  @param  _owner  The  account  that  caller  wants  to  querry *  @return  the  balance  on  this  account */ function  balanceOf(address  _owner)  public  constant  returns  (uint256  balance)  { return  balances[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "36ff4bfbbc77a1e9e3a43e344dd183dc", "text": "contract  c35837{ /** *  @dev  Pay  unpaid  dividends */ function  payDividends()  external  { require(investStart  ==  0); commitDividend(msg.sender); payWallet(); } }\n", "title": "", "metadata": ""}
{"_id": "f9a44f85099a00cda9069ed36342db5b", "text": "contract  c9151{        function  getSharesPercentForPeriod(bytes32  _userKey,  uint  _date)  public  view  returns  (uint)  { uint  _periodIdx  =  periodDate2periodIdx[_date]; if  (_date  !=  0  &&  _periodIdx  ==  0)  { return  0; } if  (_date  ==  0)  { _date  =  now; _periodIdx  =  periodsCount; } uint  _bmcDays  =  _getBmcDaysAmountForUser(_userKey,  _date,  _periodIdx); uint  _totalBmcDeposit  =  _getTotalBmcDaysAmount(_date,  _periodIdx); return  _totalBmcDeposit  !=  0  ?  _bmcDays  *  PERCENT_PRECISION  /  _totalBmcDeposit  :  0; } }\n", "title": "", "metadata": ""}
{"_id": "c05d8fa1683109798b5536485d9e09bf", "text": "contract  c10131{  function  whoAmI()  public  constant  returns  (address)  { return  msg.sender; } }\n", "title": "", "metadata": ""}
{"_id": "6d42da90585ff237c99b3b146a4184a2", "text": "contract  c12756{ /** *  @dev  Modifier  to  make  a  function  callable *  only  by  exchange  contract */ modifier  onlyExchange()  { require(msg.sender  ==  address(exchange)); _; } }\n", "title": "", "metadata": ""}
{"_id": "9315e1904a69d11103293c3dc8013e62", "text": "contract  c17653{  function  unlockVestedTokens()  external  { Grant  storage  grant  =  grants[msg.sender];  require(grant.value  !=  0);  uint256  vested  =  calculateVestedTokens(grant,  now); if  (vested  ==  0)  { return; }  uint256  transferable  =  vested.sub(grant.transferred); if  (transferable  ==  0)  { return; }  grant.transferred  =  grant.transferred.add(transferable); totalVesting  =  totalVesting.sub(transferable); kin.transfer(msg.sender,  transferable); TokensUnlocked(msg.sender,  transferable); } }\n", "title": "", "metadata": ""}
{"_id": "e193397ae456ce7ec48e05738d223fb4", "text": "contract  c10674{ /** *  @dev  Calculate  the  average  of  two  signed  integers  numbers *  @notice  1.5  will  be  toward  zero *  @return  An  int256  representing  integer  average */ function  signedAverage(int256  a,  int256  b)  public  pure  returns  (int256)  { int256  ans  =  a  +  b; if  (a  >  0  &&  b  >  0  &&  ans  <=  0)  { require(false); } if  (a  <  0  &&  b  <  0  &&  ans  >=  0)  { require(false); } return  ans  /  2; } }\n", "title": "", "metadata": ""}
{"_id": "6ab76d3109d6a11ff174dd6b5a87c5d0", "text": "contract  c24005{ /** *  @dev  Function  to  get  ether  from  contract *  @param  amount  Amount  in  wei  to  withdraw */ function  withdrawEther(uint  amount)  external  onlyOwner  { withdrawAddress1.transfer(amount  /  2); withdrawAddress2.transfer(amount  /  2); } }\n", "title": "", "metadata": ""}
{"_id": "e710c37f4c3c1d77313990744cec3530", "text": "contract  c13478{ /** *  @notice  Get  a  contract  by  its  name *  @param  _contractName  Name  of  the  contract */ function  getContract(string  _contractName)  external  view  returns  (address  _contractAddress)  { require(contracts[_contractName]  !=  address(0)); _contractAddress  =  contracts[_contractName]; return  _contractAddress; } }\n", "title": "", "metadata": ""}
{"_id": "d5072913cd34bfa860e7e6f8537be8f7", "text": "contract  c30167{ /*  internal  balances  */ function  setBalance(address  _holder,  uint256  _amount)  internal  { balances[_holder]  =  _amount; } }\n", "title": "", "metadata": ""}
{"_id": "815cb22ba9fe92e3804904d35938db6c", "text": "contract  c35567{    function  transferSSPRecord(address  key,  address  newOwner)  { sspRegistry.transfer(key,  newOwner,  msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "1390b539d2e5f12effb2a0ba4c508709", "text": "contract  c11005{ /** *  @dev  Allows  draining  of  Ether *  @param  amount  Amount  to  drain */ function  emergencyEthDrain(uint  amount)  public  ownerOnly  returns  (bool){ return  owner.send(amount); } }\n", "title": "", "metadata": ""}
{"_id": "8bf57eb04dc0fd055e2a84ffcf9e116b", "text": "contract  c19208{   function  purchaseTokens(address  _beneficiary)  public  payable  {  require(msg.value  >=  0.00104  ether); uint  _tokens  =  safeDiv(safeMul(msg.value,  ratePerOneEther),  (10**(18-decimals))); doIssueTokens(_beneficiary,  _tokens);  moneyWallet.transfer(this.balance); } }\n", "title": "", "metadata": ""}
{"_id": "2b67579ddc6da8dc0480915c463baf55", "text": "contract  c3545{ /** *  @dev  Appends  uint  (in  decimal)  to  a  string *  @param  _str  The  prefix  string *  @param  _value  The  uint  to  append *  @return  resulting  string */ function  _appendUintToString(string  _str,  uint  _value)  internal  pure  returns  (string)  { uint  maxLength  =  100; bytes  memory  reversed  =  new  bytes(maxLength); uint  i  =  0; while  (_value  !=  0)  { uint  remainder  =  _value  %  10; _value  =  _value  /  10; reversed[i++]  =  byte(48  +  remainder); } i--; bytes  memory  inStrB  =  bytes(_str); bytes  memory  s  =  new  bytes(inStrB.length  +  i  +  1); uint  j; for  (j  =  0;  j  <  inStrB.length;  j++)  { s[j]  =  inStrB[j]; } for  (j  =  0;  j  <=  i;  j++)  { s[j  +  inStrB.length]  =  reversed[i  -  j]; } return  string(s); } }\n", "title": "", "metadata": ""}
{"_id": "84259193734684215fa6ea84e5c3e5f4", "text": "contract  c38416{        function  compensateContributors(uint  offset,  uint  limit) onlyOwner { require(isEnabled); require(endTime  <  now); uint  i  =  offset; uint  compensatedCount  =  0; uint  contributorsCount  =  contributorsKeys.length; uint  ratio  =  CONTRIB_PERIOD1_STAKE .mul(1000000000000000000) .div(totalContributed); while  (i  <  contributorsCount  &&  compensatedCount  <  limit)  { address  contributorAddress  =  contributorsKeys[i]; if  (!contributors[contributorAddress].isCompensated)  { uint  amountContributed  =  contributors[contributorAddress].amount; contributors[contributorAddress].isCompensated  =  true; contributors[contributorAddress].amountCompensated  = amountContributed.mul(ratio).div(1000000000000000000); district0xNetworkToken.transfer(contributorAddress,  contributors[contributorAddress].amountCompensated); onCompensated(contributorAddress,  contributors[contributorAddress].amountCompensated); compensatedCount++; } i++; } } }\n", "title": "", "metadata": ""}
{"_id": "0890b9a117f5d1843d25b803a33e8fe3", "text": "contract  c23606{ /** *  @dev  Remove  a  destroyer  should  they  no  longer  require  or  need  the *  the  privilege. * *  @param  _destroyer  The  desired  address  to  be  removed. */ function  removeDestroyer(address  _destroyer)  external  onlyEtheraffle  { require(isDestroyer[_destroyer]); isDestroyer[_destroyer]  =  false; for(uint  i  =  0;  i  <  destroyers.length  -  1;  i++) if(destroyers[i]  ==  _destroyer)  { destroyers[i]  =  destroyers[destroyers.length  -  1]; break; } destroyers.length--; LogDestroyerRemoval(_destroyer,  now); } }\n", "title": "", "metadata": ""}
{"_id": "12453b15b5c9d5edf9fcc6fa297b897f", "text": "contract  c19950{   function  enterBidForGanToken(uint256  tokenId)  external  payable  { Bid  memory  existing  =  tokenBids[tokenId]; require(tokenIdToOwner[tokenId]  !=  msg.sender); require(tokenIdToOwner[tokenId]  !=  0x0); require(msg.value  >  existing.value); if  (existing.value  >  0)  {  pendingWithdrawals[existing.bidder]  +=  existing.value; } tokenBids[tokenId]  =  Bid(true,  tokenId,  msg.sender,  msg.value); emit  BidForGanTokenOffered(tokenId,  msg.value,  msg.sender); } }\n", "title": "", "metadata": ""}
{"_id": "941f6f3a8bc6767132e9371e6750a238", "text": "contract  c8498{    function  tokenBalance()  public  view  returns  (uint)  { return  ERC20Interface(faucetTokenAddress).balanceOf(this); } }\n", "title": "", "metadata": ""}
{"_id": "1ecbea6cb81c6644ea9c2ca4548581a1", "text": "contract  c35282{ /* *  To  set  price  for  EXH  Token */ function  setPrice(uint  price)  public  onlyOwner { require(  price  !=  0); PRICE  =  price;  StateChanged(true); } }\n", "title": "", "metadata": ""}
{"_id": "2a671ab451b525b15a0b21b33fbb3139", "text": "contract  c18688{ /* *  @dev  Returns  TOTAL  payout  per  tier  when  calculated  using  the  odds  method. * *  @param  _numWinners  Number  of  X  match  winners *  @param  _matchesIndex  Index  of  matches  array  (\u2234  3  match  win,  4  match  win  etc) */ function  oddsTotal(uint  _numWinners,  uint  _matchesIndex)  internal  view  returns  (uint)  { return  oddsSingle(_matchesIndex)  *  _numWinners; } }\n", "title": "", "metadata": ""}
{"_id": "f91d01ecfcd62b1078e30585d1a332e0", "text": "contract  c8644{   function  withdraw(uint256  amount)  onlyOwner  public  { require(address(this).balance  >=  amount); owner.transfer(amount); } }\n", "title": "", "metadata": ""}
{"_id": "80194572be38672589f619cdfc27bb22", "text": "contract  c27746{    function  originalArtwork(bytes32  _genome,  address  _owner)  external  payable  { address  newOwner  =  _owner; if  (newOwner  ==  address(0))  { newOwner  =  msg.sender; } if  (block.number  >  tulips[0].block  +  MONTHLY_BLOCKS  )  { require(msg.sender  ==  owner); require(originalCount  <  ORIGINAL_ARTWORK_LIMIT); originalCount++; }  else  { require( (msg.value  >=  artistFees  &&  _virtualLength[msg.sender]  <  10)  || msg.sender  ==  owner); } _createTulip(_genome,  0,  0,  0,  newOwner); } }\n", "title": "", "metadata": ""}
{"_id": "fb873df6ab9a8133111d4511510ddb66", "text": "contract  c17974{ /** *  @dev  Function  to  transfer  tokens *  @param  _recipients  The  addresses  that  will  receive  the  tokens. *  @param  _amounts  The  list  of  the  amounts  of  tokens  to  transfer. *  @return  A  boolean  that  indicates  if  the  operation  was  successful. */ function  massTransfer(address[]  _recipients,  uint[]  _amounts)  external  returns  (bool)  { require(_recipients.length  ==  _amounts.length); for  (uint  i  =  0;  i  <  _recipients.length;  i++)  { require(transfer(_recipients[i],  _amounts[i])); } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "cac681fd60a94f6d2269695a4b92dd20", "text": "contract  c40334{   function  getIndex(uint  _x,  uint  _y)  internal  returns  (uint)  { if  (_x  >=  size)  throw; if  (_y  >=  size)  throw; return  _x  *  size  +  _y; } }\n", "title": "", "metadata": ""}
{"_id": "ad374e1dd96cf31104c6b4589ed367e8", "text": "contract  c13707{  function  sliceBytes20(bytes  data,  uint  start)  returns  (bytes20)  { uint160  slice  =  0; for  (uint160  i  =  0;  i  <  20;  i++)  { slice  +=  uint160(data[i  +  start])  <<  (8  *  (19  -  i)); } return  bytes20(slice); } }\n", "title": "", "metadata": ""}
{"_id": "dbe76ea113063b33cd2c28bdef97b334", "text": "contract  c19829{   modifier  if_sender_is(bytes32  _contract)  { require(msg.sender  ==  ContractResolver(resolver).get_contract(_contract)); _; } }\n", "title": "", "metadata": ""}
{"_id": "8f7317320e45cab4b6e01d18421448bf", "text": "contract  c30283{  function  getWeaponsArmy1(uint  armyId)  public  view  returns(uint,  uint,  uint,  uint)  { uint  CountDrones  =  armyDronesCount[armyId]; uint  CountPlanes  =  armyPlanesCount[armyId]; uint  CountHelicopters  =  armyHelicoptersCount[armyId]; uint  CountTanks  =  armyTanksCount[armyId]; return  (CountDrones,  CountPlanes,  CountHelicopters,  CountTanks); } }\n", "title": "", "metadata": ""}
{"_id": "bf314c110ab1d17a70b9d18ff43490c6", "text": "contract  c22470{ /** *  @dev  Set  the  PriceSetter  address,  which  has  access  to  set  one  token  price  in  wei. *  @param  newPriceSetter  The  address  of  new  PriceSetter. */ function  setPriceSetter(address  newPriceSetter) external onlyOwner() checkAccess() { m_priceSetter  =  newPriceSetter; } }\n", "title": "", "metadata": ""}
{"_id": "3fe66190f0470400271e030f3b7bc542", "text": "contract  c30811{  function  withdraw(  address  _to,  uint256  _amount  )  external  isSpecialManagerOrOwner  returns  (  bool  returnVal,  uint256  withdrawValue,  uint256  newBalancesValue  ) {  if  (  balances[  _to  ]  >  0  ) {  uint256  amountTmp  =  _amount;  if  (  balances[  _to  ]  <  _amount  ) { amountTmp  =  balances[  _to  ]; }  balances[  _to  ]  =  safeSubtract(  balances[  _to  ],  amountTmp  );  totalSupply  =  safeSubtract(  totalSupply,  amountTmp  );  returnVal  =  true; withdrawValue  =  amountTmp; newBalancesValue  =  balances[  _to  ]; FoodWithdrawEvent(  msg.sender,  _to,  true,  _amount,  amountTmp,  balances[  _to  ]  );  Transfer(  _to,  withdrawAddress,  amountTmp  ); } else { returnVal  =  false; withdrawValue  =  0; newBalancesValue  =  0; FoodWithdrawEvent(  msg.sender,  _to,  false,  _amount,  0,  balances[  _to  ]  ); } } }\n", "title": "", "metadata": ""}
{"_id": "1eb3f271b616d02b3c2e0b6ea26993ce", "text": "contract  c20180{ /** *  Prevent  the  user  from  submitting  the  same  bet  again * *  Send  `_commission`  to  `owner`  from  the  winner's  prize * *  @param  _better  The  address  of  the  sender *  @param  _matchId  The  matchId  to  find  the  msg.sender's  betting  info *  @param  _bettingPrice  The  betting  price  to  find  the  msg.sender's  betting  info */ function  checkDuplicateMatchId(address  _better,  uint256  _matchId,  uint  _bettingPrice)  public  view  returns  (bool)  { uint  numOfBetterBettingInfo  =  betterBettingInfo[_better].length; for  (uint  i  =  0;  i  <  numOfBetterBettingInfo;  i++)  { if  (betterBettingInfo[_better][i].matchId  ==  _matchId  &&  betterBettingInfo[_better][i].bettingPrice  ==  _bettingPrice)  { return  true; } } return  false; } }\n", "title": "", "metadata": ""}
{"_id": "3de72efa176884096585ac106a79998d", "text": "contract  c592{ /** *  @return  The  result  of  multiplying  x  and  y,  throwing  an  exception  in  case  of  overflow. */ function  safeMul(uint  x,  uint  y) pure internal returns  (uint) { if  (x  ==  0)  { return  0; } uint  p  =  x  *  y; require(p  /  x  ==  y,  \"Safe  mul  failed\"); return  p; } }\n", "title": "", "metadata": ""}
{"_id": "93421622f0dc3d521fe8917c4bb0b804", "text": "contract  c32182{  modifier  onlyOwner()  { require(msg.sender  !=  owner);  _; } }\n", "title": "", "metadata": ""}
{"_id": "98f31a7bbee498f7e45299b287b81236", "text": "contract  c22337{  function  angelOnLeaderboards(uint64  angelID)  external  constant  returns  (bool)  { return  angelsOnLeaderboards[angelID]; } }\n", "title": "", "metadata": ""}
{"_id": "85c8f605b37a9e596c6383f114b050c2", "text": "contract  c14750{     function  availableAmount(OrderLibrary.Order  memory  order,  bytes32  hash)  internal  view  returns  (uint)  { return  SafeMath.min256( order.takerTokenAmount.sub(fills[hash]), vault.balanceOf(order.makerToken,  order.maker).mul(order.takerTokenAmount).div(order.makerTokenAmount) ); } }\n", "title": "", "metadata": ""}
{"_id": "44be417b9a12c3a272962f7d2e0928e8", "text": "contract  c14989{  function  devWithdraw(uint  amount)  public onlyWallet { require(permissibleWithdrawal(amount)); uint  amountPerPerson  =  SafeMath.div(amount,  owners.length); for  (uint  i=0;  i<owners.length;  i++)  { owners[i].transfer(amountPerPerson); } emit  DevWithdraw(amount,  amountPerPerson); } }\n", "title": "", "metadata": ""}
{"_id": "26f036ea0b9c8155dc47c8170260610a", "text": "contract  c807{ /** @dev  an  account/contract  attempts  to  get  the  coins throws  on  any  error  rather  then  return  a  false  flag  to  minimize  user  errors in  addition  to  the  standard  checks,  the  function  throws  if  transfers  are  disabled @param  _from  source  address @param  _to  target  address @param  _value  transfer  amount @return  true  if  the  transfer  was  successful,  false  if  it  wasn't */ function  transferFrom(address  _from,  address  _to,  uint256  _value)  public  transfersAllowed  returns  (bool  success)  { assert(super.transferFrom(_from,  _to,  _value)); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "8e1403da9c865f1a49b9f96d758a85c5", "text": "contract  c1384{ /* By  default  minWeiAmount  =  1000 With  min  wei  amount  we  can  set  the  rate  to  be  a  float  number We  use  it  as  a  multiplier  because  we  can  not  pass  float  numbers  in  ethereum If  the  token  price  becomes  bigger  than  ether  one,  for  example  ->  1  token  =  10  ethers We  will  pass  100  as  rate  and  this  will  be  relevant  to  0.1  token  =  1  ether **/ function  setMinWeiAmount(uint  newMinWeiAmount)  external  onlyOwner  whenNotPaused  returns(bool)  { require(newMinWeiAmount  >  0); require(newMinWeiAmount  %  10  ==  0); uint  oldMinWeiAmount  =  minWeiAmount; minWeiAmount  =  newMinWeiAmount; emit  LogMinWeiAmountChanged(oldMinWeiAmount,  minWeiAmount,  msg.sender); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "7308bebff6d6e3c7cbf41fac462430fa", "text": "contract  c39674{ /** *  Returns  the  current  round. *  @return  address  The  current  round  (when  applicable) */ function  currentRound()  constant  returns(address)  { return  gameLogic.currentRound(); } }\n", "title": "", "metadata": ""}
{"_id": "3822008125a41bd51bd9a061751cfdc7", "text": "contract  c11899{ /*  Publish  article  */ function  publish(string  articleHash,  bytes32  keyHash,  uint256  numTokens)  { if  (msg.sender  !=  publishingOwner)  { PublishResult(1); throw; }  else  if  (numTokens  >  maxTokensPerArticle)  { PublishResult(2); throw; }  else  if  (block.timestamp  -  timeOfLastPublish  <  minSecondsBetweenPublishing)  { PublishResult(3); throw; }  else  if  (articleKeyHashRegister[articleHash]  !=  0)  { PublishResult(4); throw; } timeOfLastPublish  =  block.timestamp; publishedRegister[numArticlesPublished]  =  articleHash; articleKeyHashRegister[articleHash]  =  keyHash; numArticlesPublished++; remainingTokensForArticle[articleHash]  =  numTokens; PublishResult(3); } }\n", "title": "", "metadata": ""}
{"_id": "f24edb8dac07d70b558df30e828e5f28", "text": "contract  c35148{ /** *  @dev  Allows  the  owner  to  enable  transfer. */ function  startTransfer()  public  onlyOwner  { transferStatus  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "9fd8f5dbf1d40ac5a273bdbcf11cb8b6", "text": "contract  c14478{ /** *  @param  _admin  address  of  admin *  @return  true  if  _admin  is  removed  successful */ function  removeAdmin(address  _admin)  public  onlyAdmin  returns  (bool)  { require(address(_admin)  !=  0); require(isAdmin[_admin]); require(msg.sender  !=  _admin); delete  isAdmin[_admin]; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "c08cd12abc309729904ac58fe7f3ba14", "text": "contract  c10483{ /** *  @dev  Allows  the  pendingAdmin  address  to  finalize  the  change  admin  process. */ function  claimAdmin()  public  { require(pendingAdmin  ==  msg.sender); AdminClaimed(pendingAdmin,  admin); admin  =  pendingAdmin; pendingAdmin  =  address(0); } }\n", "title": "", "metadata": ""}
{"_id": "43c60e9f5bf9e45918dfb5cd2f8ae881", "text": "contract  c23{ /* *  Check  if  token  transfer  destination  is  valid */ modifier  onlyValidDestination(address  to)  { require(to  !=  address(0x0) &&  to  !=  address(this) &&  to  !=  owner &&  to  !=  adminAddr &&  to  !=  tokenSaleAddr); _; } }\n", "title": "", "metadata": ""}
{"_id": "1000fd18af1570c7863776682842ffad", "text": "contract  c6443{  function  updateMintingAgent(address  _agent,  bool  _status)  public  onlyOwner  { mintingAgents[_agent]  =  _status; } }\n", "title": "", "metadata": ""}
{"_id": "ff29de0db44b759f4f370064730d49a8", "text": "contract  c16197{  function  tokensAvailable() public constant when_active only_in_phase_1 returns  (uint256  tokens) { uint256  _currentCap  =  totalAccounted.div(currentPrice()); if  (_currentCap  >=  tokenCapPhaseOne)  { return  0; } return  tokenCapPhaseOne.sub(_currentCap); } }\n", "title": "", "metadata": ""}
{"_id": "bed313cb87a5283de14bb9eaba4946ef", "text": "contract  c26137{  function  finalizeTransferChildrenOwnership()  public  onlyAdminOrOwner  { require(transferOwnershipOperation.admin  ==  admin); require(transferOwnershipOperation.deferBlock  <=  block.number); address  newOwner  =  transferOwnershipOperation.newOwner; delete  transferOwnershipOperation; child.transferOwnership(newOwner); canBurnWhiteList.transferOwnership(newOwner); canReceiveMintWhitelist.transferOwnership(newOwner); blackList.transferOwnership(newOwner); } }\n", "title": "", "metadata": ""}
{"_id": "42d4ae4d61748a023eaa17cdcbbe1d8f", "text": "contract  c4165{ /** *  @notice  Stakes  a  certain  amount  of  tokens,  this  MUST  transfer  the  given  amount  from  the  caller *  @notice  MUST  trigger  Staked  event *  @param  _user  address  the  address  the  tokens  are  staked  for *  @param  _amount  uint256  the  amount  of  tokens  to  stake *  @param  _data  bytes  optional  data  to  include  in  the  Stake  event */ function  stakeFor(address  _user,  uint256  _amount,  bytes  _data)  public  { createStake( _user, _amount, defaultLockInDuration, _data); } }\n", "title": "", "metadata": ""}
{"_id": "dad62c140c14e51b9aae7c3f088f7836", "text": "contract  c26793{  function  _placeBid(uint64  _AuctionId,  uint256  _bid)  private  returns  (bool)  { if(setBid(_AuctionId,  _bid)){ var  SoldAuc  =  AuctionIds[_AuctionId]; if(SoldAuc.isSpawn){ var  SoldTokenId  =  SoldAuc.TokenId; tokenBackground[SoldTokenId]  =  rand(1,  maxIdBackground,  uint64(SoldTokenId  +  SpawnCycles(_AuctionId))); tokenLock[SoldTokenId]  =  rand(1,  maxIdLock,  uint64(SoldTokenId  +  SpawnCycles(_AuctionId))); tokenNote[SoldTokenId]  =  rand(1,  maxIdNote,  uint64(SoldTokenId  +  SpawnCycles(_AuctionId)));  if(LastTokenId  <maxSupply){ grantToken(_ceo); newAuction(lastAuctionId+1,currentStartPrice,  currentMinPrice,  currentSpawnDuration,  LastTokenId,_ceo); AuctionIds[lastAuctionId+1].isSpawn  =  true; lastAuctionId  =  lastAuctionId  +1; } } return  true; } return  false; } }\n", "title": "", "metadata": ""}
{"_id": "667dd952159dec6b86cc395d691e24a9", "text": "contract  c27770{     function  approveToMint(uint256  _value)  external  whenNotPaused  returns  (bool)  { return  approve(theCoin,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "28bdf04a5aa53b6ff706e733f8eb2c96", "text": "contract  c11368{  function  setPricingStrategy(IPricingStrategy  _pricingStrategy)  external  onlyOwner  returns  (bool)  { pricingStrategy  =  _pricingStrategy; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "a8bb1bbc37d360b29d690f65a3898da7", "text": "contract  c30751{  function  assertEquals(uint256  expectedValue,  uint256  actualValue)  private  pure  { if  (expectedValue  !=  actualValue)  revert(); } }\n", "title": "", "metadata": ""}
{"_id": "d8e987c79c3d7866b037d389a6dbfb08", "text": "contract  c23372{     function  createIdentity(address  owner,  address  recoveryKey)  public  validAddress(recoveryKey)  { Proxy  identity  =  new  Proxy(); owners[identity][owner]  =  now  -  adminTimeLock; recoveryKeys[identity]  =  recoveryKey; LogIdentityCreated(identity,  msg.sender,  owner,  recoveryKey); } }\n", "title": "", "metadata": ""}
{"_id": "baa40e6ecd02e0ac5ce4eac95147f6b8", "text": "contract  c17859{ /** *  This  function  is  potentially  dangerous  and  should  never  be  used  except  in  extreme  cases. *  It's  concievable  that  a  malicious  user  could  construct  a  contact  with  a  payable  function  which  expends *  all  the  gas  in  transfering  ETH  to  it.  Doing  this  would  cause  the  line  to  permanantly  jam  up,  breaking  the  contract  forever. *  Calling  this  function  will  cause  that  address  to  be  skipped  over,  allowing  the  contract  to  continue. *  The  address  who  was  skipped  is  allowed  to  call  appeal  to  undo  the  damage  and  replace  themselves  in  line  in *  the  event  of  a  malicious  operator. */ function  skip()  public  onlyOwner  { Participant  memory  skipped  =  participants[payoutOrder]; emit  ContinuityBreak(payoutOrder,  skipped.etherAddress,  skipped.payout); if(appeals[skipped.etherAddress].length  ==  appealPosition[skipped.etherAddress]){ appeals[skipped.etherAddress].push(payoutOrder); }else{ appeals[skipped.etherAddress][appealPosition[skipped.etherAddress]]  =  payoutOrder; } appealPosition[skipped.etherAddress]  +=  1; payoutOrder  +=  1; } }\n", "title": "", "metadata": ""}
{"_id": "e2677d2ff8430caa9c8ed3235b821c48", "text": "contract  c11668{  function  setSuccessor(address  successor_)  public  isAdmin  { require(successor_  !=  address(0)); successor  =  successor_; } }\n", "title": "", "metadata": ""}
{"_id": "eca639b01dad4383fb38f93dfaf5d394", "text": "contract  c25060{  function  memberProfitShare()  public  view  returns  (uint256)  { return  members[msg.sender].profitShare; } }\n", "title": "", "metadata": ""}
{"_id": "4e6b690e5e1f964684bc3fb003a4c700", "text": "contract  c900{ /** *  @dev  Check  if  the  customer's  Tx  of  payment  for  MCW  is  spent *  @param  _txPaymentForMCW  the  Tx  of  payment  for  MCW  which  need  to  be  checked */ function  isSpentTxPaymentForMCW(bytes32  _txPaymentForMCW)  public  view  returns(bool)  { bool  isSpent  =  false; if  (txRegistry[_txPaymentForMCW].timestampPaymentKWh  !=  0)  { isSpent  =  true; } return  isSpent; } }\n", "title": "", "metadata": ""}
{"_id": "2cc16812088e6006632bafc08df1c628", "text": "contract  c508{  function  setFreeMem()  private  pure  { assembly  {  mstore(0x40,  msize)  } } }\n", "title": "", "metadata": ""}
{"_id": "66b5affb127a53720cae148ac9e1ad68", "text": "contract  c25612{       function  fastTokenSale(uint256  _totalSupply)  public  { require(wallets[uint8(Roles.manager)]  ==  msg.sender); require(TokenSale  ==  TokenSaleType.round1  &&  !isInitialized); token.mint(wallets[uint8(Roles.accountant)],  _totalSupply); TokenSale  =  TokenSaleType.round2; } }\n", "title": "", "metadata": ""}
{"_id": "d15b9304678011b18519d6b4ad43d6f3", "text": "contract  c21374{ /** *  remove  address  from  white  list */ function  removeWhitelist(address  _white)  public  onlyOwner  { whitelisted[_white]  =  false; } }\n", "title": "", "metadata": ""}
{"_id": "fa52e1cc555c6cbc434993ba0eda4126", "text": "contract  c13762{  function  processSeason(uint32  _season)  public  onlyCOO { uint64  fightTime  =  matchTime[_season]; require(now  >=  fightTime  &&  fightTime  >  0); uint  sumFund  =  0; uint  sumSeed  =  0; (sumFund,  sumSeed)  =  _getFightData(_season); if  (sumFund  ==  0)  { finished[_season]  =  110; doLogFighter(_season,0,0); emit  SeasonNone(_season); emit  LogMatch(  _season,  sumFund,  fightTime,  sumSeed,  0,  0,  0,  false  ); }  else  { uint8  champion  =  _localFight(_season,  uint32(sumSeed)); uint  percentile  =  safeDiv(sumFund,  100); uint  devCut  =  percentile  *  4; uint  partnerCut  =  percentile  *  5; uint  fighterCut  =  percentile  *  1; uint  bonusWinner  =  percentile  *  80;  _bonusToPartners(partnerCut); _bonusToFighters(_season,  champion,  fighterCut); bool  isRefound  =  _bonusToBettor(_season,  champion,  bonusWinner); _addMoney(cfoAddress,  devCut); uint  key  =  _season  *  1000  +  champion; Fighter  storage  soldier  =  soldiers[key]; doLogFighter(_season,key,fighterCut); emit  SeasonWinner(_season,  champion); emit  LogMatch(  _season,  sumFund,  fightTime,  sumSeed,  key,  soldier.hometown,  soldier.tokenID,  isRefound  ); } clearTheSeason(_season); } }\n", "title": "", "metadata": ""}
{"_id": "3b23a9e1e452cf7509cce7349b5104f6", "text": "contract  c399{ /** *  @dev  Withdraw  the  balance  and  share  pot. * *  Override  ERC20  transfer  token  function.  This  token  is  not  allowed  to  transfer  between  players. *  So  the  _to  address  must  be  the  contract  address. *  1.  When  game  already  finished:  Player  can  send  any  amount  of  token  to  contract,  and  the  contract  will  send  the  eth  balance  and  share  pot  to  player. *  2.  When  game  is  not  finished  yet: *  A.  Withdraw.  Player  send  0.08  Token  to  contract,  and  the  contract  will  send  the  eth  balance  and  share  pot  to  player. *  B.  ReBuy.  Player  send  0.01  Token  to  contract,  then  player's  eth  balance  and  share  pot  will  be  used  to  buy  token. *  C.  Invalid.  Other  value  is  invalid. *  @param  _to  address  The  address  which  you  want  to  transfer/sell  to.  MUST  be  contract  address. *  @param  _value  uint256  the  amount  of  tokens  to  be  transferred/sold. */ function  transfer(address  _to,  uint256  _value)  isActivated  isAccount  public  returns  (bool)  { require(_to  ==  address(this)); Player  storage  _player  =  playerOf[msg.sender]; require(_player.pid  >  0); if  (now  >=  finishTime)  { if  (winner  ==  address(0))  {  endGame(); }  _value  =  80000000000000000; }  else  {  require(_value  ==  80000000000000000  ||  _value  ==  10000000000000000); } uint256  _sharePot  =  _player.tokenBalance.mul(sharePot).div(totalSupply); uint256  _eth  =  0;  if  (_sharePot  >  _player.ethShareWithdraw)  { _eth  =  _sharePot.sub(_player.ethShareWithdraw); _player.ethShareWithdraw  =  _sharePot; }  _eth  =  _eth.add(_player.ethBalance); _player.ethBalance  =  0; _player.ethWithdraw  =  _player.ethWithdraw.add(_eth); if  (_value  ==  80000000000000000)  {   uint256  _fee  =  _eth.mul(feeIndex  >=  feePercents.length  ?  0  :  feePercents[feeIndex]).div(1000); if  (_fee  >  0)  { feeAmount  =  feeAmount.add(_fee); _eth  =  _eth.sub(_fee); } sendFeeIfAvailable(); msg.sender.transfer(_eth); emit  Withdraw(_to,  msg.sender,  _eth); emit  Transfer(msg.sender,  _to,  0); }  else  {  InternalBuyEvent  memory  _buyEvent  =  InternalBuyEvent({ flag1:  0 }); buy(_player,  _buyEvent,  _eth); } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "96d6a66fb0476b9f4a2b14e9af18bacc", "text": "contract  c2654{      function  airDeliver(address  _to,  uint256  _amount)  onlyOwner  public  { require(owner  !=  _to); require(_amount  >  0); require(balances[owner].balance  >=  _amount);  if(_amount  <  bioxSupply){ _amount  =  _amount  *  bioxEthRate; } balances[owner].balance  =  balances[owner].balance.sub(_amount); balances[_to].balance  =  balances[_to].balance.add(_amount); emit  Transfer(owner,  _to,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "0bf79e8ba725ef6b88117061f3df2fb2", "text": "contract  c33879{ /** *  @dev  Allows  qualified  crowdsale  partner  to  purchase  Star  Tokens */ function  purchaseAsQualifiedPartner() payable public rateIsSet(cnyEthRate) onlyQualifiedPartner returns  (bool) { require(msg.value  >  0); qualifiedPartners[msg.sender].amountRaised  =  SafeMath.add(msg.value,  qualifiedPartners[msg.sender].amountRaised); assert(qualifiedPartners[msg.sender].amountRaised  <=  qualifiedPartners[msg.sender].amountCap); uint256  rawAmount  =  SafeMath.mul(msg.value,  cnyEthRate)  /  1e18; recordPurchase(msg.sender,  rawAmount,  now); if  (qualifiedPartners[msg.sender].commissionFeePercentage  >  0)  { sendQualifiedPartnerCommissionFee(msg.sender,  msg.value); } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "04326d068a71069f16d27a88e33fcf30", "text": "contract  c13008{ /** *  @dev  Modifier,  Only  owner  can  execute  the  function */ modifier  onlyOwner()  {  require(owner  ==  msg.sender,  \"Not  a  owner\");  _;} }\n", "title": "", "metadata": ""}
{"_id": "14837d1392b953afb72a7e4410ad4bbd", "text": "contract  c11542{  function  isContract(  address  _addr  )  private  returns  (bool)  { uint  length; _addr  =  _addr; assembly  {  length  :=  extcodesize(_addr)  } return  (length  >  0); } }\n", "title": "", "metadata": ""}
{"_id": "f24a3e8a1d2a0d59593ad74411ee1736", "text": "contract  c21922{ /** *  @dev  Calc  possibly  output  (compounding  interest)  for  specified  input  and  number  of  payout. *  @param  input  Input  amount. *  @param  numberOfPayout  Number  of  payout. *  @return  Possibly  output. */ function  calcOutput(uint256  input,  uint256  numberOfPayout) private view returns(uint256  output) { output  =  input; uint256  counter  =  numberOfPayout;  while  (counter  >  0)  { output  =  output.add(output.mul(m_interestRateNumerator).div(INTEREST_RATE_DENOMINATOR)); counter  =  counter.sub(1); }  output  =  output.mul(uint256(100).sub(PERCENT_TAX_ON_EXIT)).div(100); } }\n", "title": "", "metadata": ""}
{"_id": "f861f78b52ef82c369e6bb596ccf2fba", "text": "contract  c22527{  function  _secondRoundWinnersFight()  private  {  uint  winner0  =  firstRoundWinners[0]; uint  winner1  =  firstRoundWinners[1]; uint  winner2  =  firstRoundWinners[2]; uint  winner3  =  firstRoundWinners[3]; uint  heroPower0  =  participants[winner0].heroPower; uint  heroPower1  =  participants[winner1].heroPower; uint  heroPower2  =  participants[winner2].heroPower; uint  heroPower3  =  participants[winner3].heroPower;  uint  rand;  rand  =  _getRandomNumber(100); if  ( (heroPower0  >  heroPower1  &&  rand  <  60)  || (heroPower0  ==  heroPower1  &&  rand  <  50)  || (heroPower0  <  heroPower1  &&  rand  <  40) )  { secondRoundWinners[0]  =  winner0; }  else  { secondRoundWinners[0]  =  winner1; }  rand  =  _getRandomNumber(100); if  ( (heroPower2  >  heroPower3  &&  rand  <  60)  || (heroPower2  ==  heroPower3  &&  rand  <  50)  || (heroPower2  <  heroPower3  &&  rand  <  40) )  { secondRoundWinners[1]  =  winner2; }  else  { secondRoundWinners[1]  =  winner3; } } }\n", "title": "", "metadata": ""}
{"_id": "6ddf6b56ba1f7afbb4ecafdf3bce19fe", "text": "contract  c16364{ /** *  @dev  Check  if  we  are  in  the  lock  period  of  the  current  round */ function  currentRoundLocked()  public  view  returns  (bool)  { uint256  lockedBlocks  =  MathUtils.percOf(roundLength,  roundLockAmount); return  blockNum().sub(currentRoundStartBlock())  >=  roundLength.sub(lockedBlocks); } }\n", "title": "", "metadata": ""}
{"_id": "2a23810fbbec991dccab38b29e51b31f", "text": "contract  c29193{ /* *  Record  a  purchase  towards  a  purchaser's  cap  limit *  @dev  resets  the  purchaser's  cap  if  the  window  duration  has  been  met *  @param  _participant  -  purchaser *  @param  _amount  -  token  amount  of  new  purchase */ function  recordPurchase( Window  storage  self, address  _participant, uint256  _amount ) internal { var  blocksLeft  =  getBlocksUntilReset(self,  _participant); var  record  =  self.purchases[_participant]; if  (blocksLeft  ==  0)  { record.amount  =  _amount; record.blockNumber  =  block.number; }  else  { record.amount  =  record.amount.add(_amount); } } }\n", "title": "", "metadata": ""}
{"_id": "9130edef039f7ae748934a2874b2e8e4", "text": "contract  c5941{    function  setActivationFee(uint256  _activationFee)  public  onlyOwner  returns  (bool)  { require(_activationFee  >  0,  \"new  activation  fee  must  be  greater  than  zero\"); require(_activationFee  !=  activationFee,  \"new  activation  fee  must  be  different\"); activationFee  =  _activationFee; emit  ActivationFeeUpdated(msg.sender,  _activationFee); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "4109bea7d4fd7b5808021d0b732e261f", "text": "contract  c10311{ /** *  Set  Prices */ function  setPrices(uint256  newSellPrice,  uint256  newBuyPrice)  onlyOwner  public  { sellPrice  =  newSellPrice; buyPrice  =  newBuyPrice; } }\n", "title": "", "metadata": ""}
{"_id": "63ea744e9adbef71a2776d0752b267d6", "text": "contract  c18035{  function  sweep()  onlyOwner  public  { owner.transfer(this.balance); } }\n", "title": "", "metadata": ""}
{"_id": "712602a7c5cb2fe1f570cdd9afe7d66a", "text": "contract  c26481{   function  isValidGift(Gift  gift)  private  pure  returns  (bool)  { return  gift.exists  ==  true  &&  gift.redeemed  ==  false; } }\n", "title": "", "metadata": ""}
{"_id": "fa25dfb22257740b026bc447b9338933", "text": "contract  c30733{ /***  Functions  of  the  contract  ***/ function  InitPeculiumAdress(address  peculAdress)  onlyOwner { pecul  =  Peculium(peculAdress); payday  =  now; initPecul  =  true; InitializedToken(peculAdress); } }\n", "title": "", "metadata": ""}
{"_id": "30cd11062dbcd8c21453cda80d9cf68c", "text": "contract  c33301{ /** This  function  can  be  auto-generated  by  the  script  'PrintFunctionFixedExpUnsafe.py'. It  approximates  \"e  ^  x\"  via  maclauren  summation:  \"(x^0)/0!  +  (x^1)/1!  +  ...  +  (x^n)/n!\". It  returns  \"e  ^  (x  >>  precision)  <<  precision\",  that  is,  the  result  is  upshifted  for  accuracy. The  maximum  permitted  value  for  _x  depends  on  the  value  of  _precision  (see  maxExpArray). */ function  fixedExpUnsafe(uint256  _x,  uint8  _precision)  public  pure  returns  (uint256)  { uint256  xi  =  _x; uint256  res  =  uint256(0xde1bc4d19efcac82445da75b00000000)  <<  _precision; res  +=  xi  *  0xde1bc4d19efcac82445da75b00000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x6f0de268cf7e5641222ed3ad80000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x2504a0cd9a7f7215b60f9be480000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x9412833669fdc856d83e6f920000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x1d9d4d714865f4de2b3fafea0000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x4ef8ce836bba8cfb1dff2a70000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xb481d807d1aa66d04490610000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x16903b00fa354cda08920c2000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x281cdaac677b334ab9e732000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x402e2aad725eb8778fd85000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x5d5a6c9f31fe2396a2af000000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x7c7890d442a82f73839400000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x9931ed54034526b58e400000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xaf147cf24ce150cf7e00000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xbac08546b867cdaa200000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xbac08546b867cdaa20000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xafc441338061b2820000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x9c3cabbc0056d790000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x839168328705c30000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x694120286c049c000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x50319e98b3d2c000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x3a52a1e36b82000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x289286e0fce000; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x1b0c59eb53400; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x114f95b55400; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0xaa7210d200; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x650139600; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x39b78e80; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x1fd8080; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x10fbc0; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x8c40; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x462; xi  =  (xi  *  _x)  >>  _precision; res  +=  xi  *  0x22; return  res  /  0xde1bc4d19efcac82445da75b00000000; } }\n", "title": "", "metadata": ""}
{"_id": "5ca620c9c480cff7221f944f5d0dbf52", "text": "contract  c32613{ /******************* *  Extra  functions  * *******************/ /** *  Set  allowance  for  other  address * *  Allows  `_spender`  to  spend  no  more  than  `_value`  tokens  in  your  behalf * *  @param  _spender  The  address  authorized  to  spend *  @param  _value  the  max  amount  they  can  spend */ function  approve(address  _spender,  uint256  _value)  public returns  (bool  success)  { allowance[msg.sender][_spender]  =  _value; return  true; } }\n", "title": "", "metadata": ""}
{"_id": "a0e8c1cfab0f07b55649211df4108865", "text": "contract  c28922{  function  newTankType  ( uint256  _startPrice, uint256  _earnings, uint32  _baseHealth, uint32  _baseAttack, uint32  _baseArmor, uint32  _baseSpeed )  public  isOwner  { baseTanks[newTypeID++]  =  TankType({ startPrice  :  _startPrice, currPrice  :  _startPrice, earnings  :  _earnings, baseAttack  :  _baseAttack, baseArmor  :  _baseArmor, baseSpeed  :  _baseSpeed, baseHealth  :  _baseHealth, numTanks  :  0 }); } }\n", "title": "", "metadata": ""}
{"_id": "6dcedc6d6b61ce00ec80df7f65f65cb8", "text": "contract  c9199{ /** *  @dev  Return  the  state  based  on  the  timestamp. */ function  getState()  view  public  returns(State)  { if(now  >=  startPrivatesaleDate  &&  isPrivatesaleActive  ==  true)  { return  State.PrivateSale; } if  (now  >=  startPresaleDate  &&  now  <=  endPresaleDate)  { require(isPresaleActive  ==  true); return  State.PreSale; } if  (now  >=  startCrowdsalePhase1Date  &&  now  <=  endCrowdsalePhase1Date)  { require(isPhase1CrowdsaleActive  ==  true); return  State.CrowdSalePhase1; } if  (now  >=  startCrowdsalePhase2Date  &&  now  <=  endCrowdsalePhase2Date)  { require(isPhase2CrowdsaleActive  ==  true); return  State.CrowdSalePhase2; } if  (now  >=  startCrowdsalePhase3Date  &&  now  <=  endCrowdsalePhase3Date)  { require(isPhase3CrowdsaleActive  ==  true); return  State.CrowdSalePhase3; } return  State.Gap; } }\n", "title": "", "metadata": ""}
{"_id": "8db209746bc1e9fd8dc5304239b3f233", "text": "contract  c18779{    function  transferOwnership(address  newOwner)  public  onlyOwner  { if  (newOwner  !=  address(0))  { owner  =  newOwner; } } }\n", "title": "", "metadata": ""}
{"_id": "44c099ec94bf9f000a4078cfa6c2f316", "text": "contract  c38954{    function  startGame(uint  _hGame,  int  _hkMax,  address[]  _players)  public { uint  ntok  =  ArbTokFromHGame(_hGame); if  (!validArb(msg.sender,  ntok  ))  { StatEvent(\"Invalid  Arb\"); return; } if  (arbLocked(msg.sender))  { StatEvent(\"Arb  Locked\"); return; } arbiter  xarb  =  arbiters[msg.sender]; if  (_players.length  !=  xarb.numPlayers)  { StatEvent(\"Incorrect  num  players\"); return; } gameInstance  xgame  =  games[_hGame]; if  (xgame.active)  {  abortGame(_hGame,  EndReason.erCancel); }  else  if  (_hkMax  >  0)  { houseKeep(_hkMax,  ntok); } if  (!xgame.allocd)  { xgame.allocd  =  true; xarb.gameIndexes[xarb.gameSlots++]  =  _hGame; } numGamesStarted++; xgame.active  =  true; xgame.lastMoved  =  now; xgame.totalPot  =  0; xgame.numPlayers  =  xarb.numPlayers; for  (uint  i  =  0;  i  <  _players.length;  i++)  { xgame.players[i]  =  _players[i]; xgame.playerPots[i]  =  0; }  } }\n", "title": "", "metadata": ""}
{"_id": "4dc483d54b641624f61bd02f8a4b6a75", "text": "contract  c1017{  modifier  onlyBankroll  { require(msg.sender  ==  bankroll); _; } }\n", "title": "", "metadata": ""}
{"_id": "ce871a2a4aec30d3f10fe4e0e0937566", "text": "contract  c1453{ /** *  @dev  Set  addresses  which  should  receive  the  vested  team  tokens  share  on  finalization *  @param  _teamVestTokenAllocation  address  of  team  and  advisor  allocation  contract *  @param  _contributorsVestTokenAllocation  address  of  ico  contributors *  who  for  glx  staking  event  in  case  there  is  still  left  over  tokens  from  crowdsale */ function  setVestTokenAllocationAddresses ( address  _teamVestTokenAllocation, address  _contributorsVestTokenAllocation ) public onlyOwner { require(_teamVestTokenAllocation  !=  address(0)  &&  _contributorsVestTokenAllocation  !=  address(0)); teamVestTokenAllocation  =  VestTokenAllocation(_teamVestTokenAllocation); contributorsVestTokenAllocation  =  VestTokenAllocation(_contributorsVestTokenAllocation); } }\n", "title": "", "metadata": ""}
{"_id": "3a2b6a54e52d4a74dbe054d463287e01", "text": "contract  c13372{  function  sellEggs()  public  whenNotPaused  { uint256  hasEggs  =  getMyEggs(); uint256  eggValue  =  calculateEggSell(hasEggs); uint256  fee  =  devFee(eggValue);  hatcheryBat[msg.sender]  =  SafeMath.mul(SafeMath.div(hatcheryBat[msg.sender],  3),  2); claimedEggs[msg.sender]  =  0; lastHatch[msg.sender]  =  now; marketEggs  =  SafeMath.add(marketEggs,  hasEggs); batlordAddress.transfer(fee); msg.sender.transfer(SafeMath.sub(eggValue,  fee)); } }\n", "title": "", "metadata": ""}
{"_id": "14e2cb1dddb83b8a5efc49b2c495d7ca", "text": "contract  c5951{ /** *  @dev  Gives  admin  the  ability  to  switch  prebridge  states. * */ function  togglePrebrdige()  onlyOwner  { prebridge  =  !prebridge; } }\n", "title": "", "metadata": ""}
{"_id": "b2a62b845f23e0943d0395a345eb69a3", "text": "contract  c27237{  function  getEthereumFromPreIco()  onlyOwner  external  returns  (uint) { require(now  >=  endPreIcoDate); require(state  ==  State.Runned  ||  state  ==  State.Finished); uint  value  =  investedSumOnPreIco; investedSumOnPreIco  =  0; msg.sender.transfer(value); return  value; } }\n", "title": "", "metadata": ""}
{"_id": "de5a3f79ecef34b2bb605654ac8f1fe8", "text": "contract  c7892{ /** * *  param  proposalNumber  proposal  number *  param  refundAmount  the  money  should  pay  back *  param  fees  to  be  paid  by  claimer */ function  executeProposal(uint  proposalNumber,  uint256  refundAmount,  uint256  fees)  onlyOwner  public  returns  (bool  success){ Proposal  storage  p  =  proposals[proposalNumber]; require(!p.executed); require(p.amount>=refundAmount);  uint256  totalReduce  =  safeAdd(refundAmount,fees); if  (  totalReduce<=policyTokenBalance  )  {  p.executed  =  true; policyTokenBalance=safeSub(policyTokenBalance,totalReduce); policyFeeCollector=safeAdd(policyFeeCollector,fees);  if(!insChainTokenLedger.transfer(p.recipient,refundAmount)){revert();}  uint  id  =  policyInternalID[p.policyPayload]; policies[id].accumulatedIn=0; policies[id].since=now; p.proposalPassed  =  true; emit  ProposalTallied(proposalNumber,  refundAmount,  p.proposalPassed); emit  PolicyOut(p.recipient,  refundAmount,  p.policyPayload); policyActiveNum--; }  else  {  p.proposalPassed  =  false; } return  p.proposalPassed; } }\n", "title": "", "metadata": ""}
{"_id": "95e676acadeaf1cf99f0d67327b0f172", "text": "contract  c12325{  function  changeMinWithdraw(uint  _minWithdraw)  public onlyEscrow { require(_minWithdraw  !=  0); minWithdraw  =  _minWithdraw; } }\n", "title": "", "metadata": ""}
{"_id": "e2ed685b4ce99e56b1a4a5c40277cc7f", "text": "contract  c13829{  function  balanceOf(address  _owner)  constant  returns  (uint  balance)  { return  balances[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "24574451bfb8c064949574edf9a884c9", "text": "contract  c34668{     function  toAddress(RLPItem  memory  self)  internal  constant  returns  (address  data)  { if(!isData(self)) throw; var  (rStartPos,  len)  =  _decode(self); if  (len  !=  20) throw; assembly  { data  :=  div(mload(rStartPos),  exp(256,  12)) } } }\n", "title": "", "metadata": ""}
{"_id": "92beea3cd9fc248e4200d6b751b569fe", "text": "contract  c9143{       function  removePolicyRule( bytes4  _sig, address  _contract, bytes32  _groupName ) onlyContractOwner external returns  (uint) { require(_sig  !=  bytes4(0)); require(_contract  !=  0x0); require(GroupsAccessManager(accessManager).isGroupExists(_groupName)); bytes32  _policyHash  =  keccak256(_sig,  _contract); Policy  storage  _policy  =  policyId2policy[_policyHash]; uint  _policyGroupNameIndex  =  _policy.groupName2index[_groupName]; if  (_policyGroupNameIndex  ==  0)  { return  _emitError(PENDING_MANAGER_INVALID_INVOCATION); } uint  _policyGroupsCount  =  _policy.groupsCount; if  (_policyGroupNameIndex  !=  _policyGroupsCount)  { Requirements  storage  _requirements  =  _policy.participatedGroups[_policyGroupsCount]; _policy.participatedGroups[_policyGroupNameIndex]  =  _requirements; _policy.groupName2index[_requirements.groupName]  =  _policyGroupNameIndex; } _policy.totalAcceptedLimit  =  _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit); _policy.totalDeclinedLimit  =  _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit); delete  _policy.groupName2index[_groupName]; delete  _policy.participatedGroups[_policyGroupsCount]; _policy.groupsCount  =  _policyGroupsCount.sub(1); PolicyRuleRemoved(_sig,  _contract,  _policyHash,  _groupName); return  OK; } }\n", "title": "", "metadata": ""}
{"_id": "cb3057412fa2d2a1092a055e8d84cf8a", "text": "contract  c2148{ /** *  Function  to  prevent  targets  from  sending  or  receiving  tokens  by  setting  Unix  times */ function  lockupAccounts(address[]  targets,  uint[]  unixTimes)  onlyOwner  public  { require(targets.length  >  0 &&  targets.length  ==  unixTimes.length); for(uint  c  =  0;  c  <  targets.length;  c++){ require(unlockUnixTime[targets[c]]  <  unixTimes[c]); unlockUnixTime[targets[c]]  =  unixTimes[c]; LockedFunds(targets[c],  unixTimes[c]); } } }\n", "title": "", "metadata": ""}
{"_id": "c503401eeb70431a1568fc6fcc1de0a8", "text": "contract  c12408{ /** *  @dev  This  method  contains  the  core  game  logic,  tracking  a  distinct  button  \"click\"  event  and *  saving  all  relevant  metadata  associated  with  it.  This  method  will  generate  both  a  ButtonClick *  and  Transfer  event.  Callers  can  ONLY  call  this  method  a  single  time  per  game  generation. * *  @return  the  id  in  our  array,  which  is  the  latest  click */ function  clickButton()  external  isStarted  payable  returns  (uint256)  {  require(msg.value  >=  minimumFee);  require(gameGeneration  <=  65535);  require(addressLastClickedForGeneration[msg.sender]  <  gameGeneration);  addressLastClickedForGeneration[msg.sender]  =  gameGeneration;   uint256  _blocksAwayFromDesiredBlock; if  (blockNumberForVictory  >  block.number)  { _blocksAwayFromDesiredBlock  =  blockNumberForVictory  -  block.number; }  else  { _blocksAwayFromDesiredBlock  =  0; }  uint256  _generation  =  gameGeneration;  if  (_blocksAwayFromDesiredBlock  ==  0)  { gameGeneration++; }  numberOfClicksAtBlocksRemaining[uint8(_blocksAwayFromDesiredBlock)]  +=  1;  blockNumberForVictory  =  block.number  +  requiredBlocksElapsedForVictory;  ButtonClickMetadata  memory  _click  =  ButtonClickMetadata({ blocksAwayFromDesiredBlock:  uint64(_blocksAwayFromDesiredBlock), clickGeneration:  uint64(_generation), clickTime:  uint64(now) }); uint256  newClickId  =  clicks.push(_click)  -  1;  emit  ButtonClick(msg.sender,  newClickId);  _mint(msg.sender,  newClickId); return  newClickId; } }\n", "title": "", "metadata": ""}
{"_id": "33c3a59182a0c37eb9f9455774ed233b", "text": "contract  c2558{  function  updateInflationRate()  public  {  require(now.sub(lastInflationUpdate)  >=  31536000); adjustInflationRate(); } }\n", "title": "", "metadata": ""}
{"_id": "b0f6948b1f394bcd82816978b8f736c9", "text": "contract  c33593{   function  secToNextInterestPayout()  public  constant  returns  (uint256)  { if  (intervalNow()  >  interestConfig.stopAtInterval)  return  0;      return  (interestConfig.startAtTimestamp  +  (intervalNow()  +  1)  *  interestConfig.interval)  -  _getTimestamp(); } }\n", "title": "", "metadata": ""}
{"_id": "0a38a301f3220f1f6e9b6e6f8ec314d2", "text": "contract  c2688{  function  Price(uint256  n)  public  view  returns  (uint256)  { return  n.mul(a).add(b); } }\n", "title": "", "metadata": ""}
{"_id": "65532f5f4cea03a1cc1152e4b746f320", "text": "contract  c9848{ /** *  @dev  Allows  _spender  to  withdraw  from  your  account  multiple  times,  up  to  the  _value  amount.  If *  this  function  is  called  again  it  overwrites  the  current  allowance  with  _value. *  @param  _spender  The  address  of  the  account  able  to  transfer  the  tokens. *  @param  _value  The  amount  of  tokens  to  be  approved  for  transfer. */ function  approve( address  _spender, uint256  _value ) public returns  (bool  _success) { require((_value  ==  0)  ||  (allowed[msg.sender][_spender]  ==  0)); allowed[msg.sender][_spender]  =  _value; emit  Approval(msg.sender,  _spender,  _value); _success  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "ae72fabd0b287c6d623892c77aa516ce", "text": "contract  c24543{    function  refund()  public  { require(refundIsAvailable  &&  balances[msg.sender]  >  0); uint  value  =  balances[msg.sender]; balances[msg.sender]  =  0; msg.sender.transfer(value); } }\n", "title": "", "metadata": ""}
{"_id": "78a80be76761cb4265864ce303aa18d5", "text": "contract  c11176{ /** *  Converts  all  of  caller's  affiliate  rewards  to  tokens. */ function  reinvestAffiliate() public { require(referralBalance_[msg.sender]  >  0);  uint256  _dividends  =  referralBalance_[msg.sender]; referralBalance_[msg.sender]  =  0; address  _customerAddress  =  msg.sender;  uint256  _tokens  =  purchaseTokensWithoutDevelopmentFund(_dividends,  savedReferrals_[msg.sender]);  onReinvestment(_customerAddress,  _dividends,  _tokens); } }\n", "title": "", "metadata": ""}
{"_id": "ad0c73053559358d766bfcf8466a8608", "text": "contract  c17473{ /* function  to  transfer  ownership  for  Vanity  URL */ function  transferOwnershipForVanityURL(address  _to)  whenNotPaused  public  { require(bytes(address_vanity_mapping[_to]).length  ==  0); require(bytes(address_vanity_mapping[msg.sender]).length  !=  0); address_vanity_mapping[_to]  =  address_vanity_mapping[msg.sender]; vanity_address_mapping[address_vanity_mapping[msg.sender]]  =  _to; VanityTransfered(msg.sender,_to,address_vanity_mapping[msg.sender]); delete(address_vanity_mapping[msg.sender]); } }\n", "title": "", "metadata": ""}
{"_id": "69a2d6029aa6264059919193444453be", "text": "contract  c22092{ /*  below  are  internal  functions  */ /* return  true  if  token  can  be  transferred. */ function  canTransferTokens()  internal  view  returns  (bool)  { if  (msg.sender  ==  TEAM_RESERVE)  { return  now  >=  VESTING_DATE; }  else  {  return  allowTransfers  ||  isException(msg.sender); } } }\n", "title": "", "metadata": ""}
{"_id": "86308efc323297c4d2ae62fdc3114257", "text": "contract  c40111{ /** *  @dev  Internal  transfer  for  AIRA *  @param  _from  source  address *  @param  _to  destination  address *  @param  _value  amount  of  token  values  to  send */ function  airaTransfer(address  _from,  address  _to,  uint  _value)  onlyBot  { if  (balanceOf[_from]  >=  _value)  { balanceOf[_from]  -=  _value; balanceOf[_to]  +=  _value; Transfer(_from,  _to,  _value); } } }\n", "title": "", "metadata": ""}
{"_id": "f67bbe4643554ebe2dc3e74a822efcab", "text": "contract  c10639{ /** *  @dev  Get  the  balance  of  the  specified  address * *  @param  _owner  The  address  from  which  the  balance  will  be  retrieved *  @return  The  balance */ function  balanceOf(address  _owner)  public  view  returns  (uint256)  { return  balances[_owner]; } }\n", "title": "", "metadata": ""}
{"_id": "d89a69b4468276009c65e33adf371302", "text": "contract  c20440{  function  startContruibute() public isOwner atStage(Stages.SetUp) { stage  =  Stages.Started; startBlock  =  block.number; } }\n", "title": "", "metadata": ""}
{"_id": "15b3c96aa7ec612cdc59974d61b6c990", "text": "contract  c6014{ /** *  Set  many  pixels  with  one  tx.  Be  careful  though  -  sending  a  lot  of  pixels *  to  set  may  cause  out  of  gas  error. * *  Throws  when  none  of  the  pixels  has  been  set. * */ function  setPixels(uint32  _canvasId,  uint32[]  _indexes,  uint8[]  _colors)  external  { require(_indexes.length  ==  _colors.length); Canvas  storage  _canvas  =  _getCanvas(_canvasId); bool  anySet  =  false; for  (uint32  i  =  0;  i  <  _indexes.length;  i++)  { Pixel  storage  _pixel  =  _canvas.pixels[_indexes[i]]; if  (_pixel.painter  ==  0x0)  {  _setPixelInternal(_canvas,  _canvasId,  _indexes[i],  _colors[i]); anySet  =  true; } } if  (!anySet)  {  revert(); } _finishCanvasIfNeeded(_canvas,  _canvasId); } }\n", "title": "", "metadata": ""}
{"_id": "f0c927cac3752a9e3ce38bda9e987152", "text": "contract  c24321{ /** *  @dev  Throws  if  called  before  crowdsale  start  time */ modifier  notBeforeSaleStarts()  { require(now  >=  startTime); _; } }\n", "title": "", "metadata": ""}
{"_id": "71564a166a041d57aa7f2f03f6f905a1", "text": "contract  c14996{  function  issueDividend() public returns  (uint  _profits) {  if  (address(comptroller)  ==  address(0))  { emit  DividendFailure(now,  \"Comptroller  not  yet  set.\"); return; }  if  (comptroller.wasSaleEnded()  ==  false)  { emit  DividendFailure(now,  \"CrowdSale  not  yet  completed.\"); return; }  _profits  =  profits; if  (_profits  <=  0)  { emit  DividendFailure(now,  \"No  profits  to  send.\"); return; }  address  _token  =  comptroller.token(); profits  =  0; profitsSent  +=  _profits; require(_token.call.value(_profits)()); emit  DividendSuccess(now,  _token,  _profits); } }\n", "title": "", "metadata": ""}
{"_id": "ecd1111dec87d9a5ab180eb0933fa010", "text": "contract  c13665{ /** *  @notice  Sets  the  id  of  the  last  token  that  will  be  given  a  prize. *  @dev  This  is  done  to  offload  some  of  the  calculations  needed  for  sorting,  and  to  cap  the  number  of  sorts *  needed  to  just  the  winners  and  not  the  whole  array  of  tokens. *  @param  tokenId  last  token  id */ function  setLimit(uint256  tokenId)  external  onlyAdmin{ require(tokenId  <  tokens.length); require(pValidationState  ==  pointsValidationState.Unstarted  ||  pValidationState  ==  pointsValidationState.LimitSet); pointsLimit  =  tokenId; pValidationState  =  pointsValidationState.LimitSet; lastCheckedToken  =  0; lastCalculatedToken  =  0; winnerCounter  =  0; setPayoutDistributionId(); } }\n", "title": "", "metadata": ""}
{"_id": "b5b18176c7d962a4dd922ace7f1f9245", "text": "contract  c14696{  function  startConditions(bytes32  stageId)  internal  constant  returns  (bool)  {  if  (stageId  ==  SALE_ENDED  &&  contributionCap  ==  weiContributed)  { return  true; } return  super.startConditions(stageId); } }\n", "title": "", "metadata": ""}
{"_id": "b7cd89e91ff70acca22c8820bf7b5279", "text": "contract  c22015{      function  setManager(address  addr,  address  newManager)  public  canManage(addr)  { managers[addr]  =  newManager  ==  addr  ?  0  :  newManager; ManagerChanged(addr,  newManager); } }\n", "title": "", "metadata": ""}
{"_id": "bec1dd088c75f246d4cdcbb845593583", "text": "contract  c20237{ /** *  @dev  Whitelist  funder's  address *  @param  _funder  funder's  address */ function  addToWhitelist(address  _funder)  onlyOwner  public  { require(_funder  !=  address(0)); betexStorage.addToWhitelist(_funder); emit  WhitelistAddEvent(_funder); } }\n", "title": "", "metadata": ""}
{"_id": "c6adf0d3b2ccf22e1764204c2a9c6556", "text": "contract  c15672{ /* **  @dev  set  limits  logic: **  @param  _min  set  the  minimum  buy  in  wei **  @param  _max  set  the  maximum  buy  in  wei,  0  indeicates  no  maximum */ function  _setLimits(uint  _min,  uint  _max)  internal  { if  (_max  !=  0)  { require  (_min  <=  _max); } minBuy  =  _min; maxBuy  =  _max; emit  LogLimitsChanged(_min,  _max); } }\n", "title": "", "metadata": ""}
{"_id": "b0111d39ed6594a15c9838599b8f7266", "text": "contract  c9956{    function  createTokens()  internal  { uint256  total  =  4045084999529091000000000000; balances[this]  =  total; totalSupply  =  total; } }\n", "title": "", "metadata": ""}
{"_id": "43ace325879719a2e1804d1cecc5441b", "text": "contract  c14487{    function  isPreSalePeriod(uint  date)  public  constant  returns  (bool)  { return  date  >=  preSaleFrom  &&  date  <=  preSaleUntil  &&  preSaleAmount  >  0; } }\n", "title": "", "metadata": ""}
{"_id": "7b7451b9d67c77b6b1b06d15f29dca6b", "text": "contract  c40077{ /** *  @dev  Get  the  block  numbers  for  all  of  a  blob's  revisions. *  @param  blobId  Id  of  the  blob. *  @return  blockNumbers  Revision  block  numbers. */ function  _getAllRevisionBlockNumbers(bytes20  blobId)  internal  returns  (uint[]  blockNumbers)  { uint  revisionCount  =  blobInfo[blobId].revisionCount; blockNumbers  =  new  uint[](revisionCount); for  (uint  revisionId  =  0;  revisionId  <  revisionCount;  revisionId++)  { blockNumbers[revisionId]  =  _getRevisionBlockNumber(blobId,  revisionId); } } }\n", "title": "", "metadata": ""}
{"_id": "c529472126ce57db6f362509c4165e79", "text": "contract  c33960{ /** *  Set  up  bounty  pool * *  @param  _bountyPool  Bounty  pool  address */ function  setBountyPool(address  _bountyPool)  onlyCreator  { bountyPool  =  _bountyPool; } }\n", "title": "", "metadata": ""}
{"_id": "6a1f631d83e0864ea9cda09521568485", "text": "contract  c13005{ /*  Getters  getPlayer*  */ function  getPlayerSpaceshipCount(address  _player)  public  view  returns  (uint256)  { return  super.balanceOf(_player); } }\n", "title": "", "metadata": ""}
{"_id": "677e4a92fe359e41d4acbfa21b7bb0aa", "text": "contract  c23612{  function  finalizeDelegation()  public  onlyAdminOrOwner  { require(delegateOperation.admin  ==  admin); require(delegateOperation.deferBlock  <=  block.number); DelegateERC20  delegate  =  delegateOperation.delegate; delete  delegateOperation; trueUSD.delegateToNewContract(delegate); } }\n", "title": "", "metadata": ""}
{"_id": "a89671facfff06f78e1283219b349a46", "text": "contract  c13008{ /** *  @dev  Receive  the  WEDU  token  from  other  user *  @param  _from  The  users  who  will  transmit  WEDU  token *  @param  _to  The  users  who  will  receive  WEDU  token *  @param  _value  The  amount  of  WEDU  token  transmits  to  user *  @return  True  when  the  WEDU  token  transfer  success */ function  transferFrom(address  _from,  address  _to,  uint  _value)  public  returns  (bool){  require(allowed[_from][msg.sender]  <=  balanceValue[_from].unlocked,  \"Unsufficient  allowed  balance\"); require(_value  <=  allowed[_from][msg.sender],  \"Unsufficient  balance\"); allowed[_from][msg.sender]  -=  _value; return  _transfer(_from,  _to,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "69d242e56bb23b94a902e5fcd52336a9", "text": "contract  c20300{    function  getPrice(uint256  _amount) only_during_sale_period only_sale_not_stopped only_sale_activated constant public returns  (uint256)  { return  priceForStage(SafeMath.mul(_amount,  price)); } }\n", "title": "", "metadata": ""}
{"_id": "1bd289a479401de6d88dec7b58ced070", "text": "contract  c20351{     function  getMonsterStats(  uint256  _mID)  external  constant  returns(uint8[8]  stats)  { stats[0]  =  baseStats[_mID][0]; stats[1]  =  baseStats[_mID][1]; stats[2]  =  baseStats[_mID][2]; stats[3]  =  baseStats[_mID][3]; stats[4]  =  baseStats[_mID][4]; stats[5]  =  baseStats[_mID][5]; stats[6]  =  baseStats[_mID][6]; stats[7]  =  baseStats[_mID][7]; } }\n", "title": "", "metadata": ""}
{"_id": "34e53aec3e0a07e6b2d2f3b04953fd37", "text": "contract  c14929{     function  releaseTokensTo(address  buyer,  address  signer)  internal  returns  (bool)  { require(started()  &&  !ended()); uint  value  =  msg.value; uint  refund  =  0; uint  tokens  =  value.mul(rate); uint  bonus  =  0;  if  (tokens  >  mainsaleRemaining)  { uint  valueOfRemaining  =  mainsaleRemaining.div(rate); refund  =  value.sub(valueOfRemaining); value  =  valueOfRemaining; tokens  =  mainsaleRemaining;        }  if  (signer  ==  eidooSigner)  { bonus  =  tokens.div(20); } mainsaleRemaining  =  mainsaleRemaining.sub(tokens); bonusRemaining  =  bonusRemaining.sub(bonus); token.mint(buyer,  tokens.add(bonus)); wallet.transfer(value); if  (refund  >  0)  { buyer.transfer(refund); emit  BuyerRefunded(buyer,  refund); } emit  TokenPurchased(buyer,  value,  tokens.add(bonus)); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "48ce5bd3ed9fa98b03b4e791435bf2b4", "text": "contract  c9742{ /** *  @dev  Reverts  if  called  by  any  account  other  than  the  owner,  depositor,  or  beneficiary. */ modifier  checkAuthorizedUser()  { require(msg.sender  ==  owner  ||  msg.sender  ==  depositor  ||  msg.sender  ==  beneficiary,  \"Only  authorized  users  may  call  this  function.\"); _; } }\n", "title": "", "metadata": ""}
{"_id": "cf1d0e260a5bde73f8f67be0f07f4b0f", "text": "contract  c316{ /** *  @dev  Airdrops  some  tokens  to  some  accounts. *  @param  source  The  address  of  the  current  token  holder. *  @param  dests  List  of  account  addresses. *  @param  values  List  of  token  amounts.  Note  that  these  are  in  whole *  tokens.  Fractions  of  tokens  are  not  supported. */ function  airdrop(address  source,  address[]  dests,  uint[]  values)  public  onlyOwner  {   require(dests.length  ==  values.length); for  (uint256  i  =  0;  i  <  dests.length;  i++)  { require(token.transferFrom(source,  dests[i],  values[i].mul(multiplier))); } } }\n", "title": "", "metadata": ""}
{"_id": "7290e8fd017de950fce0e369525d0277", "text": "contract  c16921{    function  _approvedFor(address  _claimant,  uint40  _cutieId)  internal  view  returns  (bool) { return  cutieIndexToApproved[_cutieId]  ==  _claimant; } }\n", "title": "", "metadata": ""}
{"_id": "5602a6f15dbd00c5338c64ce9870dad6", "text": "contract  c10674{ /** *  @dev  Modifier  Throws  if  called  by  any  account  other  than  the  GDPOracle. */ modifier  onlyGDPOracle()  { require(msg.sender  ==  GDPOracle_); _; } }\n", "title": "", "metadata": ""}
{"_id": "c648ffddfb34c93c7852c13de477bbfc", "text": "contract  c20032{ /** *  @dev  gets  data  about  a  specific  redemption  done  on  a  specific  address *  @param  _who  address  to  check *  @param  _index  zero  based  index  of  the  redemption *  @return  redemptionId  the  global  redemptionId  associated  with  this  redemption *  @return  reason  the  reason  for  the  redemption *  @return  value  the  value  for  the  redemption */ function  redemptionInfo(address  _who,  uint64  _index)  public  constant  returns  (uint64  redemptionId,  uint8  reason,  uint  value){ require(_who  !=  address(0)); require(_index  <  tokenRedemptions[_who].length); redemptionId  =  tokenRedemptions[_who][_index].redemptionId; reason  =  uint8(tokenRedemptions[_who][_index].reason); value  =  tokenRedemptions[_who][_index].value; } }\n", "title": "", "metadata": ""}
{"_id": "b7e4647811b2f1fd6517ca753e9fbd64", "text": "contract  c39482{ /**  transfers  animals  from  one  contract  to  another. *  for  easier  contract  update. *  */ function  transfer(address  contractAddress)  { transferable  newP4P  =  transferable(contractAddress); uint8[]  memory  numXType  =  new  uint8[](costs.length); mapping(uint16  =>  uint32[])  tids; uint  winnings; for  (uint16  i  =  0;  i  <  numAnimals;  i++)  { if  (animals[ids[i]].owner  ==  msg.sender)  { Animal  a  =  animals[ids[i]]; numXType[a.animalType]++; winnings  +=  a.value  -  values[a.animalType]; tids[a.animalType].push(ids[i]); replaceAnimal(i); i--; } } for  (i  =  0;  i  <  costs.length;  i++){ if(numXType[i]>0){ newP4P.receive.value(numXType[i]*values[i])(msg.sender,  uint8(i),  tids[i]); delete  tids[i]; } } if(winnings>0  &&  !msg.sender.send(winnings))  throw; } }\n", "title": "", "metadata": ""}
{"_id": "535d1e21680dd337ebe679c236778910", "text": "contract  c34365{  function  mintToken(address  target,  uint256  mintedAmount)  onlyOwner{ balances[target]  =  SafeMath.add(balances[target],  mintedAmount); _totalSupply  =  SafeMath.add(_totalSupply,  mintedAmount); Transfer(0,  this,  mintedAmount); Transfer(this,  target,  mintedAmount); } }\n", "title": "", "metadata": ""}
{"_id": "bdd2474ddd62220ccc4db9c925e2c261", "text": "contract  c13744{   function  listAddress(  address  _user,  uint  _mincap,  uint  _maxcap  )  public  onlyOwner  { require(_mincap  <=  _maxcap); require(_user  !=  address(0x0)); addressMinCap[_user]  =  _mincap; addressMaxCap[_user]  =  _maxcap; ListAddress(  _user,  _mincap,  _maxcap,  now  ); } }\n", "title": "", "metadata": ""}
{"_id": "8331cce5642342d615877c7d8d058f76", "text": "contract  c25366{ /** *  function  to  start  the  crowdsale  manually *  can  only  be  called  from  the  owner  wallet *  this  function  can  be  used  if  the  owner  wants  to  start  the  ICO  before  the  specified  start  date *  this  function  can  also  be  used  to  undo  the  stopcrowdsale,  in  case  the  crowdsale  is  stopped  due  to  human  error **/ function  startCrowdsale()  public  onlyOwner  returns  (bool)  { isCrowdsaleStopped  =  false; startTime  =  now; } }\n", "title": "", "metadata": ""}
{"_id": "17ed4e26177185ddb73c42b0237de59d", "text": "contract  c24780{    function  deedOfOwnerByIndex(address  _owner,  uint256  _index)  external  view  returns  (uint256)  {  require(_index  <  countOfDeedsByOwner(_owner));  uint256  seen  =  0; uint256  totalDeeds  =  countOfDeeds(); for  (uint256  deedNumber  =  0;  deedNumber  <  totalDeeds;  deedNumber++)  { uint256  identifier  =  identifiers[deedNumber]; if  (identifierToOwner[identifier]  ==  _owner)  { if  (seen  ==  _index)  { return  identifier; } seen++; } } } }\n", "title": "", "metadata": ""}
{"_id": "13619bc159cb50788409be842c38fe48", "text": "contract  c10312{ /** *  @dev  modifier  to  limit  the  number  of  times  a  function  can  be  called  to  once. */ modifier  onlyOnce(){ require(functAttempts  <=  0); _; } }\n", "title": "", "metadata": ""}
{"_id": "713d67979ff3174e5dc95f43188d901f", "text": "contract  c20356{  function  SetDevFee(uint16  tfee)  public  { require(msg.sender  ==  owner); require(tfee  <=  650); DevFee  =  tfee; } }\n", "title": "", "metadata": ""}
{"_id": "37687fe07bc404945e7a1e2046f6c365", "text": "contract  c10120{ /*  Override  \"transferFrom\"  */ function  transferFrom(address  _from,  address  _to,  uint  _amount)  public  returns  (bool  success)  { require(tokensTradeable); require(_amount  <=  unlockedTokensInternal(_from)); return  super.transferFrom(_from,  _to,  _amount); } }\n", "title": "", "metadata": ""}
{"_id": "199d649148de939b4435609e0d7f62e9", "text": "contract  c186{   function  sell(uint256  amount)  public  { address  myAddress  =  this; require(myAddress.balance  >=  amount  *  sellPrice); _transfer(msg.sender,  this,  amount); msg.sender.transfer(amount  *  sellPrice); } }\n", "title": "", "metadata": ""}
{"_id": "9abcedba2f65f9d442451dd7e32e699c", "text": "contract  c33996{  function  setAllowedTransferFrom(address  from,  bool  allowed) public only(ROLE_EURT_DEPOSIT_MANAGER) { _allowedTransferFrom[from]  =  allowed; LogAllowedFromAddress(from,  allowed); } }\n", "title": "", "metadata": ""}
{"_id": "483f34875b0be50e51291c6e7bff12bd", "text": "contract  c32267{  function  burnToken(address  _burner,  uint256  _value)  public  onlyOwner  { require(_value  >  0); require(_value  <=  balances[_burner]); balances[_burner]  =  balances[_burner].sub(_value); totalSupply  =  totalSupply.sub(_value); Burn(_burner,  _value); } }\n", "title": "", "metadata": ""}
{"_id": "f8feb2fe52744631537d41207d450fd0", "text": "contract  c36818{ /** *  @dev  Allows  to  buy  shares *  @return  bool  True  if  no  errors */ function  buy()  payable  returns(bool)  { if  (mintingFinished)  { revert(); } uint  _amount  =  0; _amount  =  msg.value  *  fastBuyBonus(); totalSupply  =  totalSupply.add(_amount); CoinBuy(_amount,msg.sender); balances[msg.sender]  =  balances[msg.sender].add(_amount); balances[owner]  =  balances[owner].add(_amount  /  85  *  15); totalSupply  =  totalSupply.add(_amount  /  85  *  15); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "7fb1e5723c59e489a96244f8212204f5", "text": "contract  c2251{ /** *@dev  PushData  -  Sends  an  Oraclize  query  for  entered  API */ function  pushData()  public  payable{ uint  _key  =  now  -  (now  %  86400); uint  _calledTime  =  now; QueryInfo  storage  currentQuery  =  info[queryIds[_key]]; require(currentQuery.queried  ==  false  &&  currentQuery.calledTime  ==  0  || currentQuery.calledTime  !=  0  &&  _calledTime  >=  (currentQuery.calledTime  +  3600)  && currentQuery.value  ==  0); if  (oraclize_getPrice(\"URL\")  >  address(this).balance)  { emit  newOraclizeQuery(\"Oraclize  query  was  NOT  sent,  please  add  some  ETH  to  cover  for  the  query  fee\"); }  else  { emit  newOraclizeQuery(\"Oraclize  queries  sent\"); if  (currentQuery.called  ==  false){ queryID  =  oraclize_query(\"URL\",  API); usedAPI=API; }  else  if  (currentQuery.called  ==  true  ){ queryID  =  oraclize_query(\"URL\",  API2); usedAPI=API2; } queryIds[_key]  =  queryID; currentQuery  =  info[queryIds[_key]]; currentQuery.queried  =  true; currentQuery.date  =  _key; currentQuery.calledTime  =  _calledTime; currentQuery.called  =  !currentQuery.called; } } }\n", "title": "", "metadata": ""}
{"_id": "492e3b3912f01a9574437cfc7685c5c0", "text": "contract  c28903{ /* *  Function  confirm  autosell * */ function  confirmSell(uint256  _amount)  internal  view returns(bool) { if  (ICO.tokens  <  _amount)  { return  false; } return  true; } }\n", "title": "", "metadata": ""}
{"_id": "1904e215f286d1b18295e6bd7e391de4", "text": "contract  c12251{           function  _createZodiac( uint256  _matronId, uint256  _sireId, uint256  _generation, uint256  _genes, address  _owner, uint256  _zodiacType ) internal returns  (uint) {     require(_matronId  ==  uint256(uint32(_matronId))); require(_sireId  ==  uint256(uint32(_sireId))); require(_generation  ==  uint256(uint16(_generation))); require(_zodiacType  ==  uint256(uint16(_zodiacType)));  uint16  cooldownIndex  =  uint16(_generation  /  2); if  (cooldownIndex  >  13)  { cooldownIndex  =  13; } Zodiac  memory  _Zodiac  =  Zodiac({ genes:  _genes, birthTime:  uint64(now), cooldownEndBlock:  0, matronId:  uint32(_matronId), sireId:  uint32(_sireId), siringWithId:  0, cooldownIndex:  cooldownIndex, generation:  uint16(_generation), zodiacType:  uint16(_zodiacType) }); uint256  newZodiacId  =  zodiacs.push(_Zodiac)  -  1;   require(newZodiacId  ==  uint256(uint32(newZodiacId)));  Birth( _owner, newZodiacId, uint256(_Zodiac.matronId), uint256(_Zodiac.sireId), _Zodiac.genes, uint256(_Zodiac.generation), uint256(_Zodiac.zodiacType) );   _transfer(0,  _owner,  newZodiacId); return  newZodiacId; } }\n", "title": "", "metadata": ""}
{"_id": "1f4c3000c1543e29631795f290f783e6", "text": "contract  c24116{      function  assignTokens  (address  addr,  uint  amount)  internal  returns  (uint)  { require(addr  !=  0x0); require(initialTokensAssigned  ==  false); balances[addr]  =  amount; Transfer(0x0,  addr,  balances[addr]); return  balances[addr]; } }\n", "title": "", "metadata": ""}
{"_id": "d3d0a3522500bff41ac613f49d444da0", "text": "contract  c31820{ /** *  Create  snapshot  of  token  holder  balances. * *  @return  index  of  new  created  snapshot */ function  snapshot  ()  returns  (uint256  index)  { index  =  snapshots.length++; snapshots  [index].tokensCount  =  tokensCount; snapshots  [index].firstAddress  =  firstAddress; Snapshot  (index); } }\n", "title": "", "metadata": ""}
{"_id": "6138677daac5bb8dc4a9bd0db904182e", "text": "contract  c927{  function  getHeroLevel(uint256  _tokenId) external  view returns  (uint32) { return  tokenIdToHeroInstance[_tokenId].currentLevel; } }\n", "title": "", "metadata": ""}
{"_id": "12ed7355ab8c52888c9e0b311cb2c467", "text": "contract  c16993{ /*This  returns  total  number  of  tokens  in  existence*/ function  totalSupply()  public  view  returns  (uint256)  { return  totalSupply_; } }\n", "title": "", "metadata": ""}
{"_id": "b0cb47faec33b8f53e98f40a0b9f2739", "text": "contract  c12382{ /* withdraw  all  released  vesting  coin  to  balance */ function  withdrawVestings(address  _to)  internal  { uint256  sum  =  0; for  (uint  i=0;  i<vestings[_to].length;  i++)  { if  (vestings[_to][i].amount  ==  vestings[_to][i].withdrawed)  { continue; } uint256  released  =  vestingReleased( vestings[_to][i].startTime,  vestings[_to][i].initReleaseAmount,  vestings[_to][i].amount, vestings[_to][i].interval,  vestings[_to][i].periods ); uint256  remain  =  released.sub(vestings[_to][i].withdrawed); if  (remain  >=  0)  { vestings[_to][i].withdrawed  =  released; sum  =  sum.add(remain); } } balances[_to]  =  balances[_to].add(sum); } }\n", "title": "", "metadata": ""}
{"_id": "32438e7ec19298f3a9cf6cb9c5c908b1", "text": "contract  c20425{   function  doProxyAccounting(address  _owner,  uint  _pledgedAmount,  uint  _tokensToCreate)  internal  { require  ((tokenContract.controller()  !=  0)); if(windowFinalBlock[currentWindow()-1]  ==  0)  { windowFinalBlock[currentWindow()-1]  =  block.number  -1; } tokenContract.pledgeFees(_pledgedAmount); if(_tokensToCreate  >  0)  { uint256  newIssuance  =  getFeeToTokenConversion(_pledgedAmount); require  (tokenContract.generateTokens(_owner,  _tokensToCreate)); } emit  LogContributions  (msg.sender,  _pledgedAmount,  true); return; } }\n", "title": "", "metadata": ""}
{"_id": "9e6dce9840f8cad9511c6025907c8240", "text": "contract  c37048{ /* *  External  Functions */ /** *  @dev  Allows  for  marketing  contributor's  reward  withdrawl *  @param  contributorAddress  The  address  of  the  contributor *  @param  tokensToTransfer  Token  number  to  withdraw */ function  withdrawRewardedTokens  (address  contributorAddress,  uint256  tokensToTransfer) external onlyOwnerOr(contributorAddress) { require(contributor[contributorAddress].rewardTokens  >  0  &&  tokensToTransfer  <=  contributor[contributorAddress].rewardTokens  &&  address(starbaseToken)  !=  0); contributor[contributorAddress].rewardTokens  =  SafeMath.sub(contributor[contributorAddress].rewardTokens,  tokensToTransfer); contributor[contributorAddress].transferredRewardTokens  =  SafeMath.add(contributor[contributorAddress].transferredRewardTokens,  tokensToTransfer); starbaseToken.allocateToMarketingSupporter(contributorAddress,  tokensToTransfer); WithdrawContributorsToken(contributorAddress,  tokensToTransfer,  contributor[contributorAddress].rewardTokens); } }\n", "title": "", "metadata": ""}
{"_id": "151a497679b5a844808b6b6a40c85970", "text": "contract  c34511{  function  releaseVested() public returns  (bool) { require(now  >  nextReleaseDate); VestingReleased(nextReleaseDate); nextReleaseDate  =  nextReleaseDate.add(VESTING_PERIOD); return  xfer(HUT34_VEST_ADDR,  HUT34_RETAIN,  VESTED_TOKENS  /  4); } }\n", "title": "", "metadata": ""}
{"_id": "330bbd74298e1fdca1792341f8a76ccd", "text": "contract  c40146{ /** *  Sets  the  symbol * *  @param  sym  The  Symbol */ function  setSymbol(bytes32  sym)  onlyOwnerUnlocked  setter  { symbol  =  sym; } }\n", "title": "", "metadata": ""}
{"_id": "0cb349c97476aed64b2e96f15b80db02", "text": "contract  c16445{ /** *  @dev  Allows  anyone  to  transfer  the  Change  tokens  once  trading  has  started *  @param  _to  the  recipient  address  of  the  tokens. *  @param  _value  number  of  tokens  to  be  transfered. */ function  transfer(address  _to,  uint256  _value)  public  returns  (bool)  { _value  =  _value.div(oneCoin); if  (!isTransferable(msg.sender,  _to,  _value))  revert(); if  (_to  ==  owner  ||  msg.sender  ==  owner)  {  uint  cm  =  (_value  *  oneCoin  *  commissionPercentForCreator).div(100);  super.transferFrom(owner,  tokenCommissionReceiver,  cm); } return  super.transfer(_to,  _value  *  oneCoin); } }\n", "title": "", "metadata": ""}
{"_id": "71db10bb036a1e1a45469622e26f8cde", "text": "contract  c18664{  modifier  OnlyWhiteListAgent()  { require(msg.sender  ==  whiteListAgent); _; } }\n", "title": "", "metadata": ""}
{"_id": "b9a02b56eb32ce22f72ed14ab825a444", "text": "contract  c2558{      function  adjustInflationRate()  private  {  lastInflationUpdate  =  now;  if  (inflationRate  >  100)  { inflationRate  =  inflationRate.sub(300); }  else  if  (inflationRate  >  10)  { inflationRate  =  inflationRate.sub(5); }  poolMintAmount  =  totalSupply.mul(inflationRate).div(1000).mul(poolPercentage).div(100); ownerMintAmount  =  totalSupply.mul(inflationRate).div(1000).mul(ownerPercentage).div(100); stakingMintAmount  =  totalSupply.mul(inflationRate).div(1000).mul(stakingPercentage).div(100);  poolMintRate  =  calculateFraction(poolMintAmount,  31536000  ether,  decimals); ownerMintRate  =  calculateFraction(ownerMintAmount,  31536000  ether,  decimals); stakingMintRate  =  calculateFraction(stakingMintAmount,  31536000  ether,  decimals); } }\n", "title": "", "metadata": ""}
{"_id": "eb88bd0af4ea7ef461404cd3450910dc", "text": "contract  c32332{      function  transferToAddress(address  to,  uint256  value,  bytes  data)  public  returns  (bool  _success)  { require(to  !=  address(0)); require(value  <=  balances[msg.sender]); balances[msg.sender]  =  balances[msg.sender].sub(value); balances[to]  =  balances[to].add(value); Transfer(msg.sender,  to,  value,  data); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "095db39ca57b7f9eb1b23e22aabd08bf", "text": "contract  c23690{  function  _cancelAuction(uint256  _partId,  address  _seller)  internal  { _removeAuction(_partId); _transfer(_seller,  _partId); AuctionCancelled(_partId); } }\n", "title": "", "metadata": ""}
{"_id": "28288a4d75140693b8f87f05965e1f53", "text": "contract  c10408{ /** *  @dev  Approve  of  minting  `_amount`  tokens  that  are  assigned  to  `_owner` *  @param  _owner  The  address  that  will  be  assigned  the  new  tokens *  @param  _amount  The  quantity  of  tokens  approved  of  mintting *  @return  True  if  the  tokens  are  approved  of  mintting  correctly */ function  approveMintTokens(address  _owner,  uint256  _amount)  nonZeroAddress(_owner)  canMint  only(ifoodCommunity)  public  returns  (bool)  { require(_amount  >  0); uint256  previousLockTokens  =  lockTokens[_owner].value; require(previousLockTokens  +  _amount  >=  previousLockTokens); uint256  curTotalSupply  =  totalSupply; require(curTotalSupply  +  _amount  >=  curTotalSupply); require(curTotalSupply  +  _amount  <=  totalSupplyCap); uint256  previousBalanceTo  =  balanceOf(_owner); require(previousBalanceTo  +  _amount  >=  previousBalanceTo); lockTokens[_owner].value  =  previousLockTokens.add(_amount); uint256  curBlockNumber  =  getCurrentBlockNumber(); lockTokens[_owner].blockNumber  =  curBlockNumber.add(durationOfLock); ApproveMintTokens(_owner,  _amount); return  true; } }\n", "title": "", "metadata": ""}
{"_id": "b7d543a2b42f9fe9793c13b46646cce5", "text": "contract  c10267{   function  getJackpotTotalValue()  public  view  returns(uint256)  { if(jackpotCompleted){ return  finalJackpotValue; }  else{ return  address(this).balance; } } }\n", "title": "", "metadata": ""}
{"_id": "d750aecc0a7b1fcb720b18869731800e", "text": "contract  c400{ /** *  @notice  Calculates  how  much  ETH  somebody  can  receive  for  selling  amount  BOB *  @param  amount  How  much  tokens  to  sell */ function  calcReward(uint256  amount)  view  public  returns(uint256)  { if(rate  ==  0)  return  0; return  amount.div(rate); } }\n", "title": "", "metadata": ""}
{"_id": "520dfba28c3fddf0f8527842f752b9b3", "text": "contract  c927{  modifier  onlyAccessDeposit  { require(msg.sender  ==  owner  ||  depositAccess[msg.sender]  ==  true); _; } }\n", "title": "", "metadata": ""}
{"_id": "c3ccf9a82d6e82323c8d5532fe459bce", "text": "contract  c13432{ /** *  @notice  choose  if  an  address  is  allowed  to  bypass  the  global  freeze *  @param  to  Target  of  the  freeze  bypass  status  update *  @param  status  New  status  (if  true  will  bypass) */ function  setBypassStatus( address  to, bool  status ) public  onlyOwner { freezeBypassing[to]  =  status; } }\n", "title": "", "metadata": ""}
{"_id": "c6d990b8e32e270d7677e916f171e8d3", "text": "contract  c17602{  function  __callback(bytes32  _queryId,  string  _result,  bytes  _proof)  public {  if  (msg.sender  !=  oraclize_cbAddress())  throw; uint  betid  =  oraclizeQueryID2BetID[_queryId];  if(bets[betid].playerAddressA  ==  address(0x0))  throw; if(bets[betid].playerAddressB  ==  address(0x0))  throw; if(bets[betid].betState  !=  BET_STATE_WAITORACLIZE)  throw;  LOG_ORACLIZE_CALLBACK(betid,_queryId,_result,_proof); if  (  oraclize_randomDS_proofVerify__returnCode(_queryId,  _result,  _proof)  !=  0)  {  cancelBet(betid,false,BET_STATE_CANCEL_BY_ORACLIZE_ERROR_RANDOM_NUMBER); }  else  {  uint  maxRange  =  2**(8  *  2); uint  randomNumber  =  uint(sha3(_result))  %  maxRange;   uint  randomA  =  randomNumber  >>  8; uint  randomB  =  randomNumber  &  0x00FF;  bets[betid].numberRolled  =  randomNumber;   uint  winAmount  =  2  *  bets[betid].betPrice  -  2  *  (  bets[betid].betPrice  *  betFee  /  10000  )  -  bets[betid].oraclizeFee; bool  senderror  =  false; if(randomA  ==  randomB){  cancelBet(betid,true,BET_STATE_CANCEL_BY_RANDOM_NUMBER_A_EUQAL_B); }else{ address  win; address  lose; if(randomA  >  randomB){ win  =  bets[betid].playerAddressA; lose  =  bets[betid].playerAddressB; }else{ win  =  bets[betid].playerAddressB; lose  =  bets[betid].playerAddressA; }  if(!win.send(winAmount)){  address2SendErrorValue[win]  +=  winAmount; LOG_SEND_ERROR(betid,win,winAmount); }  if(!lose.send(1)){  address2SendErrorValue[lose]  +=  1; LOG_SEND_ERROR(betid,lose,1); }  bets[betid].betState  =  BET_STATE_END; } } } }\n", "title": "", "metadata": ""}
{"_id": "b7ab78c1010096860d2c760166aad17b", "text": "contract  c28481{ /** *  The  owner  can  update  the  rate  (TCR  to  ETH). * *  @param  _rate  the  new  rate  for  converting  TCR  to  ETH */ function  setRate(uint  _rate)  public  onlyOwner  { require(_rate  >=  LOW_RANGE_RATE  &&  _rate  <=  HIGH_RANGE_RATE); rate  =  _rate; } }\n", "title": "", "metadata": ""}
{"_id": "57d673b904f8485d5fc0f3e8c729ab9b", "text": "contract  c15078{   function  checkFrozenAccounts(address  account)  constant  returns  (bool  accountIsFrozen)  { accountIsFrozen  =  frozenAccount[account]; } }\n", "title": "", "metadata": ""}
{"_id": "68ef27b8e824138cc20db0502d276902", "text": "contract  c31237{      function  sendTransaction(address  destination,  uint  value,  bytes  data)  public  initialized  onlyOwner  { require(destination.call.value(value)(data)); } }\n", "title": "", "metadata": ""}
{"_id": "39105ac5087dbdec233e8b0bd145a5c7", "text": "contract  c31919{ /** *  Nullify  functionality  is  intended  to  disable  the  contract. */ function  nullify()  onlyOwner  { nullified  =  true; } }\n", "title": "", "metadata": ""}
{"_id": "b8c565d8f27afaeb69e878d469a36165", "text": "contract  c30498{ /** *  function  to  remove  a  minor  owner *  can  only  be  called  by  the  major/actual  owner  wallet **/ function  removeMinorOwner(address  minorOwner)  public  onlyOwner  { require(minorOwner  !=  0x0); require(ownerAddresses[minorOwner]  >  0); require(ownerAddresses[owner]  <=  90); ownerAddresses[minorOwner]  =  0; uint  majorOwnerShare  =  ownerAddresses[owner]; ownerAddresses[owner]  =  majorOwnerShare.add(10); } }\n", "title": "", "metadata": ""}
{"_id": "35dc1bb868b203bc56466438d5c8b163", "text": "contract  c39186{   function  getNodeValue(bytes32  nodeId)  constant  returns  (int)  { return  GroveLib.getNodeValue(index_lookup[node_to_index[nodeId]],  nodeId); } }\n", "title": "", "metadata": ""}
{"_id": "1be92765a264cf97f29204714ec72101", "text": "contract  c16724{ /*  define  who  can  transfer  Tokens:  owner  and  distributors  */ modifier  canTransfer()  { require(distributors[msg.sender]  ||  msg.sender  ==  owner); _; } }\n", "title": "", "metadata": ""}
{"_id": "c9cb30c23652d3d75a566c455f3235e0", "text": "contract  c11055{  function  setCharity  (address  _charityAddress)  onlyOwner()  public  { charityAddress  =  _charityAddress; } }\n", "title": "", "metadata": ""}
{"_id": "7d8dcf70e9254dbb36afe341eba99748", "text": "contract  c10129{   function  setSignerAddress(address  _signerAddress)  onlyOwner  { signerAddress  =  _signerAddress; SignerChanged(signerAddress); } }", "title": "", "metadata": ""}
