1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shot noise corruption to images .<CODESPLIT>def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert comma - delimited list / string into a list of strings<CODESPLIT>def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last dimension s index or default_dim if x has no shape .<CODESPLIT>def _last_index ( x , default_dim ) : if x . get_shape ( ) . ndims is not None : return len ( x . get_shape ( ) ) - 1 else : return default_dim
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tag the given document . Parameters ---------- nerdoc : estnltk . estner . Document The document to be tagged .<CODESPLIT>def tag ( self , nerdoc ) : labels = [ ] for snt in nerdoc . sentences : xseq = [ t . feature_list ( ) for t in snt ] yseq = self . tagger . tag ( xseq ) labels . append ( yseq ) return labels
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Segmented min op .<CODESPLIT>def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the title of the console window .<CODESPLIT>def title ( msg ) : if sys . platform . startswith ( "win" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the largest real value h such that all elements in x are integer multiples of h .<CODESPLIT>def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For Python3 compatibility of generator .<CODESPLIT>def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>bytes to unicode<CODESPLIT>def b2u ( string ) : if ( isinstance ( string , bytes ) or ( PY2 and isinstance ( string , str ) ) ) : return string . decode ( 'utf-8' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will make any functions return an iterable objects by wrapping its result in a list .<CODESPLIT>def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given two data points [ X Y ] linearly interpolate those at x .<CODESPLIT>def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Queries should be a list of GraphQL objects<CODESPLIT>def graphql_queries_to_json ( * queries ) : rtn = { } for i , query in enumerate ( queries ) : rtn [ "q{}" . format ( i ) ] = query . value return json . dumps ( rtn )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>int : current max id of objects<CODESPLIT>def maxId ( self ) : if len ( self . model . db ) == 0 : return 0 return max ( map ( lambda obj : obj [ "id" ] , self . model . db ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update () extends rather than replaces existing key lists .<CODESPLIT>def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the number of quartets as n - choose - k . This is used in equal splits to decide whether a split should be exhaustively sampled or randomly sampled . Edges near tips can be exhaustive while highly nested edges probably have too many quartets<CODESPLIT>def n_choose_k ( n , k ) : return int ( reduce ( MUL , ( Fraction ( n - i , i + 1 ) for i in range ( k ) ) , 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an index from the columns of a dataframe<CODESPLIT>def _make_index ( df , cols = META_IDX ) : return pd . MultiIndex . from_tuples ( pd . unique ( list ( zip ( * [ df [ col ] for col in cols ] ) ) ) , names = tuple ( cols ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test the multiprocess<CODESPLIT>def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>u Delete the character behind the cursor . A numeric argument means to kill the characters instead of deleting them .<CODESPLIT>def backward_delete_word ( self , e ) : # (Control-Rubout)  self . l_buffer . backward_delete_word ( self . argument_reset ) self . finalize ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print an object as YAML .<CODESPLIT>def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check for whether VC is available in this bot .<CODESPLIT>async def vc_check ( ctx : commands . Context ) : # pylint: disable=unused-argument if not discord . voice_client . has_nacl : raise commands . CheckFailure ( "voice cannot be used because PyNaCl is not loaded" ) if not discord . opus . is_loaded ( ) : raise commands . CheckFailure ( "voice cannot be used because libopus is not loaded" ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ajout d un message de log de type INFO<CODESPLIT>def info ( self , text ) : self . logger . info ( "{}{}" . format ( self . message_prefix , text ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decision Tree<CODESPLIT>def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the index of elem in the reversed iterator .<CODESPLIT>def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if dtype is a numeric type .<CODESPLIT>def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the shape of the dataset as ( rows cols ) .<CODESPLIT>def shape ( self ) : if not self . data : return ( 0 , 0 ) return ( len ( self . data ) , len ( self . dimensions ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the given platform is a Unix - like platform with the usual Unix filesystem . When the parameter is omitted it defaults to sys . platform<CODESPLIT>def is_unix_like ( platform = None ) : platform = platform or sys . platform platform = platform . lower ( ) return platform . startswith ( "linux" ) or platform . startswith ( "darwin" ) or platform . startswith ( "cygwin" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only allows == against query_on . hash_key<CODESPLIT>def check_hash_key ( query_on , key ) : return ( isinstance ( key , BaseCondition ) and ( key . operation == "==" ) and ( key . column is query_on . hash_key ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove text nodes containing only whitespace<CODESPLIT>def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempts to parse a date formatted in ISO 8601 format<CODESPLIT>def datetime_is_iso ( date_str ) : try : if len ( date_str ) > 10 : dt = isodate . parse_datetime ( date_str ) else : dt = isodate . parse_date ( date_str ) return True , [ ] except : # Any error qualifies as not ISO format return False , [ 'Datetime provided is not in a valid ISO 8601 format' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return unique list of items preserving order .<CODESPLIT>def uniqued ( iterable ) : seen = set ( ) add = seen . add return [ i for i in iterable if i not in seen and not add ( i ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether the given value is a byte or unicode string .<CODESPLIT>def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates converts to a masked array<CODESPLIT>def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim left - right given string<CODESPLIT>def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( "" , somestr ) tmp = RE_TSPACES . sub ( "" , tmp ) return str ( tmp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime<CODESPLIT>def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close all connections .<CODESPLIT>def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the local ip of this device<CODESPLIT>def _get_local_ip ( ) : return set ( [ x [ 4 ] [ 0 ] for x in socket . getaddrinfo ( socket . gethostname ( ) , 80 , socket . AF_INET ) ] ) . pop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create directory with template for topic of the current environment<CODESPLIT>def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add Builders and construction variables for SGI MIPS C ++ to an Environment .<CODESPLIT>def generate ( env ) : cplusplus . generate ( env ) env [ 'CXX' ] = 'CC' env [ 'CXXFLAGS' ] = SCons . Util . CLVar ( '-LANG:std' ) env [ 'SHCXX' ] = '$CXX' env [ 'SHOBJSUFFIX' ] = '.o' env [ 'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME' ] = 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resizes an image preserving the aspect ratio .<CODESPLIT>def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return index of the nth match found of pattern in strings<CODESPLIT>def where_is ( strings , pattern , n = 1 , lookup_func = re . match ) : count = 0 for idx , item in enumerate ( strings ) : if lookup_func ( pattern , item ) : count += 1 if count == n : return idx return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if dtype is a real floating point type .<CODESPLIT>def is_real_floating_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . floating )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a bigquery table . The caller must supply a callback that takes one argument a google . cloud . bigquery . Table and mutates it .<CODESPLIT>def create_bigquery_table ( self , database , schema , table_name , callback , sql ) : conn = self . get_thread_connection ( ) client = conn . handle view_ref = self . table_ref ( database , schema , table_name , conn ) view = google . cloud . bigquery . Table ( view_ref ) callback ( view ) with self . exception_handler ( sql ) : client . create_table ( view )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a normal old python function to return the Nth fibonacci number .<CODESPLIT>def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a Python date that corresponds to the specified string representation .<CODESPLIT>def string_to_date ( value ) : if isinstance ( value , datetime . date ) : return value return dateutil . parser . parse ( value ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retry the request a few times before we determine it failed .<CODESPLIT>def _RetryRequest ( self , timeout = None , * * request_args ) : while True : try : now = time . time ( ) if not timeout : timeout = config . CONFIG [ "Client.http_timeout" ] result = requests . request ( * * request_args ) # By default requests doesn't raise on HTTP error codes. result . raise_for_status ( ) # Requests does not always raise an exception when an incorrect response # is received. This fixes that behaviour. if not result . ok : raise requests . RequestException ( response = result ) return time . time ( ) - now , result # Catch any exceptions that dont have a code (e.g. socket.error). except IOError as e : self . consecutive_connection_errors += 1 # Request failed. If we connected successfully before we attempt a few # connections before we determine that it really failed. This might # happen if the front end is loaded and returns a few throttling 500 # messages. if self . active_base_url is not None : # Propagate 406 immediately without retrying, as 406 is a valid # response that indicates a need for enrollment. response = getattr ( e , "response" , None ) if getattr ( response , "status_code" , None ) == 406 : raise if self . consecutive_connection_errors >= self . retry_error_limit : # We tried several times but this really did not work, just fail it. logging . info ( "Too many connection errors to %s, retrying another URL" , self . active_base_url ) self . active_base_url = None raise e # Back off hard to allow the front end to recover. logging . debug ( "Unable to connect to frontend. Backing off %s seconds." , self . error_poll_min ) self . Wait ( self . error_poll_min ) # We never previously connected, maybe the URL/proxy is wrong? Just fail # right away to allow callers to try a different URL. else : raise e
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to read JSON file as OrderedDict<CODESPLIT>def _read_json_file ( self , json_file ) : self . log . debug ( "Reading '%s' JSON file..." % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .<CODESPLIT>def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dataframe that is a cross between dataframes df1 and df2<CODESPLIT>def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the given colored string to standard out .<CODESPLIT>def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Patch the globals to remove the objects not available on some platforms .<CODESPLIT>def _update_globals ( ) : if not sys . platform . startswith ( 'java' ) and sys . platform != 'cli' : return incompatible = 'extract_constant' , 'get_module_constant' for name in incompatible : del globals ( ) [ name ] __all__ . remove ( name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print emphasized good the given txt message<CODESPLIT>def good ( txt ) : print ( "%s# %s%s%s" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indicate whether the specified image file is valid or not .<CODESPLIT>def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flush all items from cache .<CODESPLIT>def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print an error message<CODESPLIT>def print_error ( msg ) : if IS_POSIX : print ( u"%s[ERRO] %s%s" % ( ANSI_ERROR , msg , ANSI_END ) ) else : print ( u"[ERRO] %s" % ( msg ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pops multiple keys off a dict like object<CODESPLIT>def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the specified attribute for the specified field on the model class .<CODESPLIT>def model_field_attr ( model , model_field , attr ) : fields = dict ( [ ( field . name , field ) for field in model . _meta . fields ] ) return getattr ( fields [ model_field ] , attr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call callable ( * args ** kw ) fixing any type errors that come out .<CODESPLIT>def fix_call ( callable , * args , * * kw ) : try : val = callable ( * args , * * kw ) except TypeError : exc_info = fix_type_error ( None , callable , args , kw ) reraise ( * exc_info ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a function to map from rows with the structure of the headers to the structure of the table .<CODESPLIT>def make_table_map ( table , headers ) : header_parts = { } for i , h in enumerate ( headers ) : header_parts [ h ] = 'row[{}]' . format ( i ) body_code = 'lambda row: [{}]' . format ( ',' . join ( header_parts . get ( c . name , 'None' ) for c in table . columns ) ) header_code = 'lambda row: [{}]' . format ( ',' . join ( header_parts . get ( c . name , "'{}'" . format ( c . name ) ) for c in table . columns ) ) return eval ( header_code ) , eval ( body_code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round the number to the specified number of significant figures<CODESPLIT>def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether interface exists .<CODESPLIT>def _interface_exists ( self , interface ) : ios_cfg = self . _get_running_config ( ) parse = HTParser ( ios_cfg ) itfcs_raw = parse . find_lines ( "^interface " + interface ) return len ( itfcs_raw ) > 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate if non empty string<CODESPLIT>def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .<CODESPLIT>def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the passed variable is a tuple with two floats or integers<CODESPLIT>def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The last RQ Job this ran on<CODESPLIT>def rq_job ( self ) : if not self . rq_id or not self . rq_origin : return try : return RQJob . fetch ( self . rq_id , connection = get_connection ( self . rq_origin ) ) except NoSuchJobError : return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decode the contents of a value from a serialized stream .<CODESPLIT>def decode_value ( stream ) : length = decode_length ( stream ) ( value , ) = unpack_value ( ">{:d}s" . format ( length ) , stream ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like rotate but modifies l in - place .<CODESPLIT>def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format numpy array as a string .<CODESPLIT>def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( "," ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + "%s[%s]" % ( arr . dtype , shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dict mapping item - > indices .<CODESPLIT>def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add executable permissions to the file<CODESPLIT>def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given string starts with one of the prefixes in the given list otherwise return False .<CODESPLIT>def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper that returns if parent / item is a directory .<CODESPLIT>def _IsDirectory ( parent , item ) : return tf . io . gfile . isdir ( os . path . join ( parent , item ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the indices of all the val in m<CODESPLIT>def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively iterate through values in nested lists .<CODESPLIT>def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Double click on a given square in the map<CODESPLIT>def OnDoubleClick ( self , event ) : node = HotMapNavigator . findNodeAtPosition ( self . hot_map , event . GetPosition ( ) ) if node : wx . PostEvent ( self , SquareActivationEvent ( node = node , point = event . GetPosition ( ) , map = self ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DFS detect connected component recursive implementation<CODESPLIT>def dfs_recursive ( graph , node , seen ) : seen [ node ] = True for neighbor in graph [ node ] : if not seen [ neighbor ] : dfs_recursive ( graph , neighbor , seen )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python<CODESPLIT>def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add dots .<CODESPLIT>def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 )<CODESPLIT>def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reshape a multidimensional array to a vector .<CODESPLIT>def arr_to_vector ( arr ) : dim = array_dim ( arr ) tmp_arr = [ ] for n in range ( len ( dim ) - 1 ) : for inner in arr : for i in inner : tmp_arr . append ( i ) arr = tmp_arr tmp_arr = [ ] return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register a modele onto the lemmatizer<CODESPLIT>def register_modele ( self , modele : Modele ) : self . lemmatiseur . _modeles [ modele . gr ( ) ] = modele
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to render a list of dictionaries as an HTML display object .<CODESPLIT>def _render_table ( data , fields = None ) : return IPython . core . display . HTML ( datalab . utils . commands . HtmlBuilder . render_table ( data , fields ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a millisecond accuracy timestamp to a datetime<CODESPLIT>def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to camel case .<CODESPLIT>def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + "" . join ( x . title ( ) for x in split [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get zero - indexed line from an open file - like .<CODESPLIT>def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets a global variable given its name .<CODESPLIT>def get_var ( name , factory = None ) : if name not in _VARS and factory is not None : _VARS [ name ] = factory ( ) return _VARS . get ( name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a string and dictionary . replaces all occurrences of i with j<CODESPLIT>def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Warn if nans exist in a numpy array .<CODESPLIT>def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call the unbound method . We essentially build a bound method and call that . This ensures that the code for managing observers is invoked in the same was as it would be for a bound method .<CODESPLIT>def __call__ ( self , obj , * arg , * * kw ) : bound_method = self . _manager . __get__ ( obj , obj . __class__ ) return bound_method ( * arg , * * kw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7<CODESPLIT>def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string into list of strings by specified number .<CODESPLIT>def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Order - preserving sorting function .<CODESPLIT>def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create directory with template for topic of the current environment<CODESPLIT>def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove non - alphanumerical characters from metric word . And trim excessive underscores .<CODESPLIT>def sanitize_word ( s ) : s = re . sub ( '[^\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>renames newick from numbers to sample names<CODESPLIT>def _renamer ( self , tre ) : ## get the tre with numbered tree tip labels names = tre . get_leaves ( ) ## replace numbered names with snames for name in names : name . name = self . samples [ int ( name . name ) ] ## return with only topology and leaf labels return tre . write ( format = 9 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the greatest common divisor for a sequence of numbers . Uses a numerical tolerance so can be used on floats<CODESPLIT>def gcd_float ( numbers , tol = 1e-8 ) : def pair_gcd_tol ( a , b ) : """Calculate the Greatest Common Divisor of a and b.          Unless b==0, the result will have the same sign as b (so that when         b is divided by it, the result comes out positive).         """ while b > tol : a , b = b , a % b return a n = numbers [ 0 ] for i in numbers : n = pair_gcd_tol ( n , i ) return n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if something quacks like a list .<CODESPLIT>def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a string with comma or space - separated elements into a list .<CODESPLIT>def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns database SQL datatype for a column : e . g . VARCHAR .<CODESPLIT>def get_datatype ( self , table : str , column : str ) -> str : return self . flavour . get_datatype ( self , table , column ) . upper ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the high median of data .<CODESPLIT>def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( "no median for empty data" ) return data [ n // 2 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert arrays of datetime . datetime and datetime . timedelta objects into datetime64 and timedelta64 according to the pandas convention .<CODESPLIT>def _possibly_convert_objects ( values ) : return np . asarray ( pd . Series ( values . ravel ( ) ) ) . reshape ( values . shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function to make a dict from a coordinate for logging<CODESPLIT>def make_coord_dict ( coord ) : return dict ( z = int_if_exact ( coord . zoom ) , x = int_if_exact ( coord . column ) , y = int_if_exact ( coord . row ) , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assume fdata has even rows<CODESPLIT>def hkm_fc ( fdata , Nmax , m , s ) : f = fdata [ : , m ] L1 = f . size MM = int ( L1 / 2 ) Q = s . size ff = np . zeros ( Q , dtype = np . complex128 ) for n in xrange ( MM , L1 ) : ff [ n ] = f [ n - MM ] for n in xrange ( 0 , MM ) : ff [ n ] = f [ n + MM ] # For larger problems, this speeds things up pretty good.  F = np . fft . fft ( ff ) S = np . fft . fft ( s ) out = 4 * np . pi * np . fft . ifft ( F * S ) return out [ 0 : Nmax + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flatten all dimensions of a except the last .<CODESPLIT>def flatten_all_but_last ( a ) : ret = tf . reshape ( a , [ - 1 , tf . shape ( a ) [ - 1 ] ] ) if not tf . executing_eagerly ( ) : ret . set_shape ( [ None ] + a . get_shape ( ) . as_list ( ) [ - 1 : ] ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the nth value of array<CODESPLIT>def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>conveniently styles your text as and resets ANSI codes at its end .<CODESPLIT>def stylize ( text , styles , reset = True ) : terminator = attr ( "reset" ) if reset else "" return "{}{}{}" . format ( "" . join ( styles ) , text , terminator )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a date object and return the first day of the month .<CODESPLIT>def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the tests .<CODESPLIT>def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get unit vector for a given one .<CODESPLIT>def normalized ( vector ) : length = numpy . sum ( vector * vector , axis = - 1 ) length = numpy . sqrt ( length . reshape ( length . shape + ( 1 , ) ) ) return vector / length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the year .<CODESPLIT>def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the first n sentences with highest ranking<CODESPLIT>def _rank ( self , ranking , n ) : return nlargest ( n , ranking , key = ranking . get )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Old style use JSONTemplateResponse instead of this .<CODESPLIT>def json_template ( data , template_name , template_context ) : html = render_to_string ( template_name , template_context ) data = data or { } data [ 'html' ] = html return HttpResponse ( json_encode ( data ) , content_type = 'application/json' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace multiple values in a string<CODESPLIT>def replace ( s , replace ) : for r in replace : s = s . replace ( * r ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Opens the file and reads the value<CODESPLIT>def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all child objects in nested lists of strings .<CODESPLIT>def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fast median operation for masked array using 50th - percentile<CODESPLIT>def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>kill process Args : process - Popen object for process<CODESPLIT>def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If pair is in search_list return the index . Otherwise return - 1<CODESPLIT>def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field evaluates True .<CODESPLIT>def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the syntax of the given URL .<CODESPLIT>def url_syntax_check ( url ) : # pragma: no cover if url and isinstance ( url , str ) : # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config ( True ) return Check ( url ) . is_url_valid ( ) # We return None, there is nothing to check. return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>format mpv s title<CODESPLIT>def _format_title_string ( self , title_string ) : return self . _title_string_format_text_tag ( title_string . replace ( self . icy_tokkens [ 0 ] , self . icy_title_prefix ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801<CODESPLIT>def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normal cumulative density function .<CODESPLIT>def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the receiver s contribution to tree diagram .<CODESPLIT>def _tree_line ( self , no_type : bool = False ) -> str : return self . _tree_line_prefix ( ) + " " + self . iname ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JSSObject for the element with ID id_<CODESPLIT>def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>composion of preprocessing functions<CODESPLIT>def compose ( func_list ) : def f ( G , bim ) : for func in func_list : G , bim = func ( G , bim ) return G , bim return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts binary address to Ipv4 format .<CODESPLIT>def _get_ipv4_from_binary ( self , bin_addr ) : return socket . inet_ntop ( socket . AF_INET , struct . pack ( "!L" , bin_addr ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a log message to standard error .<CODESPLIT>def print_log ( text , * colors ) : sys . stderr . write ( sprint ( "{}: {}" . format ( script_name , text ) , * colors ) + "\n" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the table names in the database .<CODESPLIT>def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( "SELECT name FROM sqlite_master WHERE type == 'table'" ) return [ name for ( name , ) in cursor ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs an existence check on the remote database .<CODESPLIT>def exists ( self ) : resp = self . r_session . head ( self . database_url ) if resp . status_code not in [ 200 , 404 ] : resp . raise_for_status ( ) return resp . status_code == 200
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get single system variable from CCU / Homegear<CODESPLIT>def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The full remote import path as used in import statements in . go source files .<CODESPLIT>def import_path ( self ) : return os . path . join ( self . remote_root , self . pkg ) if self . pkg else self . remote_root
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .<CODESPLIT>def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format list .<CODESPLIT>def list_formatter ( handler , item , value ) : return u', ' . join ( str ( v ) for v in value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a stream discarding the data read and returns its size .<CODESPLIT>def _read_stream_for_size ( stream , buf_size = 65536 ) : size = 0 while True : buf = stream . read ( buf_size ) size += len ( buf ) if not buf : break return size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Outputs a string to the console ( stdout ) .<CODESPLIT>def out ( self , output , newline = True ) : click . echo ( output , nl = newline )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Divide a number into a list of numbers as even as possible .<CODESPLIT>def most_even ( number , group ) : count , rest = divmod ( number , group ) counts = zip_longest ( [ count ] * group , [ 1 ] * rest , fillvalue = 0 ) chunks = [ sum ( one ) for one in counts ] logging . debug ( 'chunks: %s' , chunks ) return chunks
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends a file via FTP .<CODESPLIT>def _send_file ( self , filename ) : # pylint: disable=E1101 ftp = ftplib . FTP ( host = self . host ) ftp . login ( user = self . user , passwd = self . password ) ftp . set_pasv ( True ) ftp . storbinary ( "STOR %s" % os . path . basename ( filename ) , file ( filename , 'rb' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a workaround where Collections are no longer iterable when using JPype .<CODESPLIT>def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rounds a float value off to the desired precision<CODESPLIT>def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>date to unix timestamp in milliseconds<CODESPLIT>def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the list of distinct values with preserving order .<CODESPLIT>def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Value of property .<CODESPLIT>def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns factor and offset of linear regression function by least squares method .<CODESPLIT>def linearRegressionAnalysis ( series ) : n = safeLen ( series ) sumI = sum ( [ i for i , v in enumerate ( series ) if v is not None ] ) sumV = sum ( [ v for i , v in enumerate ( series ) if v is not None ] ) sumII = sum ( [ i * i for i , v in enumerate ( series ) if v is not None ] ) sumIV = sum ( [ i * v for i , v in enumerate ( series ) if v is not None ] ) denominator = float ( n * sumII - sumI * sumI ) if denominator == 0 : return None else : factor = ( n * sumIV - sumI * sumV ) / denominator / series . step offset = sumII * sumV - sumIV * sumI offset = offset / denominator - factor * series . start return factor , offset
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}<CODESPLIT>def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs out the current session by removing it from the cache . This is expected to only occur when a session has<CODESPLIT>def logout ( cache ) : cache . set ( flask . session [ 'auth0_key' ] , None ) flask . session . clear ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns background color rgb tuple of right line<CODESPLIT>def _get_background_color ( self ) : color = self . cell_attributes [ self . key ] [ "bgcolor" ] return tuple ( c / 255.0 for c in color_pack2rgb ( color ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Probability density function ( normal distribution )<CODESPLIT>def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the MachineGuid from HKEY_LOCAL_MACHINE \ Software \ Microsoft \ Cryptography \ MachineGuid<CODESPLIT>def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r"Software\Microsoft\Cryptography" ) try : return winreg . QueryValueEx ( key , "MachineGuid" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .<CODESPLIT>def yaml_to_param ( obj , name ) : return from_pyvalue ( u"yaml:%s" % name , unicode ( yaml . dump ( obj ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function used to fit the exponential decay .<CODESPLIT>def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove decoded instruction from instruction cache<CODESPLIT>def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first line of a file .<CODESPLIT>def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\n' ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the amount of characters in this token list .<CODESPLIT>def token_list_len ( tokenlist ) : ZeroWidthEscape = Token . ZeroWidthEscape return sum ( len ( item [ 1 ] ) for item in tokenlist if item [ 0 ] != ZeroWidthEscape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the closest matching key and / or value in a dictionary ( must have all string keys! )<CODESPLIT>def fuzzy_get_tuple ( dict_obj , approximate_key , dict_keys = None , key_and_value = False , similarity = 0.6 , default = None ) : return fuzzy_get ( dict ( ( '|' . join ( str ( k2 ) for k2 in k ) , v ) for ( k , v ) in viewitems ( dict_obj ) ) , '|' . join ( str ( k ) for k in approximate_key ) , dict_keys = dict_keys , key_and_value = key_and_value , similarity = similarity , default = default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .<CODESPLIT>def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Outputs a string to the console ( stdout ) .<CODESPLIT>def out ( self , output , newline = True ) : click . echo ( output , nl = newline )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Import a class or function given it s absolute path .<CODESPLIT>def import_by_path ( path : str ) -> Callable : module_path , _ , class_name = path . rpartition ( '.' ) return getattr ( import_module ( module_path ) , class_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility to print something only if verbose = True is given<CODESPLIT>def print_verbose ( * args , * * kwargs ) : if kwargs . pop ( 'verbose' , False ) is True : gprint ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies the sofplus activation function element - wise to the input .<CODESPLIT>def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator for JSON - per - line in a file pattern<CODESPLIT>def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in comparison to argrelmax () more simple and reliable peak finder<CODESPLIT>def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Max reduction op .<CODESPLIT>def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a O ( 1 ) memory hash of an iterable of arbitrary length .<CODESPLIT>def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether flyweight object with specified key has already been created .<CODESPLIT>def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a copy of this list with each element copied to new memory<CODESPLIT>def copy ( self ) : out = type ( self ) ( ) for series in self : out . append ( series . copy ( ) ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the value of the cell on the given row and column .<CODESPLIT>def cell ( self , rowName , columnName ) : return self . matrix [ self . rowIndices [ rowName ] , self . columnIndices [ columnName ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Squash self . out into string .<CODESPLIT>def build_output ( self , fout ) : fout . write ( '\n' . join ( [ s for s in self . out ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove resource instance from internal cache<CODESPLIT>def __delitem__ ( self , resource ) : self . __caches [ type ( resource ) ] . pop ( resource . get_cache_internal_key ( ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the unit tests .<CODESPLIT>def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to a list with sanitization .<CODESPLIT>def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new Image instance filled with a color .<CODESPLIT>def new ( self , size , fill ) : return Image ( PIL . Image . new ( "RGB" , size , fill ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .<CODESPLIT>def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attach a callback on the group pubsub<CODESPLIT>def listen_for_updates ( self ) : self . toredis . subscribe ( self . group_pubsub , callback = self . callback )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display all available logging information .<CODESPLIT>def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns a Python unicode string list into a Java String array .<CODESPLIT>def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( "java/lang/String" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute a command installed into the active virtualenv .<CODESPLIT>def vsh ( cmd , * args , * * kw ) : args = '" "' . join ( i . replace ( '"' , r'\"' ) for i in args ) easy . sh ( '"%s" "%s"' % ( venv_bin ( cmd ) , args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get ( and maybe create ) a set by name .<CODESPLIT>def _get_set ( self , key , operation , create = False ) : return self . _get_by_type ( key , operation , create , b'set' , set ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function uses a PIL routine to get the bounding box of the rendered image .<CODESPLIT>def calculate_bounding_box_from_image ( im , curr_page ) : xMax , y_max = im . size bounding_box = im . getbbox ( ) # note this uses ltrb convention if not bounding_box : #print("\nWarning: could not calculate a bounding box for this page." #      "\nAn empty page is assumed.", file=sys.stderr) bounding_box = ( xMax / 2 , y_max / 2 , xMax / 2 , y_max / 2 ) bounding_box = list ( bounding_box ) # make temporarily mutable # Compensate for reversal of the image y convention versus PDF. bounding_box [ 1 ] = y_max - bounding_box [ 1 ] bounding_box [ 3 ] = y_max - bounding_box [ 3 ] full_page_box = curr_page . mediaBox # should have been set already to chosen box # Convert pixel units to PDF's bp units. convert_x = float ( full_page_box . getUpperRight_x ( ) - full_page_box . getLowerLeft_x ( ) ) / xMax convert_y = float ( full_page_box . getUpperRight_y ( ) - full_page_box . getLowerLeft_y ( ) ) / y_max # Get final box; note conversion to lower-left point, upper-right point format. final_box = [ bounding_box [ 0 ] * convert_x , bounding_box [ 3 ] * convert_y , bounding_box [ 2 ] * convert_x , bounding_box [ 1 ] * convert_y ] return final_box
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses format string looking for substitutions<CODESPLIT>def parse ( self ) : standard_formatters = re . compile ( r'\((.+?)\)' , re . IGNORECASE ) return standard_formatters . findall ( self . _fmt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize the state of the object<CODESPLIT>def __init__ ( self ) : self . state = self . STATE_INITIALIZING self . state_start = time . time ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dictionary of distances keyed by the keys in the given dict .<CODESPLIT>def calculate_single_tanimoto_set_distances ( target : Iterable [ X ] , dict_of_sets : Mapping [ Y , Set [ X ] ] ) -> Mapping [ Y , float ] : target_set = set ( target ) return { k : tanimoto_set_similarity ( target_set , s ) for k , s in dict_of_sets . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the window bounds as a tuple of ( x y w h )<CODESPLIT>def getRect ( self ) : return ( self . x , self . y , self . w , self . h )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes the specified file from the local filesystem .<CODESPLIT>def _delete_local ( self , filename ) : if os . path . exists ( filename ) : os . remove ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrun True if x is a valid YYYYMMDD date ; otherwise return False .<CODESPLIT>def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Safely convert a single number to integer .<CODESPLIT>def safe_int_conv ( number ) : try : return int ( np . array ( number ) . astype ( int , casting = 'safe' ) ) except TypeError : raise ValueError ( 'cannot safely convert {} to integer' . format ( number ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format the UTC timestamp for Elasticsearch eg . 2014 - 07 - 09T08 : 37 : 18 . 000Z<CODESPLIT>def format_timestamp ( timestamp ) : tz_info = tz . tzutc ( ) return datetime . fromtimestamp ( timestamp , tz = tz_info ) . strftime ( "%Y-%m-%dT%H:%M:%S.000Z" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts markdown content to text<CODESPLIT>def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an ISO - 8601 representation of a datetime object .<CODESPLIT>def datetime_iso_format ( date ) : return "{0:0>4}-{1:0>2}-{2:0>2}T{3:0>2}:{4:0>2}:{5:0>2}Z" . format ( date . year , date . month , date . day , date . hour , date . minute , date . second )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>str to bytes ( py3k )<CODESPLIT>def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse an int robustly ignoring commas and other cruft .<CODESPLIT>def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalizes list<CODESPLIT>def normalize_array ( lst ) : np_arr = np . array ( lst ) x_normalized = np_arr / np_arr . max ( axis = 0 ) return list ( x_normalized )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start the Django dev server .<CODESPLIT>def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the file extension for an abi3 - compliant Extension ()<CODESPLIT>def get_abi3_suffix ( ) : for suffix , _ , _ in ( s for s in imp . get_suffixes ( ) if s [ 2 ] == imp . C_EXTENSION ) : if '.abi3' in suffix : # Unix return suffix elif suffix == '.pyd' : # Windows return suffix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether any of the filenames exist .<CODESPLIT>def do_files_exist ( filenames ) : preexisting = [ tf . io . gfile . exists ( f ) for f in filenames ] return any ( preexisting )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>kwarg values always have defaults<CODESPLIT>def test_kwargs_are_optional ( self ) : with patch ( "sys.exit" ) as mock_exit : cli = MicroCLITestCase . T ( "script_name f3" . split ( ) ) . run ( ) # kwargs are optional mock_exit . assert_called_with ( 4 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads and iterates through each image file in the given directory<CODESPLIT>def each_img ( img_dir ) : for fname in utils . each_img ( img_dir ) : fname = os . path . join ( img_dir , fname ) yield cv . imread ( fname ) , fname
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses hostname from URL . : param url : URL : return : hostname<CODESPLIT>def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Slicing op .<CODESPLIT>def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the SQL typename required to store the given FieldDefinition<CODESPLIT>def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate the fill similarity over the image<CODESPLIT>def _sim_fill ( r1 , r2 , imsize ) : bbsize = ( ( max ( r1 [ "max_x" ] , r2 [ "max_x" ] ) - min ( r1 [ "min_x" ] , r2 [ "min_x" ] ) ) * ( max ( r1 [ "max_y" ] , r2 [ "max_y" ] ) - min ( r1 [ "min_y" ] , r2 [ "min_y" ] ) ) ) return 1.0 - ( bbsize - r1 [ "size" ] - r2 [ "size" ] ) / imsize
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes a : py : class : . Series from the chart .<CODESPLIT>def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( "Cannot remove last series from %s" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ctypes float pointer array to a numpy array .<CODESPLIT>def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a list of strings and clear whitespace on each one . If a value in the list is not a string pass it through untouched .<CODESPLIT>def clean_strings ( iterable ) : retval = [ ] for val in iterable : try : retval . append ( val . strip ( ) ) except ( AttributeError ) : retval . append ( val ) return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert from whatever is given to a list of scalars for the lookup_field .<CODESPLIT>def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal random datetime generator .<CODESPLIT>def _rnd_datetime ( self , start , end ) : return self . from_utctimestamp ( random . randint ( int ( self . to_utctimestamp ( start ) ) , int ( self . to_utctimestamp ( end ) ) , ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>zfill ( x width ) - > string<CODESPLIT>def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list into a space - separated string and puts it in a dictionary<CODESPLIT>def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : " " . join ( str ( i ) for i in list_ ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Init a noise variable .<CODESPLIT>def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An iterable of column names for a particular table or view .<CODESPLIT>def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes underscores and capitalizes the neighbouring character<CODESPLIT>def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a conda environment inside the current sandbox for the given list of dependencies and options .<CODESPLIT>def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ "conda" , "create" , "--yes" , "--copy" , "--quiet" , "-p" , env_dir ] + list ( options ) + dependencies log . info ( "Creating conda environment: " ) log . info ( "  command line: %s" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( "Environment created" ) return env_dir , env_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a column to the current table .<CODESPLIT>def add_column ( connection , column ) : stmt = alembic . ddl . base . AddColumn ( _State . table . name , column ) connection . execute ( stmt ) _State . reflect_metadata ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if key exists in datastore . True if yes False if no .<CODESPLIT>def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purely a debugging aid : Ascii - art picture of a tree descended from node<CODESPLIT>def debugTreePrint ( node , pfx = "->" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , "  " + pfx )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns numpy array of natural logarithms of values .<CODESPLIT>def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( "ignore" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redraw event handler for the figure panel<CODESPLIT>def OnUpdateFigurePanel ( self , event ) : if self . updating : return self . updating = True self . figure_panel . update ( self . get_figure ( self . code ) ) self . updating = False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply Gaussian blur to the given data .<CODESPLIT>def GaussianBlur ( X , ksize_width , ksize_height , sigma_x , sigma_y ) : return image_transform ( X , cv2 . GaussianBlur , ksize = ( ksize_width , ksize_height ) , sigmaX = sigma_x , sigmaY = sigma_y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value of the checkbox .<CODESPLIT>def set_value ( self , value ) : if value : self . setChecked ( Qt . Checked ) else : self . setChecked ( Qt . Unchecked )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn dict keys and values into native strings .<CODESPLIT>def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the fully - qualified name of a function .<CODESPLIT>def _fullname ( o ) : return o . __module__ + "." + o . __name__ if o . __module__ else o . __name__
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read and return the data from a corpus json file .<CODESPLIT>def read_corpus ( file_name ) : with io . open ( file_name , encoding = 'utf-8' ) as data_file : return yaml . load ( data_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if the given value is a scalar .<CODESPLIT>def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap i and j rows<CODESPLIT>def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Local test .<CODESPLIT>def test ( ) : from spyder . utils . qthelpers import qapplication app = qapplication ( ) dlg = ProjectDialog ( None ) dlg . show ( ) sys . exit ( app . exec_ ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a normal old python function to return the Nth fibonacci number .<CODESPLIT>def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a datetime to a millisecond accuracy timestamp<CODESPLIT>def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the deepest level of nesting within a list of lists<CODESPLIT>def list_depth ( list_ , func = max , _depth = 0 ) : depth_list = [ list_depth ( item , func = func , _depth = _depth + 1 ) for item in list_ if util_type . is_listlike ( item ) ] if len ( depth_list ) > 0 : return func ( depth_list ) else : return _depth
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .<CODESPLIT>def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates in a list .<CODESPLIT>def _uniquify ( _list ) : seen = set ( ) result = [ ] for x in _list : if x not in seen : result . append ( x ) seen . add ( x ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move cursor to this line in the current buffer .<CODESPLIT>def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .<CODESPLIT>def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column<CODESPLIT>def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>IP address range validation and expansion .<CODESPLIT>def ip_address_list ( ips ) : # first, try it as a single IP address try : return ip_address ( ips ) except ValueError : pass # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it return list ( ipaddress . ip_network ( u ( ips ) ) . hosts ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adapts a Numpy array into an ARRAY string to put into the database .<CODESPLIT>def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes stopwords contained in a list of words .<CODESPLIT>def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Se asegura de que un directorio exista .<CODESPLIT>def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a 2D numpy array of bools<CODESPLIT>def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the approximate size of the queue ( not reliable! ) .<CODESPLIT>def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join the given iterable with<CODESPLIT>def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Push item onto heap maintaining the heap invariant .<CODESPLIT>def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retries function until it doesn t raise an EINTR error<CODESPLIT>def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pdf evaluated at the peak .<CODESPLIT>def _pdf_at_peak ( self ) : return ( self . peak - self . low ) / ( self . high - self . low )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes comments ( # ... ) from python code .<CODESPLIT>def split_comment ( cls , code ) : if '#' not in code : return code #: Remove comments only (leave quoted strings as they are) subf = lambda m : '' if m . group ( 0 ) [ 0 ] == '#' else m . group ( 0 ) return re . sub ( cls . re_pytokens , subf , code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>simple method to determine if a url is relative or absolute<CODESPLIT>def is_relative_url ( url ) : if url . startswith ( "#" ) : return None if url . find ( "://" ) > 0 or url . startswith ( "//" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Insert many items at once into a temporary table .<CODESPLIT>def insert_many ( self , items ) : return SessionContext . session . execute ( self . insert ( values = [ to_dict ( item , self . c ) for item in items ] ) , ) . rowcount
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the memory byte size of a Numpy array as an integer .<CODESPLIT>def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove problem characters from string<CODESPLIT>def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\'' ] for c in remove : string = string . replace ( c , '_' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Excel worksheet reference to the X values for this chart ( not including the column label ) .<CODESPLIT>def x_values_ref ( self , series ) : top_row = self . series_table_row_offset ( series ) + 2 bottom_row = top_row + len ( series ) - 1 return "Sheet1!$A$%d:$A$%d" % ( top_row , bottom_row )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random string of length string_length .<CODESPLIT>def random_string ( string_length = 10 ) : random = str ( uuid . uuid4 ( ) ) # Convert UUID format to a Python string. random = random . upper ( ) # Make all characters uppercase. random = random . replace ( "-" , "" ) # Remove the UUID '-'. return random [ 0 : string_length ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a structured NumPy array into a Table .<CODESPLIT>def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP response for not - authorized access ( status code 403 )<CODESPLIT>def HttpResponse401 ( request , template = KEY_AUTH_401_TEMPLATE , content = KEY_AUTH_401_CONTENT , content_type = KEY_AUTH_401_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 401 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop the progress bar .<CODESPLIT>def stop ( self ) : if self . _progressing : self . _progressing = False self . _thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add one tick to progress bar<CODESPLIT>def tick ( self ) : self . current += 1 if self . current == self . factor : sys . stdout . write ( '+' ) sys . stdout . flush ( ) self . current = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize representation of the column for local caching .<CODESPLIT>def to_dict ( self ) : return { 'schema' : self . schema , 'table' : self . table , 'name' : self . name , 'type' : self . type }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the default WSGI handler for the runner .<CODESPLIT>def get_handler ( self , * args , * * options ) : handler = get_internal_wsgi_application ( ) from django . contrib . staticfiles . handlers import StaticFilesHandler return StaticFilesHandler ( handler )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts time strings to integer seconds : param time : %H : %M : %S string : return : integer seconds<CODESPLIT>def str_time_to_day_seconds ( time ) : t = str ( time ) . split ( ':' ) seconds = int ( t [ 0 ] ) * 3600 + int ( t [ 1 ] ) * 60 + int ( t [ 2 ] ) return seconds
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restoring scrollbar position after main window is visible<CODESPLIT>def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns sequence of integer ids given a sequence of string ids .<CODESPLIT>def strids2ids ( tokens : Iterable [ str ] ) -> List [ int ] : return list ( map ( int , tokens ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from an iterable preserving the order .<CODESPLIT>def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pre - order depth - first<CODESPLIT>def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make file user readable if it is not a link .<CODESPLIT>def make_file_readable ( filename ) : if not os . path . islink ( filename ) : util . set_mode ( filename , stat . S_IRUSR )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to camel case .<CODESPLIT>def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + "" . join ( x . title ( ) for x in split [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Colorize text with given color .<CODESPLIT>def _write_color_colorama ( fp , text , color ) : foreground , background , style = get_win_color ( color ) colorama . set_console ( foreground = foreground , background = background , style = style ) fp . write ( text ) colorama . reset_console ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>from a valid python module path get the run method name passed<CODESPLIT>def get_method_from_module ( module_path , method_name ) : top_module = __import__ ( module_path ) module = top_module # we tunnel down until we find the module we want for submodule_name in module_path . split ( '.' ) [ 1 : ] : module = getattr ( module , submodule_name ) assert hasattr ( module , method_name ) , "unable to find method {0} from module {1}. does the method exist?" . format ( method_name , module_path ) return getattr ( module , method_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is the same functionality as int . from_bytes in python 3<CODESPLIT>def _from_bytes ( bytes , byteorder = "big" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a dtype is a subclass of the numpy datetime types<CODESPLIT>def is_datetime_like ( dtype ) : return ( np . issubdtype ( dtype , np . datetime64 ) or np . issubdtype ( dtype , np . timedelta64 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dictionary of key / values from os . environ .<CODESPLIT>def _get_os_environ_dict ( keys ) : return { k : os . environ . get ( k , _UNDEFINED ) for k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values<CODESPLIT>def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( "Error getting image size {}" . format ( url ) , exc_info = True ) return w_h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a main config value or default if it does not exist .<CODESPLIT>def _get_config_or_default ( self , key , default , as_type = lambda x : x ) : if self . main_config . has_option ( self . main_section , key ) : return as_type ( self . main_config . get ( self . main_section , key ) ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set foreground - and background colors and intensity .<CODESPLIT>def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>writes a string to file<CODESPLIT>def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function for sort_file_tabs_alphabetically () .<CODESPLIT>def sorted ( self ) : for i in range ( 0 , self . tabs . tabBar ( ) . count ( ) - 1 ) : if ( self . tabs . tabBar ( ) . tabText ( i ) > self . tabs . tabBar ( ) . tabText ( i + 1 ) ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reconstruct the image from the tf example .<CODESPLIT>def decode_example ( self , example ) : img = tf . image . decode_image ( example , channels = self . _shape [ - 1 ] , dtype = tf . uint8 ) img . set_shape ( self . _shape ) return img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add Builders and construction variables for SGI MIPS C ++ to an Environment .<CODESPLIT>def generate ( env ) : cplusplus . generate ( env ) env [ 'CXX' ] = 'CC' env [ 'CXXFLAGS' ] = SCons . Util . CLVar ( '-LANG:std' ) env [ 'SHCXX' ] = '$CXX' env [ 'SHOBJSUFFIX' ] = '.o' env [ 'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME' ] = 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Proximal operator to project onto zero<CODESPLIT>def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>date to unix timestamp in milliseconds<CODESPLIT>def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the parent directory of a filename .<CODESPLIT>def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .<CODESPLIT>def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recieving the JSON file from uulm<CODESPLIT>def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( "utf-8" ) data = json . loads ( data ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Force compilation of expression for the SQLite target<CODESPLIT>def compile ( expr , params = None ) : from ibis . sql . alchemy import to_sqlalchemy return to_sqlalchemy ( expr , dialect . make_context ( params = params ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Patch the modules with gevent<CODESPLIT>def _gevent_patch ( ) : try : assert gevent assert grequests except NameError : logger . warn ( 'gevent not exist, fallback to multiprocess...' ) return MULTITHREAD else : monkey . patch_all ( ) # Must patch before get_photos_info return GEVENT
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of synsets of a word after lemmatization .<CODESPLIT>def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find longest ORF from the given list of ORFs .<CODESPLIT>def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the name of the current git branch<CODESPLIT>def get_git_branch ( git_path = 'git' ) : branch_match = call ( ( git_path , 'rev-parse' , '--symbolic-full-name' , 'HEAD' ) ) if branch_match == "HEAD" : return None else : return os . path . basename ( branch_match )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Data from http : // indexed . blogspot . com / 2007 / 12 / meltdown - indeed . html<CODESPLIT>def house_explosions ( ) : chart = PieChart2D ( int ( settings . width * 1.7 ) , settings . height ) chart . add_data ( [ 10 , 10 , 30 , 200 ] ) chart . set_pie_labels ( [ 'Budding Chemists' , 'Propane issues' , 'Meth Labs' , 'Attempts to escape morgage' , ] ) chart . download ( 'pie-house-explosions.png' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit the shell session .<CODESPLIT>def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test the multiprocess<CODESPLIT>def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>save the current session override if session was saved earlier<CODESPLIT>def save ( self ) : if self . path : self . _saveState ( self . path ) else : self . saveAs ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a n + 1 dim one - hot array from n dim int - categorical array .<CODESPLIT>def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Truncates a value to a number of decimals places<CODESPLIT>def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close child subprocess<CODESPLIT>def close ( self ) : if self . _subprocess is not None : os . killpg ( self . _subprocess . pid , signal . SIGTERM ) self . _subprocess = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if value is an integer long integer or float .<CODESPLIT>def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises the supplied figure number or figure window .<CODESPLIT>def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if all of the elements in the list are equal .<CODESPLIT>def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , "Input value must be a list." return not lst or lst . count ( lst [ 0 ] ) == len ( lst )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encodes a list of strings to a single string . : type strs : List [ str ] : rtype : str<CODESPLIT>def encode ( strs ) : res = '' for string in strs . split ( ) : res += str ( len ( string ) ) + ":" + string return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a public RSA key from a PEM file .<CODESPLIT>def import_public_rsa_key_from_file ( filename ) : with open ( filename , "rb" ) as key_file : public_key = serialization . load_pem_public_key ( key_file . read ( ) , backend = default_backend ( ) ) return public_key
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the contents of an object stored in S3 as string .<CODESPLIT>def get_as_string ( self , s3_path , encoding = 'utf-8' ) : content = self . get_as_bytes ( s3_path ) return content . decode ( encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns number of wraps around given method .<CODESPLIT>def wrap_count ( method ) : number = 0 while hasattr ( method , '__aspects_orig' ) : number += 1 method = method . __aspects_orig return number
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the ROI model to a FITS file .<CODESPLIT>def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .<CODESPLIT>def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>kill process Args : process - Popen object for process<CODESPLIT>def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a UTC datetime to a Unix timestamp<CODESPLIT>def datetime_to_timestamp ( dt ) : delta = dt - datetime . utcfromtimestamp ( 0 ) return delta . seconds + delta . days * 24 * 3600
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove and return the item at index .<CODESPLIT>def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load the correct module according to the version<CODESPLIT>def load_library ( version ) : check_version ( version ) module_name = SUPPORTED_LIBRARIES [ version ] lib = sys . modules . get ( module_name ) if lib is None : lib = importlib . import_module ( module_name ) return lib
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to a list with sanitization .<CODESPLIT>def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transparently unzip the file handle<CODESPLIT>def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when a new DropDownItem gets selected .<CODESPLIT>def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The standard deviation of a set of values . Pass in the mean if you already know it .<CODESPLIT>def stddev ( values , meanval = None ) : #from AI: A Modern Appproach if meanval == None : meanval = mean ( values ) return math . sqrt ( sum ( [ ( x - meanval ) ** 2 for x in values ] ) / ( len ( values ) - 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return time in milliseconds from start_time<CODESPLIT>def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds the supplied dict as a new entity<CODESPLIT>def add ( self , entity ) : result = self . _http_req ( 'connections' , method = 'POST' , payload = entity ) status = result [ 'status' ] if not status == 201 : raise ServiceRegistryError ( status , "Couldn't add entity" ) self . debug ( 0x01 , result ) return result [ 'decoded' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array .<CODESPLIT>def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Do all elements of x have a type from types?<CODESPLIT>def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method to check if a set of types is the { AnyObject } singleton<CODESPLIT>def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a numpy array to YAML .<CODESPLIT>def numpy_to_yaml ( representer : Representer , data : np . ndarray ) -> Sequence [ Any ] : return representer . represent_sequence ( "!numpy_array" , data . tolist ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the covarince between two points implied by Vario2d<CODESPLIT>def covariance ( self , pt0 , pt1 ) : x = np . array ( [ pt0 [ 0 ] , pt1 [ 0 ] ] ) y = np . array ( [ pt0 [ 1 ] , pt1 [ 1 ] ] ) names = [ "n1" , "n2" ] return self . covariance_matrix ( x , y , names = names ) . x [ 0 , 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare two strings if all contiguous whitespace is coalesced .<CODESPLIT>def assert_looks_like ( first , second , msg = None ) : first = _re . sub ( "\s+" , " " , first . strip ( ) ) second = _re . sub ( "\s+" , " " , second . strip ( ) ) if first != second : raise AssertionError ( msg or "%r does not look like %r" % ( first , second ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if required dependency is installed<CODESPLIT>def check ( modname ) : for dependency in DEPENDENCIES : if dependency . modname == modname : return dependency . check ( ) else : raise RuntimeError ( "Unkwown dependency %s" % modname )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dump Python object as JSON string .<CODESPLIT>def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns one value if the condition evaluates to TRUE and another value if it evaluates to FALSE<CODESPLIT>def _if ( ctx , logical_test , value_if_true = 0 , value_if_false = False ) : return value_if_true if conversions . to_boolean ( logical_test , ctx ) else value_if_false
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a Python object stored in a specified YAML file .<CODESPLIT>def ReadManyFromPath ( filepath ) : with io . open ( filepath , mode = "r" , encoding = "utf-8" ) as filedesc : return ReadManyFromFile ( filedesc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a time DOWN to half nearest half - hour .<CODESPLIT>def _round_half_hour ( record ) : k = record . datetime + timedelta ( minutes = - ( record . datetime . minute % 30 ) ) return datetime ( k . year , k . month , k . day , k . hour , k . minute , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detach from all tracked classes and objects . Restore the original constructors and cleanse the tracking lists .<CODESPLIT>def detach_all ( self ) : self . detach_all_classes ( ) self . objects . clear ( ) self . index . clear ( ) self . _keepalive [ : ] = [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if the json_element passed is present for the task specified .<CODESPLIT>def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits a string into parts at multiple characters<CODESPLIT>def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Empty the range from start to stop .<CODESPLIT>def empty ( self , start = None , stop = None ) : self . set ( NOT_SET , start = start , stop = stop )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts an ARRAY string stored in the database back into a Numpy array .<CODESPLIT>def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to overcome pickling problem in python2 .<CODESPLIT>def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python 3 input () / Python 2 raw_input ()<CODESPLIT>def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build argument parsers .<CODESPLIT>def build_parser ( ) : parser = argparse . ArgumentParser ( "Release packages to pypi" ) parser . add_argument ( '--check' , '-c' , action = "store_true" , help = "Do a dry run without uploading" ) parser . add_argument ( 'component' , help = "The component to release as component-version" ) return parser
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return only the part of the row which should be printed .<CODESPLIT>def _get_printable_columns ( columns , row ) : if not columns : return row # Extract the column values, in the order specified. return tuple ( row [ c ] for c in columns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns day number of the last day of the month : param t : datetime : return : int<CODESPLIT>def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a flatten version of the nested argument<CODESPLIT>def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP request method of interface implementation .<CODESPLIT>def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method to check if a set of types is the { AnyObject } singleton<CODESPLIT>def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a numpy row - major homogenous transformation matrix to a flat column - major GLfloat transformation .<CODESPLIT>def matrix_to_gl ( matrix ) : matrix = np . asanyarray ( matrix , dtype = np . float64 ) if matrix . shape != ( 4 , 4 ) : raise ValueError ( 'matrix must be (4,4)!' ) # switch to column major and flatten to (16,) column = matrix . T . flatten ( ) # convert to GLfloat glmatrix = ( gl . GLfloat * 16 ) ( * column ) return glmatrix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove legend for axes or gca .<CODESPLIT>def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple from parsing a b c d - > ( a b c d )<CODESPLIT>def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a Python date that corresponds to the specified string representation .<CODESPLIT>def string_to_date ( value ) : if isinstance ( value , datetime . date ) : return value return dateutil . parser . parse ( value ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get an x and y numpy . ndarray that spans the + / - 4 standard deviation range of a gaussian distribution with a given mean and standard deviation . useful for plotting<CODESPLIT>def gaussian_distribution ( mean , stdev , num_pts = 50 ) : xstart = mean - ( 4.0 * stdev ) xend = mean + ( 4.0 * stdev ) x = np . linspace ( xstart , xend , num_pts ) y = ( 1.0 / np . sqrt ( 2.0 * np . pi * stdev * stdev ) ) * np . exp ( - 1.0 * ( ( x - mean ) ** 2 ) / ( 2.0 * stdev * stdev ) ) return x , y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls the specified Trigger of another Area with the optionally given parameters .<CODESPLIT>def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Presenter to force yaml . dump to use multi - line string style .<CODESPLIT>def string_presenter ( self , dumper , data ) : if '\n' in data : return dumper . represent_scalar ( 'tag:yaml.org,2002:str' , data , style = '|' ) else : return dumper . represent_scalar ( 'tag:yaml.org,2002:str' , data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a function that is only callable once ; any other call will do nothing<CODESPLIT>def _callable_once ( func ) : def once ( * args , * * kwargs ) : if not once . called : once . called = True return func ( * args , * * kwargs ) once . called = False return once
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a graphviz graph from text<CODESPLIT>def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the next value in the page .<CODESPLIT>def next ( self ) : item = six . next ( self . _item_iter ) result = self . _item_to_value ( self . _parent , item ) # Since we've successfully got the next value from the # iterator, we update the number of remaining. self . _remaining -= 1 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Instanciates a new * Document * from this collection<CODESPLIT>def __call__ ( self , * args , * * kwargs ) : kwargs [ "mongokat_collection" ] = self return self . document_class ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>given a segment ( rectangle ) and an image returns it s corresponding subimage<CODESPLIT>def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the given number in decimal format using a period and commas<CODESPLIT>def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decode ( bytearray raw = False ) - > value<CODESPLIT>def decode ( self , bytes , raw = False ) : return struct . unpack ( self . format , buffer ( bytes ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch an image from url and convert it into a Pillow Image object<CODESPLIT>def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convolve 2d gaussian .<CODESPLIT>def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>assert that the mock was called only once .<CODESPLIT>def assert_called_once ( _mock_self ) : self = _mock_self if not self . call_count == 1 : msg = ( "Expected '%s' to have been called once. Called %s times." % ( self . _mock_name or 'mock' , self . call_count ) ) raise AssertionError ( msg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .<CODESPLIT>def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lock connection from being used else where<CODESPLIT>def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the MD5 hash for a file .<CODESPLIT>def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a ctypes void pointer to the memory mapped region .<CODESPLIT>def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a DataFrame with the duplicated values of the column col_name in df .<CODESPLIT>def duplicated_rows ( df , col_name ) : _check_cols ( df , [ col_name ] ) dups = df [ pd . notnull ( df [ col_name ] ) & df . duplicated ( subset = [ col_name ] ) ] return dups
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str<CODESPLIT>def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads a floating point value from a memory address . If 2nd arg . start with * it is always treated as an indirect value .<CODESPLIT>def _loadf ( ins ) : output = _float_oper ( ins . quad [ 2 ] ) output . extend ( _fpush ( ) ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Promise an object of class cls with content members .<CODESPLIT>def create_object ( cls , members ) : obj = cls . __new__ ( cls ) obj . __dict__ = members return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns a Python unicode string list into a Java String array .<CODESPLIT>def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( "java/lang/String" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the list of distinct values with preserving order .<CODESPLIT>def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This removes newlines and multiple spaces from a string .<CODESPLIT>def normalize_value ( text ) : result = text . replace ( '\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if key exists in datastore . True if yes False if no .<CODESPLIT>def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>last row or column of square A<CODESPLIT>def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a multiline string into a list excluding blank lines .<CODESPLIT>def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\n' ) ) if element ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call this on an lxml . etree document to remove all namespaces<CODESPLIT>def remove_namespaces ( root ) : for elem in root . getiterator ( ) : if not hasattr ( elem . tag , 'find' ) : continue i = elem . tag . find ( '}' ) if i >= 0 : elem . tag = elem . tag [ i + 1 : ] objectify . deannotate ( root , cleanup_namespaces = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ends an indentation block leaving an empty line afterwards<CODESPLIT>def end_block ( self ) : self . current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self . auto_added_line : self . writeln ( ) self . auto_added_line = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>shows structured information of a object list tuple etc<CODESPLIT>def var_dump ( * obs ) : i = 0 for x in obs : str = var_dump_output ( x , 0 , '  ' , '\n' , True ) print ( str . strip ( ) ) #dump(x, 0, i, '', object) i += 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a list in tabular format Based on https : // stackoverflow . com / a / 8356620<CODESPLIT>def __print_table ( table ) : col_width = [ max ( len ( x ) for x in col ) for col in zip ( * table ) ] print ( "| " + " | " . join ( "{:{}}" . format ( x , col_width [ i ] ) for i , x in enumerate ( table [ 0 ] ) ) + " |" ) print ( "| " + " | " . join ( "{:{}}" . format ( '-' * col_width [ i ] , col_width [ i ] ) for i , x in enumerate ( table [ 0 ] ) ) + " |" ) for line in table [ 1 : ] : print ( "| " + " | " . join ( "{:{}}" . format ( x , col_width [ i ] ) for i , x in enumerate ( line ) ) + " |" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get domain part of an url .<CODESPLIT>def get_domain ( url ) : parse_result = urlparse ( url ) domain = "{schema}://{netloc}" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move the turtle forward .<CODESPLIT>def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request the power state of the server .<CODESPLIT>def get_host_power_status ( self ) : sushy_system = self . _get_sushy_system ( PROLIANT_SYSTEM_ID ) return GET_POWER_STATE_MAP . get ( sushy_system . power_state )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out system information ( version MAC addrs ) .<CODESPLIT>async def sysinfo ( dev : Device ) : click . echo ( await dev . get_system_info ( ) ) click . echo ( await dev . get_interface_information ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Only return cursor instance if configured for multiselect<CODESPLIT>def get_python ( self ) : if self . multiselect : return super ( MultiSelectField , self ) . get_python ( ) return self . _get ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Builds a comment .<CODESPLIT>def to_comment ( value ) : if value is None : return if len ( value . split ( '\n' ) ) == 1 : return "* " + value else : return '\n' . join ( [ ' * ' + l for l in value . split ( '\n' ) [ : - 1 ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a temporary filename based on filename .<CODESPLIT>def get_incomplete_path ( filename ) : random_suffix = "" . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) return filename + ".incomplete" + random_suffix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes a HEAD requests to the URI .<CODESPLIT>def dir_exists ( self ) : r = requests . request ( self . method if self . method else 'HEAD' , self . url , * * self . storage_args ) try : r . raise_for_status ( ) except Exception : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed<CODESPLIT>def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure that path in URL with authority starts with a leading slash .<CODESPLIT>def _validate_authority_uri_abs_path ( host , path ) : if len ( host ) > 0 and len ( path ) > 0 and not path . startswith ( "/" ) : raise ValueError ( "Path in a URL with authority " "should start with a slash ('/') if set" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forcefully delete objects from memory<CODESPLIT>def cleanup ( self ) : for instance in self . context : del ( instance ) for plugin in self . plugins : del ( plugin )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether all number in the sequence s lie inside the interval formed by l and r .<CODESPLIT>def are_in_interval ( s , l , r , border = 'included' ) : return numpy . all ( [ IntensityRangeStandardization . is_in_interval ( x , l , r , border ) for x in s ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enforce HTML escaping . This will probably double escape variables .<CODESPLIT>def do_forceescape ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return escape ( unicode ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logarithmic loss with non - necessarily - binary labels .<CODESPLIT>def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute Pearson correlation coefficient .<CODESPLIT>def cor ( y_true , y_pred ) : y_true , y_pred = _mask_nan ( y_true , y_pred ) return np . corrcoef ( y_true , y_pred ) [ 0 , 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>save something to a pickle file<CODESPLIT>def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , "wb" ) , pickle . HIGHEST_PROTOCOL ) return thing
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the request payload size<CODESPLIT>def calculate_size ( name , function ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += calculate_size_data ( function ) return data_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a horizontal line up to a given length .<CODESPLIT>def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Should we skip logging for this handler?<CODESPLIT>def should_skip_logging ( func ) : disabled = strtobool ( request . headers . get ( "x-request-nolog" , "false" ) ) return disabled or getattr ( func , SKIP_LOGGING , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip agents from a string .<CODESPLIT>def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a copy of the list without duplicates .<CODESPLIT>def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns xlwt . pattern for pyspread style<CODESPLIT>def _get_pattern ( self , pys_style ) : # Return None if there is no bgcolor if "bgcolor" not in pys_style : return pattern = xlwt . Pattern ( ) pattern . pattern = xlwt . Pattern . SOLID_PATTERN bgcolor = wx . Colour ( ) bgcolor . SetRGB ( pys_style [ "bgcolor" ] ) pattern . pattern_fore_colour = self . color2idx ( * bgcolor . Get ( ) ) return pattern
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the key which comes before the give key .<CODESPLIT>def previous_key ( tuple_of_tuples , key ) : for i , t in enumerate ( tuple_of_tuples ) : if t [ 0 ] == key : try : return tuple_of_tuples [ i - 1 ] [ 0 ] except IndexError : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Synthesize white noise<CODESPLIT>def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .<CODESPLIT>def seq_to_str ( obj , sep = "," ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply gzip compression to a response .<CODESPLIT>def _gzip ( self , response ) : bytesio = six . BytesIO ( ) with gzip . GzipFile ( fileobj = bytesio , mode = 'w' ) as gz : gz . write ( response ) return bytesio . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if given string is a punctuation<CODESPLIT>def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if key is in adict . The search is case insensitive .<CODESPLIT>def contains_case_insensitive ( adict , akey ) : for key in adict : if key . lower ( ) == akey . lower ( ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses the default Plone sortable_text index lower - case<CODESPLIT>def sortable_title ( instance ) : title = plone_sortable_title ( instance ) if safe_callable ( title ) : title = title ( ) return title . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns mean of non - None elements of the list<CODESPLIT>def _aggr_mean ( inList ) : aggrSum = 0 nonNone = 0 for elem in inList : if elem != SENTINEL_VALUE_FOR_MISSING_DATA : aggrSum += elem nonNone += 1 if nonNone != 0 : return aggrSum / nonNone else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a dict to a JSON file .<CODESPLIT>def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs drag a element to another elmenet .<CODESPLIT>def drag_and_drop ( self , droppable ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . drag_and_drop ( self . _element , droppable . _element ) . perform ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shape a list of lists into the appropriate shape and data type<CODESPLIT>def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method for just changing font size .<CODESPLIT>def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts from a Minigo coordinate to a GTP coordinate .<CODESPLIT>def to_gtp ( coord ) : if coord is None : return 'pass' y , x = coord return '{}{}' . format ( _GTP_COLUMNS [ x ] , go . N - y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run verbose PyLint on source . Optionally specify fmt = html for HTML output .<CODESPLIT>def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field is not None .<CODESPLIT>def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return random lognormal variates .<CODESPLIT>def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .<CODESPLIT>def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>!<CODESPLIT>def manhattan_distance_numpy ( object1 , object2 ) : return numpy . sum ( numpy . absolute ( object1 - object2 ) , axis = 1 ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1x1 convolution<CODESPLIT>def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Configuration - friendly boolean type converter .<CODESPLIT>def boolean ( value ) : if isinstance ( value , bool ) : return value if value == "" : return False return strtobool ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the 2 - D size of a Jacobian matrix in tuple<CODESPLIT>def get_size ( self , m ) : nrow , ncol = 0 , 0 if m [ 0 ] == 'F' : nrow = self . n elif m [ 0 ] == 'G' : nrow = self . m if m [ 1 ] == 'x' : ncol = self . n elif m [ 1 ] == 'y' : ncol = self . m return nrow , ncol
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the provided value is a valid enum constant .<CODESPLIT>def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list possibly nested to any level return it flattened .<CODESPLIT>def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Go to parent directory<CODESPLIT>def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a 20 char passphrase with easily typeable chars .<CODESPLIT>def GeneratePassphrase ( length = 20 ) : valid_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" valid_chars += "0123456789 ,-_&$#" return "" . join ( random . choice ( valid_chars ) for i in range ( length ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a fresh id<CODESPLIT>def generate_id ( self ) : if self . use_repeatable_ids : self . repeatable_id_counter += 1 return 'autobaked-{}' . format ( self . repeatable_id_counter ) else : return str ( uuid4 ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert snake case string to camel case .<CODESPLIT>def _snake_to_camel_case ( value ) : words = value . split ( "_" ) return words [ 0 ] + "" . join ( map ( str . capitalize , words [ 1 : ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method that must transform the value from string Ex : if the expected type is int it should return int ( self . _attr )<CODESPLIT>def normalize_field ( self , value ) : if self . default is not None : if value is None or value == '' : value = self . default return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a C function that takes a pointer as its last argument and return the C object that it contains after the function has finished .<CODESPLIT>def get_ctype ( rtype , cfunc , * args ) : val_p = backend . ffi . new ( rtype ) args = args + ( val_p , ) cfunc ( * args ) return val_p [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a message in the log<CODESPLIT>def format ( self , record , * args , * * kwargs ) : return logging . Formatter . format ( self , record , * args , * * kwargs ) . replace ( '\n' , '\n' + ' ' * 8 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .<CODESPLIT>def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case<CODESPLIT>def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True when the graph has the given edge .<CODESPLIT>def has_edge ( self , p_from , p_to ) : return p_from in self . _edges and p_to in self . _edges [ p_from ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7<CODESPLIT>def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Gets the string representation of the given type .<CODESPLIT>def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the line number parsed from the comment or 0 .<CODESPLIT>def _get_line_no_from_comments ( py_line ) : matched = LINECOL_COMMENT_RE . match ( py_line ) if matched : return int ( matched . group ( 1 ) ) else : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the memory byte size of a Numpy array as an integer .<CODESPLIT>def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from strings to integers<CODESPLIT>def str2int ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . str2int ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether an object is a path .<CODESPLIT>def _is_path ( s ) : if isinstance ( s , string_types ) : try : return op . exists ( s ) except ( OSError , ValueError ) : return False else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>compose a list of functions<CODESPLIT>def compose ( * funcs ) : return lambda x : reduce ( lambda v , f : f ( v ) , reversed ( funcs ) , x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove any duplicate item preserving order<CODESPLIT>def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if cnr or cns files are empty ( only have a header )<CODESPLIT>def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if the last two moves were Pass or if the position is at a move greater than the max depth .<CODESPLIT>def is_done ( self ) : return self . position . is_game_over ( ) or self . position . n >= FLAGS . max_game_length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current desktop . Uses _NET_CURRENT_DESKTOP of the EWMH spec .<CODESPLIT>def get_current_desktop ( self ) : desktop = ctypes . c_long ( 0 ) _libxdo . xdo_get_current_desktop ( self . _xdo , ctypes . byref ( desktop ) ) return desktop . value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use numpy to create a real matrix object from the data<CODESPLIT>def get_matrix ( self ) : return np . array ( [ self . get_row_list ( i ) for i in range ( self . row_count ( ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether the given value is a byte or unicode string .<CODESPLIT>def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read text from file automatically detect encoding . chardet required .<CODESPLIT>def smartread ( path ) : with open ( path , "rb" ) as f : content = f . read ( ) result = chardet . detect ( content ) return content . decode ( result [ "encoding" ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear not used counters<CODESPLIT>def trim ( self ) : for key , value in list ( iteritems ( self . counters ) ) : if value . empty ( ) : del self . counters [ key ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rewrite a file adding a line to its beginning .<CODESPLIT>def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closest distance between a line segment and a point<CODESPLIT>def distance_to_line ( a , b , p ) : return distance ( closest_point ( a , b , p ) , p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper on iter method callback gets an iterator result<CODESPLIT>def find_all ( self , string , callback ) : for index , output in self . iter ( string ) : callback ( index , output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Releases this resource back to the pool it came from .<CODESPLIT>def release ( self ) : if self . errored : self . pool . delete_resource ( self ) else : self . pool . release ( self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Nested lists to single - level list does not split strings<CODESPLIT>def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Upload the IPList as json payload .<CODESPLIT>def upload_as_json ( name , mylist ) : location = list ( IPList . objects . filter ( name ) ) if location : iplist = location [ 0 ] return iplist . upload ( json = mylist , as_type = 'json' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the shape of img .<CODESPLIT>def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return list of the key property names for a class<CODESPLIT>def get_keys_from_class ( cc ) : return [ prop . name for prop in cc . properties . values ( ) if 'key' in prop . qualifiers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a C function that takes a pointer as its last argument and return the C object that it contains after the function has finished .<CODESPLIT>def get_ctype ( rtype , cfunc , * args ) : val_p = backend . ffi . new ( rtype ) args = args + ( val_p , ) cfunc ( * args ) return val_p [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds widget attributes to a bound form field .<CODESPLIT>def add_form_widget_attr ( field , attr_name , attr_value , replace = 0 ) : if not replace : attr = field . field . widget . attrs . get ( attr_name , '' ) attr += force_text ( attr_value ) field . field . widget . attrs [ attr_name ] = attr return field else : field . field . widget . attrs [ attr_name ] = attr_value return field
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the * cmd * and exit with the proper exit code .<CODESPLIT>def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge two dicts and return a new dict . Much like subclassing works .<CODESPLIT>def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load and execute a python file .<CODESPLIT>def load_files ( files ) : for py_file in files : LOG . debug ( "exec %s" , py_file ) execfile ( py_file , globals ( ) , locals ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill all null values with NaN values in a column . Null values are None or en empty string<CODESPLIT>def fill_nulls ( self , col : str ) : n = [ None , "" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute boxplot for given pandas Series .<CODESPLIT>def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = "|" . join ( map ( str , stats [ 'fliers' ] ) ) return stats
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of a geometry in a list of geometries avoiding expensive equality checks of in operator .<CODESPLIT>def find_geom ( geom , geoms ) : for i , g in enumerate ( geoms ) : if g is geom : return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform CamelCase naming convention into C - ish convention .<CODESPLIT>def uncamel ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the number of leaves in a tree<CODESPLIT>def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use openpyxl to read an Excel file .<CODESPLIT>def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like rotate but modifies l in - place .<CODESPLIT>def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively converts iterables into tuples .<CODESPLIT>def tuplize ( nested ) : if isinstance ( nested , str ) : return nested try : return tuple ( map ( tuplize , nested ) ) except TypeError : return nested
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures preceding predicates ( specifically : meth : called_with () ) result in * expected_exception * being raised and the string representation of * expected_exception * must match regular expression * expected_regexp * .<CODESPLIT>def raises_regex ( self , expected_exception , expected_regexp ) : return unittest_case . assertRaisesRegexp ( expected_exception , expected_regexp , self . _orig_subject , * self . _args , * * self . _kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : x : iterable of strings<CODESPLIT>def gen_lower ( x : Iterable [ str ] ) -> Generator [ str , None , None ] : for string in x : yield string . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove resource instance from internal cache<CODESPLIT>def __delitem__ ( self , resource ) : self . __caches [ type ( resource ) ] . pop ( resource . get_cache_internal_key ( ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert this confusion matrix into a 2x2 plain list of values .<CODESPLIT>def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Synthesize white noise<CODESPLIT>def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>disassemble Python byte - code file ( . pyc )<CODESPLIT>def disassemble_file ( filename , outstream = None ) : filename = check_object_path ( filename ) ( version , timestamp , magic_int , co , is_pypy , source_size ) = load_module ( filename ) if type ( co ) == list : for con in co : disco ( version , con , outstream ) else : disco ( version , co , outstream , is_pypy = is_pypy ) co = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a flatten version of the nested argument<CODESPLIT>def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Asynchronously run the worker does not close connections . Useful when testing .<CODESPLIT>async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Path to tensorflow_datasets directory .<CODESPLIT>def tfds_dir ( ) : return os . path . dirname ( os . path . dirname ( os . path . dirname ( __file__ ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts from hex to hsv<CODESPLIT>def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used when the plot method defined does not create a figure nor calls save_plot Then the plot method has to use self . fig<CODESPLIT>def plot_and_save ( self , * * kwargs ) : self . fig = pyplot . figure ( ) self . plot ( ) self . axes = pyplot . gca ( ) self . save_plot ( self . fig , self . axes , * * kwargs ) pyplot . close ( self . fig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the size of a multidimansional array .<CODESPLIT>def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build documentation as HTML .<CODESPLIT>def build ( ctx ) : return_code = run_sphinx ( ctx . obj [ 'root_dir' ] ) if return_code > 0 : sys . exit ( return_code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connects to an Access database via ODBC with the DSN prespecified .<CODESPLIT>def connect_to_database_odbc_access ( self , dsn : str , autocommit : bool = True ) -> None : self . connect ( engine = ENGINE_ACCESS , interface = INTERFACE_ODBC , dsn = dsn , autocommit = autocommit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return lines of a file with whitespace removed<CODESPLIT>def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( "Could not open file: {!r}" . format ( filename ) ) return [ line . strip ( ) for line in lines ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def lines ( self ) : if self . _lines is None : self . _lines = self . obj . content . splitlines ( ) return self . _lines
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to draw lines connecting a set of nodes that are scaled for the Screen .<CODESPLIT>def _draw_lines_internal ( self , coords , colour , bg ) : for i , ( x , y ) in enumerate ( coords ) : if i == 0 : self . _screen . move ( x , y ) else : self . _screen . draw ( x , y , colour = colour , bg = bg , thin = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the names of all callable attributes of an object<CODESPLIT>def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted<CODESPLIT>def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case<CODESPLIT>def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds execute permission to file . : param filename : : return :<CODESPLIT>def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}<CODESPLIT>def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x .<CODESPLIT>def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the first sunday of a month .<CODESPLIT>def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds the argument variable as one of the input variable<CODESPLIT>def add_input_variable ( self , var ) : assert ( isinstance ( var , Variable ) ) self . input_variable_list . append ( var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for iterating numpy array<CODESPLIT>def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ "refs_ok" ] ) : c = a . item ( ) if c is not None : yield c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string * s * into list of strings no longer than * length *<CODESPLIT>def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a date object and return the first day of the month .<CODESPLIT>def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to float if object is a float string .<CODESPLIT>def _tofloat ( obj ) : if "inf" in obj . lower ( ) . strip ( ) : return obj try : return int ( obj ) except ValueError : try : return float ( obj ) except ValueError : return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pyglet specific key press callback . Forwards and translates the events to : py : func : keyboard_event<CODESPLIT>def on_key_press ( self , symbol , modifiers ) : self . keyboard_event ( symbol , self . keys . ACTION_PRESS , modifiers )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string representing a numpy array of 0 s and 1 s<CODESPLIT>def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param string : String can be type resource or python case<CODESPLIT>def python ( string : str ) : return underscore ( singularize ( string ) if Naming . _pluralize ( string ) else string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize time in arbitrary timezone to UTC naive object .<CODESPLIT>def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Combine data and a fits header to write a fits file .<CODESPLIT>def write_fits ( data , header , file_name ) : hdu = fits . PrimaryHDU ( data ) hdu . header = header hdulist = fits . HDUList ( [ hdu ] ) hdulist . writeto ( file_name , overwrite = True ) logging . info ( "Wrote {0}" . format ( file_name ) ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print dicttree in Json - like format . keys are sorted<CODESPLIT>def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( "," , ": " ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether the handler is using sys . stdout .<CODESPLIT>def _using_stdout ( self ) : if WINDOWS and colorama : # Then self.stream is an AnsiToWin32 object. return self . stream . wrapped is sys . stdout return self . stream is sys . stdout
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the file - like object is readable .<CODESPLIT>def is_readable ( fp , size = 1 ) : read_size = len ( fp . read ( size ) ) fp . seek ( - read_size , 1 ) return read_size == size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the modified time of the RPM Database .<CODESPLIT>def _get_mtime ( ) : return os . path . exists ( RPM_PATH ) and int ( os . path . getmtime ( RPM_PATH ) ) or 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterable - first replacement of Python s built - in map () function .<CODESPLIT>def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Short Time Fourier Transform for real data keeping the full FFT block .<CODESPLIT>def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return True if the current distribution is running on debian like OS .<CODESPLIT>def is_archlinux ( ) : if platform . system ( ) . lower ( ) == 'linux' : if platform . linux_distribution ( ) == ( '' , '' , '' ) : # undefined distribution. Fixed in python 3. if os . path . exists ( '/etc/arch-release' ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes // - comments and single - line C - style / * * / comments .<CODESPLIT>def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tells Windows this is an independent application with an unique icon on task bar .<CODESPLIT>def setAsApplication ( myappid ) : if os . name == 'nt' : import ctypes ctypes . windll . shell32 . SetCurrentProcessExplicitAppUserModelID ( myappid )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>see doc in Term class<CODESPLIT>def get_size ( self ) : self . curses . setupterm ( ) return self . curses . tigetnum ( 'cols' ) , self . curses . tigetnum ( 'lines' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates a count of the number of times each unique item appears in a list<CODESPLIT>def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all non - printable characters from a text string<CODESPLIT>def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts XY point from Spherical Mercator EPSG : 900913 to lat / lon in WGS84 Datum<CODESPLIT>def metres2latlon ( mx , my , origin_shift = 2 * pi * 6378137 / 2.0 ) : lon = ( mx / origin_shift ) * 180.0 lat = ( my / origin_shift ) * 180.0 lat = 180 / pi * ( 2 * atan ( exp ( lat * pi / 180.0 ) ) - pi / 2.0 ) return lat , lon
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print the header for the CSV table .<CODESPLIT>def printheader ( h = None ) : writer = csv . writer ( sys . stdout ) writer . writerow ( header_fields ( h ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate overlap count between the values of two dictionaries<CODESPLIT>def _calc_overlap_count ( markers1 : dict , markers2 : dict , ) : overlaps = np . zeros ( ( len ( markers1 ) , len ( markers2 ) ) ) j = 0 for marker_group in markers1 : tmp = [ len ( markers2 [ i ] . intersection ( markers1 [ marker_group ] ) ) for i in markers2 . keys ( ) ] overlaps [ j , : ] = tmp j += 1 return overlaps
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a value to session .<CODESPLIT>def _session_set ( self , key , value ) : self . session [ self . _session_key ( key ) ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read text from stdin and print a helpful message for ttys .<CODESPLIT>def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>shows JSON indented representation of d<CODESPLIT>def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper on iter method callback gets an iterator result<CODESPLIT>def find_all ( self , string , callback ) : for index , output in self . iter ( string ) : callback ( index , output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Break lists into small lists for processing : w<CODESPLIT>def chunked_list ( _list , _chunk_size = 50 ) : for i in range ( 0 , len ( _list ) , _chunk_size ) : yield _list [ i : i + _chunk_size ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compiles to native Python bytecode and runs program returning the topmost value on the stack .<CODESPLIT>def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a property by name<CODESPLIT>def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is an object iterable like a list ( and not a string ) ?<CODESPLIT>def listlike ( obj ) : return hasattr ( obj , "__iter__" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transpose matrix<CODESPLIT>def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix solve op .<CODESPLIT>def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the absolute path to the directory containing the package data .<CODESPLIT>def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , "data" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Escapes a filesystem path for use as a command - line argument<CODESPLIT>def escapePathForShell ( path ) : if platform . system ( ) == 'Windows' : return '"{}"' . format ( path . replace ( '"' , '""' ) ) else : return shellescape . quote ( path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty printing for numpy matrix X<CODESPLIT>def print_matrix ( X , decimals = 1 ) : for row in np . round ( X , decimals = decimals ) : print ( row )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds first file in path whose filename matches pattern ( via : func : fnmatch . fnmatch ) or raises : exc : IndexError .<CODESPLIT>def find_first ( pattern : str , path : str ) -> str : try : return find ( pattern , path ) [ 0 ] except IndexError : log . critical ( '''Couldn't find "{}" in "{}"''' , pattern , path ) raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a shared memory array with the same shape and type as a given array filled with value .<CODESPLIT>def full_like ( array , value , dtype = None ) : shared = empty_like ( array , dtype ) shared [ : ] = value return shared
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a simple check if the value is callable .<CODESPLIT>def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar<CODESPLIT>def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Truncates a value to a number of decimals places<CODESPLIT>def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get string from file .<CODESPLIT>def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback to redraw the plot to reflect the new parameter values .<CODESPLIT>def _update_plot ( self , _ ) : # Since all sliders call this same callback without saying who they are # I need to update the values for all parameters. This can be # circumvented by creating a seperate callback function for each # parameter. for param in self . model . params : param . value = self . _sliders [ param ] . val for indep_var , dep_var in self . _projections : self . _update_specific_plot ( indep_var , dep_var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random positive integer ( for a Django PositiveIntegerField )<CODESPLIT>def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the average price between two asset states .<CODESPLIT>def average_price ( quantity_1 , price_1 , quantity_2 , price_2 ) : return ( quantity_1 * price_1 + quantity_2 * price_2 ) / ( quantity_1 + quantity_2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plot a smoothed ( by kernel density estimate ) histogram . : type data : numpy array : param data : An array containing the data to be plotted<CODESPLIT>def plot_kde ( data , ax , title = None , color = 'r' , fill_bt = True ) : if isinstance ( data , list ) : data = np . asarray ( data ) e = kde . KDEUnivariate ( data . astype ( np . float ) ) e . fit ( ) ax . plot ( e . support , e . density , color = color , alpha = 0.9 , linewidth = 2.25 ) if fill_bt : ax . fill_between ( e . support , e . density , alpha = .35 , zorder = 1 , antialiased = True , color = color ) if title is not None : t = ax . set_title ( title ) t . set_y ( 1.05 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill all null values with NaN values in a column . Null values are None or en empty string<CODESPLIT>def fill_nulls ( self , col : str ) : n = [ None , "" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return this consoles current blend mode .<CODESPLIT>def console_get_background_flag ( con : tcod . console . Console ) -> int : return int ( lib . TCOD_console_get_background_flag ( _console ( con ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to get bins for histplot .<CODESPLIT>def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if two revisions have actually changed .<CODESPLIT>def default_diff ( latest_config , current_config ) : # Pop off the fields we don't care about: pop_no_diff_fields ( latest_config , current_config ) diff = DeepDiff ( latest_config , current_config , ignore_order = True ) return diff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run Python test cases against Java runtime classes .<CODESPLIT>def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until all queued messages are sent .<CODESPLIT>def wait_send ( self , timeout = None ) : self . _send_queue_cleared . clear ( ) self . _send_queue_cleared . wait ( timeout = timeout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a skew - symmetric cross - product matrix to its corresponding vector . Only works for 3x3 matrices .<CODESPLIT>def deskew ( S ) : x = np . zeros ( 3 ) x [ 0 ] = S [ 2 , 1 ] x [ 1 ] = S [ 0 , 2 ] x [ 2 ] = S [ 1 , 0 ] return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given HTML markup return a list of hrefs for each anchor tag .<CODESPLIT>def get_anchor_href ( markup ) : soup = BeautifulSoup ( markup , 'lxml' ) return [ '%s' % link . get ( 'href' ) for link in soup . find_all ( 'a' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert a ctypes structure to a dictionary<CODESPLIT>def struct2dict ( struct ) : return { x : getattr ( struct , x ) for x in dict ( struct . _fields_ ) . keys ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap text in an ansi escape sequence<CODESPLIT>def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shape a list of lists into the appropriate shape and data type<CODESPLIT>def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print all rows in this result query .<CODESPLIT>def print_runs ( query ) : if query is None : return for tup in query : print ( ( "{0} @ {1} - {2} id: {3} group: {4}" . format ( tup . end , tup . experiment_name , tup . project_name , tup . experiment_group , tup . run_group ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return lines of a file with whitespace removed<CODESPLIT>def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( "Could not open file: {!r}" . format ( filename ) ) return [ line . strip ( ) for line in lines ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manufacture decorator that filters return value with given function .<CODESPLIT>def apply ( filter ) : def decorator ( callable ) : return lambda * args , * * kwargs : filter ( callable ( * args , * * kwargs ) ) return decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort the list into natural alphanumeric order .<CODESPLIT>def natural_sort ( list , key = lambda s : s ) : def get_alphanum_key_func ( key ) : convert = lambda text : int ( text ) if text . isdigit ( ) else text return lambda s : [ convert ( c ) for c in re . split ( '([0-9]+)' , key ( s ) ) ] sort_key = get_alphanum_key_func ( key ) list . sort ( key = sort_key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a random ( i . e . unique ) string identifier<CODESPLIT>def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert list of key value lists to dict<CODESPLIT>def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>string dict / object / value to JSON<CODESPLIT>def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle conversion of pymongo cursor into a JSON object formatted for UI consumption<CODESPLIT>def _obj_cursor_to_dictionary ( self , cursor ) : if not cursor : return cursor cursor = json . loads ( json . dumps ( cursor , cls = BSONEncoder ) ) if cursor . get ( "_id" ) : cursor [ "id" ] = cursor . get ( "_id" ) del cursor [ "_id" ] return cursor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>writes a string to file<CODESPLIT>def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : img ( PIL Image ) : Image to be padded .<CODESPLIT>def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close connection with the database<CODESPLIT>def close_database_session ( session ) : try : session . close ( ) except OperationalError as e : raise DatabaseError ( error = e . orig . args [ 1 ] , code = e . orig . args [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if created today .<CODESPLIT>def created_today ( self ) : if self . datetime . date ( ) == datetime . today ( ) . date ( ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Clean up whitespace in column names . See better version at pugnlp . clean_columns<CODESPLIT>def normalize_column_names ( df ) : columns = df . columns if hasattr ( df , 'columns' ) else df columns = [ c . lower ( ) . replace ( ' ' , '_' ) for c in columns ] return columns
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .<CODESPLIT>def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output<CODESPLIT>def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops the analysis as soon as possible .<CODESPLIT>def stop ( self ) -> None : if self . _stop and not self . _posted_kork : self . _stop ( ) self . _stop = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter for dict note f should have signature : f :: key - > value - > bool<CODESPLIT>def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is an enum type .<CODESPLIT>def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialises a protobuf object as json<CODESPLIT>def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the key from the request<CODESPLIT>def get ( key , default = None ) : data = get_form ( ) or get_query_string ( ) return data . get ( key , default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts the string representation of a json number into its python object equivalent an int long float or whatever type suits .<CODESPLIT>def default_number_converter ( number_str ) : is_int = ( number_str . startswith ( '-' ) and number_str [ 1 : ] . isdigit ( ) ) or number_str . isdigit ( ) # FIXME: this handles a wider range of numbers than allowed by the json standard, # etc.: float('nan') and float('inf'). But is this a problem? return int ( number_str ) if is_int else float ( number_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conform Series to new index with optional filling logic .<CODESPLIT>def reindex_axis ( self , labels , axis = 0 , * * kwargs ) : # for compatibility with higher dims if axis != 0 : raise ValueError ( "cannot reindex series on non-zero axis!" ) msg = ( "'.reindex_axis' is deprecated and will be removed in a future " "version. Use '.reindex' instead." ) warnings . warn ( msg , FutureWarning , stacklevel = 2 ) return self . reindex ( index = labels , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a colored string to the target handle .<CODESPLIT>def cprint ( string , fg = None , bg = None , end = '\n' , target = sys . stdout ) : _color_manager . set_color ( fg , bg ) target . write ( string + end ) target . flush ( ) # Needed for Python 3.x _color_manager . set_defaults ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a vector with the elements rounded to the given number of digits .<CODESPLIT>def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if we have a compatible fill_value and arr dtype then fill<CODESPLIT>def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Error handler<CODESPLIT>def on_error ( e ) : # pragma: no cover exname = { 'RuntimeError' : 'Runtime error' , 'Value Error' : 'Value error' } sys . stderr . write ( '{}: {}\n' . format ( exname [ e . __class__ . __name__ ] , str ( e ) ) ) sys . stderr . write ( 'See file slam_error.log for additional details.\n' ) sys . exit ( 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a simple check if the value is callable .<CODESPLIT>def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print the object s representation .<CODESPLIT>def pretty ( obj , verbose = False , max_width = 79 , newline = '\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to lower_and_underscore .<CODESPLIT>def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) .<CODESPLIT>def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string from snake case to camel case .<CODESPLIT>def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Primary entry point to turn kwargs into properties<CODESPLIT>def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager to temporarily disable certificate validation in the standard SSL library .<CODESPLIT>def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of bytes to represent this dtype .<CODESPLIT>def size ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'size' ) : return dtype . size return np . dtype ( dtype ) . itemsize
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses hostname from URL . : param url : URL : return : hostname<CODESPLIT>def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .<CODESPLIT>def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for pulling a keyed value off various types of objects<CODESPLIT>def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes the string to stdout<CODESPLIT>def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets RAM memory usage<CODESPLIT>def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is a finite number .<CODESPLIT>def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the column mapped by db_field name<CODESPLIT>def _get_column_by_db_name ( cls , name ) : return cls . _columns . get ( cls . _db_map . get ( name , name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Downsample x by factor using striding .<CODESPLIT>def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleanup the session if it was created here<CODESPLIT>def __del__ ( self ) : if self . _cleanup_session : self . _session . loop . run_until_complete ( self . _session . close ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips spaces : param x : : return :<CODESPLIT>def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\t' , b'' ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Index of the last occurrence of x in the sequence .<CODESPLIT>def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pad the text .<CODESPLIT>def _pad ( self , text ) : top_bottom = ( "\n" * self . _padding ) + " " right_left = " " * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string with punctuation removed .<CODESPLIT>def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\w' , r'\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conveinience :<CODESPLIT>def get_tablenames ( cur ) : cur . execute ( "SELECT name FROM sqlite_master WHERE type='table'" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerce value to an JSON - compatible representation .<CODESPLIT>def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( "ascii" ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip whitespace from string columns .<CODESPLIT>def strip_columns ( tab ) : for colname in tab . colnames : if tab [ colname ] . dtype . kind in [ 'S' , 'U' ] : tab [ colname ] = np . core . defchararray . strip ( tab [ colname ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Do all elements of x have a type from types?<CODESPLIT>def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the specified element selector is present on the page .<CODESPLIT>def is_element_present ( driver , selector , by = By . CSS_SELECTOR ) : try : driver . find_element ( by = by , value = selector ) return True except Exception : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a numpy array of integers<CODESPLIT>def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a run . log within folder . This file contains the time of the latest successful run .<CODESPLIT>def create_run_logfile ( folder ) : with open ( os . path . join ( folder , "run.log" ) , "w" ) as f : datestring = datetime . datetime . utcnow ( ) . strftime ( "%Y-%m-%d %H:%M:%S" ) f . write ( "timestamp: '%s'" % datestring )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to read a value named key from the headers .<CODESPLIT>def get_from_headers ( request , key ) : value = request . headers . get ( key ) return to_native ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull the value from the cookiejar .<CODESPLIT>def parse_cookies ( self , req , name , field ) : return core . get_value ( req . COOKIES , name , field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a prettified version of the SQL as a list of lines to help in creating a useful diff between two SQL statements .<CODESPLIT>def prettifysql ( sql ) : pretty = [ ] for line in sql . split ( '\n' ) : pretty . extend ( [ "%s,\n" % x for x in line . split ( ',' ) ] ) return pretty
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a string as an integer encapsulating error handling .<CODESPLIT>def prsint ( string ) : string = stypes . stringToCharP ( string ) intval = ctypes . c_int ( ) libspice . prsint_c ( string , ctypes . byref ( intval ) ) return intval . value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compiles to native Python bytecode and runs program returning the topmost value on the stack .<CODESPLIT>def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value in bytearray to int<CODESPLIT>def set_int ( bytearray_ , byte_index , _int ) : # make sure were dealing with an int _int = int ( _int ) _bytes = struct . unpack ( '2B' , struct . pack ( '>h' , _int ) ) bytearray_ [ byte_index : byte_index + 2 ] = _bytes return bytearray_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add an object to Javascript .<CODESPLIT>def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a list of items seperated by seps .<CODESPLIT>def itemlist ( item , sep , suppress_trailing = True ) : return condense ( item + ZeroOrMore ( addspace ( sep + item ) ) + Optional ( sep . suppress ( ) if suppress_trailing else sep ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to create regexp for matching escaped separators in strings .<CODESPLIT>def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\]|\\.)+)' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return wrapper to named api method .<CODESPLIT>def __getattr__ ( self , name ) : return functools . partial ( self . _obj . request , self . _api_prefix + name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert comma - delimited list / string into a list of strings<CODESPLIT>def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restore settings to default values .<CODESPLIT>def restore_default_settings ( ) : global __DEFAULTS __DEFAULTS . CACHE_DIR = defaults . CACHE_DIR __DEFAULTS . SET_SEED = defaults . SET_SEED __DEFAULTS . SEED = defaults . SEED logging . info ( 'Settings reverted to their default values.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds parent folder of file<CODESPLIT>def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This removes newlines and multiple spaces from a string .<CODESPLIT>def normalize_value ( text ) : result = text . replace ( '\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute average gradient norm of an image<CODESPLIT>def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple of ( start end ) indices of an item from its index .<CODESPLIT>def _get_item_position ( self , idx ) : start = 0 if idx == 0 else self . _index [ idx - 1 ] + 1 end = self . _index [ idx ] return start , end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join the given iterable with<CODESPLIT>def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get adjacency matrix .<CODESPLIT>def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function used for joins builds left and right join list for join function<CODESPLIT>def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .<CODESPLIT>def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the yaml output of the dict .<CODESPLIT>def yaml ( self ) : return ordered_dump ( OrderedDict ( self ) , Dumper = yaml . SafeDumper , default_flow_style = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes stopwords contained in a list of words .<CODESPLIT>def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return unique rows<CODESPLIT>def _unique_rows_numpy ( a ) : a = np . ascontiguousarray ( a ) unique_a = np . unique ( a . view ( [ ( '' , a . dtype ) ] * a . shape [ 1 ] ) ) return unique_a . view ( a . dtype ) . reshape ( ( unique_a . shape [ 0 ] , a . shape [ 1 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return possible range for min function .<CODESPLIT>def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if list contains either values of type vtype or None .<CODESPLIT>def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The current active : class : . Window .<CODESPLIT>def get_active_window ( self ) : app = get_app ( ) try : return self . _active_window_for_cli [ app ] except KeyError : self . _active_window_for_cli [ app ] = self . _last_active_window or self . windows [ 0 ] return self . windows [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function returns a pretty table used to display the port results .<CODESPLIT>def get_table ( ports ) : table = PrettyTable ( [ "Name" , "Port" , "Protocol" , "Description" ] ) table . align [ "Name" ] = "l" table . align [ "Description" ] = "l" table . padding_width = 1 for port in ports : table . add_row ( port ) return table
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encapsulating the rules for whether the request was to a Flask endpoint<CODESPLIT>def _has_fr_route ( self ) : # 404's, 405's, which might not have a url_rule if self . _should_use_fr_error_handler ( ) : return True # for all other errors, just check if FR dispatched the route if not request . url_rule : return False return self . owns_endpoint ( request . url_rule . endpoint )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Blocks until a keyboard event happens then returns that event s name or if missing its scan code .<CODESPLIT>def read_key ( suppress = False ) : event = read_event ( suppress ) return event . name or event . scan_code
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this an integer .<CODESPLIT>def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to snake_case .<CODESPLIT>def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1<CODESPLIT>def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove comments and empty lines<CODESPLIT>def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print emphasized good the given txt message<CODESPLIT>def good ( txt ) : print ( "%s# %s%s%s" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .<CODESPLIT>def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle pause mode<CODESPLIT>def toggle_pause ( self ) : self . controller . playing = not self . controller . playing self . music . toggle_pause ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts markdown content to text<CODESPLIT>def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs a bash script in the local directory<CODESPLIT>def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( "bash {}" . format ( filename ) , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This removes newlines and multiple spaces from a string .<CODESPLIT>def normalize_value ( text ) : result = text . replace ( '\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get object if child already been read or get child .<CODESPLIT>def get_object_or_child_by_type ( self , * types ) : objects = self . get_objects_or_children_by_type ( * types ) return objects [ 0 ] if any ( objects ) else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pyqt specific key release callback function . Translates and forwards events to : py : func : keyboard_event .<CODESPLIT>def keyReleaseEvent ( self , event ) : self . keyboard_event ( event . key ( ) , self . keys . ACTION_RELEASE , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill file at<CODESPLIT>def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses the Unix ps program to see if a process is running .<CODESPLIT>def is_running ( process_id : int ) -> bool : pstr = str ( process_id ) encoding = sys . getdefaultencoding ( ) s = subprocess . Popen ( [ "ps" , "-p" , pstr ] , stdout = subprocess . PIPE ) for line in s . stdout : strline = line . decode ( encoding ) if pstr in strline : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursivly delete a directory<CODESPLIT>def rrmdir ( directory ) : for root , dirs , files in os . walk ( directory , topdown = False ) : for name in files : os . remove ( os . path . join ( root , name ) ) for name in dirs : os . rmdir ( os . path . join ( root , name ) ) os . rmdir ( directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform log transform log ( x + 1 ) . Parameters ---------- data : array_like<CODESPLIT>def log_normalize ( data ) : if sp . issparse ( data ) : data = data . copy ( ) data . data = np . log2 ( data . data + 1 ) return data return np . log2 ( data . astype ( np . float64 ) + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve contents of each page of PDF<CODESPLIT>def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random positive integer ( for a Django PositiveIntegerField )<CODESPLIT>def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract all union queries from table .<CODESPLIT>def flatten_union ( table ) : op = table . op ( ) if isinstance ( op , ops . Union ) : return toolz . concatv ( flatten_union ( op . left ) , [ op . distinct ] , flatten_union ( op . right ) ) return [ table ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A tensorflow variable tranfomed to be constrained in a L2 unit ball .<CODESPLIT>def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively loop through a directory to find all python script files . When one is found it is analyzed for import statements : param path : string : return : generator<CODESPLIT>def search_script_directory ( self , path ) : for subdir , dirs , files in os . walk ( path ) : for file_name in files : if file_name . endswith ( ".py" ) : self . search_script_file ( subdir , file_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .<CODESPLIT>def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batches a list into a list of lists with sub - lists sized by a specified batch size .<CODESPLIT>def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>move cursor up<CODESPLIT>def select_up ( self ) : r , c = self . _index self . _select_index ( r - 1 , c )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the progress ratio and percentage .<CODESPLIT>def ratio_and_percentage ( current , total , time_remaining ) : return "{} / {} ({}% completed)" . format ( current , total , int ( current / total * 100 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .<CODESPLIT>def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of bytes into an integer as per X9 . 62 .<CODESPLIT>def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get letters from string only .<CODESPLIT>def return_letters_from_string ( text ) : out = "" for letter in text : if letter . isalpha ( ) : out += letter return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>the field member matching name or None if no such field is found<CODESPLIT>def get_field_by_name ( self , name ) : for f in self . fields : if f . get_name ( ) == name : return f return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like dict but does not hold any null values .<CODESPLIT>def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load and execute a python file .<CODESPLIT>def load_files ( files ) : for py_file in files : LOG . debug ( "exec %s" , py_file ) execfile ( py_file , globals ( ) , locals ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback for closing the websocket connection<CODESPLIT>def _ws_on_close ( self , ws : websocket . WebSocketApp ) : self . connected = False self . logger . error ( 'Websocket closed' ) self . _reconnect_websocket ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .<CODESPLIT>def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to snake case .<CODESPLIT>def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate a method to write the configuration in yaml to the method desired<CODESPLIT>def generate_write_yaml_to_file ( file_name ) : def write_yaml ( config ) : with open ( file_name , 'w+' ) as fh : fh . write ( yaml . dump ( config ) ) return write_yaml
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write to given samples to a wav file . The samples are expected to be floating point numbers in the range of - 1 . 0 to 1 . 0 .<CODESPLIT>def write_wav ( path , samples , sr = 16000 ) : max_value = np . abs ( np . iinfo ( np . int16 ) . min ) data = ( samples * max_value ) . astype ( np . int16 ) scipy . io . wavfile . write ( path , sr , data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render the plot with bokeh . io and push to notebook .<CODESPLIT>def _push_render ( self ) : bokeh . io . push_notebook ( handle = self . handle ) self . last_update = time . time ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a nested list and returns the size of each dimension followed by the element type in the list<CODESPLIT>def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a gzipped stream of data yield streams of decompressed data .<CODESPLIT>def load_streams ( chunks ) : chunks = peekable ( chunks ) while chunks : if six . PY3 : dc = zlib . decompressobj ( wbits = zlib . MAX_WBITS | 16 ) else : dc = zlib . decompressobj ( zlib . MAX_WBITS | 16 ) yield load_stream ( dc , chunks ) if dc . unused_data : chunks = peekable ( itertools . chain ( ( dc . unused_data , ) , chunks ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate if non empty string<CODESPLIT>def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a 2D numpy array of bools<CODESPLIT>def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return n size lists from a given list l<CODESPLIT>def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .<CODESPLIT>def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new dict with any empty items removed .<CODESPLIT>def _remove_empty_items ( d , required ) : new_dict = { } for k , v in d . items ( ) : if k in required : new_dict [ k ] = v elif isinstance ( v , int ) or v : # "if v" would suppress emitting int(0) new_dict [ k ] = v return new_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Install or upgrade setuptools and EasyInstall<CODESPLIT>def main ( argv , version = DEFAULT_VERSION ) : tarball = download_setuptools ( ) _install ( tarball , _build_install_args ( argv ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit the shell session .<CODESPLIT>def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokenizes * source * and returns the tokens as a list of lists .<CODESPLIT>def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a read_range primitive<CODESPLIT>def add_range ( self , sequence , begin , end ) : sequence . parser_tree = parsing . Range ( self . value ( begin ) . strip ( "'" ) , self . value ( end ) . strip ( "'" ) ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print msg to stdout and option log at info level .<CODESPLIT>def pout ( msg , log = None ) : _print ( msg , sys . stdout , log_func = log . info if log else None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of all the image s colors .<CODESPLIT>def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform underscore separated string to pascal case<CODESPLIT>def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts list to string with comma separated values . For string is no - op .<CODESPLIT>def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = "," . join ( value ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the duplicates in a list .<CODESPLIT>def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate chi - squared .<CODESPLIT>def chi_square_calc ( classes , table , TOP , P , POP ) : try : result = 0 for i in classes : for index , j in enumerate ( classes ) : expected = ( TOP [ j ] * P [ i ] ) / ( POP [ i ] ) result += ( ( table [ i ] [ j ] - expected ) ** 2 ) / expected return result except Exception : return "None"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively find size of a tree . Slow .<CODESPLIT>def size ( self ) : if self is NULL : return 0 return 1 + self . left . size ( ) + self . right . size ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Just the last entry .<CODESPLIT>def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM "%s" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move cursor to this line in the current buffer .<CODESPLIT>def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminate all workers and threads .<CODESPLIT>def terminate ( self ) : for t in self . _threads : t . quit ( ) self . _thread = [ ] self . _workers = [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull the value from the cookiejar .<CODESPLIT>def parse_cookies ( self , req , name , field ) : return core . get_value ( req . COOKIES , name , field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if invoking supplied clang - apply - replacements binary works .<CODESPLIT>def check_clang_apply_replacements_binary ( args ) : try : subprocess . check_call ( [ args . clang_apply_replacements_binary , '--version' ] ) except : print ( 'Unable to run clang-apply-replacements. Is clang-apply-replacements ' 'binary correctly specified?' , file = sys . stderr ) traceback . print_exc ( ) sys . exit ( 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert numbers to floats whether the decimal point is . or<CODESPLIT>def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get random binary tree node .<CODESPLIT>def getRandomBinaryTreeLeafNode ( binaryTree ) : if binaryTree . internal == True : if random . random ( ) > 0.5 : return getRandomBinaryTreeLeafNode ( binaryTree . left ) else : return getRandomBinaryTreeLeafNode ( binaryTree . right ) else : return binaryTree
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call spell checker with arguments .<CODESPLIT>def call_spellchecker ( cmd , input_text = None , encoding = None ) : process = get_process ( cmd ) # A buffer has been provided if input_text is not None : for line in input_text . splitlines ( ) : # Hunspell truncates lines at `0x1fff` (at least on Windows this has been observed) # Avoid truncation by chunking the line on white space and inserting a new line to break it. offset = 0 end = len ( line ) while True : chunk_end = offset + 0x1fff m = None if chunk_end >= end else RE_LAST_SPACE_IN_CHUNK . search ( line , offset , chunk_end ) if m : chunk_end = m . start ( 1 ) chunk = line [ offset : m . start ( 1 ) ] offset = m . end ( 1 ) else : chunk = line [ offset : chunk_end ] offset = chunk_end # Avoid wasted calls to empty strings if chunk and not chunk . isspace ( ) : process . stdin . write ( chunk + b'\n' ) if offset >= end : break return get_process_output ( process , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check that value is in values<CODESPLIT>def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of dictionaries which are sorted for only unique entries .<CODESPLIT>def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield all items from iterable except the last one .<CODESPLIT>def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get primary key properties for a SQLAlchemy cls . Taken from marshmallow_sqlalchemy<CODESPLIT>def primary_keys_full ( cls ) : mapper = cls . __mapper__ return [ mapper . get_property_by_column ( column ) for column in mapper . primary_key ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the dimensions of a capture<CODESPLIT>def get_capture_dimensions ( capture ) : width = int ( capture . get ( cv2 . CAP_PROP_FRAME_WIDTH ) ) height = int ( capture . get ( cv2 . CAP_PROP_FRAME_HEIGHT ) ) return width , height
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To know the allocated memory at function termination .<CODESPLIT>def memory_used ( self ) : if self . _end_memory : memory_used = self . _end_memory - self . _start_memory return memory_used else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read and return filename in root dir of project and return string<CODESPLIT>def read ( filename ) : return codecs . open ( os . path . join ( __DIR__ , filename ) , 'r' ) . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Instantiate an anonymous file - based Bucket around a single key .<CODESPLIT>def __init__ ( self , name , contained_key ) : self . name = name self . contained_key = contained_key
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a 3x3 cross - product matrix from a 3 - element vector .<CODESPLIT>def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the mapping given an index<CODESPLIT>def find_mapping ( es_url , index ) : mapping = None backend = find_perceval_backend ( es_url , index ) if backend : mapping = backend . get_elastic_mappings ( ) if mapping : logging . debug ( "MAPPING FOUND:\n%s" , json . dumps ( json . loads ( mapping [ 'items' ] ) , indent = True ) ) return mapping
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether num is a power of two<CODESPLIT>def is_power_of_2 ( num ) : log = math . log2 ( num ) return int ( log ) == float ( log )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if arg is a valid file that already exists on the file system .<CODESPLIT>def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( "The file %s does not exist!" % arg ) else : return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a header as a list ready to write to TSV file<CODESPLIT>def generate_header ( headerfields , oldheader , group_by_field ) : fieldtypes = [ 'peptidefdr' , 'peptidepep' , 'nopsms' , 'proteindata' , 'precursorquant' , 'isoquant' ] return generate_general_header ( headerfields , fieldtypes , peptabledata . HEADER_PEPTIDE , oldheader , group_by_field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines whether the passed value is a string safe for 2 / 3 .<CODESPLIT>def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a vector of spherical bessel functions yn : x : The argument . N : values of n will run from 0 to N - 1 .<CODESPLIT>def sbessely ( x , N ) : out = np . zeros ( N , dtype = np . float64 ) out [ 0 ] = - np . cos ( x ) / x out [ 1 ] = - np . cos ( x ) / ( x ** 2 ) - np . sin ( x ) / x for n in xrange ( 2 , N ) : out [ n ] = ( ( 2.0 * n - 1.0 ) / x ) * out [ n - 1 ] - out [ n - 2 ] return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns names of object columns in the DataFrame .<CODESPLIT>def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plot a smoothed ( by kernel density estimate ) histogram . : type data : numpy array : param data : An array containing the data to be plotted<CODESPLIT>def plot_kde ( data , ax , title = None , color = 'r' , fill_bt = True ) : if isinstance ( data , list ) : data = np . asarray ( data ) e = kde . KDEUnivariate ( data . astype ( np . float ) ) e . fit ( ) ax . plot ( e . support , e . density , color = color , alpha = 0.9 , linewidth = 2.25 ) if fill_bt : ax . fill_between ( e . support , e . density , alpha = .35 , zorder = 1 , antialiased = True , color = color ) if title is not None : t = ax . set_title ( title ) t . set_y ( 1.05 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the specified parameter from this query<CODESPLIT>def remove_parameter ( self , name ) : if name in self . __query : self . __query . pop ( name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes the connection .<CODESPLIT>def disconnect ( self ) : self . logger . debug ( 'Close connection...' ) self . auto_reconnect = False if self . websocket is not None : self . websocket . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read text from stdin and print a helpful message for ttys .<CODESPLIT>def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download file from S3 Bucket<CODESPLIT>def download_file_from_bucket ( self , bucket , file_path , key ) : with open ( file_path , 'wb' ) as data : self . __s3 . download_fileobj ( bucket , key , data ) return file_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Type casting .<CODESPLIT>def convert_value ( bind , value ) : type_name = get_type ( bind ) try : return typecast . cast ( type_name , value ) except typecast . ConverterError : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a view into the memory<CODESPLIT>def read ( self , start_position : int , size : int ) -> memoryview : return memoryview ( self . _bytes ) [ start_position : start_position + size ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of column 0 of the current item in the underlying model . See also the notes at the top of this module on current item vs selected item ( s ) .<CODESPLIT>def getRowCurrentIndex ( self ) : curIndex = self . currentIndex ( ) col0Index = curIndex . sibling ( curIndex . row ( ) , 0 ) return col0Index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively find size of a tree . Slow .<CODESPLIT>def size ( self ) : if self is NULL : return 0 return 1 + self . left . size ( ) + self . right . size ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the median of numeric data unsing the mean of middle two method . If data is empty 0 is returned .<CODESPLIT>def median ( data ) : if len ( data ) == 0 : return None data = sorted ( data ) return float ( ( data [ len ( data ) // 2 ] + data [ ( len ( data ) - 1 ) // 2 ] ) / 2. )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if two numbers are equal up to the specified number of places after the decimal point .<CODESPLIT>def _float_almost_equal ( float1 , float2 , places = 7 ) : if round ( abs ( float2 - float1 ) , places ) == 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Index of the last occurrence of x in the sequence .<CODESPLIT>def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Populate axis limits GUI with current plot values .<CODESPLIT>def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redirect the stdout<CODESPLIT>def redirect_stdout ( new_stdout ) : old_stdout , sys . stdout = sys . stdout , new_stdout try : yield None finally : sys . stdout = old_stdout
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like rotate but modifies l in - place .<CODESPLIT>def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .<CODESPLIT>def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the short - time Fourier transform magnitude .<CODESPLIT>def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the SSE to the cluster center<CODESPLIT>def _cal_dist2center ( X , center ) : dmemb2cen = scipy . spatial . distance . cdist ( X , center . reshape ( 1 , X . shape [ 1 ] ) , metric = 'seuclidean' ) return ( np . sum ( dmemb2cen ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emulate lpop .<CODESPLIT>def rpop ( self , key ) : redis_list = self . _get_list ( key , 'RPOP' ) if self . _encode ( key ) not in self . redis : return None try : value = redis_list . pop ( ) if len ( redis_list ) == 0 : self . delete ( key ) return value except ( IndexError ) : # Redis returns nil if popping from an empty list return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When the with statement ends .<CODESPLIT>def __exit__ ( self , type , value , traceback ) : if not self . asarfile : return self . asarfile . close ( ) self . asarfile = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates symbolic link for either operating system . http : // stackoverflow . com / questions / 6260149 / os - symlink - support - in - windows<CODESPLIT>def create_symlink ( source , link_name ) : os_symlink = getattr ( os , "symlink" , None ) if isinstance ( os_symlink , collections . Callable ) : os_symlink ( source , link_name ) else : import ctypes csl = ctypes . windll . kernel32 . CreateSymbolicLinkW csl . argtypes = ( ctypes . c_wchar_p , ctypes . c_wchar_p , ctypes . c_uint32 ) csl . restype = ctypes . c_ubyte flags = 1 if os . path . isdir ( source ) else 0 if csl ( link_name , source , flags ) == 0 : raise ctypes . WinError ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs out the current session by removing it from the cache . This is expected to only occur when a session has<CODESPLIT>def logout ( cache ) : cache . set ( flask . session [ 'auth0_key' ] , None ) flask . session . clear ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .<CODESPLIT>def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function which returns an array with the Intervals boundaries .<CODESPLIT>def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Submit the form having given id .<CODESPLIT>def submit_form_id ( step , id ) : form = world . browser . find_element_by_xpath ( str ( 'id("{id}")' . format ( id = id ) ) ) form . submit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Slugify filename<CODESPLIT>def slugify_filename ( filename ) : name , ext = os . path . splitext ( filename ) slugified = get_slugified_name ( name ) return slugified + ext
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs the unit test framework . Can be overridden to run anything . Returns True on passing and False on failure .<CODESPLIT>def run ( self ) : try : import nose arguments = [ sys . argv [ 0 ] ] + list ( self . test_args ) return nose . run ( argv = arguments ) except ImportError : print ( ) print ( "*** Nose library missing. Please install it. ***" ) print ( ) raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of all parsed comments in a file . Mostly for testing & interactive use .<CODESPLIT>def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register plugin in Spyder s main window<CODESPLIT>def register_plugin ( self ) : self . main . restore_scrollbar_position . connect ( self . restore_scrollbar_position ) self . main . add_dockwidget ( self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is an object iterable like a list ( and not a string ) ?<CODESPLIT>def listlike ( obj ) : return hasattr ( obj , "__iter__" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file or directory is world writable .<CODESPLIT>def is_writable_by_others ( filename ) : mode = os . stat ( filename ) [ stat . ST_MODE ] return mode & stat . S_IWOTH
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all dates between two dates .<CODESPLIT>def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a SHA256 hash from a Numpy array .<CODESPLIT>def array_sha256 ( a ) : dtype = str ( a . dtype ) . encode ( ) shape = numpy . array ( a . shape ) sha = hashlib . sha256 ( ) sha . update ( dtype ) sha . update ( shape ) sha . update ( a . tobytes ( ) ) return sha . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encode ndarray to base64 string image data Parameters ---------- arr : ndarray ( rows cols depth ) kwargs : passed directly to matplotlib . image . imsave<CODESPLIT>def img_encode ( arr , * * kwargs ) : sio = BytesIO ( ) imsave ( sio , arr , * * kwargs ) sio . seek ( 0 ) img_format = kwargs [ 'format' ] if kwargs . get ( 'format' ) else 'png' img_str = base64 . b64encode ( sio . getvalue ( ) ) . decode ( ) return 'data:image/{};base64,{}' . format ( img_format , img_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A list of functions declared or defined in this module .<CODESPLIT>def functions ( self ) : return [ v for v in self . globals . values ( ) if isinstance ( v , values . Function ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>test if object is a list or tuple<CODESPLIT>def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - optimal implementation of a regex filter<CODESPLIT>def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert list of key value lists to dict<CODESPLIT>def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert any timestamp to UTC ( with tzinfo ) .<CODESPLIT>def to_utc ( self , dt ) : if dt . tzinfo is None : return dt . replace ( tzinfo = self . utc ) return dt . astimezone ( self . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses a date string formatted like YYYY - MM - DD .<CODESPLIT>def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .<CODESPLIT>def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a datetime object of a given timestamp ( in UTC ) .<CODESPLIT>def utcfromtimestamp ( cls , timestamp ) : obj = datetime . datetime . utcfromtimestamp ( timestamp ) obj = pytz . utc . localize ( obj ) return cls ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get dimension of an array getting the number of rows and the max num of columns .<CODESPLIT>def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a log message to standard error .<CODESPLIT>def print_log ( text , * colors ) : sys . stderr . write ( sprint ( "{}: {}" . format ( script_name , text ) , * colors ) + "\n" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decodes a given base64 string into bytes .<CODESPLIT>def decode_bytes ( string ) : if is_string_type ( type ( string ) ) : string = bytes ( string , "utf-8" ) return base64 . decodebytes ( string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .<CODESPLIT>def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return locale from GET lang param or automatically .<CODESPLIT>def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return checker .<CODESPLIT>def cpp_checker ( code , working_directory ) : return gcc_checker ( code , '.cpp' , [ os . getenv ( 'CXX' , 'g++' ) , '-std=c++0x' ] + INCLUDE_FLAGS , working_directory = working_directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if the socket managed by this connection is connected<CODESPLIT>def is_connected ( self ) : try : return self . socket is not None and self . socket . getsockname ( ) [ 1 ] != 0 and BaseTransport . is_connected ( self ) except socket . error : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to camel_case<CODESPLIT>def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a byte sized value .<CODESPLIT>def fmt_sz ( intval ) : try : return fmt . human_size ( intval ) except ( ValueError , TypeError ) : return "N/A" . rjust ( len ( fmt . human_size ( 0 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates requests session user - agent with the driver s user agent<CODESPLIT>def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( "return navigator.userAgent;" ) self . headers . update ( { "user-agent" : selenium_user_agent } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will make any functions return an iterable objects by wrapping its result in a list .<CODESPLIT>def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a file exists and is non - empty .<CODESPLIT>def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the largest real value h such that all elements in x are integer multiples of h .<CODESPLIT>def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interpolate linearly variable x in rangeX onto rangeY .<CODESPLIT>def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpickle a python object from the given path .<CODESPLIT>def unpickle ( pickle_file ) : pickle = None with open ( pickle_file , "rb" ) as pickle_f : pickle = dill . load ( pickle_f ) if not pickle : LOG . error ( "Could not load python object from file" ) return pickle
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether another set contains this set .<CODESPLIT>def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Collect and serve static files .<CODESPLIT>def serve_static ( request , path , insecure = False , * * kwargs ) : # Follow the same logic Django uses for determining access to the # static-serving view. if not django_settings . DEBUG and not insecure : raise ImproperlyConfigured ( "The staticfiles view can only be used in " "debug mode or if the --insecure " "option of 'runserver' is used" ) if not settings . PIPELINE_ENABLED and settings . PIPELINE_COLLECTOR_ENABLED : # Collect only the requested file, in order to serve the result as # fast as possible. This won't interfere with the template tags in any # way, as those will still cause Django to collect all media. default_collector . collect ( request , files = [ path ] ) return serve ( request , path , document_root = django_settings . STATIC_ROOT , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively merge dicts .<CODESPLIT>def update ( dct , dct_merge ) : for key , value in dct_merge . items ( ) : if key in dct and isinstance ( dct [ key ] , dict ) : dct [ key ] = update ( dct [ key ] , value ) else : dct [ key ] = value return dct
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When the with statement ends .<CODESPLIT>def __exit__ ( self , type , value , traceback ) : if not self . asarfile : return self . asarfile . close ( ) self . asarfile = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the current xy coordinates of the mouse cursor as a two - integer tuple by calling the GetCursorPos () win32 function .<CODESPLIT>def _position ( ) : cursor = POINT ( ) ctypes . windll . user32 . GetCursorPos ( ctypes . byref ( cursor ) ) return ( cursor . x , cursor . y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Open up a GUI browse dialog window and let to user pick a target directory . : return str : Target directory path<CODESPLIT>def browse_dialog_dir ( ) : _go_to_package ( ) logger_directory . info ( "enter browse_dialog" ) _path_bytes = subprocess . check_output ( [ 'python' , 'gui_dir_browse.py' ] , shell = False ) _path = _fix_path_bytes ( _path_bytes , file = False ) if len ( _path ) >= 1 : _path = _path [ 0 ] else : _path = "" logger_directory . info ( "chosen path: {}" . format ( _path ) ) logger_directory . info ( "exit browse_dialog" ) return _path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make bars in horizontal bar chart thinner<CODESPLIT>def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to uncheck a checkbox<CODESPLIT>def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1x1 convolution<CODESPLIT>def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the available ffmpeg version<CODESPLIT>def ffmpeg_version ( ) : cmd = [ 'ffmpeg' , '-version' ] output = sp . check_output ( cmd ) aac_codecs = [ x for x in output . splitlines ( ) if "ffmpeg version " in str ( x ) ] [ 0 ] hay = aac_codecs . decode ( 'ascii' ) match = re . findall ( r'ffmpeg version (\d+\.)?(\d+\.)?(\*|\d+)' , hay ) if match : return "" . join ( match [ 0 ] ) else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a horizontal line up to a given length .<CODESPLIT>def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the length of the longest consecutive run of True values .<CODESPLIT>def longest_run ( da , dim = 'time' ) : d = rle ( da , dim = dim ) rl_long = d . max ( dim = dim ) return rl_long
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpickles the classifier used<CODESPLIT>def load ( self , filename = 'classifier.dump' ) : ifile = open ( filename , 'r+' ) self . classifier = pickle . load ( ifile ) ifile . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Asks an SQLAlchemy class how its attribute names correspond to database column names .<CODESPLIT>def attrname_to_colname_dict ( cls ) -> Dict [ str , str ] : attr_col = { } # type: Dict[str, str] for attrname , column in gen_columns ( cls ) : attr_col [ attrname ] = column . name return attr_col
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleanup any active connections and free all DDEML resources .<CODESPLIT>def __del__ ( self ) : if self . _hConv : DDE . Disconnect ( self . _hConv ) if self . _idInst : DDE . Uninitialize ( self . _idInst )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the value of a local variable somewhere in the call stack .<CODESPLIT>def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generator for reading from standard input in nonblocking mode .<CODESPLIT>def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of factor levels for each categorical column .<CODESPLIT>def nlevels ( self ) : levels = self . levels ( ) return [ len ( l ) for l in levels ] if levels else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a string from a file - like object .<CODESPLIT>def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a string and dictionary . replaces all occurrences of i with j<CODESPLIT>def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a pandas . Series into an xarray . DataArray .<CODESPLIT>def from_series ( cls , series ) : # TODO: add a 'name' parameter name = series . name df = pd . DataFrame ( { name : series } ) ds = Dataset . from_dataframe ( df ) return ds [ name ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare two strings while protecting against timing attacks<CODESPLIT>def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given extension is one of the watched extensions<CODESPLIT>def watched_extension ( extension ) : for ext in hamlpy . VALID_EXTENSIONS : if extension . endswith ( '.' + ext ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract from the given iterable of lines the list of words .<CODESPLIT>def extract_words ( lines ) : for line in lines : for word in re . findall ( r"\w+" , line ) : yield word
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute a stored procedure . Returns the first row of the result set or None .<CODESPLIT>def query_proc_row ( procname , args = ( ) , factory = None ) : for row in query_proc ( procname , args , factory ) : return row return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply a function in parallel to each element of the input<CODESPLIT>def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the largest contig for each strain : param contig_lengths_dict : dictionary of strain name : reverse - sorted list of all contig lengths : return : longest_contig_dict : dictionary of strain name : longest contig<CODESPLIT>def find_largest_contig ( contig_lengths_dict ) : # Initialise the dictionary longest_contig_dict = dict ( ) for file_name , contig_lengths in contig_lengths_dict . items ( ) : # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict [ file_name ] = contig_lengths [ 0 ] return longest_contig_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed<CODESPLIT>def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>save something to a pickle file<CODESPLIT>def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , "wb" ) , pickle . HIGHEST_PROTOCOL ) return thing
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop and destroy Bloomberg connection<CODESPLIT>def delete_connection ( ) : if _CON_SYM_ in globals ( ) : con = globals ( ) . pop ( _CON_SYM_ ) if not getattr ( con , '_session' ) . start ( ) : con . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether we re in an interactive shell . Sets interactivity off if appropriate . cf http : // stackoverflow . com / questions / 24861351 / how - to - detect - if - python - script - is - being - run - as - a - background - process<CODESPLIT>def determine_interactive ( self ) : try : if not sys . stdout . isatty ( ) or os . getpgrp ( ) != os . tcgetpgrp ( sys . stdout . fileno ( ) ) : self . interactive = 0 return False except Exception : self . interactive = 0 return False if self . interactive == 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses hostname from URL . : param url : URL : return : hostname<CODESPLIT>def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert napoleon docstring to plain sphinx string .<CODESPLIT>def napoleon_to_sphinx ( docstring , * * config_params ) : if "napoleon_use_param" not in config_params : config_params [ "napoleon_use_param" ] = False if "napoleon_use_rtype" not in config_params : config_params [ "napoleon_use_rtype" ] = False config = Config ( * * config_params ) return str ( GoogleDocstring ( docstring , config ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scale the image to uint8<CODESPLIT>def uint8sc ( im ) : im = np . asarray ( im ) immin = im . min ( ) immax = im . max ( ) imrange = immax - immin return cv2 . convertScaleAbs ( im - immin , alpha = 255 / imrange )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns day number of the last day of the month : param t : datetime : return : int<CODESPLIT>def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Earth orientation as a rotating matrix<CODESPLIT>def earth_orientation ( date ) : x_p , y_p , s_prime = np . deg2rad ( _earth_orientation ( date ) ) return rot3 ( - s_prime ) @ rot2 ( x_p ) @ rot1 ( y_p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method validate the parsing and schema return a boolean<CODESPLIT>def validate ( self , xml_input ) : parsed_xml = etree . parse ( self . _handle_xml ( xml_input ) ) try : return self . xmlschema . validate ( parsed_xml ) except AttributeError : raise CannotValidate ( 'Set XSD to validate the XML' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a random element from seq n times . If n is None it continues indefinitly<CODESPLIT>def rand_elem ( seq , n = None ) : return map ( random . choice , repeat ( seq , n ) if n is not None else repeat ( seq ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if two rectangles each input as a tuple ( xmin xmax ymin ymax ) intersect .<CODESPLIT>def boxes_intersect ( box1 , box2 ) : xmin1 , xmax1 , ymin1 , ymax1 = box1 xmin2 , xmax2 , ymin2 , ymax2 = box2 if interval_intersection_width ( xmin1 , xmax1 , xmin2 , xmax2 ) and interval_intersection_width ( ymin1 , ymax1 , ymin2 , ymax2 ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of characters at the beginning of text that are whitespace .<CODESPLIT>def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverse the range<CODESPLIT>def negate ( self ) : self . from_value , self . to_value = self . to_value , self . from_value self . include_lower , self . include_upper = self . include_upper , self . include_lower
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns uptime in seconds or None on Syllable .<CODESPLIT>def _uptime_syllable ( ) : global __boottime try : __boottime = os . stat ( '/dev/pty/mst/pty0' ) . st_mtime return time . time ( ) - __boottime except ( NameError , OSError ) : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to handle what to do when the stop button is pressed<CODESPLIT>def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging  if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return True if callback is a vanilla plain jane function<CODESPLIT>def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as : meth : random . choice but also supports : class : set type to be passed as sequence .<CODESPLIT>def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detach from all tracked classes and objects . Restore the original constructors and cleanse the tracking lists .<CODESPLIT>def detach_all ( self ) : self . detach_all_classes ( ) self . objects . clear ( ) self . index . clear ( ) self . _keepalive [ : ] = [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the progress ratio and percentage .<CODESPLIT>def ratio_and_percentage ( current , total , time_remaining ) : return "{} / {} ({}% completed)" . format ( current , total , int ( current / total * 100 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the top level domain from an URL .<CODESPLIT>def top_level ( url , fix_protocol = True ) : ext = tld . get_tld ( url , fix_protocol = fix_protocol ) toplevel = '.' . join ( urlparse ( url ) . netloc . split ( '.' ) [ - 2 : ] ) . split ( ext ) [ 0 ] + ext return toplevel
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the type of the ( sub ) tree : Root Nucleus or Satellite<CODESPLIT>def get_tree_type ( tree ) : tree_type = tree . label ( ) assert tree_type in SUBTREE_TYPES , "tree_type: {}" . format ( tree_type ) return tree_type
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits<CODESPLIT>def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not<CODESPLIT>def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = "json" ) is_json = True except : is_json = False return ( is_json )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a repr () for a list / tuple<CODESPLIT>def _tuple_repr ( data ) : if len ( data ) == 1 : return "(%s,)" % rpr ( data [ 0 ] ) else : return "(%s)" % ", " . join ( [ rpr ( x ) for x in data ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset analyzer state<CODESPLIT>def reset ( self ) : self . prevframe = None self . wasmoving = False self . t0 = 0 self . ismoving = False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .<CODESPLIT>def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine True / False from argument<CODESPLIT>def process_bool_arg ( arg ) : if isinstance ( arg , bool ) : return arg elif isinstance ( arg , basestring ) : if arg . lower ( ) in [ "true" , "1" ] : return True elif arg . lower ( ) in [ "false" , "0" ] : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DEBUG FUNC modify argv to look like you ran a command<CODESPLIT>def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage .<CODESPLIT>def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Not meant to be used directly use : meth : Instaloader . save_session_to_file .<CODESPLIT>def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms the output of parse () into a Text object . The token parameter lists the order of tags in each token in the input string .<CODESPLIT>def tree ( string , token = [ WORD , POS , CHUNK , PNP , REL , ANCHOR , LEMMA ] ) : return Text ( string , token )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print dicttree in Json - like format . keys are sorted<CODESPLIT>def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( "," , ": " ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the request s User - Agent if available .<CODESPLIT>def _get_user_agent ( self ) : user_agent = request . headers . get ( 'User-Agent' ) if user_agent : user_agent = user_agent . encode ( 'utf-8' ) return user_agent or ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for plotting .<CODESPLIT>def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal helper to ask if the entity has a value for this Property .<CODESPLIT>def _is_initialized ( self , entity ) : return ( not self . _required or ( ( self . _has_value ( entity ) or self . _default is not None ) and self . _get_value ( entity ) is not None ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a parser for CLI arguments and options .<CODESPLIT>def default_parser ( ) -> argparse . ArgumentParser : parser = argparse . ArgumentParser ( prog = CONSOLE_SCRIPT , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) build_parser ( parser ) return parser
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate equality between two ( Comparable ) objects .<CODESPLIT>def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pop the heap value from the heap .<CODESPLIT>def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () .<CODESPLIT>def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a querystring value from the request .<CODESPLIT>def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of ( key value ) pairs and turns it into a dict .<CODESPLIT>def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserializes string to date .<CODESPLIT>def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value<CODESPLIT>def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap vertical table in a function for TabularOutputFormatter .<CODESPLIT>def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accepts a NumberGenerator operand an operator and optional arguments to be provided to the operator when calling it on the operand .<CODESPLIT>def __init__ ( self , operand , operator , * * args ) : # Note that it's currently not possible to set # parameters in the superclass when creating an instance, # because **args is used by this class itself. super ( UnaryOperator , self ) . __init__ ( ) self . operand = operand self . operator = operator self . args = args
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does a string replace with a list of search and replacements<CODESPLIT>def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the serial port e . g . : / dev / tty . usbserial - A4001ib8<CODESPLIT>def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check features data are not empty<CODESPLIT>def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function for loading yaml - encoded data from disk .<CODESPLIT>def load_yaml ( filepath ) : with open ( filepath ) as f : txt = f . read ( ) return yaml . load ( txt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show tip<CODESPLIT>def show_tip ( self , tip = "" ) : QToolTip . showText ( self . mapToGlobal ( self . pos ( ) ) , tip , self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts Matrix3 in an array : param m : Matrix3 : returns : 3x3 array<CODESPLIT>def _matrix3_to_dcm_array ( self , m ) : assert ( isinstance ( m , Matrix3 ) ) return np . array ( [ [ m . a . x , m . a . y , m . a . z ] , [ m . b . x , m . b . y , m . b . z ] , [ m . c . x , m . c . y , m . c . z ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the week start date and end date<CODESPLIT>def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>execute jobs in processes using N threads<CODESPLIT>def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print execution time of the function . For quick n dirty profiling .<CODESPLIT>def timeit ( func , log , limit ) : def newfunc ( * args , * * kwargs ) : """Execute function and print execution time.""" t = time . time ( ) res = func ( * args , * * kwargs ) duration = time . time ( ) - t if duration > limit : print ( func . __name__ , "took %0.2f seconds" % duration , file = log ) print ( args , file = log ) print ( kwargs , file = log ) return res return update_func_meta ( newfunc , func )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last number_of_bytes of filename<CODESPLIT>def tail ( filename , number_of_bytes ) : with open ( filename , "rb" ) as f : if os . stat ( filename ) . st_size > number_of_bytes : f . seek ( - number_of_bytes , 2 ) return f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update dict with fields from obj . attributes .<CODESPLIT>def update_dict ( obj , dict , attributes ) : for attribute in attributes : if hasattr ( obj , attribute ) and getattr ( obj , attribute ) is not None : dict [ attribute ] = getattr ( obj , attribute )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .<CODESPLIT>def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a lat & lng what s the string search query .<CODESPLIT>def _query_for_reverse_geocoding ( lat , lng ) : # have to do some stupid f/Decimal/str stuff to (a) ensure we get as much # decimal places as the user already specified and (b) to ensure we don't # get e-5 stuff return "{0:f},{1:f}" . format ( Decimal ( str ( lat ) ) , Decimal ( str ( lng ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) .<CODESPLIT>def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the title of the console window .<CODESPLIT>def title ( msg ) : if sys . platform . startswith ( "win" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>expects a _n . array returns the global minimum of ( value - array ) ^2<CODESPLIT>def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the list have unique items only and maintains the order<CODESPLIT>def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a colored string to the target handle .<CODESPLIT>def cprint ( string , fg = None , bg = None , end = '\n' , target = sys . stdout ) : _color_manager . set_color ( fg , bg ) target . write ( string + end ) target . flush ( ) # Needed for Python 3.x _color_manager . set_defaults ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A block of standard 2d convolutions .<CODESPLIT>def conv_block ( inputs , filters , dilation_rates_and_kernel_sizes , * * kwargs ) : return conv_block_internal ( conv , inputs , filters , dilation_rates_and_kernel_sizes , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all non - printable characters from a text string<CODESPLIT>def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If called after an update the sprite can move back<CODESPLIT>def move_back ( self , dt ) : self . _position = self . _old_position self . rect . topleft = self . _position self . feet . midbottom = self . rect . midbottom
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a value to str on Python 3 and unicode on Python 2 .<CODESPLIT>def text ( value , encoding = "utf-8" , errors = "strict" ) : if isinstance ( value , text_type ) : return value elif isinstance ( value , bytes ) : return text_type ( value , encoding , errors ) else : return text_type ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the year .<CODESPLIT>def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Abstraction over executemany method<CODESPLIT>def store_many ( self , sql , values ) : cursor = self . get_cursor ( ) cursor . executemany ( sql , values ) self . conn . commit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This loads a geojson file into a geojson python dictionary using the json module . Note : to load with a different text encoding use the encoding argument .<CODESPLIT>def _loadfilepath ( self , filepath , * * kwargs ) : with open ( filepath , "r" ) as f : data = json . load ( f , * * kwargs ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrun True if x is a valid YYYYMMDD date ; otherwise return False .<CODESPLIT>def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Linear model m is [ slope nugget ]<CODESPLIT>def linear_variogram_model ( m , d ) : slope = float ( m [ 0 ] ) nugget = float ( m [ 1 ] ) return slope * d + nugget
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the margin in pixels above the plot area setting border_top .<CODESPLIT>def calculate_top_margin ( self ) : self . border_top = 5 if self . show_graph_title : self . border_top += self . title_font_size self . border_top += 5 if self . show_graph_subtitle : self . border_top += self . subtitle_font_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if an executable is available on the system .<CODESPLIT>def executable_exists ( executable ) : for directory in os . getenv ( "PATH" ) . split ( ":" ) : if os . path . exists ( os . path . join ( directory , executable ) ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform re . sub with the patterns in the given dict Args : dict_ : { pattern : repl } source : str<CODESPLIT>def substitute ( dict_ , source ) : d_esc = ( re . escape ( k ) for k in dict_ . keys ( ) ) pattern = re . compile ( '|' . join ( d_esc ) ) return pattern . sub ( lambda x : dict_ [ x . group ( ) ] , source )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sum reduction op .<CODESPLIT>def Sum ( a , axis , keep_dims ) : return np . sum ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method performs an I2C write at a given I2C address : param command : { method : i2c_write_request params : [ I2C_DEVICE_ADDRESS [ DATA_TO_WRITE ]] } : returns : No return message .<CODESPLIT>async def i2c_write_request ( self , command ) : device_address = int ( command [ 0 ] ) params = command [ 1 ] params = [ int ( i ) for i in params ] await self . core . i2c_write_request ( device_address , params )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset view to the root of the tree<CODESPLIT>def OnRootView ( self , event ) : self . adapter , tree , rows = self . RootNode ( ) self . squareMap . SetModel ( tree , self . adapter ) self . RecordHistory ( ) self . ConfigureViewTypeChoices ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Slow conversion of a recarray into a list of records with python types .<CODESPLIT>def irecarray_to_py ( a ) : pytypes = [ pyify ( typestr ) for name , typestr in a . dtype . descr ] def convert_record ( r ) : return tuple ( [ converter ( value ) for converter , value in zip ( pytypes , r ) ] ) return ( convert_record ( r ) for r in a )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a password is valid<CODESPLIT>def is_password_valid ( password ) : pattern = re . compile ( r"^.{4,75}$" ) return bool ( pattern . match ( password ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>arr_out = round_array ( array_in )<CODESPLIT>def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )
