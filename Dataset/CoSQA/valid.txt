1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts py2 unicode / py3 bytestring into str Args : string ( unicode byte_string ) : string to be converted Returns : ( str )<CODESPLIT>def ub_to_str ( string ) : if not isinstance ( string , str ) : if six . PY2 : return str ( string ) else : return string . decode ( ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if filename1 and filename2 point to the same file object . There can be false negatives ie . the result is False but it is the same file anyway . Reason is that network filesystems can create different paths to the same physical file .<CODESPLIT>def is_same_file ( filename1 , filename2 ) : if filename1 == filename2 : return True if os . name == 'posix' : return os . path . samefile ( filename1 , filename2 ) return is_same_filename ( filename1 , filename2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Align the position in the file to the next block of specified size<CODESPLIT>def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will make any functions return an iterable objects by wrapping its result in a list .<CODESPLIT>def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7<CODESPLIT>def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets the dimensions depending on python version and os<CODESPLIT>def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The title of this window<CODESPLIT>def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rounds float to closest int : rtype : int : param n : float<CODESPLIT>def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Looks at the files in a git root directory and grabs the last modified timestamp<CODESPLIT>def get_last_modified_timestamp ( self ) : cmd = "find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .<CODESPLIT>def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the querystring from the end of a URL .<CODESPLIT>def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + "://" + p . netloc + p . path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for checking a valid regex .<CODESPLIT>def is_valid_regex ( regex ) : if len ( regex ) == 0 : return False try : re . compile ( regex ) return True except sre_constants . error : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a dict to a JSON file .<CODESPLIT>def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a copy of the list without duplicates .<CODESPLIT>def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert hex string like \ x0A \ xE3 to 2787 .<CODESPLIT>def hex_to_int ( value ) : if version_info . major >= 3 : return int . from_bytes ( value , "big" ) return int ( value . encode ( "hex" ) , 16 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a Bokeh glyph object .<CODESPLIT>def _init_glyph ( self , plot , mapping , properties ) : properties = mpl_to_bokeh ( properties ) plot_method = self . _plot_methods . get ( 'batched' if self . batched else 'single' ) if isinstance ( plot_method , tuple ) : # Handle alternative plot method for flipped axes plot_method = plot_method [ int ( self . invert_axes ) ] renderer = getattr ( plot , plot_method ) ( * * dict ( properties , * * mapping ) ) return renderer , renderer . glyph
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a new instance .<CODESPLIT>def simple_generate ( cls , create , * * kwargs ) : strategy = enums . CREATE_STRATEGY if create else enums . BUILD_STRATEGY return cls . generate ( strategy , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a file is empty or not .<CODESPLIT>def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :<CODESPLIT>def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( "non-list value found where list is expected" ) return all ( isinstance ( x , str ) for x in arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the full singular value matrix of self<CODESPLIT>def full_s ( self ) : x = np . zeros ( ( self . shape ) , dtype = np . float32 ) x [ : self . s . shape [ 0 ] , : self . s . shape [ 0 ] ] = self . s . as_2d s = Matrix ( x = x , row_names = self . row_names , col_names = self . col_names , isdiagonal = False , autoalign = False ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a set of strings .<CODESPLIT>def _split_comma_separated ( string ) : return set ( text . strip ( ) for text in string . split ( ',' ) if text . strip ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to infer an object s dtype for use in arithmetic ops<CODESPLIT>def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructs the covariance matrix from PCA residuals<CODESPLIT>def _covariance_matrix ( self , type = 'noise' ) : if type == 'sampling' : return self . sigma ** 2 / ( self . n - 1 ) elif type == 'noise' : return 4 * self . sigma * N . var ( self . rotated ( ) , axis = 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns OK then waits approximately 1 second and restarts container<CODESPLIT>async def restart ( request ) : def wait_and_restart ( ) : log . info ( 'Restarting server' ) sleep ( 1 ) os . system ( 'kill 1' ) Thread ( target = wait_and_restart ) . start ( ) return web . json_response ( { "message" : "restarting" } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .<CODESPLIT>def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Horizontally flip the given PIL Image .<CODESPLIT>def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get unit vector for a given one .<CODESPLIT>def normalized ( vector ) : length = numpy . sum ( vector * vector , axis = - 1 ) length = numpy . sqrt ( length . reshape ( length . shape + ( 1 , ) ) ) return vector / length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerce value to an JSON - compatible representation .<CODESPLIT>def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( "ascii" ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>simple method to determine if a url is relative or absolute<CODESPLIT>def is_relative_url ( url ) : if url . startswith ( "#" ) : return None if url . find ( "://" ) > 0 or url . startswith ( "//" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns index tuple in histogram of bin which contains value<CODESPLIT>def get_bin_indices ( self , values ) : return tuple ( [ self . get_axis_bin_index ( values [ ax_i ] , ax_i ) for ax_i in range ( self . dimensions ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to MySQL with retries .<CODESPLIT>def connect_mysql ( host , port , user , password , database ) : return pymysql . connect ( host = host , port = port , user = user , passwd = password , db = database )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to snake case .<CODESPLIT>def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find and kill child processes of a process .<CODESPLIT>def kill_process_children ( pid ) : if sys . platform == "darwin" : kill_process_children_osx ( pid ) elif sys . platform == "linux" : kill_process_children_unix ( pid ) else : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>similar to blockshaped but splits an array into n0 * n1 blocks<CODESPLIT>def into2dBlocks ( arr , n0 , n1 ) : s0 , s1 = arr . shape b = blockshaped ( arr , s0 // n0 , s1 // n1 ) return b . reshape ( n0 , n1 , * b . shape [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>is_valid_image_extension .<CODESPLIT>def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initiates a graceful stop of the processes<CODESPLIT>def stop ( self , timeout = None ) : self . stopping = True for process in list ( self . processes ) : self . stop_process ( process , timeout = timeout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the list of distinct values with preserving order .<CODESPLIT>def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Looks at the files in a git root directory and grabs the last modified timestamp<CODESPLIT>def get_last_modified_timestamp ( self ) : cmd = "find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if an element from a list is in a string .<CODESPLIT>def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute boxplot for given pandas Series .<CODESPLIT>def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = "|" . join ( map ( str , stats [ 'fliers' ] ) ) return stats
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>MoveWindow from Win32 . handle : int the handle of a native window . x : int . y : int . width : int . height : int . repaint : int use 1 or 0 . Return bool True if succeed otherwise False .<CODESPLIT>def MoveWindow ( handle : int , x : int , y : int , width : int , height : int , repaint : int = 1 ) -> bool : return bool ( ctypes . windll . user32 . MoveWindow ( ctypes . c_void_p ( handle ) , x , y , width , height , repaint ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the mean value across a list of dictionaries<CODESPLIT>def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If given environment key is defined print it out .<CODESPLIT>def print_env_info ( key , out = sys . stderr ) : value = os . getenv ( key ) if value is not None : print ( key , "=" , repr ( value ) , file = out )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare two nodes for equality .<CODESPLIT>def _eq ( self , other ) : return ( self . type , self . value ) == ( other . type , other . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get trace_id from flask request headers .<CODESPLIT>def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( "/" , 1 ) [ 0 ] return trace_id
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>React to a docstring event and append contracts to it .<CODESPLIT>def process_docstring ( app , what , name , obj , options , lines ) : # pylint: disable=unused-argument # pylint: disable=too-many-arguments lines . extend ( _format_contracts ( what = what , obj = obj ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the exectuable bit on the given filename<CODESPLIT>def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates and returns a month number basing on PESEL standard .<CODESPLIT>def calculate_month ( birth_date ) : year = int ( birth_date . strftime ( '%Y' ) ) month = int ( birth_date . strftime ( '%m' ) ) + ( ( int ( year / 100 ) - 14 ) % 5 ) * 20 return month
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if string could be a valid python identifier<CODESPLIT>def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A generator of n - length chunks of an input iterable<CODESPLIT>def split_every ( iterable , n ) : # TODO: Remove this, or make it return a generator. i = iter ( iterable ) piece = list ( islice ( i , n ) ) while piece : yield piece piece = list ( islice ( i , n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to allow getting the arguments for a single command for Sphinx documentation<CODESPLIT>def doc_parser ( ) : parser = argparse . ArgumentParser ( prog = 'ambry' , description = 'Ambry {}. Management interface for ambry, libraries ' 'and repositories. ' . format ( ambry . _meta . __version__ ) ) return parser
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if given value is a list tries to convert if it is not .<CODESPLIT>def to_list ( var ) : if var is None : return [ ] if isinstance ( var , str ) : var = var . split ( '\n' ) elif not isinstance ( var , list ) : try : var = list ( var ) except TypeError : raise ValueError ( "{} cannot be converted to the list." . format ( var ) ) return var
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7<CODESPLIT>def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current mouse location ( coordinates and screen number ) .<CODESPLIT>def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .<CODESPLIT>def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dictionary of words and word counts in a string .<CODESPLIT>def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function for loading yaml - encoded data from disk .<CODESPLIT>def load_yaml ( filepath ) : with open ( filepath ) as f : txt = f . read ( ) return yaml . load ( txt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the table * name * exists in the database .<CODESPLIT>def has_table ( self , name ) : return len ( self . sql ( "SELECT name FROM sqlite_master WHERE type='table' AND name=?" , parameters = ( name , ) , asrecarray = False , cache = False ) ) > 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets<CODESPLIT>def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the request payload size<CODESPLIT>def calculate_size ( name , max_size ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += INT_SIZE_IN_BYTES return data_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list with no repeated elements .<CODESPLIT>def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as : meth : random . choice but also supports : class : set type to be passed as sequence .<CODESPLIT>def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get a set of keys from redis<CODESPLIT>def get ( self , key ) : res = self . connection . get ( key ) print ( res ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP response for not - authorized access ( status code 403 )<CODESPLIT>def HttpResponse401 ( request , template = KEY_AUTH_401_TEMPLATE , content = KEY_AUTH_401_CONTENT , content_type = KEY_AUTH_401_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 401 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the local ip of this device<CODESPLIT>def _get_local_ip ( ) : return set ( [ x [ 4 ] [ 0 ] for x in socket . getaddrinfo ( socket . gethostname ( ) , 80 , socket . AF_INET ) ] ) . pop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts SoftLayer . CLI . formatting . Table instance to a prettytable .<CODESPLIT>def format_prettytable ( table ) : for i , row in enumerate ( table . rows ) : for j , item in enumerate ( row ) : table . rows [ i ] [ j ] = format_output ( item ) ptable = table . prettytable ( ) ptable . hrules = prettytable . FRAME ptable . horizontal_char = '.' ptable . vertical_char = ':' ptable . junction_char = ':' return ptable
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>writes the line and count newlines after the line<CODESPLIT>def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>!<CODESPLIT>def timedcall ( executable_function , * args ) : time_start = time . clock ( ) result = executable_function ( * args ) time_end = time . clock ( ) return ( time_end - time_start , result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decompress a Plan 9 image file . Assumes f is already cued past the initial compressed \ n string .<CODESPLIT>def decompress ( f ) : r = meta ( f . read ( 60 ) ) return r , decomprest ( f , r [ 4 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>main entry point for the jardiff CLI<CODESPLIT>def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Jacobian matrix given Christophe s suggestion of f<CODESPLIT>def jac ( x , a ) : return ( x - a ) / np . sqrt ( ( ( x - a ) ** 2 ) . sum ( 1 ) ) [ : , np . newaxis ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the md5 hash of the given file - object<CODESPLIT>def md5_hash_file ( fh ) : md5 = hashlib . md5 ( ) while True : data = fh . read ( 8192 ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Construction from a string raise a TypeError if not possible<CODESPLIT>def construct_from_string ( cls , string ) : if string == cls . name : return cls ( ) raise TypeError ( "Cannot construct a '{}' from " "'{}'" . format ( cls , string ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a name which includes the module name and function name .<CODESPLIT>def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls the specified Trigger of another Area with the optionally given parameters .<CODESPLIT>def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal helper to clone self . _properties if necessary .<CODESPLIT>def _clone_properties ( self ) : cls = self . __class__ if self . _properties is cls . _properties : self . _properties = dict ( cls . _properties )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find a number using a given regular expression . If the string cannot be found returns None . The regex should contain one matching group as only the result of the first group is returned . The group should only contain numeric characters ( [ 0 - 9 ] + ) . s - The string to search . regex - A string containing the regular expression . Returns an integer or None .<CODESPLIT>def find_number ( regex , s ) : result = find_string ( regex , s ) if result is None : return None return int ( result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper parse action to convert tokens to upper case .<CODESPLIT>def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A background thread to kill the process if it takes too long .<CODESPLIT>def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( "Killing program due to %f second timeout" % timeout ) os . _exit ( 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses many YAML documents into a list of Python objects .<CODESPLIT>def ParseMany ( text ) : precondition . AssertType ( text , Text ) if compatibility . PY2 : text = text . encode ( "utf-8" ) return list ( yaml . safe_load_all ( text ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Heuristic check if an object is a namedtuple .<CODESPLIT>def isnamedtuple ( obj ) : return isinstance ( obj , tuple ) and hasattr ( obj , "_fields" ) and hasattr ( obj , "_asdict" ) and callable ( obj . _asdict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The parsed cookies attached to this request .<CODESPLIT>def cookies ( self ) -> Dict [ str , str ] : cookies = SimpleCookie ( ) cookies . load ( self . headers . get ( 'Cookie' , '' ) ) return { key : cookie . value for key , cookie in cookies . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Union of masks .<CODESPLIT>def _join_masks_from_masked_array ( data ) : if not isinstance ( data . mask , np . ndarray ) : # workaround to handle mask compressed to single value mask = np . empty ( data . data . shape , dtype = np . bool ) mask . fill ( data . mask ) return mask mask = data . mask [ 0 ] . copy ( ) for i in range ( 1 , len ( data . mask ) ) : mask = np . logical_or ( mask , data . mask [ i ] ) return mask [ np . newaxis , : , : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log - normal function from scipy<CODESPLIT>def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shut down a specific process .<CODESPLIT>def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set foreground - and background colors and intensity .<CODESPLIT>def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reshape data into ( num_example batch_size )<CODESPLIT>def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sample a colormap from matplotlib<CODESPLIT>def sample_colormap ( cmap_name , n_samples ) : colors = [ ] colormap = cm . cmap_d [ cmap_name ] for i in np . linspace ( 0 , 1 , n_samples ) : colors . append ( colormap ( i ) ) return colors
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .<CODESPLIT>def input_int_default ( question = "" , default = 0 ) : answer = input_string ( question ) if answer == "" or answer == "yes" : return default else : return int ( answer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Argument class constructor should be used inside a class that inherits the BaseAction class .<CODESPLIT>def __init__ ( self , name , flag , * * kwargs ) : self . name = name self . flag = flag self . options = kwargs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>\ kills the child and exits<CODESPLIT>def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method that escapes parameters to a SQL query .<CODESPLIT>def _escape ( s ) : e = s e = e . replace ( '\\' , '\\\\' ) e = e . replace ( '\n' , '\\n' ) e = e . replace ( '\r' , '\\r' ) e = e . replace ( "'" , "\\'" ) e = e . replace ( '"' , '\\"' ) return e
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This wraps a function that would normally only accept an array and allows it to operate on a DataFrame . Useful for applying numpy functions to DataFrames .<CODESPLIT>def ts_func ( f ) : def wrap_func ( df , * args ) : # TODO: should vectorize to apply over all columns? return Chromatogram ( f ( df . values , * args ) , df . index , df . columns ) return wrap_func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a DataTable instance built from either the filename or STDIN if filename is None .<CODESPLIT>def get_data_table ( filename ) : with get_file_object ( filename , "r" ) as rf : return DataTable ( list ( csv . reader ( rf ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Binary operator .<CODESPLIT>def on_binop ( self , node ) : # ('left', 'op', 'right') return op2func ( node . op ) ( self . run ( node . left ) , self . run ( node . right ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempt to guess the title from the filename<CODESPLIT>def guess_title ( basename ) : base , _ = os . path . splitext ( basename ) return re . sub ( r'[ _-]+' , r' ' , base ) . title ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return system CPU times as a namedtuple .<CODESPLIT>def get_system_cpu_times ( ) : user , nice , system , idle = _psutil_osx . get_system_cpu_times ( ) return _cputimes_ntuple ( user , nice , system , idle )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function used internally to format string data for output to XML . Escapes back - slashes and quotes and wraps the resulting string in quotes .<CODESPLIT>def string_format_func ( s ) : return u"\"%s\"" % unicode ( s ) . replace ( u"\\" , u"\\\\" ) . replace ( u"\"" , u"\\\"" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Frees all resources .<CODESPLIT>def __del__ ( self ) : if hasattr ( self , '_Api' ) : self . _Api . close ( ) self . _Logger . info ( 'object destroyed' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set additionnal options as plain text .<CODESPLIT>def set_axis_options ( self , row , column , text ) : subplot = self . get_subplot_at ( row , column ) subplot . set_axis_options ( text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>strips any namespaces from an xml string<CODESPLIT>def _strip_namespace ( self , xml ) : p = re . compile ( b"xmlns=*[\"\"][^\"\"]*[\"\"]" ) allmatches = p . finditer ( xml ) for match in allmatches : xml = xml . replace ( match . group ( ) , b"" ) return xml
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP PUT operation to API endpoint .<CODESPLIT>def put ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'PUT' , endpoint , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A magic method to implement shallow copy behavior .<CODESPLIT>def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns some subset of the features . Parameters ---------- indices : : obj : list of : obj : int indices of the features in the list<CODESPLIT>def feature_subset ( self , indices ) : if isinstance ( indices , np . ndarray ) : indices = indices . tolist ( ) if not isinstance ( indices , list ) : raise ValueError ( 'Can only index with lists' ) return [ self . features_ [ i ] for i in indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rewrite a file adding a line to its beginning .<CODESPLIT>def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compatibility wrapper for the loop . create_task () call introduced in 3 . 4 . 2 .<CODESPLIT>def create_task ( coro , loop ) : # pragma: no cover if hasattr ( loop , 'create_task' ) : return loop . create_task ( coro ) return asyncio . Task ( coro , loop = loop )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random color between min and max .<CODESPLIT>def random_color ( _min = MIN_COLOR , _max = MAX_COLOR ) : return color ( random . randint ( _min , _max ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to camel_case<CODESPLIT>def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator for JSON - per - line in a file pattern<CODESPLIT>def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a block of data and parse using the given protobuf object .<CODESPLIT>def read_proto_object ( fobj , klass ) : log . debug ( '%s chunk' , klass . __name__ ) obj = klass ( ) obj . ParseFromString ( read_block ( fobj ) ) log . debug ( 'Header: %s' , str ( obj ) ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether all number in the sequence s lie inside the interval formed by l and r .<CODESPLIT>def are_in_interval ( s , l , r , border = 'included' ) : return numpy . all ( [ IntensityRangeStandardization . is_in_interval ( x , l , r , border ) for x in s ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for plotting .<CODESPLIT>def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>numpy . ndarray dumper .<CODESPLIT>def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { "$" + class_name : self . _json_convert ( obj . tolist ( ) ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List all RDS thingys .<CODESPLIT>def list_rds ( region , filter_by_kwargs ) : conn = boto . rds . connect_to_region ( region ) instances = conn . get_all_dbinstances ( ) return lookup ( instances , filter_by = filter_by_kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads a pushdb maintained in a properties file at the given path .<CODESPLIT>def load ( path ) : with open ( path , 'r' ) as props : properties = Properties . load ( props ) return PushDb ( properties )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Concatenate two InferenceData objects .<CODESPLIT>def __add__ ( self , other ) : return concat ( self , other , copy = True , inplace = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like dict but does not hold any null values .<CODESPLIT>def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the union of two RangeSets as a new RangeSet .<CODESPLIT>def __or__ ( self , other ) : if not isinstance ( other , set ) : return NotImplemented return self . union ( other )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print n_top values from a LDA model s topic - word distributions .<CODESPLIT>def print_ldamodel_topic_words ( topic_word_distrib , vocab , n_top = 10 , row_labels = DEFAULT_TOPIC_NAME_FMT ) : print_ldamodel_distribution ( topic_word_distrib , row_labels = row_labels , val_labels = vocab , top_n = n_top )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG<CODESPLIT>def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns seconds since 0h00 .<CODESPLIT>def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logarithmic loss with non - necessarily - binary labels .<CODESPLIT>def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 )<CODESPLIT>def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the local variables in the caller s frame .<CODESPLIT>def caller_locals ( ) : import inspect frame = inspect . currentframe ( ) try : return frame . f_back . f_back . f_locals finally : del frame
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the files with the commas removed .<CODESPLIT>def readCommaList ( fileList ) : names = fileList . split ( ',' ) fileList = [ ] for item in names : fileList . append ( item ) return fileList
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the location of the static data directory .<CODESPLIT>def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , "static" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalizes list<CODESPLIT>def normalize_array ( lst ) : np_arr = np . array ( lst ) x_normalized = np_arr / np_arr . max ( axis = 0 ) return list ( x_normalized )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Call f n times with args and kwargs . Useful e . g . for simplistic timing .<CODESPLIT>def nTimes ( n , f , * args , * * kwargs ) : for i in xrange ( n ) : f ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a dict to an encoded URL . Example : given data = { a : 1 b : 2 } it returns a = 1&b = 2<CODESPLIT>def get_dict_to_encoded_url ( data ) : unicode_data = dict ( [ ( k , smart_str ( v ) ) for k , v in data . items ( ) ] ) encoded = urllib . urlencode ( unicode_data ) return encoded
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>will plot a stack of traces one above the other assuming marray . shape = numRows numSamples<CODESPLIT>def stackplot ( marray , seconds = None , start_time = None , ylabels = None ) : tarray = np . transpose ( marray ) stackplot_t ( tarray , seconds = seconds , start_time = start_time , ylabels = ylabels ) plt . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - optimal implementation of a regex filter<CODESPLIT>def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a file safely . If it s not present no - op .<CODESPLIT>def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new : class : DataFrame containing rows only in both this frame and another frame .<CODESPLIT>def intersect ( self , other ) : return DataFrame ( self . _jdf . intersect ( other . _jdf ) , self . sql_ctx )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Temporarily replace sys . argv with current arguments<CODESPLIT>def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a string with comma or space - separated elements into a list .<CODESPLIT>def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate if non empty string<CODESPLIT>def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns uptime in seconds or None on Syllable .<CODESPLIT>def _uptime_syllable ( ) : global __boottime try : __boottime = os . stat ( '/dev/pty/mst/pty0' ) . st_mtime return time . time ( ) - __boottime except ( NameError , OSError ) : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs an asynchronous function without needing to use await - useful for lambda<CODESPLIT>def runcoro ( async_function ) : future = _asyncio . run_coroutine_threadsafe ( async_function , client . loop ) result = future . result ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns numpy array of natural logarithms of values .<CODESPLIT>def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( "ignore" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method for setting the value of an openpyxl cell<CODESPLIT>def set_cell_value ( cell , value ) : if OPENPYXL_MAJOR_VERSION > 1 : cell . value = value else : cell . internal_value = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like map but also chains the results .<CODESPLIT>def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use openpyxl to read an Excel file .<CODESPLIT>def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal helper to return the values of a dictionary sorted by key .<CODESPLIT>def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .<CODESPLIT>def energy_string_to_float ( string ) : energy_re = re . compile ( "(-?\d+\.\d+)" ) return float ( energy_re . match ( string ) . group ( 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate standard deviation weighted by errors<CODESPLIT>def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the first value in each row .<CODESPLIT>def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Value of property .<CODESPLIT>def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill an array from a list<CODESPLIT>def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( for multiline edit ) . Move cursor to the previous line .<CODESPLIT>def cursor_up ( self , count = 1 ) : original_column = self . preferred_column or self . document . cursor_position_col self . cursor_position += self . document . get_cursor_up_position ( count = count , preferred_column = original_column ) # Remember the original column for the next up/down movement. self . preferred_column = original_column
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create 2D rotation matrix<CODESPLIT>def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the given name is used as a variadic argument .<CODESPLIT>def _is_name_used_as_variadic ( name , variadics ) : return any ( variadic . value == name or variadic . value . parent_of ( name ) for variadic in variadics )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute a minimal rectangle that covers all the points .<CODESPLIT>def get_bound ( pts ) : ( x0 , y0 , x1 , y1 ) = ( INF , INF , - INF , - INF ) for ( x , y ) in pts : x0 = min ( x0 , x ) y0 = min ( y0 , y ) x1 = max ( x1 , x ) y1 = max ( y1 , y ) return ( x0 , y0 , x1 , y1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .<CODESPLIT>def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets up the python include paths to include src<CODESPLIT>def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , "src" ) ] + sys . path pass return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print the values of all this object s Parameters .<CODESPLIT>def print_param_values ( self_ ) : self = self_ . self for name , val in self . param . get_param_values ( ) : print ( '%s.%s = %s' % ( self . name , name , val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes // - comments and single - line C - style / * * / comments .<CODESPLIT>def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sort a list of files by filename only ignoring the directory names<CODESPLIT>def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize a KeyValuePair object from a json dictionary .<CODESPLIT>def _from_dict ( cls , _dict ) : args = { } if 'key' in _dict : args [ 'key' ] = Key . _from_dict ( _dict . get ( 'key' ) ) if 'value' in _dict : args [ 'value' ] = Value . _from_dict ( _dict . get ( 'value' ) ) return cls ( * * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gaussian noise corruption to images .<CODESPLIT>def gaussian_noise ( x , severity = 1 ) : c = [ .08 , .12 , 0.18 , 0.26 , 0.38 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( x + np . random . normal ( size = x . shape , scale = c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>main entry point for the jardiff CLI<CODESPLIT>def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add two 3 dimensional vectors . http : // naif . jpl . nasa . gov / pub / naif / toolkit_docs / C / cspice / vadd_c . html<CODESPLIT>def vadd ( v1 , v2 ) : v1 = stypes . toDoubleVector ( v1 ) v2 = stypes . toDoubleVector ( v2 ) vout = stypes . emptyDoubleVector ( 3 ) libspice . vadd_c ( v1 , v2 , vout ) return stypes . cVectorToPython ( vout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return grandparent s path string<CODESPLIT>def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .<CODESPLIT>def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return "\n" . join ( centered )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn a list into a comma - and / or and - separated string .<CODESPLIT>def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7<CODESPLIT>def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get a set of keys from redis<CODESPLIT>def get ( self , key ) : res = self . connection . get ( key ) print ( res ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a datetime . timedelta object return the delta in milliseconds<CODESPLIT>def datetime_delta_to_ms ( delta ) : delta_ms = delta . days * 24 * 60 * 60 * 1000 delta_ms += delta . seconds * 1000 delta_ms += delta . microseconds / 1000 delta_ms = int ( delta_ms ) return delta_ms
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the text for the given root node ( xml . dom . minidom ) .<CODESPLIT>def __get_xml_text ( root ) : txt = "" for e in root . childNodes : if ( e . nodeType == e . TEXT_NODE ) : txt += e . data return txt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits a string into parts at multiple characters<CODESPLIT>def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shape a list of lists into the appropriate shape and data type<CODESPLIT>def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value<CODESPLIT>def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes JSON formatted data converting it into native Python objects<CODESPLIT>def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts list to string with comma separated values . For string is no - op .<CODESPLIT>def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = "," . join ( value ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the default stream encoding if not found .<CODESPLIT>def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return u if u! = 0 return 1 if u == 0<CODESPLIT>def not0 ( a ) : return matrix ( list ( map ( lambda x : 1 if x == 0 else x , a ) ) , a . size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print at most limit elements of list .<CODESPLIT>def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ "'%s'" % str ( i ) for i in lst ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show revision list<CODESPLIT>def show ( config ) : with open ( config , 'r' ) : main . show ( yaml . load ( open ( config ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method for setting the value of an openpyxl cell<CODESPLIT>def set_cell_value ( cell , value ) : if OPENPYXL_MAJOR_VERSION > 1 : cell . value = value else : cell . internal_value = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list consisting of the cumulative sum of the items in the passed list .<CODESPLIT>def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the longest path in a dag between two nodes<CODESPLIT>def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempts to convert given object to a string object<CODESPLIT>def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the longest path in a dag between two nodes<CODESPLIT>def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shorcut for self . run .<CODESPLIT>def __call__ ( self , func , * args , * * kwargs ) : return self . run ( func , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .<CODESPLIT>def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .<CODESPLIT>def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return file name ( s ) from Tkinter s file open dialog .<CODESPLIT>def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Install or upgrade setuptools and EasyInstall<CODESPLIT>def main ( argv , version = DEFAULT_VERSION ) : tarball = download_setuptools ( ) _install ( tarball , _build_install_args ( argv ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will make any functions return an iterable objects by wrapping its result in a list .<CODESPLIT>def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to make map () behave the same on Py2 and Py3 .<CODESPLIT>def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disable event loop integration with wxPython .<CODESPLIT>def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the parent node of node whch is located in tree s node list .<CODESPLIT>def _get_node_parent ( self , age , pos ) : return self . nodes [ age ] [ int ( pos / self . comp ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fit a Gaussian to the data<CODESPLIT>def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper on iter method callback gets an iterator result<CODESPLIT>def find_all ( self , string , callback ) : for index , output in self . iter ( string ) : callback ( index , output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simplest required implementation of collections . Counter . Required as 2 . 6 does not have Counter in collections .<CODESPLIT>def counter ( items ) : results = { } for item in items : results [ item ] = results . get ( item , 0 ) + 1 return results
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last weekday in a given month . e . g :<CODESPLIT>def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>!<CODESPLIT>def timedcall ( executable_function , * args ) : time_start = time . clock ( ) result = executable_function ( * args ) time_end = time . clock ( ) return ( time_end - time_start , result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes l2 norm of params by flattening them into a vector .<CODESPLIT>def l2_norm ( params ) : flattened , _ = flatten ( params ) return np . dot ( flattened , flattened )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return flattened dictionary from MultiDict .<CODESPLIT>def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>numpy . ndarray dumper .<CODESPLIT>def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { "$" + class_name : self . _json_convert ( obj . tolist ( ) ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy a file whole from input to output .<CODESPLIT>def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove key from dict and return value .<CODESPLIT>def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port .<CODESPLIT>def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .<CODESPLIT>def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read helper method<CODESPLIT>def read_from_file ( file_path , encoding = "utf-8" ) : with codecs . open ( file_path , "r" , encoding ) as f : return f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if all of the elements in the list are equal .<CODESPLIT>def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , "Input value must be a list." return not lst or lst . count ( lst [ 0 ] ) == len ( lst )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .<CODESPLIT>def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .<CODESPLIT>def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the passed variable is a tuple with two floats or integers<CODESPLIT>def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a string with comma or space - separated elements into a list .<CODESPLIT>def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restores the state of the batched queue for writing .<CODESPLIT>def enable_writes ( self ) : self . write_buffer = [ ] self . flush_lock = threading . RLock ( ) self . flush_thread = FlushThread ( self . max_batch_time , self . _flush_writes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into a list of tokens .<CODESPLIT>def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \t' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize an API .<CODESPLIT>def initialize_api ( flask_app ) : if not flask_restplus : return api = flask_restplus . Api ( version = "1.0" , title = "My Example API" ) api . add_resource ( HelloWorld , "/hello" ) blueprint = flask . Blueprint ( "api" , __name__ , url_prefix = "/api" ) api . init_app ( blueprint ) flask_app . register_blueprint ( blueprint )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called to implement the built - in function complex () .<CODESPLIT>def __complex__ ( self ) : if self . _t != 99 or self . key != [ 're' , 'im' ] : return complex ( float ( self ) ) return complex ( float ( self . re ) , float ( self . im ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load the state from the given file moving to the file s directory during load ( temporarily moving back after loaded )<CODESPLIT>def load ( filename ) : path , name = os . path . split ( filename ) path = path or '.' with util . indir ( path ) : return pickle . load ( open ( name , 'rb' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If values in a series match a specified value change them to np . nan .<CODESPLIT>def na_if ( series , * values ) : series = pd . Series ( series ) series [ series . isin ( values ) ] = np . nan return series
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Acquire the : attr : lock asynchronously<CODESPLIT>async def acquire_async ( self ) : r = self . acquire ( blocking = False ) while not r : await asyncio . sleep ( .01 ) r = self . acquire ( blocking = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of days since January 1 of the given year .<CODESPLIT>def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>consider the distance between two mapPoints ignoring all terrain pathing issues<CODESPLIT>def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper parse action to convert tokens to upper case .<CODESPLIT>def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill file at<CODESPLIT>def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether any of the strings contains any of the candidates .<CODESPLIT>def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a 2D numpy array of bools<CODESPLIT>def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used when the plot method defined does not create a figure nor calls save_plot Then the plot method has to use self . fig<CODESPLIT>def plot_and_save ( self , * * kwargs ) : self . fig = pyplot . figure ( ) self . plot ( ) self . axes = pyplot . gca ( ) self . save_plot ( self . fig , self . axes , * * kwargs ) pyplot . close ( self . fig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to infer an object s dtype for use in arithmetic ops<CODESPLIT>def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses box coordinates to crop an image without resizing it first .<CODESPLIT>def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Natural log of scipy norm function truncated at zero<CODESPLIT>def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add executable permissions to a file .<CODESPLIT>def _MakeExecutable ( self , metadata_script ) : mode = os . stat ( metadata_script ) . st_mode os . chmod ( metadata_script , mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If output is string then print the string and also time used<CODESPLIT>def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve a User object by ID .<CODESPLIT>def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1<CODESPLIT>def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The main machinery of the Pipe calling the chosen callable with the recorded arguments .<CODESPLIT>def __ror__ ( self , other ) : return self . callable ( * ( self . args + ( other , ) ) , * * self . kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read text from stdin and print a helpful message for ttys .<CODESPLIT>def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string into list of strings by specified number .<CODESPLIT>def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hook into Gunicorn to display message after launching .<CODESPLIT>def post_worker_init ( worker ) : quit_command = 'CTRL-BREAK' if sys . platform == 'win32' else 'CONTROL-C' sys . stdout . write ( "Django version {djangover}, Gunicorn version {gunicornver}, " "using settings {settings!r}\n" "Starting development server at {urls}\n" "Quit the server with {quit_command}.\n" . format ( djangover = django . get_version ( ) , gunicornver = gunicorn . __version__ , settings = os . environ . get ( 'DJANGO_SETTINGS_MODULE' ) , urls = ', ' . join ( 'http://{0}/' . format ( b ) for b in worker . cfg . bind ) , quit_command = quit_command , ) , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a Python object into a pretty - printed representation .<CODESPLIT>def pformat ( object , indent = 1 , width = 80 , depth = None ) : return PrettyPrinter ( indent = indent , width = width , depth = depth ) . pformat ( object )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if an array is a square matrix .<CODESPLIT>def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as : meth : random . choice but also supports : class : set type to be passed as sequence .<CODESPLIT>def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to snake case .<CODESPLIT>def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return indices of inputs to the node with the given index .<CODESPLIT>def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Step over the next statement<CODESPLIT>def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this an integer .<CODESPLIT>def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the title of the console window .<CODESPLIT>def title ( msg ) : if sys . platform . startswith ( "win" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure an object is JSON - serializable Use this to return errors and other info that does not need to be deserialized or does not contain important app data . Best for returning error info and such<CODESPLIT>def Serializable ( o ) : if isinstance ( o , ( str , dict , int ) ) : return o else : try : json . dumps ( o ) return o except Exception : LOG . debug ( "Got a non-serilizeable object: %s" % o ) return o . __repr__ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update () extends rather than replaces existing key lists .<CODESPLIT>def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn an SQLAlchemy model into a dict of field names and values .<CODESPLIT>def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns path to packaged static files<CODESPLIT>def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Heuristic check if an object is a namedtuple .<CODESPLIT>def isnamedtuple ( obj ) : return isinstance ( obj , tuple ) and hasattr ( obj , "_fields" ) and hasattr ( obj , "_asdict" ) and callable ( obj . _asdict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a file from an AWS S3 bucket .<CODESPLIT>def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Max reduction op .<CODESPLIT>def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if the argument is a string representing a valid hexadecimal digit .<CODESPLIT>def ishex ( obj ) : return isinstance ( obj , str ) and ( len ( obj ) == 1 ) and ( obj in string . hexdigits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quit signal handler .<CODESPLIT>def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( "\nSIGINT in frame signal received. Quitting..." ) sys . stdout . flush ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterable - first replacement of Python s built - in map () function .<CODESPLIT>def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decide if the Ipython command line is running code .<CODESPLIT>def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , "function" , None ) == pkg_resources . load_entry_point ( "ipython" , "console_scripts" , "ipython" ) . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .<CODESPLIT>def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the absolute uri for a file<CODESPLIT>def __absolute__ ( self , uri ) : return op . abspath ( op . join ( self . __path__ , uri ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if a list is sorted<CODESPLIT>def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mono - exponential curve .<CODESPLIT>def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does this filename match any of the patterns?<CODESPLIT>def file_matches ( filename , patterns ) : return any ( fnmatch . fnmatch ( filename , pat ) for pat in patterns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip a section<CODESPLIT>def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230<CODESPLIT>def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if value is an integer .<CODESPLIT>def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a grayscale image to BGR image .<CODESPLIT>def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether a system service is available<CODESPLIT>def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extracts the session data from cookie .<CODESPLIT>def _get_data ( self ) : cookie = self . adapter . cookies . get ( self . name ) return self . _deserialize ( cookie ) if cookie else { }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if string could be a valid python identifier<CODESPLIT>def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the number of leaves in a tree<CODESPLIT>def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to snake case .<CODESPLIT>def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Idempotent and None - safe version of strict_bool .<CODESPLIT>def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear all indexes in the es core<CODESPLIT>def clear_es ( ) : # TODO: should receive a catalog slug. ESHypermap . es . indices . delete ( ESHypermap . index_name , ignore = [ 400 , 404 ] ) LOGGER . debug ( 'Elasticsearch: Index cleared' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assert that text has n errors of type check .<CODESPLIT>def assert_error ( text , check , n = 1 ) : assert_error . description = "No {} error for '{}'" . format ( check , text ) assert ( check in [ error [ 0 ] for error in lint ( text ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a dict of 1d array to a numpy recarray<CODESPLIT>def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts vtkImageData to a vtkTexture<CODESPLIT>def image_to_texture ( image ) : vtex = vtk . vtkTexture ( ) vtex . SetInputDataObject ( image ) vtex . Update ( ) return vtex
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of the earliest occurence of an item from a list in a string<CODESPLIT>def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform actions before parent main window is closed<CODESPLIT>def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - negative integer .<CODESPLIT>def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the directed graph g has a cycle . The directed graph should be represented as a dictionary mapping of edges for each node .<CODESPLIT>def is_cyclic ( graph ) : path = set ( ) def visit ( vertex ) : path . add ( vertex ) for neighbour in graph . get ( vertex , ( ) ) : if neighbour in path or visit ( neighbour ) : return True path . remove ( vertex ) return False return any ( visit ( v ) for v in graph )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert datetime to epoch seconds .<CODESPLIT>def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call * func * with kwargs but only those kwargs that it accepts .<CODESPLIT>def apply_kwargs ( func , * * kwargs ) : new_kwargs = { } params = signature ( func ) . parameters for param_name in params . keys ( ) : if param_name in kwargs : new_kwargs [ param_name ] = kwargs [ param_name ] return func ( * * new_kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the next value in the page .<CODESPLIT>def next ( self ) : item = six . next ( self . _item_iter ) result = self . _item_to_value ( self . _parent , item ) # Since we've successfully got the next value from the # iterator, we update the number of remaining. self . _remaining -= 1 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the a new dict with underscores instead of hyphens in keys .<CODESPLIT>def dict_keys_without_hyphens ( a_dict ) : return dict ( ( key . replace ( '-' , '_' ) , val ) for key , val in a_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to get return code of a url<CODESPLIT>def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send the cmd info and collected stdout to logger .<CODESPLIT>def dump_to_log ( self , logger ) : logger . error ( "Execution ended in %s for cmd %s" , self . _retcode , self . _cmd ) for line in self . _collected_stdout : logger . error ( STDOUT_LOG_PREFIX + line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .<CODESPLIT>def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Die on SIGTERM or SIGINT<CODESPLIT>def set_terminate_listeners ( stream ) : def stop ( signum , frame ) : terminate ( stream . listener ) # Installs signal handlers for handling SIGINT and SIGTERM # gracefully. signal . signal ( signal . SIGINT , stop ) signal . signal ( signal . SIGTERM , stop )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a column to a FITS file .<CODESPLIT>def add_column ( filename , column , formula , force = False ) : columns = parse_formula ( formula ) logger . info ( "Running file: %s" % filename ) logger . debug ( "  Reading columns: %s" % columns ) data = fitsio . read ( filename , columns = columns ) logger . debug ( '  Evaluating formula: %s' % formula ) col = eval ( formula ) col = np . asarray ( col , dtype = [ ( column , col . dtype ) ] ) insert_columns ( filename , col , force = force ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Repeat each item in iterable n times .<CODESPLIT>def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Centre and normalize a given array .<CODESPLIT>def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to remove all comments from a file and save it if changes were made .<CODESPLIT>def example_write_file_to_disk_if_changed ( ) : my_file = FileAsObj ( '/tmp/example_file.txt' ) my_file . rm ( my_file . egrep ( '^#' ) ) if my_file . changed : my_file . save ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take the union of a list of lists .<CODESPLIT>def listunion ( ListOfLists ) : u = [ ] for s in ListOfLists : if s != None : u . extend ( s ) return u
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pre - order depth - first<CODESPLIT>def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a prettier version of obj<CODESPLIT>def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleanup generated document artifacts .<CODESPLIT>def clean ( ctx , dry_run = False ) : basedir = ctx . sphinx . destdir or "build/docs" cleanup_dirs ( [ basedir ] , dry_run = dry_run )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test whether a stream can be written to .<CODESPLIT>def writable_stream ( handle ) : if isinstance ( handle , io . IOBase ) and sys . version_info >= ( 3 , 5 ) : return handle . writable ( ) try : handle . write ( b'' ) except ( io . UnsupportedOperation , IOError ) : return False else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the estimated standard error of the mean ( sx - bar ) of the values in the passed list . sem = stdev / sqrt ( n )<CODESPLIT>def lsem ( inlist ) : sd = stdev ( inlist ) n = len ( inlist ) return sd / math . sqrt ( n )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a value wrap it in a 0 - D numpy . ndarray .<CODESPLIT>def to_0d_array ( value : Any ) -> np . ndarray : if np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and value . ndim == 0 ) : return np . array ( value ) else : return to_0d_object_array ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Code due to Thomas Heller - published in Python Cookbook ( O Reilley )<CODESPLIT>def debug_on_error ( type , value , tb ) : traceback . print_exc ( type , value , tb ) print ( ) pdb . pm ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return view of the recarray with all int32 cast to int64 .<CODESPLIT>def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .<CODESPLIT>def seq_to_str ( obj , sep = "," ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for running binary search on a sorted list .<CODESPLIT>def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get longitudes from cartesian coordinates .<CODESPLIT>def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether a system service is available<CODESPLIT>def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set y limits for plot .<CODESPLIT>def set_ylim ( self , xlims , dx , xscale , reverse = False ) : self . _set_axis_limits ( 'y' , xlims , dx , xscale , reverse ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flush all items from cache .<CODESPLIT>def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse val into a positive integer .<CODESPLIT>def positive_int ( val ) : if isinstance ( val , float ) : raise ValueError ( '"{}" must not be a float' . format ( val ) ) val = int ( val ) if val >= 0 : return val raise ValueError ( '"{}" must be positive' . format ( val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Private method for setting axis limits .<CODESPLIT>def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get from a list with an optional default value .<CODESPLIT>def list_get ( l , idx , default = None ) : try : if l [ idx ] : return l [ idx ] else : return default except IndexError : return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cache the first return value of a function for all subsequent calls .<CODESPLIT>def lazy_property ( function ) : cached_val = [ ] def _wrapper ( * args ) : try : return cached_val [ 0 ] except IndexError : ret_val = function ( * args ) cached_val . append ( ret_val ) return ret_val return _wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Opens the file and reads the value<CODESPLIT>def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Warn if nans exist in a numpy array .<CODESPLIT>def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs the function asynchronously taking care of exceptions .<CODESPLIT>def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DFS detect connected component recursive implementation<CODESPLIT>def dfs_recursive ( graph , node , seen ) : seen [ node ] = True for neighbor in graph [ node ] : if not seen [ neighbor ] : dfs_recursive ( graph , neighbor , seen )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a normal old python function to return the Nth fibonacci number .<CODESPLIT>def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle linear / log scale for Y - axis .<CODESPLIT>def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace regex with string .<CODESPLIT>def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the user is rooted .<CODESPLIT>def _is_root ( ) : import os import ctypes try : return os . geteuid ( ) == 0 except AttributeError : return ctypes . windll . shell32 . IsUserAnAdmin ( ) != 0 return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a json array as a list<CODESPLIT>def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert input argument to bytes<CODESPLIT>def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make bars in horizontal bar chart thinner<CODESPLIT>def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a type attribute statically circumventing the descriptor protocol .<CODESPLIT>def static_get_type_attr ( t , name ) : for type_ in t . mro ( ) : try : return vars ( type_ ) [ name ] except KeyError : pass raise AttributeError ( name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks to see if list is equal everywhere<CODESPLIT>def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reduces a multiline string to a single line of text .<CODESPLIT>def reduce_multiline ( string ) : string = str ( string ) return " " . join ( [ item . strip ( ) for item in string . split ( "\n" ) if item . strip ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wraps the given string with terminal color codes .<CODESPLIT>def highlight ( text : str , color_code : int , bold : bool = False ) -> str : return '{}\033[{}m{}\033[0m' . format ( '\033[1m' if bold else '' , color_code , text , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emulate what a Python set () does but keeping the element s order .<CODESPLIT>def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a dict to a querystring suitable to be appended to a URL .<CODESPLIT>def dict_to_querystring ( dictionary ) : s = u"" for d in dictionary . keys ( ) : s = unicode . format ( u"{0}{1}={2}&" , s , d , dictionary [ d ] ) return s [ : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for inserting int64 features into Example proto .<CODESPLIT>def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>htmlify string<CODESPLIT>def safe_quotes ( text , escape_single_quotes = False ) : if isinstance ( text , str ) : safe_text = text . replace ( '"' , "&quot;" ) if escape_single_quotes : safe_text = safe_text . replace ( "'" , "&#92;'" ) return safe_text . replace ( 'True' , 'true' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a datetime to a millisecond accuracy timestamp<CODESPLIT>def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleanup temporary directory .<CODESPLIT>def _cleanup ( path : str ) -> None : if os . path . isdir ( path ) : shutil . rmtree ( path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the console .<CODESPLIT>def clear ( ) : if sys . platform . startswith ( "win" ) : call ( "cls" , shell = True ) else : call ( "clear" , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save object as json on CNS .<CODESPLIT>def save_json ( object , handle , indent = 2 ) : obj_json = json . dumps ( object , indent = indent , cls = NumpyJSONEncoder ) handle . write ( obj_json )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get single system variable from CCU / Homegear<CODESPLIT>def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Correct the timezone information on the given datetime<CODESPLIT>def normalize ( self , dt , is_dst = False ) : if dt . tzinfo is self : return dt if dt . tzinfo is None : raise ValueError ( 'Naive time - no tzinfo set' ) return dt . astimezone ( self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string with terminal colors .<CODESPLIT>def stringc ( text , color ) : if has_colors : text = str ( text ) return "\033[" + codeCodes [ color ] + "m" + text + "\033[0m" else : return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Concatenates blocks into a block diagonal matrix .<CODESPLIT>def block_diag ( * blocks : np . ndarray ) -> np . ndarray : for b in blocks : if b . shape [ 0 ] != b . shape [ 1 ] : raise ValueError ( 'Blocks must be square.' ) if not blocks : return np . zeros ( ( 0 , 0 ) , dtype = np . complex128 ) n = sum ( b . shape [ 0 ] for b in blocks ) dtype = functools . reduce ( _merge_dtypes , ( b . dtype for b in blocks ) ) result = np . zeros ( shape = ( n , n ) , dtype = dtype ) i = 0 for b in blocks : j = i + b . shape [ 0 ] result [ i : j , i : j ] = b i = j return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds a chart to the worksheet at ( row col ) .<CODESPLIT>def add_chart ( self , chart , row , col ) : self . __charts . append ( ( chart , ( row , col ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses numpy . load to open the underlying file<CODESPLIT>def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a nested list and returns the size of each dimension followed by the element type in the list<CODESPLIT>def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the given colored string to standard out .<CODESPLIT>def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return view of the recarray with all int32 cast to int64 .<CODESPLIT>def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normal cumulative density function .<CODESPLIT>def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moved out to make testing easier .<CODESPLIT>def _request ( self , data ) : return requests . post ( self . endpoint , data = data . encode ( "ascii" ) ) . content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a json array as a list<CODESPLIT>def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes average length of words<CODESPLIT>def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the first sunday of a month .<CODESPLIT>def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback for comboboxes : notifies us that a combobox for the given item and column has changed<CODESPLIT>def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the circular permutation for a given list of items .<CODESPLIT>def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator which adds correct MIME type for python source to the decorated bottle API function .<CODESPLIT>def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = "text/x-python" return fn ( * args , * * kwargs ) return python_mime_decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts to float representing number of seconds since 1970 - 01 - 01 GMT .<CODESPLIT>def dt2ts ( dt ) : # Note: no assertion to really keep this fast  assert isinstance ( dt , ( datetime . datetime , datetime . date ) ) ret = time . mktime ( dt . timetuple ( ) ) if isinstance ( dt , datetime . datetime ) : ret += 1e-6 * dt . microsecond return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like from pairs but combines duplicate key values into arrays : param pairs : : return :<CODESPLIT>def from_pairs_to_array_values ( pairs ) : result = { } for pair in pairs : result [ pair [ 0 ] ] = concat ( prop_or ( [ ] , pair [ 0 ] , result ) , [ pair [ 1 ] ] ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate random string with specified length<CODESPLIT>def gen_random_string ( str_len ) : return '' . join ( random . choice ( string . ascii_letters + string . digits ) for _ in range ( str_len ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal helper to return the values of a dictionary sorted by key .<CODESPLIT>def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if an element from a list is in a string .<CODESPLIT>def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .<CODESPLIT>def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list where the duplicates have been removed .<CODESPLIT>def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request that the Outstation perform a cold restart . Command syntax is : restart<CODESPLIT>def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function returns the summary for a given model<CODESPLIT>def _summarize_object_type ( model ) : # the fields for the service's model model_fields = { field . name : field for field in list ( model . fields ( ) ) } # summarize the model return { 'fields' : [ { 'name' : key , 'type' : type ( convert_peewee_field ( value ) ) . __name__ } for key , value in model_fields . items ( ) ] }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write data with column headers to a CSV .<CODESPLIT>def writeCSV ( data , headers , csvFile ) : with open ( csvFile , "wb" ) as f : writer = csv . writer ( f , delimiter = "," ) writer . writerow ( headers ) writer . writerows ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the angle between vectors a and b in degrees .<CODESPLIT>def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a python string to c array .<CODESPLIT>def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .<CODESPLIT>def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yaml either have automatically converted it to a datetime object or it is a string that will be validated later .<CODESPLIT>def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if cnr or cns files are empty ( only have a header )<CODESPLIT>def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sum the total number of cycles over a list of tokens .<CODESPLIT>def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all the files and subdirectories in a directory .<CODESPLIT>def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read a simple text file from a private location to get username and password<CODESPLIT>def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\n' ) password = f . readline ( ) . strip ( '\n' ) return username , password
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like dict but does not hold any null values .<CODESPLIT>def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the user enter max and min values of where the raster points should appear on the y - axis<CODESPLIT>def values ( self ) : lower = float ( self . lowerSpnbx . value ( ) ) upper = float ( self . upperSpnbx . value ( ) ) return ( lower , upper )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return physical memory usage ( float ) Requires the cross - platform psutil ( > = v0 . 3 ) library ( https : // github . com / giampaolo / psutil )<CODESPLIT>def psutil_phymem_usage ( ) : import psutil # This is needed to avoid a deprecation warning error with  # newer psutil versions  try : percent = psutil . virtual_memory ( ) . percent except : percent = psutil . phymem_usage ( ) . percent return percent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for pymongo . Collection . ensure_index<CODESPLIT>def ensure_index ( self , key , unique = False ) : return self . collection . ensure_index ( key , unique = unique )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback to go to the next tab . Called by the accel key .<CODESPLIT>def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Copy object to the system clipboard .<CODESPLIT>def to_clipboard ( self , excel = True , sep = None , * * kwargs ) : from pandas . io import clipboards clipboards . to_clipboard ( self , excel = excel , sep = sep , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day<CODESPLIT>def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a json array as a list<CODESPLIT>def __as_list ( value : List [ JsonObjTypes ] ) -> List [ JsonTypes ] : return [ e . _as_dict if isinstance ( e , JsonObj ) else e for e in value ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the syntax of the given URL .<CODESPLIT>def url_syntax_check ( url ) : # pragma: no cover if url and isinstance ( url , str ) : # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config ( True ) return Check ( url ) . is_url_valid ( ) # We return None, there is nothing to check. return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of processors on this machine .<CODESPLIT>def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( "SC_NPROCESSORS_CONF" ) except ( AttributeError , ValueError ) : pass gen_log . error ( "Could not detect number of processors; assuming 1" ) return 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indent given text using custom spacing default is set to 4 .<CODESPLIT>def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes a : py : class : . Series from the chart .<CODESPLIT>def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( "Cannot remove last series from %s" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a formatted indented text .<CODESPLIT>def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs a bash script in the local directory<CODESPLIT>def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( "bash {}" . format ( filename ) , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a scalar validator in a list validator<CODESPLIT>def as_list ( callable ) : @ wraps ( callable ) def wrapper ( value_iter ) : return [ callable ( value ) for value in value_iter ] return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DOES NOT WORK WELL WITH MOPIDY Hack from https : // www . daniweb . com / software - development / python / code / 260268 / restart - your - python - program to support updating the settings since mopidy is not able to do that yet Restarts the current program Note : this function does not return . Any cleanup action ( like saving data ) must be done before calling this function<CODESPLIT>def restart_program ( ) : python = sys . executable os . execl ( python , python , * sys . argv )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort the data .<CODESPLIT>def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of dict like objects and uses champ_id field as Id<CODESPLIT>def _from_list_dict ( cls , list_dic ) : return cls ( { _convert_id ( dic [ cls . CHAMP_ID ] ) : dict ( dic ) for dic in list_dic } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal convenience function for deprecation warnings<CODESPLIT>def _depr ( fn , usage , stacklevel = 3 ) : warn ( '{0} is deprecated. Use {1} instead' . format ( fn , usage ) , stacklevel = stacklevel , category = DeprecationWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a lambda code archive for running custodian .<CODESPLIT>def custodian_archive ( packages = None ) : modules = { 'c7n' , 'pkg_resources' } if packages : modules = filter ( None , modules . union ( packages ) ) return PythonPackageArchive ( * sorted ( modules ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression .<CODESPLIT>def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether a system service is available<CODESPLIT>def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a list unique retaining order of initial appearance .<CODESPLIT>def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the shape after scaling ( should be the same as ndimage . zoom<CODESPLIT>def _scale_shape ( dshape , scale = ( 1 , 1 , 1 ) ) : nshape = np . round ( np . array ( dshape ) * np . array ( scale ) ) return tuple ( nshape . astype ( np . int ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pop the head off the iterator and return it .<CODESPLIT>def __next__ ( self ) : res = self . _head self . _fill ( ) if res is None : raise StopIteration ( ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process a matplotlib image object and call renderer . draw_image<CODESPLIT>def draw_image ( self , ax , image ) : self . renderer . draw_image ( imdata = utils . image_to_base64 ( image ) , extent = image . get_extent ( ) , coordinates = "data" , style = { "alpha" : image . get_alpha ( ) , "zorder" : image . get_zorder ( ) } , mplobj = image )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to unpickle data from picklefile .<CODESPLIT>def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a string into a Message object model .<CODESPLIT>def message_from_string ( s , * args , * * kws ) : from future . backports . email . parser import Parser return Parser ( * args , * * kws ) . parsestr ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Explicitly reload context with DB usage to get access to complete DB object .<CODESPLIT>def update ( self , * * kwargs ) : self . reload_context ( es_based = False , * * kwargs ) return super ( ESCollectionView , self ) . update ( * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips spaces : param x : : return :<CODESPLIT>def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\t' , b'' ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a decimal price and rounds to a number of decimal places<CODESPLIT>def price_rounding ( price , decimals = 2 ) : try : exponent = D ( '.' + decimals * '0' ) except InvalidOperation : # Currencies with no decimal places, ex. JPY, HUF exponent = D ( ) return price . quantize ( exponent , rounding = ROUND_UP )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an SArray that contains the last n elements in the SArray .<CODESPLIT>def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>interpret the dtype from a scalar or array . This is a convenience routines to infer dtype from a scalar or an array<CODESPLIT>def infer_dtype_from ( val , pandas_dtype = False ) : if is_scalar ( val ) : return infer_dtype_from_scalar ( val , pandas_dtype = pandas_dtype ) return infer_dtype_from_array ( val , pandas_dtype = pandas_dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove instance from model<CODESPLIT>def remove_instance ( self , item ) : self . instances . remove ( item ) self . remove_item ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove any duplicate entries .<CODESPLIT>def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places all the child widgets in the appropriate positions .<CODESPLIT>def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = "nswe" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = "ns" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Auto - scales the axes to fit all the data in plot index n . If n == None auto - scale everyone .<CODESPLIT>def autozoom ( self , n = None ) : if n == None : for p in self . plot_widgets : p . autoRange ( ) else : self . plot_widgets [ n ] . autoRange ( ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses OLS to fit the regression .<CODESPLIT>def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to check valid options<CODESPLIT>def _check_valid ( key , val , valid ) : if val not in valid : raise ValueError ( '%s must be one of %s, not "%s"' % ( key , valid , val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run verbose PyLint on source . Optionally specify fmt = html for HTML output .<CODESPLIT>def lint ( fmt = 'colorized' ) : if fmt == 'html' : outfile = 'pylint_report.html' local ( 'pylint -f %s davies > %s || true' % ( fmt , outfile ) ) local ( 'open %s' % outfile ) else : local ( 'pylint -f %s davies || true' % fmt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP POST operation to API endpoint .<CODESPLIT>def post ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'POST' , endpoint , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provides hook for Python2 iterator functionality .<CODESPLIT>def next ( self ) : _LOGGER . debug ( "reading next" ) if self . closed : _LOGGER . debug ( "stream is closed" ) raise StopIteration ( ) line = self . readline ( ) if not line : _LOGGER . debug ( "nothing more to read" ) raise StopIteration ( ) return line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print the message to the predefined log file without newline<CODESPLIT>def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create the file with the given content<CODESPLIT>def write_file ( filename , content ) : print 'Generating {0}' . format ( filename ) with open ( filename , 'wb' ) as out_f : out_f . write ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the contents of an object stored in S3 as bytes<CODESPLIT>def get_as_bytes ( self , s3_path ) : ( bucket , key ) = self . _path_to_bucket_and_key ( s3_path ) obj = self . s3 . Object ( bucket , key ) contents = obj . get ( ) [ 'Body' ] . read ( ) return contents
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Official way to get the extension of compiled files ( . pyc or . pyo )<CODESPLIT>def _get_compiled_ext ( ) : for ext , mode , typ in imp . get_suffixes ( ) : if typ == imp . PY_COMPILED : return ext
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a value from a dict which contains just one item .<CODESPLIT>def get_single_value ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . itervalues ( d ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emit a sine wave at the given frequency .<CODESPLIT>def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generator for reading from standard input in nonblocking mode .<CODESPLIT>def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes a ( shell ) command in the background<CODESPLIT>def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a object into dictionary with all of its readable attributes .<CODESPLIT>def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the distance between two points .<CODESPLIT>def dist ( x1 , x2 , axis = 0 ) : return np . linalg . norm ( x2 - x1 , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method removes columns in data<CODESPLIT>def remove_columns ( self , data , columns ) : for column in columns : if column in data . columns : data = data . drop ( column , axis = 1 ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decorator to convert a method taking a iterable to a * args one<CODESPLIT>def _iterable_to_varargs_method ( func ) : def wrapped ( self , * args , * * kwargs ) : return func ( self , args , * * kwargs ) return wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> find_index ( [[ 0 1 2 ] [ 3 4 ] [ 5 6 7 ]] 0 ) 0 >>> find_index ( [[ 0 1 2 ] [ 3 4 ] [ 5 6 7 ]] 1 ) 0 >>> find_index ( [[ 0 1 2 ] [ 3 4 ] [ 5 6 7 ]] 5 ) 2 >>> find_index ( [[ 0 1 2 ] [ 3 4 ] [ 5 6 7 ]] 6 ) 2<CODESPLIT>def find_index ( segmentation , stroke_id ) : for i , symbol in enumerate ( segmentation ) : for sid in symbol : if sid == stroke_id : return i return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get width and height of a PDF<CODESPLIT>def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python<CODESPLIT>def slugify ( string ) : string = re . sub ( '[^\w .-]' , '' , string ) string = string . replace ( " " , "-" ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update inplace widgets position when doing vertical scroll<CODESPLIT>def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be an iterable ( list array tuple )<CODESPLIT>def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shot noise corruption to images .<CODESPLIT>def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string representing a numpy array of 0 s and 1 s<CODESPLIT>def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add an additional response header not removing duplicates .<CODESPLIT>def add_header ( self , name , value ) : self . _headers . setdefault ( _hkey ( name ) , [ ] ) . append ( _hval ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the average color from the list of colors where each color is a 3 - tuple of ( r g b ) values .<CODESPLIT>def get_average_color ( colors ) : c = reduce ( color_reducer , colors ) total = len ( colors ) return tuple ( v / total for v in c )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>verify the validity of the given file . Never trust the End - User<CODESPLIT>def is_valid_file ( parser , arg ) : if not os . path . exists ( arg ) : parser . error ( "File %s not found" % arg ) else : return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper over time module to produce Unix epoch time as a float<CODESPLIT>def to_unix ( cls , timestamp ) : if not isinstance ( timestamp , datetime . datetime ) : raise TypeError ( 'Time.milliseconds expects a datetime object' ) base = time . mktime ( timestamp . timetuple ( ) ) return base
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values<CODESPLIT>def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( "Error getting image size {}" . format ( url ) , exc_info = True ) return w_h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends plain text using _send_text () .<CODESPLIT>async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gaussian model m is [ psill range nugget ]<CODESPLIT>def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close log<CODESPLIT>def close_log ( log , verbose = True ) : if verbose : print ( 'Closing log file:' , log . name ) # Send closing message. log . info ( 'The log file has been closed.' ) # Remove all handlers from log. [ log . removeHandler ( handler ) for handler in log . handlers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Old style use JSONTemplateResponse instead of this .<CODESPLIT>def json_template ( data , template_name , template_context ) : html = render_to_string ( template_name , template_context ) data = data or { } data [ 'html' ] = html return HttpResponse ( json_encode ( data ) , content_type = 'application/json' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks for an empty image .<CODESPLIT>def is_empty ( self ) : if ( ( ( self . channels == [ ] ) and ( not self . shape == ( 0 , 0 ) ) ) or ( ( not self . channels == [ ] ) and ( self . shape == ( 0 , 0 ) ) ) ) : raise RuntimeError ( "Channels-shape mismatch." ) return self . channels == [ ] and self . shape == ( 0 , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for matplotlib imshow<CODESPLIT>def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dot product of two vectors<CODESPLIT>def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Command line interface for PyBEL .<CODESPLIT>def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compress object to bytes .<CODESPLIT>def _compress_obj ( obj , level ) : return zlib . compress ( pickle . dumps ( obj , protocol = 2 ) , level )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transparently unzip the file handle<CODESPLIT>def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sample data from given histogram and min max values within range<CODESPLIT>def inverseHistogram ( hist , bin_range ) : data = hist . astype ( float ) / np . min ( hist [ np . nonzero ( hist ) ] ) new_data = np . empty ( shape = np . sum ( data , dtype = int ) ) i = 0 xvals = np . linspace ( bin_range [ 0 ] , bin_range [ 1 ] , len ( data ) ) for d , x in zip ( data , xvals ) : new_data [ i : i + d ] = x i += int ( d ) return new_data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to lower_and_underscore .<CODESPLIT>def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read and return an entire section<CODESPLIT>def _read_section ( self ) : lines = [ self . _last [ self . _last . find ( ":" ) + 1 : ] ] self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : lines . append ( self . _last ) self . _last = self . _f . readline ( ) return lines
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts an dict to a Enum .<CODESPLIT>def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - optimal implementation of a regex filter<CODESPLIT>def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if val is of integer type .<CODESPLIT>def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return file name ( s ) from Tkinter s file open dialog .<CODESPLIT>def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for fast reading from sensor files .<CODESPLIT>def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space .<CODESPLIT>def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print warning about interrupt and empty the job queue .<CODESPLIT>def finish ( ) : out . warn ( "Interrupted!" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( "Waiting for download threads to finish." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add arrow to plot<CODESPLIT>def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a header request to the endpoint .<CODESPLIT>def fetch_header ( self ) : query = self . query ( ) . add_query_parameter ( req = 'header' ) return self . _parse_messages ( self . get_query ( query ) . content ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Command line interface for PyBEL .<CODESPLIT>def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Imputes data set containing Nan values<CODESPLIT>def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .<CODESPLIT>def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( "to_dataframe requires the optional dependency Pandas." ) return pd . DataFrame . from_dict ( products , orient = 'index' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all child objects in nested lists of strings .<CODESPLIT>def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .<CODESPLIT>def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>!<CODESPLIT>def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse markdown sintaxt to html .<CODESPLIT>def clean_markdown ( text ) : result = text if isinstance ( text , str ) : result = '' . join ( BeautifulSoup ( markdown ( text ) , 'lxml' ) . findAll ( text = True ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate all matches found within a string for a regex and yield each match as a string<CODESPLIT>def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates a LaTeX table from parameter summaries .<CODESPLIT>def get_latex_table ( self , parameters = None , transpose = False , caption = None , label = "tab:model_params" , hlines = True , blank_fill = "--" ) : # pragma: no cover if parameters is None : parameters = self . parent . _all_parameters for p in parameters : assert isinstance ( p , str ) , "Generating a LaTeX table requires all parameters have labels" num_parameters = len ( parameters ) num_chains = len ( self . parent . chains ) fit_values = self . get_summary ( squeeze = False ) if label is None : label = "" if caption is None : caption = "" end_text = " \\\\ \n" if transpose : column_text = "c" * ( num_chains + 1 ) else : column_text = "c" * ( num_parameters + 1 ) center_text = "" hline_text = "\\hline\n" if hlines : center_text += hline_text + "\t\t" if transpose : center_text += " & " . join ( [ "Parameter" ] + [ c . name for c in self . parent . chains ] ) + end_text if hlines : center_text += "\t\t" + hline_text for p in parameters : arr = [ "\t\t" + p ] for chain_res in fit_values : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += " & " . join ( arr ) + end_text else : center_text += " & " . join ( [ "Model" ] + parameters ) + end_text if hlines : center_text += "\t\t" + hline_text for name , chain_res in zip ( [ c . name for c in self . parent . chains ] , fit_values ) : arr = [ "\t\t" + name ] for p in parameters : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += " & " . join ( arr ) + end_text if hlines : center_text += "\t\t" + hline_text final_text = get_latex_table_frame ( caption , label ) % ( column_text , center_text ) return final_text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an SArray that contains the last n elements in the SArray .<CODESPLIT>def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a Stripe API timestamp response ( unix epoch ) to a native datetime .<CODESPLIT>def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the re module can compile the given regular expression .<CODESPLIT>def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run Python test cases against Java runtime classes .<CODESPLIT>def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An argparse type representing an email address .<CODESPLIT>def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( "{0} is not a valid email address" . format ( repr ( arg ) ) ) return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of ( key value ) pairs and turns it into a dict .<CODESPLIT>def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of unique items ( similar to set functionality ) .<CODESPLIT>def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the log level from the environment variable .<CODESPLIT>def extract_log_level_from_environment ( k , default ) : return LOG_LEVELS . get ( os . environ . get ( k ) ) or int ( os . environ . get ( k , default ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add global variables to JavaScript about the location and latest version of transpiled files . Usage :: { % static_urls_js % }<CODESPLIT>def static_urls_js ( ) : if apps . is_installed ( 'django.contrib.staticfiles' ) : from django . contrib . staticfiles . storage import staticfiles_storage static_base_url = staticfiles_storage . base_url else : static_base_url = PrefixNode . handle_simple ( "STATIC_URL" ) transpile_base_url = urljoin ( static_base_url , 'js/transpile/' ) return { 'static_base_url' : static_base_url , 'transpile_base_url' : transpile_base_url , 'version' : LAST_RUN [ 'version' ] }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns system clipboard contents .<CODESPLIT>def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Imputes data set containing Nan values<CODESPLIT>def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )<CODESPLIT>def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the approximate size of the queue ( not reliable! ) .<CODESPLIT>def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to get a number out of a string and cast it .<CODESPLIT>def get_number ( s , cast = int ) : import string d = "" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Right replaces count occurrences of old with new in string . For example ::<CODESPLIT>def right_replace ( string , old , new , count = 1 ) : if not string : return string return new . join ( string . rsplit ( old , count ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if arg is a valid file that already exists on the file system .<CODESPLIT>def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( "The file %s does not exist!" % arg ) else : return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip a section<CODESPLIT>def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads and returns a class for a given fully qualified name .<CODESPLIT>def load_member ( fqn ) : modulename , member_name = split_fqn ( fqn ) module = __import__ ( modulename , globals ( ) , locals ( ) , member_name ) return getattr ( module , member_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> sort_key (( name ( ROUTE URL ))) - 3<CODESPLIT>def sort_key ( x ) : name , ( r , u ) = x return - len ( u ) + u . count ( '}' ) * 100
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed<CODESPLIT>def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an int of form yyyymmdd to a python date object .<CODESPLIT>def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a function after a delay unless another function is set in the meantime .<CODESPLIT>def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count number of item in generator .<CODESPLIT>def count_generator ( generator , memory_efficient = True ) : if memory_efficient : counter = 0 for _ in generator : counter += 1 return counter else : return len ( list ( generator ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>SPSS . sav files to Pandas DataFrame through Rpy2<CODESPLIT>def sav_to_pandas_rpy2 ( input_file ) : import pandas . rpy . common as com w = com . robj . r ( 'foreign::read.spss("%s", to.data.frame=TRUE)' % input_file ) return com . convert_robj ( w )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This will equal 124 for the V1 database .<CODESPLIT>def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a byte value to boolean ( 0 or 1 ) if the global flag strictBool is True<CODESPLIT>def convertToBool ( ) : if not OPTIONS . strictBool . value : return [ ] REQUIRES . add ( 'strictbool.asm' ) result = [ ] result . append ( 'pop af' ) result . append ( 'call __NORMALIZE_BOOLEAN' ) result . append ( 'push af' ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort files or folders by modified time<CODESPLIT>def sort_by_modified ( files_or_folders : list ) -> list : return sorted ( files_or_folders , key = os . path . getmtime , reverse = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes a file if it doesn t already exist with the same content .<CODESPLIT>def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( "Not overwriting {} because it is unchanged" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the list of distinct values with preserving order .<CODESPLIT>def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add data to send queue .<CODESPLIT>async def send ( self , data ) : self . writer . write ( data ) await self . writer . drain ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of dimensions of a tensor<CODESPLIT>def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends all messages to logger . [ mthd ] () for handling<CODESPLIT>def setLoggerAll ( self , mthd ) : for key in self . _logger_methods : self . _logger_methods [ key ] = mthd
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the modified time for a file as a datetime instance<CODESPLIT>def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop the resolver threads .<CODESPLIT>def stop ( self ) : with self . lock : for dummy in self . threads : self . queue . put ( None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the largest contig for each strain : param contig_lengths_dict : dictionary of strain name : reverse - sorted list of all contig lengths : return : longest_contig_dict : dictionary of strain name : longest contig<CODESPLIT>def find_largest_contig ( contig_lengths_dict ) : # Initialise the dictionary longest_contig_dict = dict ( ) for file_name , contig_lengths in contig_lengths_dict . items ( ) : # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict [ file_name ] = contig_lengths [ 0 ] return longest_contig_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :<CODESPLIT>def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( "non-list value found where list is expected" ) return all ( isinstance ( x , str ) for x in arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies the sofplus activation function element - wise to the input .<CODESPLIT>def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns uptime in seconds or None on Syllable .<CODESPLIT>def _uptime_syllable ( ) : global __boottime try : __boottime = os . stat ( '/dev/pty/mst/pty0' ) . st_mtime return time . time ( ) - __boottime except ( NameError , OSError ) : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Align the position in the file to the next block of specified size<CODESPLIT>def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>image resize function used by quite a few image problems .<CODESPLIT>def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns nr of first entry parseable to float in ll None otherwise<CODESPLIT>def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a file descriptor from stdin or opening a file from a given path .<CODESPLIT>def file_or_stdin ( ) -> Callable : def parse ( path ) : if path is None or path == "-" : return sys . stdin else : return data_io . smart_open ( path ) return parse
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .<CODESPLIT>def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( "to_dataframe requires the optional dependency Pandas." ) return pd . DataFrame . from_dict ( products , orient = 'index' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a random element from seq n times . If n is None it continues indefinitly<CODESPLIT>def rand_elem ( seq , n = None ) : return map ( random . choice , repeat ( seq , n ) if n is not None else repeat ( seq ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a leading hash # at the beginning of every line in the source .<CODESPLIT>def _add_hash ( source ) : source = '\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build a C ++ binary executable<CODESPLIT>def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get user name provide by operating system<CODESPLIT>def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns a werkzeug . MultiDict or django . MultiValueDict into a dict with list values : param d : a MultiDict or MultiValueDict instance : return : a dict instance<CODESPLIT>def multidict_to_dict ( d ) : return dict ( ( k , v [ 0 ] if len ( v ) == 1 else v ) for k , v in iterlists ( d ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes average length of words<CODESPLIT>def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Just sends the request using its send method and returns its response .<CODESPLIT>def send ( r , stream = False ) : r . send ( stream = stream ) return r . response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interpolate linearly variable x in rangeX onto rangeY .<CODESPLIT>def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This should only be used for testing . The primary mode of operation is as an imported library .<CODESPLIT>def main ( pargs ) : input_file = sys . argv [ 1 ] fp = ParseFileLineByLine ( input_file ) for i in fp : print ( i )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructs a numpy - compatible polygon from a page representation .<CODESPLIT>def polygon_from_points ( points ) : polygon = [ ] for pair in points . split ( " " ) : x_y = pair . split ( "," ) polygon . append ( [ float ( x_y [ 0 ] ) , float ( x_y [ 1 ] ) ] ) return polygon
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenient interface to the ecstasy package .<CODESPLIT>def beautify ( string , * args , * * kwargs ) : parser = Parser ( args , kwargs ) return parser . beautify ( string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function called everytime a new file is modified .<CODESPLIT>def on_modified ( self , event ) : self . _logger . debug ( 'Detected modify event on watched path: %s' , event . src_path ) self . _process_event ( event )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert iterable object into numpy array<CODESPLIT>def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assert that a value must be a given type .<CODESPLIT>def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join helper<CODESPLIT>def _join ( verb ) : data = pd . merge ( verb . x , verb . y , * * verb . kwargs ) # Preserve x groups if isinstance ( verb . x , GroupedDataFrame ) : data . plydata_groups = list ( verb . x . plydata_groups ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string with punctuation removed .<CODESPLIT>def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\w' , r'\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a 1D list to a single long string for file output using the string . join function .<CODESPLIT>def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find longest ORF from the given list of ORFs .<CODESPLIT>def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function flatten given nested list . Argument : nested list Returns : flat list<CODESPLIT>def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the screen clear color<CODESPLIT>def set_clear_color ( self , color = 'black' , alpha = None ) : self . glir . command ( 'FUNC' , 'glClearColor' , * Color ( color , alpha ) . rgba )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check code coverage quickly with the default Python<CODESPLIT>def coverage ( ) : run ( "coverage run --source {PROJECT_NAME} -m py.test" . format ( PROJECT_NAME = PROJECT_NAME ) ) run ( "coverage report -m" ) run ( "coverage html" ) webbrowser . open ( 'file://' + os . path . realpath ( "htmlcov/index.html" ) , new = 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a graphviz graph from text<CODESPLIT>def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a datetime . timedelta object return the delta in milliseconds<CODESPLIT>def datetime_delta_to_ms ( delta ) : delta_ms = delta . days * 24 * 60 * 60 * 1000 delta_ms += delta . seconds * 1000 delta_ms += delta . microseconds / 1000 delta_ms = int ( delta_ms ) return delta_ms
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be a float<CODESPLIT>def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a datetime object to a multiple of a timedelta dt : datetime . datetime object default now .<CODESPLIT>def __round_time ( self , dt ) : round_to = self . _resolution . total_seconds ( ) seconds = ( dt - dt . min ) . seconds rounding = ( seconds + round_to / 2 ) // round_to * round_to return dt + timedelta ( 0 , rounding - seconds , - dt . microsecond )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to make map () behave the same on Py2 and Py3 .<CODESPLIT>def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Acquire a lock on the output file prevents collisions between multiple runs .<CODESPLIT>def __enter__ ( self ) : self . fd = open ( self . filename , 'a' ) fcntl . lockf ( self . fd , fcntl . LOCK_EX ) return self . fd
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Asynchronously run the worker does not close connections . Useful when testing .<CODESPLIT>async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the filename exists under the path .<CODESPLIT>def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a dictionary from a URL params<CODESPLIT>def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finish up a session .<CODESPLIT>def destroy ( self ) : if self . session_type == 'bash' : # TODO: does this work/handle already being logged out/logged in deep OK? self . logout ( ) elif self . session_type == 'vagrant' : # TODO: does this work/handle already being logged out/logged in deep OK? self . logout ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>zfill ( x width ) - > string<CODESPLIT>def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Has a 50 / 50 chance of calling a function<CODESPLIT>def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .<CODESPLIT>def yaml_to_param ( obj , name ) : return from_pyvalue ( u"yaml:%s" % name , unicode ( yaml . dump ( obj ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add up a list of freq counts to get the total counts .<CODESPLIT>def reduce_freqs ( freqlist ) : allfreqs = np . zeros_like ( freqlist [ 0 ] ) for f in freqlist : allfreqs += f return allfreqs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute a minimal rectangle that covers all the points .<CODESPLIT>def get_bound ( pts ) : ( x0 , y0 , x1 , y1 ) = ( INF , INF , - INF , - INF ) for ( x , y ) in pts : x0 = min ( x0 , x ) y0 = min ( y0 , y ) x1 = max ( x1 , x ) y1 = max ( y1 , y ) return ( x0 , y0 , x1 , y1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a remote api method but don t raise if an error occurred .<CODESPLIT>def safe_call ( cls , method , * args ) : return cls . call ( method , * args , safe = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>last row or column of square A<CODESPLIT>def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to lowercase and strip spaces<CODESPLIT>def lowstrip ( term ) : term = re . sub ( '\s+' , ' ' , term ) term = term . lower ( ) return term
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns index tuple in histogram of bin which contains value<CODESPLIT>def get_bin_indices ( self , values ) : return tuple ( [ self . get_axis_bin_index ( values [ ax_i ] , ax_i ) for ax_i in range ( self . dimensions ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if unicode string only contains ASCII characters .<CODESPLIT>def unicode_is_ascii ( u_string ) : assert isinstance ( u_string , str ) try : u_string . encode ( 'ascii' ) return True except UnicodeEncodeError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hacked run function which installs the trace .<CODESPLIT>def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the value of a float property .<CODESPLIT>def get_property_as_float ( self , name : str ) -> float : return float ( self . __instrument . get_property ( name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds execute permission to file . : param filename : : return :<CODESPLIT>def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a virtual concatenate of several NumPy arrays .<CODESPLIT>def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert iterable object into numpy array<CODESPLIT>def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to a list with sanitization .<CODESPLIT>def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the first sunday of a month .<CODESPLIT>def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpickles the classifier used<CODESPLIT>def load ( self , filename = 'classifier.dump' ) : ifile = open ( filename , 'r+' ) self . classifier = pickle . load ( ifile ) ifile . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run application tests<CODESPLIT>def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a function to map from rows with the structure of the headers to the structure of the table .<CODESPLIT>def make_table_map ( table , headers ) : header_parts = { } for i , h in enumerate ( headers ) : header_parts [ h ] = 'row[{}]' . format ( i ) body_code = 'lambda row: [{}]' . format ( ',' . join ( header_parts . get ( c . name , 'None' ) for c in table . columns ) ) header_code = 'lambda row: [{}]' . format ( ',' . join ( header_parts . get ( c . name , "'{}'" . format ( c . name ) ) for c in table . columns ) ) return eval ( header_code ) , eval ( body_code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string containing the type and text of the exception .<CODESPLIT>def format_exception ( e ) : from . utils . printing import fill return '\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print the given item and all children items<CODESPLIT>def print_item_with_children ( ac , classes , level ) : print_row ( ac . id , ac . name , f"{ac.allocation:,.2f}" , level ) print_children_recursively ( classes , ac , level + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gaussian model m is [ psill range nugget ]<CODESPLIT>def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - optimal implementation of a regex filter<CODESPLIT>def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert string to int or float .<CODESPLIT>def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit on system end of file character<CODESPLIT>def do_EOF ( self , args ) : if _debug : ConsoleCmd . _debug ( "do_EOF %r" , args ) return self . do_exit ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get a list and return a string with comma separated list values Examples [ to ta ] will return to ta .<CODESPLIT>def _return_comma_list ( self , l ) : if isinstance ( l , ( text_type , int ) ) : return l if not isinstance ( l , list ) : raise TypeError ( l , ' should be a list of integers, \ not {0}' . format ( type ( l ) ) ) str_ids = ',' . join ( str ( i ) for i in l ) return str_ids
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find and kill child processes of a process .<CODESPLIT>def kill_process_children ( pid ) : if sys . platform == "darwin" : kill_process_children_osx ( pid ) elif sys . platform == "linux" : kill_process_children_unix ( pid ) else : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the angle between vector x and y<CODESPLIT>def angle_between_vectors ( x , y ) : dp = dot_product ( x , y ) if dp == 0 : return 0 xm = magnitude ( x ) ym = magnitude ( y ) return math . acos ( dp / ( xm * ym ) ) * ( 180. / math . pi )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit the shell session .<CODESPLIT>def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterable - first replacement of Python s built - in map () function .<CODESPLIT>def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the help text ( signature + docstring ) for a command ( function ) .<CODESPLIT>def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\x08' , '' , help_text ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Directly reads text data from url<CODESPLIT>def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete index entirely ( removes all documents and mapping ) .<CODESPLIT>def delete_index ( index ) : logger . info ( "Deleting search index: '%s'" , index ) client = get_client ( ) return client . indices . delete ( index = index )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dump bel specification dictionary using YAML<CODESPLIT>def _dump_spec ( spec ) : with open ( "spec.yaml" , "w" ) as f : yaml . dump ( spec , f , Dumper = MyDumper , default_flow_style = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decision Tree<CODESPLIT>def human__decision_tree ( ) : # build data N = 1000000 M = 3 X = np . zeros ( ( N , M ) ) X . shape y = np . zeros ( N ) X [ 0 , 0 ] = 1 y [ 0 ] = 8 X [ 1 , 1 ] = 1 y [ 1 ] = 8 X [ 2 , 0 : 2 ] = 1 y [ 2 ] = 4 # fit model xor_model = sklearn . tree . DecisionTreeRegressor ( max_depth = 2 ) xor_model . fit ( X , y ) return xor_model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the argument is a readable file - like object .<CODESPLIT>def _is_readable ( self , obj ) : try : read = getattr ( obj , 'read' ) except AttributeError : return False else : return is_method ( read , max_arity = 1 )
