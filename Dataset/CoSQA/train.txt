1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns day number of the last day of the month : param t : datetime : return : int<CODESPLIT>def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a base static url always ending with a /<CODESPLIT>def get_static_url ( ) : path = getattr ( settings , 'STATIC_URL' , None ) if not path : path = getattr ( settings , 'MEDIA_URL' , None ) if not path : path = '/' return path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a virtual concatenate of several NumPy arrays .<CODESPLIT>def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a file exists and is non - empty .<CODESPLIT>def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the file exif<CODESPLIT>def information ( filename ) : check_if_this_file_exist ( filename ) filename = os . path . abspath ( filename ) result = get_json ( filename ) result = result [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the MachineGuid from HKEY_LOCAL_MACHINE \ Software \ Microsoft \ Cryptography \ MachineGuid<CODESPLIT>def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r"Software\Microsoft\Cryptography" ) try : return winreg . QueryValueEx ( key , "MachineGuid" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return array - like containing only true / non - NaN values possibly empty .<CODESPLIT>def remove_na_arraylike ( arr ) : if is_extension_array_dtype ( arr ) : return arr [ notna ( arr ) ] else : return arr [ notna ( lib . values_from_object ( arr ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds an object to the collection based on klass and key .<CODESPLIT>def addClassKey ( self , klass , key , obj ) : d = self . _getClass ( klass ) d [ key ] = obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds first file in path whose filename matches pattern ( via : func : fnmatch . fnmatch ) or raises : exc : IndexError .<CODESPLIT>def find_first ( pattern : str , path : str ) -> str : try : return find ( pattern , path ) [ 0 ] except IndexError : log . critical ( '''Couldn't find "{}" in "{}"''' , pattern , path ) raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>for a list of samples return the value of a global option<CODESPLIT>def get_in_samples ( samples , fn ) : for sample in samples : sample = to_single_data ( sample ) if fn ( sample , None ) : return fn ( sample ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeros in the list of integers and returns a new list of integers<CODESPLIT>def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield one date per day from starting date to ending date .<CODESPLIT>def daterange ( start_date , end_date ) : for n in range ( int ( ( end_date - start_date ) . days ) ) : yield start_date + timedelta ( n )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list where the duplicates have been removed .<CODESPLIT>def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a boolean index with True if the value is masked .<CODESPLIT>def maskIndex ( self ) : if isinstance ( self . mask , bool ) : return np . full ( self . data . shape , self . mask , dtype = np . bool ) else : return self . mask
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether the given value is a byte or unicode string .<CODESPLIT>def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a number from its unit 1px - > ( q px ) Args : value ( str ) : input returns : tuple<CODESPLIT>def split_unit ( value ) : r = re . search ( '^(\-?[\d\.]+)(.*)$' , str ( value ) ) return r . groups ( ) if r else ( '' , '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of active CPUs on a Darwin system .<CODESPLIT>def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def table_exists ( cursor , tablename , schema = 'public' ) : query = """     SELECT EXISTS (         SELECT 1         FROM information_schema.tables         WHERE table_schema = %s         AND table_name = %s     )""" cursor . execute ( query , ( schema , tablename ) ) res = cursor . fetchone ( ) [ 0 ] return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return BGR image read by opencv<CODESPLIT>def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The current position of the cursor .<CODESPLIT>def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends tzinfo and assumes UTC if datetime object has no tzinfo already .<CODESPLIT>def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split s by sep unless it s inside a quote .<CODESPLIT>def split_on ( s , sep = " " ) : pattern = '''((?:[^%s"']|"[^"]*"|'[^']*')+)''' % sep return [ _strip_speechmarks ( t ) for t in re . split ( pattern , s ) [ 1 : : 2 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a file and close it . Returns the file source .<CODESPLIT>def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Softsign op .<CODESPLIT>def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shorthand for returning a URL for the requested static file .<CODESPLIT>def static_url ( path , absolute = False ) : if os . sep != '/' : path = '/' . join ( path . split ( os . sep ) ) return flask . url_for ( 'static' , filename = path , _external = absolute )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterate chunks of size chunk_size from a file - like object<CODESPLIT>def iterate_chunks ( file , chunk_size ) : chunk = file . read ( chunk_size ) while chunk : yield chunk chunk = file . read ( chunk_size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return n size lists from a given list l<CODESPLIT>def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - negative integer .<CODESPLIT>def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a byte sized value .<CODESPLIT>def fmt_sz ( intval ) : try : return fmt . human_size ( intval ) except ( ValueError , TypeError ) : return "N/A" . rjust ( len ( fmt . human_size ( 0 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print escape codes to set the terminal color .<CODESPLIT>def colorize ( txt , fg = None , bg = None ) : setting = '' setting += _SET_FG . format ( fg ) if fg else '' setting += _SET_BG . format ( bg ) if bg else '' return setting + str ( txt ) + _STYLE_RESET
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Under UNIX : is a keystroke available?<CODESPLIT>def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns given method name .<CODESPLIT>def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( "__" ) and not name . endswith ( "__" ) : name = "_{0}{1}" . format ( get_object_name ( method . im_class ) , name ) return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given two data points [ X Y ] linearly interpolate those at x .<CODESPLIT>def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Evaluates a piece of Javascript in the context of the current page and returns its value .<CODESPLIT>def eval_script ( self , expr ) : ret = self . conn . issue_command ( "Evaluate" , expr ) return json . loads ( "[%s]" % ret ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all rows from a cursor as a dict .<CODESPLIT>def _dictfetchall ( self , cursor ) : columns = [ col [ 0 ] for col in cursor . description ] return [ dict ( zip ( columns , row ) ) for row in cursor . fetchall ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim a PIL image and remove white space .<CODESPLIT>def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of rows in a particular table .<CODESPLIT>def count_rows ( self , table , cols = '*' ) : query = 'SELECT COUNT({0}) FROM {1}' . format ( join_cols ( cols ) , wrap ( table ) ) result = self . fetch ( query ) return result if result is not None else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the ( name value ) pairs of the enum .<CODESPLIT>def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Time execution of function . Returns ( res seconds ) .<CODESPLIT>def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Selectively log an accepted request .<CODESPLIT>def log_request ( self , code = '-' , size = '-' ) : if self . server . logRequests : BaseHTTPServer . BaseHTTPRequestHandler . log_request ( self , code , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type one that inherits from : class : Numeric such as : class : Float : class : Decimal ?<CODESPLIT>def is_sqlatype_numeric ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Numeric )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return manhattan distance between two lists of numbers .<CODESPLIT>def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provides the color corresponding to value x in the form of a tuple ( R G B A ) with int values between 0 and 255 .<CODESPLIT>def rgba_bytes_tuple ( self , x ) : return tuple ( int ( u * 255.9999 ) for u in self . rgba_floats_tuple ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .<CODESPLIT>def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .<CODESPLIT>def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def process_instance ( self , instance ) : self . log . debug ( "e = mc^2" ) self . log . info ( "About to fail.." ) self . log . warning ( "Failing.. soooon.." ) self . log . critical ( "Ok, you're done." ) assert False , """ValidateFailureMock was destined to fail..  Here's some extended information about what went wrong.  It has quite the long string associated with it, including a few newlines and a list.  - Item 1 - Item 2  """
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like map but also chains the results .<CODESPLIT>def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>From a list of intervals extract a list of sorted gaps in the form of [ ( g i ) ] where g is the size of the ith gap .<CODESPLIT>def _gaps_from ( intervals ) : sliding_window = zip ( intervals , intervals [ 1 : ] ) gaps = [ b [ 0 ] - a [ 1 ] for a , b in sliding_window ] return gaps
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether this is a complex floating point type .<CODESPLIT>def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a dictionary mapping aliases to their respective name . import_alias_names is used in module_definitions . py and visit_Call<CODESPLIT>def retrieve_import_alias_mapping ( names_list ) : import_alias_names = dict ( ) for alias in names_list : if alias . asname : import_alias_names [ alias . asname ] = alias . name return import_alias_names
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Minifies the input javascript files to the output file .<CODESPLIT>def minify_js ( input_files , output_file ) : from . modules import minify , utils if not isinstance ( input_files , ( list , tuple ) ) : raise RuntimeError ( 'JS minifier takes a list of input files.' ) return { 'dependencies_fn' : utils . no_dependencies , 'compiler_fn' : minify . minify_js , 'input' : input_files , 'output' : output_file , 'kwargs' : { } , }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the first location in our array that is not empty<CODESPLIT>def find_start_point ( self ) : for i , row in enumerate ( self . data ) : for j , _ in enumerate ( row ) : if self . data [ i , j ] != 0 : # or not np.isfinite(self.data[i,j]): return i , j
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .<CODESPLIT>def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the topmost parent of the current category .<CODESPLIT>def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round the number to the specified number of significant figures<CODESPLIT>def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializes a numpy array to a compressed base64 string<CODESPLIT>def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quit signal handler .<CODESPLIT>def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( "\nSIGINT in frame signal received. Quitting..." ) sys . stdout . flush ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes a file if it doesn t already exist with the same content .<CODESPLIT>def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( "Not overwriting {} because it is unchanged" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raise the elements of an asynchronous sequence to the given power .<CODESPLIT>async def power ( source , exponent ) : async with streamcontext ( source ) as streamer : async for item in streamer : yield item ** exponent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if n is a prime number<CODESPLIT>def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return unit sphere coordinates from window coordinates .<CODESPLIT>def arcball_map_to_sphere ( point , center , radius ) : v0 = ( point [ 0 ] - center [ 0 ] ) / radius v1 = ( center [ 1 ] - point [ 1 ] ) / radius n = v0 * v0 + v1 * v1 if n > 1.0 : # position outside of sphere n = math . sqrt ( n ) return numpy . array ( [ v0 / n , v1 / n , 0.0 ] ) else : return numpy . array ( [ v0 , v1 , math . sqrt ( 1.0 - n ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of literal values .<CODESPLIT>def INIT_LIST_EXPR ( self , cursor ) : values = [ self . parse_cursor ( child ) for child in list ( cursor . get_children ( ) ) ] return values
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the default matplotlib ticks .<CODESPLIT>def clear_matplotlib_ticks ( self , axis = "both" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>As a convenience turn Python lists and tuples into NumPy arrays .<CODESPLIT>def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets<CODESPLIT>def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Expire a specific object from cache .<CODESPLIT>def ExpireObject ( self , key ) : node = self . _hash . pop ( key , None ) if node : self . _age . Unlink ( node ) self . KillObject ( node . data ) return node . data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns a werkzeug . MultiDict or django . MultiValueDict into a dict with list values : param d : a MultiDict or MultiValueDict instance : return : a dict instance<CODESPLIT>def multidict_to_dict ( d ) : return dict ( ( k , v [ 0 ] if len ( v ) == 1 else v ) for k , v in iterlists ( d ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>splits iterables a in equal parts of size sz<CODESPLIT>def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the output shape from an array .<CODESPLIT>def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips spaces : param x : : return :<CODESPLIT>def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\t' , b'' ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>initializes 3D plot<CODESPLIT>def plot3d_init ( fignum ) : from mpl_toolkits . mplot3d import Axes3D fig = plt . figure ( fignum ) ax = fig . add_subplot ( 111 , projection = '3d' ) return ax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a slug for each Work already in the DB .<CODESPLIT>def set_slug ( apps , schema_editor , class_name ) : Cls = apps . get_model ( 'spectator_events' , class_name ) for obj in Cls . objects . all ( ) : obj . slug = generate_slug ( obj . pk ) obj . save ( update_fields = [ 'slug' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a datetime object of a given timestamp ( in local tz ) .<CODESPLIT>def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if we have a compatible fill_value and arr dtype then fill<CODESPLIT>def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a repr () for a list / tuple<CODESPLIT>def _tuple_repr ( data ) : if len ( data ) == 1 : return "(%s,)" % rpr ( data [ 0 ] ) else : return "(%s)" % ", " . join ( [ rpr ( x ) for x in data ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method asserts that only one value of the provided list is True .<CODESPLIT>def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download an HTML page using the requests session and return the final URL after following redirects .<CODESPLIT>def get_page_and_url ( session , url ) : reply = get_reply ( session , url ) return reply . text , reply . url
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gaussian pdf . : param x : free variable . : param mu : mean of the distribution . : param sig : standard deviation of the distribution . : return : sympy . Expr for a Gaussian pdf .<CODESPLIT>def Gaussian ( x , mu , sig ) : return sympy . exp ( - ( x - mu ) ** 2 / ( 2 * sig ** 2 ) ) / sympy . sqrt ( 2 * sympy . pi * sig ** 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>globlookup finds filesystem objects whose relative path matches the given pattern .<CODESPLIT>def globlookup ( pattern , root ) : for subdir , dirnames , filenames in os . walk ( root ) : d = subdir [ len ( root ) + 1 : ] files = ( os . path . join ( d , f ) for f in filenames ) for f in fnmatch . filter ( files , pattern ) : yield f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator to ensure API calls are made and return expected data .<CODESPLIT>def api_test ( method = 'GET' , * * response_kwargs ) : method = method . lower ( ) def api_test_factory ( fn ) : @ functools . wraps ( fn ) @ mock . patch ( 'requests.{}' . format ( method ) ) def execute_test ( method_func , * args , * * kwargs ) : method_func . return_value = MockResponse ( * * response_kwargs ) expected_url , response = fn ( * args , * * kwargs ) method_func . assert_called_once ( ) assert_valid_api_call ( method_func , expected_url ) assert isinstance ( response , JSONAPIParser ) assert response . json_data is method_func . return_value . data return execute_test return api_test_factory
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a stream discarding the data read and returns its size .<CODESPLIT>def _read_stream_for_size ( stream , buf_size = 65536 ) : size = 0 while True : buf = stream . read ( buf_size ) size += len ( buf ) if not buf : break return size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get rid of all axis ticks lines etc .<CODESPLIT>def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add all of the members of the complex abundances to the graph .<CODESPLIT>def enrich_complexes ( graph : BELGraph ) -> None : nodes = list ( get_nodes_by_function ( graph , COMPLEX ) ) for u in nodes : for v in u . members : graph . add_has_component ( u , v )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter to keep bolts<CODESPLIT>def filter_bolts ( table , header ) : bolts_info = [ ] for row in table : if row [ 0 ] == 'bolt' : bolts_info . append ( row ) return bolts_info , header
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first day of the current month<CODESPLIT>def get_month_start_date ( self ) : now = timezone . now ( ) return timezone . datetime ( day = 1 , month = now . month , year = now . year , tzinfo = now . tzinfo )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test the multiprocess<CODESPLIT>def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Spawns a kafka continuous consumer thread<CODESPLIT>def _spawn_kafka_consumer_thread ( self ) : self . logger . debug ( "Spawn kafka consumer thread" "" ) self . _consumer_thread = Thread ( target = self . _consumer_loop ) self . _consumer_thread . setDaemon ( True ) self . _consumer_thread . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add index alias to index_name<CODESPLIT>def add_index_alias ( es , index_name , alias_name ) : es . indices . put_alias ( index = index_name , name = terms_alias )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Submits the packaged application to spark using a spark - submit subprocess<CODESPLIT>def __run_spark_submit ( lane_yaml , dist_dir , spark_home , spark_args , silent ) : # spark-submit binary cmd = [ 'spark-submit' if spark_home is None else os . path . join ( spark_home , 'bin/spark-submit' ) ] # Supplied spark arguments if spark_args : cmd += spark_args # Packaged App & lane cmd += [ '--py-files' , 'libs.zip,_framework.zip,tasks.zip' , 'main.py' ] cmd += [ '--lane' , lane_yaml ] logging . info ( 'Submitting to Spark' ) logging . debug ( str ( cmd ) ) # Submit devnull = open ( os . devnull , 'w' ) outp = { 'stderr' : STDOUT , 'stdout' : devnull } if silent else { } call ( cmd , cwd = dist_dir , env = MY_ENV , * * outp ) devnull . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a number to a precision<CODESPLIT>def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param Path path :<CODESPLIT>def _load_mod_ui_libraries ( self , path ) : path = path / Path ( 'mod' ) sys . path . append ( str ( path ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a file is empty or not .<CODESPLIT>def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch & return a new Domain object representing the domain s current state<CODESPLIT>def fetch ( self ) : api = self . doapi_manager return api . _domain ( api . request ( self . url ) [ "domain" ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new dict from an existing dict that only has the given keys<CODESPLIT>def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a variable from this dataset .<CODESPLIT>def __delitem__ ( self , key ) : del self . _variables [ key ] self . _coord_names . discard ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .<CODESPLIT>def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .<CODESPLIT>def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether flyweight object with specified key has already been created .<CODESPLIT>def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restore settings to default values .<CODESPLIT>def restore_default_settings ( ) : global __DEFAULTS __DEFAULTS . CACHE_DIR = defaults . CACHE_DIR __DEFAULTS . SET_SEED = defaults . SET_SEED __DEFAULTS . SEED = defaults . SEED logging . info ( 'Settings reverted to their default values.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: rtype : bool<CODESPLIT>def is_all_field_none ( self ) : if self . _type_ is not None : return False if self . _value is not None : return False if self . _name is not None : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert GPU arras to numpy and return them<CODESPLIT>def to_np ( * args ) : if len ( args ) > 1 : return ( cp . asnumpy ( x ) for x in args ) else : return cp . asnumpy ( args [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the deepest level of nesting within a list of lists<CODESPLIT>def list_depth ( list_ , func = max , _depth = 0 ) : depth_list = [ list_depth ( item , func = func , _depth = _depth + 1 ) for item in list_ if util_type . is_listlike ( item ) ] if len ( depth_list ) > 0 : return func ( depth_list ) else : return _depth
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Install some packages on the remote host .<CODESPLIT>def yum_install ( self , packages , ignore_error = False ) : return self . run ( 'yum install -y --quiet ' + ' ' . join ( packages ) , ignore_error = ignore_error , retry = 5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read entire contents of file into a string .<CODESPLIT>def read_string_from_file ( path , encoding = "utf8" ) : with codecs . open ( path , "rb" , encoding = encoding ) as f : value = f . read ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read an image from file - PIL doesnt close nicely<CODESPLIT>def load_image ( fname ) : with open ( fname , "rb" ) as f : i = Image . open ( fname ) #i.load() return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d change ( in place ) d [ key ] to value .<CODESPLIT>def dictlist_replace ( dict_list : Iterable [ Dict ] , key : str , value : Any ) -> None : for d in dict_list : d [ key ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a dict to an encoded URL . Example : given data = { a : 1 b : 2 } it returns a = 1&b = 2<CODESPLIT>def get_dict_to_encoded_url ( data ) : unicode_data = dict ( [ ( k , smart_str ( v ) ) for k , v in data . items ( ) ] ) encoded = urllib . urlencode ( unicode_data ) return encoded
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get line count of file<CODESPLIT>def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 )<CODESPLIT>def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause for this many seconds<CODESPLIT>def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get list of datetime objects extracted from a filename<CODESPLIT>def get_dt_list ( fn_list ) : dt_list = np . array ( [ fn_getdatetime ( fn ) for fn in fn_list ] ) return dt_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hide the window .<CODESPLIT>def hide ( self ) : self . tk . withdraw ( ) self . _visible = False if self . _modal : self . tk . grab_release ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the job is still running or zero - os still knows about this job ID<CODESPLIT>def exists ( self ) : r = self . _client . _redis flag = '{}:flag' . format ( self . _queue ) return bool ( r . exists ( flag ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate random string with specified length<CODESPLIT>def gen_random_string ( str_len ) : return '' . join ( random . choice ( string . ascii_letters + string . digits ) for _ in range ( str_len ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpacks sqlite rows as returned by fetchall into an array of simple dicts .<CODESPLIT>def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random positive integer ( for a Django PositiveIntegerField )<CODESPLIT>def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a random walk and return True if the walker has returned to the origin after taking n steps .<CODESPLIT>def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs .<CODESPLIT>def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print emphasized good the given txt message<CODESPLIT>def good ( txt ) : print ( "%s# %s%s%s" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sample from independent normal distributions<CODESPLIT>def sample_normal ( mean , var , rng ) : ret = numpy . sqrt ( var ) * rng . randn ( * mean . shape ) + mean return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>inverse hyperbolic sine transformation<CODESPLIT>def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get user name provide by operating system<CODESPLIT>def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the angle between two points .<CODESPLIT>def angle ( x0 , y0 , x1 , y1 ) : return degrees ( atan2 ( y1 - y0 , x1 - x0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first line of a file .<CODESPLIT>def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\n' ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all dates between two dates .<CODESPLIT>def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the exception is always safe to retry .<CODESPLIT>def _is_retryable_exception ( e ) : if isinstance ( e , urllib3 . exceptions . ProtocolError ) : e = e . args [ 1 ] if isinstance ( e , ( socket . gaierror , socket . herror ) ) : return True if isinstance ( e , socket . error ) and e . errno in _RETRYABLE_SOCKET_ERRORS : return True if isinstance ( e , urllib3 . exceptions . NewConnectionError ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render the plot with bokeh . io and push to notebook .<CODESPLIT>def _push_render ( self ) : bokeh . io . push_notebook ( handle = self . handle ) self . last_update = time . time ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230<CODESPLIT>def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the content of the zip - file at zip_path into target_folder .<CODESPLIT>def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Path to tensorflow_datasets directory .<CODESPLIT>def tfds_dir ( ) : return os . path . dirname ( os . path . dirname ( os . path . dirname ( __file__ ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Propagate a mean through linear Gaussian transformation .<CODESPLIT>def _propagate_mean ( mean , linop , dist ) : return linop . matmul ( mean ) + dist . mean ( ) [ ... , tf . newaxis ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a symbolic link<CODESPLIT>def symlink ( source , destination ) : log ( "Symlinking {} as {}" . format ( source , destination ) ) cmd = [ 'ln' , '-sf' , source , destination , ] subprocess . check_call ( cmd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return start and end date of this quarter .<CODESPLIT>def this_quarter ( ) : since = TODAY + delta ( day = 1 ) while since . month % 3 != 0 : since -= delta ( months = 1 ) until = since + delta ( months = 3 ) return Date ( since ) , Date ( until )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Original doc : A dialog to get a file name . Returns the name of a file or None if user chose to cancel .<CODESPLIT>def fileopenbox ( msg = None , title = None , argInitialFile = None ) : return psidialogs . ask_file ( message = msg , title = title , default = argInitialFile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverse the normalization done to a batch of images .<CODESPLIT>def denorm ( self , arr ) : if type ( arr ) is not np . ndarray : arr = to_np ( arr ) if len ( arr . shape ) == 3 : arr = arr [ None ] return self . transform . denorm ( np . rollaxis ( arr , 1 , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Colorize text with given color .<CODESPLIT>def _write_color_colorama ( fp , text , color ) : foreground , background , style = get_win_color ( color ) colorama . set_console ( foreground = foreground , background = background , style = style ) fp . write ( text ) colorama . reset_console ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If value is a datetime convert to timestamp<CODESPLIT>def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpacks sqlite rows as returned by fetchall into an array of simple dicts .<CODESPLIT>def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a querystring value from the request .<CODESPLIT>def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .<CODESPLIT>def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Substitutes the replacement string / character at the given index in the given string returns the modified string .<CODESPLIT>def subat ( orig , index , replace ) : return "" . join ( [ ( orig [ x ] if x != index else replace ) for x in range ( len ( orig ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a file is empty or not .<CODESPLIT>def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shuffle the data .<CODESPLIT>def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set authenatication .<CODESPLIT>def set_basic_auth ( self , username , password ) : from requests . auth import HTTPBasicAuth self . auth = HTTPBasicAuth ( username , password ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs an asynchronous function without needing to use await - useful for lambda<CODESPLIT>def runcoro ( async_function ) : future = _asyncio . run_coroutine_threadsafe ( async_function , client . loop ) result = future . result ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>g<CODESPLIT>def _top ( self ) : # Goto top of the list self . top . body . focus_position = 2 if self . compact is False else 0 self . top . keypress ( self . size , "" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if the value is in the list move it to the front and return it .<CODESPLIT>def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from integers to strings<CODESPLIT>def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string with punctuation removed .<CODESPLIT>def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\w' , r'\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dataframe that is a cross between dataframes df1 and df2<CODESPLIT>def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This parallel fetcher uses gevent one uses gevent<CODESPLIT>def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load the pickled model weights .<CODESPLIT>def load ( self , path ) : with io . open ( path , 'rb' ) as fin : self . weights = pickle . load ( fin )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list into a space - separated string and puts it in a dictionary<CODESPLIT>def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : " " . join ( str ( i ) for i in list_ ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If Python 2 replace non - ascii characters and return encoded string .<CODESPLIT>def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\u2019' , "'" ) return uni . encode ( 'utf-8' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read an image from file - PIL doesnt close nicely<CODESPLIT>def load_image ( fname ) : with open ( fname , "rb" ) as f : i = Image . open ( fname ) #i.load() return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for the requests . request () function . It accepts the same arguments as the original plus an optional retries that overrides the default retry mechanism .<CODESPLIT>def request ( method , url , * * kwargs ) : retries = kwargs . pop ( 'retries' , None ) with Session ( retries = retries ) as session : return session . request ( method = method , url = url , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register a struct definition globally<CODESPLIT>def define_struct ( defn ) : struct = parse_type ( defn ) ALL_TYPES [ struct . name ] = struct return struct
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the stretched data .<CODESPLIT>def show ( data , negate = False ) : from PIL import Image as pil data = np . array ( ( data - data . min ( ) ) * 255.0 / ( data . max ( ) - data . min ( ) ) , np . uint8 ) if negate : data = 255 - data img = pil . fromarray ( data ) img . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response .<CODESPLIT>def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == "POST" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == "OPTIONS" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copies file from default data directory to local directory .<CODESPLIT>def copy_default_data_file ( filename , module = None ) : if module is None : module = __get_filetypes_module ( ) fullpath = get_default_data_path ( filename , module = module ) shutil . copy ( fullpath , "." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>round to closest resolution<CODESPLIT>def roundClosestValid ( val , res , decimals = None ) : if decimals is None and "." in str ( res ) : decimals = len ( str ( res ) . split ( '.' ) [ 1 ] ) return round ( round ( val / res ) * res , decimals )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if an element from a list is in a string .<CODESPLIT>def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a python string to C string .<CODESPLIT>def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Keep one of the subplots completely empty .<CODESPLIT>def set_empty ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . set_empty ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the display length of a string . This can differ from the character length if the string contains wide characters .<CODESPLIT>def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is a builtin one .<CODESPLIT>def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting<CODESPLIT>def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show a 3D surface plot .<CODESPLIT>def surface ( self , zdata , * * kwargs ) : self . _configure_3d ( ) surf = scene . SurfacePlot ( z = zdata , * * kwargs ) self . view . add ( surf ) self . view . camera . set_range ( ) return surf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .<CODESPLIT>def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log memory usage before and after a method .<CODESPLIT>def memory_usage ( method ) : def wrapper ( * args , * * kwargs ) : logging . info ( 'Memory before method %s is %s.' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) result = method ( * args , * * kwargs ) logging . info ( 'Memory after method %s is %s' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) return result return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function flatten given nested list . Argument : nested list Returns : flat list<CODESPLIT>def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete credentials from the SQLAlchemy datastore .<CODESPLIT>def locked_delete ( self ) : filters = { self . key_name : self . key_value } self . session . query ( self . model_class ) . filter_by ( * * filters ) . delete ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a label by name .<CODESPLIT>def del_label ( self , name ) : labels_tag = self . root [ 0 ] labels_tag . remove ( self . _find_label ( name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>zoom out full data range<CODESPLIT>def unzoom_all ( self , event = None ) : if len ( self . conf . zoom_lims ) > 0 : self . conf . zoom_lims = [ self . conf . zoom_lims [ 0 ] ] self . unzoom ( event )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def _drop_str_columns ( df ) : str_columns = filter ( lambda pair : pair [ 1 ] . char == 'S' , df . _gather_dtypes ( ) . items ( ) ) str_column_names = list ( map ( lambda pair : pair [ 0 ] , str_columns ) ) return df . drop ( str_column_names )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if two images have the same height and width ( and optionally channels ) .<CODESPLIT>def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function which returns an array with the Intervals boundaries .<CODESPLIT>def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callable function for the multiprocessing pool .<CODESPLIT>def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use Python % format strings as template format specifiers .<CODESPLIT>def PythonPercentFormat ( format_str ) : if format_str . startswith ( 'printf ' ) : fmt = format_str [ len ( 'printf ' ) : ] return lambda value : fmt % value else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove files specified multiple times in a list .<CODESPLIT>def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ "path" ] not in seen : out . append ( x ) seen . add ( x [ "path" ] ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function that reads a local file and generates a SHA256 hash digest for it<CODESPLIT>def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts list to string with comma separated values . For string is no - op .<CODESPLIT>def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = "," . join ( value ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .<CODESPLIT>def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a thread local stack uniquified by the given name .<CODESPLIT>def _get_or_create_stack ( name ) : stack = getattr ( _LOCAL_STACKS , name , None ) if stack is None : stack = [ ] setattr ( _LOCAL_STACKS , name , stack ) return stack
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uphold the spec rules about naming .<CODESPLIT>def assert_valid_name ( name : str ) -> str : error = is_valid_name_error ( name ) if error : raise error return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a pdf of the current matplotlib figure .<CODESPLIT>def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dotproduct between self and another vector .<CODESPLIT>def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>to get states from multiprocessing . queue<CODESPLIT>def get ( self , queue_get ) : if isinstance ( queue_get , ( tuple , list ) ) : self . result . extend ( queue_get )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return flattened dictionary from MultiDict .<CODESPLIT>def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the median of a list of values Returns a float / int<CODESPLIT>def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This class method could be used as decorator on subclasses it ensures update method is called after function execution .<CODESPLIT>def auto_update ( cls , function ) : def wrapper ( self , * args , * * kwargs ) : f = function ( self , * args , * * kwargs ) self . update ( ) return f return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>execute jobs in processes using N threads<CODESPLIT>def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decision Tree<CODESPLIT>def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the given user is in all given groups<CODESPLIT>def user_in_all_groups ( user , groups ) : return user_is_superuser ( user ) or all ( user_in_group ( user , group ) for group in groups )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of leading spaces in line .<CODESPLIT>def GetIndentLevel ( line ) : indent = Match ( r'^( *)\S' , line ) if indent : return len ( indent . group ( 1 ) ) else : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function used to fit the exponential decay .<CODESPLIT>def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get max for queryset .<CODESPLIT>def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update dict with fields from obj . attributes .<CODESPLIT>def update_dict ( obj , dict , attributes ) : for attribute in attributes : if hasattr ( obj , attribute ) and getattr ( obj , attribute ) is not None : dict [ attribute ] = getattr ( obj , attribute )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Command line interface for PyBEL .<CODESPLIT>def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the local variables in the caller s frame .<CODESPLIT>def caller_locals ( ) : import inspect frame = inspect . currentframe ( ) try : return frame . f_back . f_back . f_locals finally : del frame
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a O ( 1 ) memory hash of an iterable of arbitrary length .<CODESPLIT>def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show exception with traceback .<CODESPLIT>def format_exc ( * exc_info ) : typ , exc , tb = exc_info or sys . exc_info ( ) error = traceback . format_exception ( typ , exc , tb ) return "" . join ( error )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets the dimensions depending on python version and os<CODESPLIT>def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the slice after at sub in string astr<CODESPLIT>def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send signal to process .<CODESPLIT>def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Square of the euclidean distance<CODESPLIT>def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator that turns a synchronous function into one returning a future .<CODESPLIT>def return_future ( fn ) : @ wraps ( fn ) def decorated ( * args , * * kwargs ) : return gen . maybe_future ( fn ( * args , * * kwargs ) ) return decorated
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gaussian model m is [ psill range nugget ]<CODESPLIT>def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Segmented max op .<CODESPLIT>def SegmentMax ( a , ids ) : func = lambda idxs : np . amax ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove text nodes containing only whitespace<CODESPLIT>def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plot the empirical histogram versus best - fit distribution s PDF .<CODESPLIT>def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes the passed chunk and flushes it to the client .<CODESPLIT>def send ( self , * args , * * kwargs ) : self . write ( * args , * * kwargs ) self . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a Django project is being managed with manage . py or django - admin scripts<CODESPLIT>def is_managed ( ) : for item in sys . argv : if re . search ( r'manage.py|django-admin|django' , item ) is not None : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close the db and release memory<CODESPLIT>def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a float returns a rounded int . Should give the same result on both Py2 / 3<CODESPLIT>def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert record array to a dictionaries<CODESPLIT>def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the path to the virtualenv python<CODESPLIT>def get_python ( ) : if sys . platform == 'win32' : python = path . join ( VE_ROOT , 'Scripts' , 'python.exe' ) else : python = path . join ( VE_ROOT , 'bin' , 'python' ) return python
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clone a directory try by copying it .<CODESPLIT>def clone_with_copy ( src_path , dest_path ) : log . info ( 'Cloning directory tree %s to %s' , src_path , dest_path ) shutil . copytree ( src_path , dest_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to FTP server login and return an ftplib . FTP instance .<CODESPLIT>def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a snake cased version of a string .<CODESPLIT>def snake_case ( a_string ) : partial = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , a_string ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , partial ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>kill process Args : process - Popen object for process<CODESPLIT>def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get longitudes from cartesian coordinates .<CODESPLIT>def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>closeEvent reimplementation<CODESPLIT>def closeEvent ( self , event ) : if self . closing ( True ) : event . accept ( ) else : event . ignore ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flush the write buffers of the stream if applicable .<CODESPLIT>def _flush ( self , buffer ) : container , obj = self . _client_args with _handle_client_exception ( ) : self . _client . put_object ( container , obj , buffer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the GET querstring contains on values but it can contain empty keys . This is better than doing not bool ( request . GET ) as an empty key will return True<CODESPLIT>def check_empty_dict ( GET_dict ) : empty = True for k , v in GET_dict . items ( ) : # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all' : empty = False return empty
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a workaround where Collections are no longer iterable when using JPype .<CODESPLIT>def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a value or list of values and returns a single result joined by if necessary .<CODESPLIT>def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load the correct module according to the version<CODESPLIT>def load_library ( version ) : check_version ( version ) module_name = SUPPORTED_LIBRARIES [ version ] lib = sys . modules . get ( module_name ) if lib is None : lib = importlib . import_module ( module_name ) return lib
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use the S3 SWAG backend .<CODESPLIT>def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list consisting of the cumulative sum of the items in the passed list .<CODESPLIT>def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert arrays of datetime . datetime and datetime . timedelta objects into datetime64 and timedelta64 according to the pandas convention .<CODESPLIT>def _possibly_convert_objects ( values ) : return np . asarray ( pd . Series ( values . ravel ( ) ) ) . reshape ( values . shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the help text ( signature + docstring ) for a command ( function ) .<CODESPLIT>def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\x08' , '' , help_text ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the table names in the database .<CODESPLIT>def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( "SELECT name FROM sqlite_master WHERE type == 'table'" ) return [ name for ( name , ) in cursor ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns number of days in the given month . 1 - based numbers as arguments . i . e . November = 11<CODESPLIT>def get_days_in_month ( year : int , month : int ) -> int : month_range = calendar . monthrange ( year , month ) return month_range [ 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>All commits with that message ( in current branch )<CODESPLIT>def commits_with_message ( message ) : output = log ( "--grep '%s'" % message , oneline = True , quiet = True ) lines = output . splitlines ( ) return [ l . split ( ' ' , 1 ) [ 0 ] for l in lines ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the most common element in iterable .<CODESPLIT>def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If value is a datetime convert to timestamp<CODESPLIT>def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sync the database with the current state of the game .<CODESPLIT>def on_pause ( self ) : self . engine . commit ( ) self . strings . save ( ) self . funcs . save ( ) self . config . write ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load Context with data<CODESPLIT>def set_context ( self , data ) : for key in data : setattr ( self . local_context , key , data [ key ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restores CMD and ENTRYPOINT values of the image<CODESPLIT>def restore_image_options ( cli , image , options ) : dockerfile = io . StringIO ( ) dockerfile . write ( u'FROM {image}\nCMD {cmd}' . format ( image = image , cmd = json . dumps ( options [ 'cmd' ] ) ) ) if options [ 'entrypoint' ] : dockerfile . write ( '\nENTRYPOINT {}' . format ( json . dumps ( options [ 'entrypoint' ] ) ) ) cli . build ( tag = image , fileobj = dockerfile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quits the application ( called when the last window is closed )<CODESPLIT>def quit ( self ) : logger . debug ( "ArgosApplication.quit called" ) assert len ( self . mainWindows ) == 0 , "Bug: still {} windows present at application quit!" . format ( len ( self . mainWindows ) ) self . qApplication . quit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the item at the given index .<CODESPLIT>def __getitem__ ( self , index ) : row , col = index return self . rows [ row ] [ col ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>last row or column of square A<CODESPLIT>def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the count of objects of key<CODESPLIT>def objectcount ( data , key ) : objkey = key . upper ( ) return len ( data . dt [ objkey ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Command line parser .<CODESPLIT>def parse_command_args ( ) : parser = argparse . ArgumentParser ( description = 'Register PB devices.' ) parser . add_argument ( 'num_pb' , type = int , help = 'Number of PBs devices to register.' ) return parser . parse_args ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find earliest occurrence of one of substrings in line .<CODESPLIT>def _find_first_of ( line , substrings ) : starts = ( ( line . find ( i ) , i ) for i in substrings ) found = [ ( i , sub ) for i , sub in starts if i != - 1 ] if found : return min ( found ) else : return - 1 , None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the shape of the region as ( x y w h )<CODESPLIT>def getTuple ( self ) : return ( self . x , self . y , self . w , self . h )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try popping a key from a dict . Instead of raising KeyError just return the default value .<CODESPLIT>def dict_pop_or ( d , key , default = None ) : val = default with suppress ( KeyError ) : val = d . pop ( key ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this an integer .<CODESPLIT>def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback to go to the next tab . Called by the accel key .<CODESPLIT>def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the last NoteContainer in the Bar .<CODESPLIT>def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all records from a table . Use caution!<CODESPLIT>def wipe_table ( self , table : str ) -> int : sql = "DELETE FROM " + self . delimit ( table ) return self . db_exec ( sql )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove prefix ( and space ) from line<CODESPLIT>def uncomment_line ( line , prefix ) : if not prefix : return line if line . startswith ( prefix + ' ' ) : return line [ len ( prefix ) + 1 : ] if line . startswith ( prefix ) : return line [ len ( prefix ) : ] return line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for plotting .<CODESPLIT>def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .<CODESPLIT>def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove non - alphanumerical characters from metric word . And trim excessive underscores .<CODESPLIT>def sanitize_word ( s ) : s = re . sub ( '[^\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Override of PantsService . terminate () that cleans up when the Pailgun server is terminated .<CODESPLIT>def terminate ( self ) : # Tear down the Pailgun TCPServer. if self . pailgun : self . pailgun . server_close ( ) super ( PailgunService , self ) . terminate ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return iterator for items in each page<CODESPLIT>def items ( self , limit = 0 ) : i = ItemIterator ( self . iterator ) i . limit = limit return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into a list of tokens .<CODESPLIT>def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \t' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove html code contained into the given string .<CODESPLIT>def strip_html ( string , keep_tag_content = False ) : r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE return r . sub ( '' , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort list elements by name .<CODESPLIT>def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper to create a proxy method in a class .<CODESPLIT>def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Obtain a real address as an integer from an objectproxy .<CODESPLIT>def objectproxy_realaddress ( obj ) : voidp = QROOT . TPython . ObjectProxy_AsVoidPtr ( obj ) return C . addressof ( C . c_char . from_buffer ( voidp ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns file name of file at given url .<CODESPLIT>def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from a sequence ( of hashable items ) while maintaining order . NOTE : This only works if items in the list are hashable types .<CODESPLIT>def dedupe ( items ) : seen = set ( ) for item in items : if item not in seen : yield item seen . add ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns numpy array of natural logarithms of values .<CODESPLIT>def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( "ignore" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the minimum of an array ignoring any NaNs .<CODESPLIT>def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserialize b ( instance of bytes ) to a Python object .<CODESPLIT>def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cumulative product of a list .<CODESPLIT>def _cumprod ( l ) : ret = [ 1 ] for item in l : ret . append ( ret [ - 1 ] * item ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .<CODESPLIT>def restart ( self , reset = False ) : # Get start path to use in restart script  spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started  # Note: Variables defined in bootstrap.py and spyder/app/start.py  env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder  pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py  if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess  env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS  if os . name == 'nt' : # Hide flashing command prompt  startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '"{0}" "{1}"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and  # the error can be inspected in the internal console  print ( error ) # spyder: test-skip  print ( command )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Establishes access of GettableProperty values<CODESPLIT>def get_property ( self ) : scope = self def fget ( self ) : """Call the HasProperties _get method""" return self . _get ( scope . name ) return property ( fget = fget , doc = scope . sphinx ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the next row .<CODESPLIT>def next ( self ) : # I'm pretty sure this is the completely wrong way to go about this, but # oh well, this works. if not hasattr ( self , '_iter' ) : self . _iter = self . readrow_as_dict ( ) return self . _iter . next ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert the entire image to bytes . : rtype : bytes<CODESPLIT>def to_bytes ( self ) : chunks = [ PNG_SIGN ] chunks . extend ( c [ 1 ] for c in self . chunks ) return b"" . join ( chunks )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if a list is sorted<CODESPLIT>def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display both SQLAlchemy and Python help statements<CODESPLIT>def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the given path relative to this file .<CODESPLIT>def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is an enum type .<CODESPLIT>def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a tweepy auth object<CODESPLIT>def get_tweepy_auth ( twitter_api_key , twitter_api_secret , twitter_access_token , twitter_access_token_secret ) : auth = tweepy . OAuthHandler ( twitter_api_key , twitter_api_secret ) auth . set_access_token ( twitter_access_token , twitter_access_token_secret ) return auth
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform column - stacking on a list of 2d data blocks .<CODESPLIT>def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .<CODESPLIT>def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function to display sympy expression using display style LaTeX in PNG .<CODESPLIT>def print_display_png ( o ) : s = latex ( o , mode = 'plain' ) s = s . strip ( '$' ) # As matplotlib does not support display style, dvipng backend is # used here. png = latex_to_png ( '$$%s$$' % s , backend = 'dvipng' ) return png
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs a thing once and once only .<CODESPLIT>def once ( func ) : lock = threading . Lock ( ) def new_func ( * args , * * kwargs ) : if new_func . called : return with lock : if new_func . called : return rv = func ( * args , * * kwargs ) new_func . called = True return rv new_func = update_wrapper ( new_func , func ) new_func . called = False return new_func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime<CODESPLIT>def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns ( module locals ) of the funciton depth frames away from the caller<CODESPLIT>def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes the client connection to the database .<CODESPLIT>def _close ( self ) : if self . connection : with self . wrap_database_errors : self . connection . client . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all the unnamed columns<CODESPLIT>def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return unit sphere coordinates from window coordinates .<CODESPLIT>def arcball_map_to_sphere ( point , center , radius ) : v0 = ( point [ 0 ] - center [ 0 ] ) / radius v1 = ( center [ 1 ] - point [ 1 ] ) / radius n = v0 * v0 + v1 * v1 if n > 1.0 : # position outside of sphere n = math . sqrt ( n ) return numpy . array ( [ v0 / n , v1 / n , 0.0 ] ) else : return numpy . array ( [ v0 , v1 , math . sqrt ( 1.0 - n ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert special characters using %xx escape .<CODESPLIT>def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run server with provided command line arguments .<CODESPLIT>def start ( args ) : application = tornado . web . Application ( [ ( r"/run" , run . get_handler ( args ) ) , ( r"/status" , run . StatusHandler ) ] ) application . runmonitor = RunMonitor ( ) application . listen ( args . port ) tornado . ioloop . IOLoop . instance ( ) . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create random string of selected size<CODESPLIT>def random_str ( size = 10 ) : return '' . join ( random . choice ( string . ascii_lowercase ) for _ in range ( size ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Drops and re - creates the SQL schema<CODESPLIT>def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the tanimoto set similarity .<CODESPLIT>def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to read an environment variable<CODESPLIT>def _get_env ( self , env_var ) : value = os . environ . get ( env_var ) if not value : raise ValueError ( 'Missing environment variable:%s' % env_var ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disables legends if show_legend is disabled .<CODESPLIT>def _process_legend ( self ) : for l in self . handles [ 'plot' ] . legend : l . items [ : ] = [ ] l . border_line_alpha = 0 l . background_fill_alpha = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the code object for this BUILD file .<CODESPLIT>def code ( self ) : return compile ( self . source ( ) , self . full_path , 'exec' , flags = 0 , dont_inherit = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Debug a single doctest docstring in argument src<CODESPLIT>def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all . py files .<CODESPLIT>def clean_py_files ( path ) : for dirname , subdirlist , filelist in os . walk ( path ) : for f in filelist : if f . endswith ( 'py' ) : os . remove ( os . path . join ( dirname , f ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a |_LineSegment| operation to the drawing sequence .<CODESPLIT>def _add_line_segment ( self , x , y ) : self . _drawing_operations . append ( _LineSegment . new ( self , x , y ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear screen and go to 0 0<CODESPLIT>def clear ( self ) : # Erase current output first. self . erase ( ) # Send "Erase Screen" command and go to (0, 0). output = self . output output . erase_screen ( ) output . cursor_goto ( 0 , 0 ) output . flush ( ) self . request_absolute_cursor_position ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a US format date and return epoch .<CODESPLIT>def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , "%m/%d/%Y" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yields tokens from input string .<CODESPLIT>def get_tokens ( line : str ) -> Iterator [ str ] : for token in line . rstrip ( ) . split ( ) : if len ( token ) > 0 : yield token
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves the Python library directory path .<CODESPLIT>def GetPythonLibraryDirectoryPath ( ) : path = sysconfig . get_python_lib ( True ) _ , _ , path = path . rpartition ( sysconfig . PREFIX ) if path . startswith ( os . sep ) : path = path [ 1 : ] return path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mocked decorator needed in the case we need to mock a decorator<CODESPLIT>def mock_decorator ( * args , * * kwargs ) : def _called_decorator ( dec_func ) : @ wraps ( dec_func ) def _decorator ( * args , * * kwargs ) : return dec_func ( ) return _decorator return _called_decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Last modified timestamp as a UTC datetime<CODESPLIT>def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get single system variable from CCU / Homegear<CODESPLIT>def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def copy ( obj ) : def copy ( self ) : """         Copy self to a new object.         """ from copy import deepcopy return deepcopy ( self ) obj . copy = copy return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function for loading yaml - encoded data from disk .<CODESPLIT>def load_yaml ( filepath ) : with open ( filepath ) as f : txt = f . read ( ) return yaml . load ( txt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls a function . If an error of the given exception type with interrupted system call ( EINTR ) occurs calls the function again .<CODESPLIT>def eintr_retry ( exc_type , f , * args , * * kwargs ) : while True : try : return f ( * args , * * kwargs ) except exc_type as exc : if exc . errno != EINTR : raise else : break
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .<CODESPLIT>def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set limits for the x - axis .<CODESPLIT>def set_xlimits ( self , min = None , max = None ) : self . limits [ 'xmin' ] = min self . limits [ 'xmax' ] = max
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>splits iterables a in equal parts of size sz<CODESPLIT>def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort input filename list by datetime<CODESPLIT>def sort_fn_list ( fn_list ) : dt_list = get_dt_list ( fn_list ) fn_list_sort = [ fn for ( dt , fn ) in sorted ( zip ( dt_list , fn_list ) ) ] return fn_list_sort
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .<CODESPLIT>def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>parse the domain from the url<CODESPLIT>def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run a playbook .<CODESPLIT>def callPlaybook ( self , playbook , ansibleArgs , wait = True , tags = [ "all" ] ) : playbook = os . path . join ( self . playbooks , playbook ) # Path to playbook being executed verbosity = "-vvvvv" if logger . isEnabledFor ( logging . DEBUG ) else "-v" command = [ "ansible-playbook" , verbosity , "--tags" , "," . join ( tags ) , "--extra-vars" ] command . append ( " " . join ( [ "=" . join ( i ) for i in ansibleArgs . items ( ) ] ) ) # Arguments being passed to playbook command . append ( playbook ) logger . debug ( "Executing Ansible call `%s`" , " " . join ( command ) ) p = subprocess . Popen ( command ) if wait : p . communicate ( ) if p . returncode != 0 : # FIXME: parse error codes raise RuntimeError ( "Ansible reported an error when executing playbook %s" % playbook )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for Django s reverse in templates .<CODESPLIT>def url ( viewname , * args , * * kwargs ) : return reverse ( viewname , args = args , kwargs = kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create ctypes pointer to object .<CODESPLIT>def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the single element of iterable or raise an error .<CODESPLIT>def assert_single_element ( iterable ) : it = iter ( iterable ) first_item = next ( it ) try : next ( it ) except StopIteration : return first_item raise ValueError ( "iterable {!r} has more than one element." . format ( iterable ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to extract keywords from the text provided .<CODESPLIT>def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine memory specifications of the machine .<CODESPLIT>def memory ( ) : mem_info = dict ( ) for k , v in psutil . virtual_memory ( ) . _asdict ( ) . items ( ) : mem_info [ k ] = int ( v ) return mem_info
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert input argument to bytes<CODESPLIT>def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Searches for the specified method and returns its descriptor .<CODESPLIT>def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the base directory<CODESPLIT>def get_base_dir ( ) : return os . path . split ( os . path . abspath ( os . path . dirname ( __file__ ) ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Aggregation function to get the first non - zero value .<CODESPLIT>def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create database tables from sqlalchemy models<CODESPLIT>def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the folder exisits . If not create the folder<CODESPLIT>def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip excess spaces from a string<CODESPLIT>def strip_spaces ( s ) : return u" " . join ( [ c for c in s . split ( u' ' ) if c ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix .<CODESPLIT>def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of active CPUs on a Darwin system .<CODESPLIT>def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete credentials from the SQLAlchemy datastore .<CODESPLIT>def locked_delete ( self ) : filters = { self . key_name : self . key_value } self . session . query ( self . model_class ) . filter_by ( * * filters ) . delete ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the flattened version of a 2D list . List - correlate to the a . flat () method of NumPy arrays .<CODESPLIT>def flat ( l ) : newl = [ ] for i in range ( len ( l ) ) : for j in range ( len ( l [ i ] ) ) : newl . append ( l [ i ] [ j ] ) return newl
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add plots to an existing plot<CODESPLIT>def add_plot ( x , y , xl , yl , fig , ax , LATEX = False , linestyle = None , * * kwargs ) : if LATEX : xl_data = xl [ 1 ] # NOQA yl_data = yl [ 1 ] else : xl_data = xl [ 0 ] # NOQA yl_data = yl [ 0 ] for idx in range ( len ( y ) ) : ax . plot ( x , y [ idx ] , label = yl_data [ idx ] , linestyle = linestyle ) ax . legend ( loc = 'upper right' ) ax . set_ylim ( auto = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to uncheck a checkbox<CODESPLIT>def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list containing first n digits of Pi<CODESPLIT>def getPiLambert ( n ) : mypi = piGenLambert ( ) result = [ ] if n > 0 : result += [ next ( mypi ) for i in range ( n ) ] mypi . close ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the string name of an enum value .<CODESPLIT>def EnumValueName ( self , enum , value ) : return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a string and parses via NLP ready for mapping<CODESPLIT>def parse_text_to_dict ( self , txt ) : op = { } print ( 'TODO - import NLP, split into verbs / nouns' ) op [ 'nouns' ] = txt op [ 'verbs' ] = txt return op
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup the flask - cache on a flask app<CODESPLIT>def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rotate and flip a quadrant appropriately<CODESPLIT>def _rotate ( n , x , y , rx , ry ) : if ry == 0 : if rx == 1 : x = n - 1 - x y = n - 1 - y return y , x return x , y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Determine the intersection of two line segments .<CODESPLIT>def segment_intersection ( start0 , end0 , start1 , end1 ) : delta0 = end0 - start0 delta1 = end1 - start1 cross_d0_d1 = _helpers . cross_product ( delta0 , delta1 ) if cross_d0_d1 == 0.0 : return None , None , False else : start_delta = start1 - start0 s = _helpers . cross_product ( start_delta , delta1 ) / cross_d0_d1 t = _helpers . cross_product ( start_delta , delta0 ) / cross_d0_d1 return s , t , True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a pdf of the current matplotlib figure .<CODESPLIT>def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>updates the scale of all actors in the plotter<CODESPLIT>def update_scale ( self , value ) : self . plotter . set_scale ( self . x_slider_group . value , self . y_slider_group . value , self . z_slider_group . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For JSON the source it the file path<CODESPLIT>def load_parameters ( self , source ) : with open ( source ) as parameters_source : return json . loads ( parameters_source . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add one tick to progress bar<CODESPLIT>def tick ( self ) : self . current += 1 if self . current == self . factor : sys . stdout . write ( '+' ) sys . stdout . flush ( ) self . current = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a Path or string is a file on the file system .<CODESPLIT>def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Type casting .<CODESPLIT>def convert_value ( bind , value ) : type_name = get_type ( bind ) try : return typecast . cast ( type_name , value ) except typecast . ConverterError : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1x1 convolution<CODESPLIT>def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mono - exponential curve .<CODESPLIT>def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .<CODESPLIT>def generate_unique_host_id ( ) : host = "." . join ( reversed ( socket . gethostname ( ) . split ( "." ) ) ) pid = os . getpid ( ) return "%s.%d" % ( host , pid )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Waits until all outstanding tasks are completed .<CODESPLIT>def Join ( self ) : for _ in range ( self . JOIN_TIMEOUT_DECISECONDS ) : if self . _queue . empty ( ) and not self . busy_threads : return time . sleep ( 0.1 ) raise ValueError ( "Timeout during Join() for threadpool %s." % self . name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the set of implemented system flags .<CODESPLIT>def get_system_flags ( ) -> FrozenSet [ Flag ] : return frozenset ( { Seen , Recent , Deleted , Flagged , Answered , Draft } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the most common element in iterable .<CODESPLIT>def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Has a 50 / 50 chance of calling a function<CODESPLIT>def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if we have a compatible fill_value and arr dtype then fill<CODESPLIT>def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rate limit a function .<CODESPLIT>def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field is None .<CODESPLIT>def selectnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is None , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new copied dictionary without the keys with None values from the given Mapping object .<CODESPLIT>def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the year .<CODESPLIT>def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lookup country for IP address .<CODESPLIT>def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether another set contains this RangeSet .<CODESPLIT>def issubset ( self , other ) : self . _binary_sanity_check ( other ) return set . issubset ( self , other )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read text from stdin and print a helpful message for ttys .<CODESPLIT>def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialise sets used for uniqueness checking .<CODESPLIT>def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method for just changing font size .<CODESPLIT>def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates RGB values from HSV values in line with a typical light spectrum .<CODESPLIT>def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Estimates the memory of the supplied array in bytes<CODESPLIT>def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve core and memory information for the current machine .<CODESPLIT>def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { "memory" : float ( "%.1f" % ( free_bytes / BYTES_IN_GIG ) ) , "cores" : multiprocessing . cpu_count ( ) , "name" : socket . gethostname ( ) } ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an aiosqlite cursor wrapping a sqlite3 cursor object .<CODESPLIT>async def cursor ( self ) -> Cursor : return Cursor ( self , await self . _execute ( self . _conn . cursor ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an ISO 8601 formatted string in UTC into a timezone - aware datetime object .<CODESPLIT>def _strptime ( self , time_str ) : if time_str : # Parse UTC string into naive datetime, then add timezone dt = datetime . strptime ( time_str , __timeformat__ ) return dt . replace ( tzinfo = UTC ( ) ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .<CODESPLIT>def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when websocket connection is closed<CODESPLIT>def on_close ( self , ws ) : log . debug ( "Closing WebSocket connection with {}" . format ( self . url ) ) if self . keepalive and self . keepalive . is_alive ( ) : self . keepalive . do_run = False self . keepalive . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply WHERE filter to input dataset : param input : : param params : : return : filtered data<CODESPLIT>def filter_set ( input , * * params ) : PARAM_WHERE = 'where' return Converter . df2list ( pd . DataFrame . from_records ( input ) . query ( params . get ( PARAM_WHERE ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to run commands synchronously for testing .<CODESPLIT>def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( "Event loop is already running." ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uniformly format a path .<CODESPLIT>def fixpath ( path ) : return os . path . normpath ( os . path . realpath ( os . path . expanduser ( path ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for pymongo . Collection . ensure_index<CODESPLIT>def ensure_index ( self , key , unique = False ) : return self . collection . ensure_index ( key , unique = unique )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the high median of data .<CODESPLIT>def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( "no median for empty data" ) return data [ n // 2 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encodes numpy images into gif string .<CODESPLIT>def _encode_gif ( images , fps ) : writer = WholeVideoWriter ( fps ) writer . write_multi ( images ) return writer . finish ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if two images have the same height and width ( and optionally channels ) .<CODESPLIT>def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of JSON values to a list of models<CODESPLIT>def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Paints a cube at a certain position a color .<CODESPLIT>def paint_cube ( self , x , y ) : # get the color color = self . next_color ( ) # calculate the position cube_pos = [ x , y , x + self . cube_size , y + self . cube_size ] # draw the cube draw = ImageDraw . Draw ( im = self . image ) draw . rectangle ( xy = cube_pos , fill = color )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update () extends rather than replaces existing key lists .<CODESPLIT>def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield all items from iterable except the last one .<CODESPLIT>def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a Python object into a pretty - printed representation .<CODESPLIT>def pformat ( object , indent = 1 , width = 80 , depth = None ) : return PrettyPrinter ( indent = indent , width = width , depth = depth ) . pformat ( object )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Colorize text with given color .<CODESPLIT>def _write_color_colorama ( fp , text , color ) : foreground , background , style = get_win_color ( color ) colorama . set_console ( foreground = foreground , background = background , style = style ) fp . write ( text ) colorama . reset_console ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .<CODESPLIT>def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from list while preserving order .<CODESPLIT>def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>valid whether the point is located in a mulitpolygon ( donut polygon is not supported )<CODESPLIT>def point_in_multipolygon ( point , multipoly ) : coords_array = [ multipoly [ 'coordinates' ] ] if multipoly [ 'type' ] == "MultiPolygon" else multipoly [ 'coordinates' ] for coords in coords_array : if _point_in_polygon ( point , coords ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract text from a given lxml node .<CODESPLIT>def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( ".//text()" ) ) ) ) return " " . join ( text for text in texts if text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>%D .<CODESPLIT>def percent_d ( data , period ) : p_k = percent_k ( data , period ) percent_d = sma ( p_k , 3 ) return percent_d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Truncates a value to a number of decimals places<CODESPLIT>def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .<CODESPLIT>def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns svg from matplotlib chart<CODESPLIT>def fig2x ( figure , format ) : # Save svg to file like object svg_io io = StringIO ( ) figure . savefig ( io , format = format ) # Rewind the file like object io . seek ( 0 ) data = io . getvalue ( ) io . close ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Measure length of a string for a Base14 font .<CODESPLIT>def measure_string ( self , text , fontname , fontsize , encoding = 0 ) : return _fitz . Tools_measure_string ( self , text , fontname , fontsize , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print_tree : prints out structure of tree Args : indent ( int ) : What level of indentation at which to start printing Returns : None<CODESPLIT>def print_tree ( self , indent = 2 ) : config . LOGGER . info ( "{indent}{data}" . format ( indent = "   " * indent , data = str ( self ) ) ) for child in self . children : child . print_tree ( indent + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper to clean up an input string<CODESPLIT>def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rounds a float value off to the desired precision<CODESPLIT>def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A tensorflow variable tranfomed to be constrained in a L_inf unit ball .<CODESPLIT>def unit_ball_L_inf ( shape , precondition = True ) : x = tf . Variable ( tf . zeros ( shape ) ) if precondition : return constrain_L_inf_precondition ( x ) else : return constrain_L_inf ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a re . match object if an empty comment was found on line .<CODESPLIT>def _match_space_at_line ( line ) : regex = re . compile ( r"^{0}$" . format ( _MDL_COMMENT ) ) return regex . match ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last modified time of path as a Timestamp .<CODESPLIT>def last_modified_time ( path ) : return pd . Timestamp ( os . path . getmtime ( path ) , unit = 's' , tz = 'UTC' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts camel - case identifiers to snake - case .<CODESPLIT>def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the login credentials from the user if not specified while invoking the script .<CODESPLIT>def get_login_credentials ( args ) : if not args . username : args . username = raw_input ( "Enter Username: " ) if not args . password : args . password = getpass . getpass ( "Enter Password: " )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute a python code object in the given environment .<CODESPLIT>def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>R x M x R^ - 1<CODESPLIT>def similarity_transformation ( rot , mat ) : return np . dot ( rot , np . dot ( mat , np . linalg . inv ( rot ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple of ( start end ) indices of an item from its index .<CODESPLIT>def _get_item_position ( self , idx ) : start = 0 if idx == 0 else self . _index [ idx - 1 ] + 1 end = self . _index [ idx ] return start , end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>exit without breaking pipes .<CODESPLIT>def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an array . Keyword arguments as per : func : zarr . creation . zeros .<CODESPLIT>def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Drops the trailinz zeros from decimal value . Returns a string<CODESPLIT>def drop_trailing_zeros_decimal ( num ) : out = str ( num ) return out . rstrip ( '0' ) . rstrip ( '.' ) if '.' in out else out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the size of the layer with the border size already subtracted .<CODESPLIT>def getSize ( self ) : return self . widget . size [ 0 ] - self . border [ 0 ] * 2 , self . widget . size [ 1 ] - self . border [ 1 ] * 2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plot a scatterplot matrix for a list of features colored by target value .<CODESPLIT>def scatterplot_matrix ( df , features , downsample_frac = None , figsize = ( 15 , 15 ) ) : if downsample_frac : df = df . sample ( frac = downsample_frac ) plt . figure ( figsize = figsize ) sns . pairplot ( df [ features ] , hue = 'target' ) plt . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to pickle data in picklefile .<CODESPLIT>def pickle_data ( data , picklefile ) : with open ( picklefile , 'wb' ) as f : pickle . dump ( data , f , protocol = 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the keys that maps to the top n max values in the given dict .<CODESPLIT>def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>verify the validity of the given file . Never trust the End - User<CODESPLIT>def is_valid_file ( parser , arg ) : if not os . path . exists ( arg ) : parser . error ( "File %s not found" % arg ) else : return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the given number in decimal format using a period and commas<CODESPLIT>def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses numpy . load to open the underlying file<CODESPLIT>def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add value to a set in a dictionary by key<CODESPLIT>def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>\ kills the child and exits<CODESPLIT>def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field is a member of the given value .<CODESPLIT>def selectin ( table , field , value , complement = False ) : return select ( table , field , lambda v : v in value , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the channels of a palettebar .<CODESPLIT>def palettebar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) + 1 - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . palettize ( cbar )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like dict ( ** kwargs ) but where the source key is special .<CODESPLIT>def _sourced_dict ( self , source = None , * * kwargs ) : if source : kwargs [ 'source' ] = source elif self . source : kwargs [ 'source' ] = self . source return kwargs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset analyzer state<CODESPLIT>def reset ( self ) : self . prevframe = None self . wasmoving = False self . t0 = 0 self . ismoving = False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the total length of all of the flattened variables .<CODESPLIT>def get_flat_size ( self ) : return sum ( np . prod ( v . get_shape ( ) . as_list ( ) ) for v in self . variables . values ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interpolated flux at a given wavelength ( calls np . interp ) .<CODESPLIT>def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to remove all comments from a file and save it if changes were made .<CODESPLIT>def example_write_file_to_disk_if_changed ( ) : my_file = FileAsObj ( '/tmp/example_file.txt' ) my_file . rm ( my_file . egrep ( '^#' ) ) if my_file . changed : my_file . save ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete the index if it exists .<CODESPLIT>def delete_index ( self ) : es = self . _init_connection ( ) if es . indices . exists ( index = self . index ) : es . indices . delete ( index = self . index )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>raise a descriptive exception on a bad request response<CODESPLIT>def handle_errors ( resp ) : if resp . status_code == 400 : raise ApiException ( json . loads ( resp . content ) . get ( 'message' ) ) return resp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a yaml file s contents as a dictionary<CODESPLIT>def getYamlDocument ( filePath ) : with open ( filePath ) as stream : doc = yaml . load ( stream ) return doc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if email is valid<CODESPLIT>def is_valid_email ( email ) : pattern = re . compile ( r'[\w\.-]+@[\w\.-]+[.]\w+' ) return bool ( pattern . match ( email ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type aws_access_key_id : string : param aws_access_key_id : Your AWS Access Key ID<CODESPLIT>def connect_rds ( aws_access_key_id = None , aws_secret_access_key = None , * * kwargs ) : from boto . rds import RDSConnection return RDSConnection ( aws_access_key_id , aws_secret_access_key , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a set of variables by name from another frame .<CODESPLIT>def extract_vars_above ( * names ) : callerNS = sys . _getframe ( 2 ) . f_locals return dict ( ( k , callerNS [ k ] ) for k in names )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rebuilds the pathing based on the parts .<CODESPLIT>def startEdit ( self ) : self . _originalText = self . text ( ) self . scrollWidget ( ) . hide ( ) self . setFocus ( ) self . selectAll ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get dimension of an array getting the number of rows and the max num of columns .<CODESPLIT>def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator version of get_list_column<CODESPLIT>def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Annual growth given growth from start date to end date .<CODESPLIT>def growthfromrange ( rangegrowth , startdate , enddate ) : _yrs = ( pd . Timestamp ( enddate ) - pd . Timestamp ( startdate ) ) . total_seconds ( ) / dt . timedelta ( 365.25 ) . total_seconds ( ) return yrlygrowth ( rangegrowth , _yrs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of bytes into an integer as per X9 . 62 .<CODESPLIT>def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the passed variable is a tuple with two floats or integers<CODESPLIT>def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert dict of ascii str / unicode to dict of str if necessary<CODESPLIT>def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a UUID .<CODESPLIT>def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>writes the line and count newlines after the line<CODESPLIT>def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the size of a multidimansional array .<CODESPLIT>def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .<CODESPLIT>def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initiates a graceful stop of the processes<CODESPLIT>def stop ( self , timeout = None ) : self . stopping = True for process in list ( self . processes ) : self . stop_process ( process , timeout = timeout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: rtype : tuple<CODESPLIT>def tuple ( self , var , cast = None , default = NOTSET ) : return self . get_value ( var , cast = tuple if not cast else ( cast , ) , default = default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lock connection from being used else where<CODESPLIT>def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert hex string like \ x0A \ xE3 to 2787 .<CODESPLIT>def hex_to_int ( value ) : if version_info . major >= 3 : return int . from_bytes ( value , "big" ) return int ( value . encode ( "hex" ) , 16 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike .<CODESPLIT>def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls the specified Trigger of another Area with the optionally given parameters .<CODESPLIT>def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if an item is iterable ( list tuple generator ) but not string<CODESPLIT>def _is_iterable ( item ) : return isinstance ( item , collections . Iterable ) and not isinstance ( item , six . string_types )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a lowercase string with punctuation and bad chars removed : param s : string to clean<CODESPLIT>def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\u200b' , " " ) . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that gets relative path to the filename<CODESPLIT>def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get element by name<CODESPLIT>def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the index of the closest in xarr to value val<CODESPLIT>def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether this collection contains all items .<CODESPLIT>def issuperset ( self , items ) : return all ( _compat . map ( self . _seen . __contains__ , items ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of unique items ( similar to set functionality ) .<CODESPLIT>def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads an array from bytestring with big - endian data .<CODESPLIT>def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If value is a datetime convert to timestamp<CODESPLIT>def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get resource variable .<CODESPLIT>def _get_var_from_string ( item ) : modname , varname = _split_mod_var_names ( item ) if modname : mod = __import__ ( modname , globals ( ) , locals ( ) , [ varname ] , - 1 ) return getattr ( mod , varname ) else : return globals ( ) [ varname ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns seconds since 0h00 .<CODESPLIT>def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads a model from specified file<CODESPLIT>def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace all the ocurrences ( in a file ) of a string with another value .<CODESPLIT>def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit this application<CODESPLIT>def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add pytest unit tests to be built as part of build / test / output .<CODESPLIT>def autobuild_python_test ( path ) : env = Environment ( tools = [ ] ) target = env . Command ( [ 'build/test/output/pytest.log' ] , [ path ] , action = env . Action ( run_pytest , "Running python unit tests" ) ) env . AlwaysBuild ( target )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokenizes * source * and returns the tokens as a list of lists .<CODESPLIT>def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterate over all JSON input ( Generator )<CODESPLIT>def read ( self ) : for line in self . io . read ( ) : with self . parse_line ( line ) as j : yield j
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if day is after month s 3rd friday<CODESPLIT>def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the range of the colormap to [ * min_val * * max_val * ]<CODESPLIT>def set_range ( self , min_val , max_val ) : if min_val > max_val : max_val , min_val = min_val , max_val self . values = ( ( ( self . values * 1.0 - self . values . min ( ) ) / ( self . values . max ( ) - self . values . min ( ) ) ) * ( max_val - min_val ) + min_val )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cumulative product of a list .<CODESPLIT>def _cumprod ( l ) : ret = [ 1 ] for item in l : ret . append ( ret [ - 1 ] * item ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read MM_HEADER tag from file and return as numpy . rec . array .<CODESPLIT>def read_mm_header ( fd , byte_order , dtype , count ) : return numpy . rec . fromfile ( fd , MM_HEADER , 1 , byteorder = byte_order ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Categorical accuracy<CODESPLIT>def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Capitalizes all the words and replaces some characters in the string to create a nicer looking title .<CODESPLIT>def titleize ( text ) : if len ( text ) == 0 : # if empty string, return it return text else : text = text . lower ( ) # lower all char # delete redundant empty space  chunks = [ chunk [ 0 ] . upper ( ) + chunk [ 1 : ] for chunk in text . split ( " " ) if len ( chunk ) >= 1 ] return " " . join ( chunks )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the median of a list .<CODESPLIT>def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move the cursor up a number of lines .<CODESPLIT>def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the topmost parent of the current category .<CODESPLIT>def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>assumes that a figure is open<CODESPLIT>def _enter_plotting ( self , fontsize = 9 ) : # interactive_status = matplotlib.is_interactive() self . original_fontsize = pyplot . rcParams [ 'font.size' ] pyplot . rcParams [ 'font.size' ] = fontsize pyplot . hold ( False ) # opens a figure window, if non exists pyplot . ioff ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to a list with sanitization .<CODESPLIT>def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a str if a bytes object is given .<CODESPLIT>def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns current utcoffset for a timezone . Uses DEFAULT_LOCAL_TZ by default . That value can be changed at runtime using the func below .<CODESPLIT>def current_offset ( local_tz = None ) : if local_tz is None : local_tz = DEFAULT_LOCAL_TZ dt = local_tz . localize ( datetime . now ( ) ) return dt . utcoffset ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Counts the word frequences in a list of sentences .<CODESPLIT>def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>save the geometry before dialog is close to restore it later<CODESPLIT>def done ( self , result ) : self . _geometry = self . geometry ( ) QtWidgets . QDialog . done ( self , result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method asserts that only one value of the provided list is True .<CODESPLIT>def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Visible width of a potentially multiline content .<CODESPLIT>def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( "[\r\n]" , multiline_s ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file or directory is world writable .<CODESPLIT>def is_writable_by_others ( filename ) : mode = os . stat ( filename ) [ stat . ST_MODE ] return mode & stat . S_IWOTH
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encodes Unicode strings to byte strings if necessary .<CODESPLIT>def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d convert ( in place ) d [ key ] to a float . If that fails convert it to None .<CODESPLIT>def dictlist_convert_to_float ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : try : d [ key ] = float ( d [ key ] ) except ValueError : d [ key ] = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends a PDF to a pyPDF writer . Legacy interface .<CODESPLIT>def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Value of property .<CODESPLIT>def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a character delimited version of the provided list as a Python string<CODESPLIT>def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quits the application ( called when the last window is closed )<CODESPLIT>def quit ( self ) : logger . debug ( "ArgosApplication.quit called" ) assert len ( self . mainWindows ) == 0 , "Bug: still {} windows present at application quit!" . format ( len ( self . mainWindows ) ) self . qApplication . quit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find longest ORF from the given list of ORFs .<CODESPLIT>def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield all items from iterable except the last one .<CODESPLIT>def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>hacky inference of kwargs keys<CODESPLIT>def parse_func_kwarg_keys ( func , with_vals = False ) : sourcecode = get_func_sourcecode ( func , strip_docstr = True , strip_comments = True ) kwkeys = parse_kwarg_keys ( sourcecode , with_vals = with_vals ) #ut.get_func_kwargs  TODO return kwkeys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints a summary of all objects in the database . Input string or list of strings in ** ID ** or ** unum ** for specific objects .<CODESPLIT>def inventory ( self , source_id , fetch = False , fmt = 'table' ) : data_tables = { } t = self . query ( "SELECT * FROM sqlite_master WHERE type='table'" , fmt = 'table' ) all_tables = t [ 'name' ] . tolist ( ) for table in [ 'sources' ] + [ t for t in all_tables if t not in [ 'sources' , 'sqlite_sequence' ] ] : try : # Get the columns, pull out redundant ones, and query the table for this source's data t = self . query ( "PRAGMA table_info({})" . format ( table ) , fmt = 'table' ) columns = np . array ( t [ 'name' ] ) types = np . array ( t [ 'type' ] ) if table == 'sources' or 'source_id' in columns : # If printing, only get simple data types and exclude redundant 'source_id' for nicer printing if not fetch : columns = columns [ ( ( types == 'REAL' ) | ( types == 'INTEGER' ) | ( types == 'TEXT' ) ) & ( columns != 'source_id' ) ] # Query the table try : id = 'id' if table . lower ( ) == 'sources' else 'source_id' data = self . query ( "SELECT {} FROM {} WHERE {}={}" . format ( ',' . join ( columns ) , table , id , source_id ) , fmt = 'table' ) if not data and table . lower ( ) == 'sources' : print ( 'No source with id {}. Try db.search() to search the database for a source_id.' . format ( source_id ) ) except : data = None # If there's data for this table, save it if data : if fetch : data_tables [ table ] = self . query ( "SELECT {} FROM {} WHERE {}={}" . format ( ',' . join ( columns ) , table , id , source_id ) , fetch = True , fmt = fmt ) else : data = data [ [ c . lower ( ) for c in columns ] ] pprint ( data , title = table . upper ( ) ) else : pass except : print ( 'Could not retrieve data from {} table.' . format ( table . upper ( ) ) ) if fetch : return data_tables
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets a naive datetime from a datetime .<CODESPLIT>def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , "asdatetime" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts query strings into native Python objects<CODESPLIT>def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName<CODESPLIT>def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply last 2D transforms<CODESPLIT>def post_process ( self ) : self . image . putdata ( self . pixels ) self . image = self . image . transpose ( Image . ROTATE_90 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>OFFSET<CODESPLIT>def _adjust_offset ( self , real_wave_mfcc , algo_parameters ) : self . log ( u"Called _adjust_offset" ) self . _apply_offset ( offset = algo_parameters [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates a rough guess of runtime based on product of parameters<CODESPLIT>def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type .<CODESPLIT>def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if end - of - file is reached for file fd .<CODESPLIT>def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates rst codeblock for given text and language<CODESPLIT>def get_codeblock ( language , text ) : rst = "\n\n.. code-block:: " + language + "\n\n" for line in text . splitlines ( ) : rst += "\t" + line + "\n" rst += "\n" return rst
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>MoveWindow from Win32 . handle : int the handle of a native window . x : int . y : int . width : int . height : int . repaint : int use 1 or 0 . Return bool True if succeed otherwise False .<CODESPLIT>def MoveWindow ( handle : int , x : int , y : int , width : int , height : int , repaint : int = 1 ) -> bool : return bool ( ctypes . windll . user32 . MoveWindow ( ctypes . c_void_p ( handle ) , x , y , width , height , repaint ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Open a file .<CODESPLIT>def open_file ( file , mode ) : if hasattr ( file , "read" ) : return file if hasattr ( file , "open" ) : return file . open ( mode ) return open ( file , mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if we have a compatible fill_value and arr dtype then fill<CODESPLIT>def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the help text ( signature + docstring ) for a command ( function ) .<CODESPLIT>def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\x08' , '' , help_text ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace regex with string .<CODESPLIT>def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the unit tests on an installed copy of unyt .<CODESPLIT>def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )<CODESPLIT>def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method that escapes parameters to a SQL query .<CODESPLIT>def _escape ( s ) : e = s e = e . replace ( '\\' , '\\\\' ) e = e . replace ( '\n' , '\\n' ) e = e . replace ( '\r' , '\\r' ) e = e . replace ( "'" , "\\'" ) e = e . replace ( '"' , '\\"' ) return e
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply a function in parallel to each element of the input<CODESPLIT>def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given string starts with one of the prefixes in the given list otherwise return False .<CODESPLIT>def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the Hamming distance between two bit strings<CODESPLIT>def hamming_distance ( str1 , str2 ) : if len ( str1 ) != len ( str2 ) : raise VisualizationError ( 'Strings not same length.' ) return sum ( s1 != s2 for s1 , s2 in zip ( str1 , str2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function to display sympy expression using display style LaTeX in PNG .<CODESPLIT>def print_display_png ( o ) : s = latex ( o , mode = 'plain' ) s = s . strip ( '$' ) # As matplotlib does not support display style, dvipng backend is # used here. png = latex_to_png ( '$$%s$$' % s , backend = 'dvipng' ) return png
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the default bucket from a list of buckets i . e . the largest bucket .<CODESPLIT>def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace accentuated chars in string by their non accentuated equivalent .<CODESPLIT>def unaccentuate ( s ) : return "" . join ( c for c in unicodedata . normalize ( "NFKD" , s ) if not unicodedata . combining ( c ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Temporary helper function to link to the API routes<CODESPLIT>def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the window bounds from a tuple of ( x y w h )<CODESPLIT>def setRect ( self , rect ) : self . x , self . y , self . w , self . h = rect
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a column of the given matrix .<CODESPLIT>def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a column of the given matrix .<CODESPLIT>def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns current grid cursor cell ( row col tab )<CODESPLIT>def get_cursor ( self ) : return self . grid . GetGridCursorRow ( ) , self . grid . GetGridCursorCol ( ) , self . grid . current_table
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>!<CODESPLIT>def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get dimension of an array getting the number of rows and the max num of columns .<CODESPLIT>def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a set of unique n - grams from a string .<CODESPLIT>def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Search into instance attributes properties and return values of no - args methods .<CODESPLIT>def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts bokehJS timestamp to datetime64 .<CODESPLIT>def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the filename exists under the path .<CODESPLIT>def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose the most common item from the list or the first item if all items are unique .<CODESPLIT>def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>how high in sorted list each key is . inverse permutation of sorter such that sorted [ rank ] == keys<CODESPLIT>def rank ( self ) : r = np . empty ( self . size , np . int ) r [ self . sorter ] = np . arange ( self . size ) return r
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforma una string con elementos separados por sep en una lista .<CODESPLIT>def string_to_list ( string , sep = "," , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the SQL typename required to store the given FieldDefinition<CODESPLIT>def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the write permissions for the given file for owner groups and others .<CODESPLIT>def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def matrixTimesVector ( MM , aa ) : bb = np . zeros ( 3 , np . float ) for ii in range ( 3 ) : bb [ ii ] = np . sum ( MM [ ii , : ] * aa ) return bb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge any number of dictionaries<CODESPLIT>def merge_dict ( data , * args ) : results = { } for current in ( data , ) + args : results . update ( current ) return results
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns x rounded to n significant figures .<CODESPLIT>def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserialize s ( a str ) to a Python object .<CODESPLIT>def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the path always without the \\ ? \ prefix .<CODESPLIT>def path ( self ) : path = super ( WindowsPath2 , self ) . path if path . startswith ( "\\\\?\\" ) : return path [ 4 : ] return path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )<CODESPLIT>def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the attribute name identifier<CODESPLIT>def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize a file / dir name for comparison purposes<CODESPLIT>def normalize_path ( filename ) : return os . path . normcase ( os . path . realpath ( os . path . normpath ( _cygwin_patch ( filename ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A wrapper around tf multiplication that does more automatic casting of the input .<CODESPLIT>def mul ( a , b ) : def multiply ( a , b ) : """Multiplication""" return a * b return op_with_scalar_cast ( a , b , multiply )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert a code sequence to HTML<CODESPLIT>def make_html_code ( self , lines ) : line = code_header + '\n' for l in lines : line = line + html_quote ( l ) + '\n' return line + code_footer
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I convert strings into integers floats and strings!<CODESPLIT>def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminate the pool immediately .<CODESPLIT>def terminate ( self ) : if self . _pool is not None : self . _pool . terminate ( ) self . _pool . join ( ) self . _pool = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the returned Celery result from the Airflow task ID provided to the sensor and returns True if the celery result has been finished execution .<CODESPLIT>def _check_task_id ( self , context ) : ti = context [ 'ti' ] celery_result = ti . xcom_pull ( task_ids = self . target_task_id ) return celery_result . ready ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Expect a comment end and return the match object .<CODESPLIT>def expect_comment_end ( self ) : match = self . _expect_match ( '#}' , COMMENT_END_PATTERN ) self . advance ( match . end ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extracts all integers from a string an return them in a list<CODESPLIT>def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates one element of the collection<CODESPLIT>def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u"$set" in doc : doc = doc [ u"$set" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log out the active user<CODESPLIT>def logout ( ) : flogin . logout_user ( ) next = flask . request . args . get ( 'next' ) return flask . redirect ( next or flask . url_for ( "user" ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this a string .<CODESPLIT>def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from integers to strings<CODESPLIT>def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Subclassing hook to specialize how JSON data is converted to keyword arguments<CODESPLIT>def json_to_initkwargs ( self , json_data , kwargs ) : if isinstance ( json_data , basestring ) : json_data = json . loads ( json_data ) return json_to_initkwargs ( self , json_data , kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a numpy array of integers<CODESPLIT>def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip the whitespace from all column names in the given DataFrame and return the result .<CODESPLIT>def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if string could be a valid python identifier<CODESPLIT>def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper that returns if parent / item is a directory .<CODESPLIT>def _IsDirectory ( parent , item ) : return tf . io . gfile . isdir ( os . path . join ( parent , item ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the slice after at sub in string astr<CODESPLIT>def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normal cumulative density function .<CODESPLIT>def normcdf ( x , log = False ) : y = np . atleast_1d ( x ) . copy ( ) flib . normcdf ( y ) if log : if ( y > 0 ) . all ( ) : return np . log ( y ) return - np . inf return y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>shutdown : to be run by atexit handler . All open connection are closed .<CODESPLIT>def shutdown ( self ) : self . run_clean_thread = False self . cleanup ( True ) if self . cleaner_thread . isAlive ( ) : self . cleaner_thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does a string replace with a list of search and replacements<CODESPLIT>def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the path exists and false otherwise .<CODESPLIT>def exists ( self , path ) : import hdfs try : self . client . status ( path ) return True except hdfs . util . HdfsError as e : if str ( e ) . startswith ( 'File does not exist: ' ) : return False else : raise e
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Inserts a single document into a mongo collection https : // api . mongodb . com / python / current / api / pymongo / collection . html#pymongo . collection . Collection . insert_one<CODESPLIT>def insert_one ( self , mongo_collection , doc , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) return collection . insert_one ( doc , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms a list of 2 element tuples to a dictionary<CODESPLIT>def list2dict ( list_of_options ) : d = { } for key , value in list_of_options : d [ key ] = value return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict where the keys are all the values listed in the values of the original dict<CODESPLIT>def inverted_dict_of_lists ( d ) : new_dict = { } for ( old_key , old_value_list ) in viewitems ( dict ( d ) ) : for new_key in listify ( old_value_list ) : new_dict [ new_key ] = old_key return new_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .<CODESPLIT>def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if values are not increasing .<CODESPLIT>def non_increasing ( values ) : return all ( x >= y for x , y in zip ( values , values [ 1 : ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in string astr replace all occurences of thefind with thereplace<CODESPLIT>def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate str as a date and return string version of date<CODESPLIT>def _validate_date_str ( str_ ) : if not str_ : return None # Convert to datetime so we can validate it's a real date that exists then # convert it back to the string. try : date = datetime . strptime ( str_ , DATE_FMT ) except ValueError : msg = 'Invalid date format, should be YYYY-MM-DD' raise argparse . ArgumentTypeError ( msg ) return date . strftime ( DATE_FMT )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of characters at the beginning of text that are whitespace .<CODESPLIT>def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a dict of 1d array to a numpy recarray<CODESPLIT>def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the provided array or dtype is of the string dtype .<CODESPLIT>def is_string_dtype ( arr_or_dtype ) : # TODO: gh-15585: consider making the checks stricter. def condition ( dtype ) : return dtype . kind in ( 'O' , 'S' , 'U' ) and not is_period_dtype ( dtype ) return _is_dtype ( arr_or_dtype , condition )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates .<CODESPLIT>def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tries to load an encoded json string back into an object : param json_string : : return :<CODESPLIT>def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to get the location of a Python file .<CODESPLIT>def getScriptLocation ( ) : location = os . path . abspath ( "./" ) if __file__ . rfind ( "/" ) != - 1 : location = __file__ [ : __file__ . rfind ( "/" ) ] return location
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () .<CODESPLIT>def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .<CODESPLIT>def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an iterator over the values of a dictionary .<CODESPLIT>def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits string into n sized chunks .<CODESPLIT>def schunk ( string , size ) : return [ string [ i : i + size ] for i in range ( 0 , len ( string ) , size ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal helper to return the values of a dictionary sorted by key .<CODESPLIT>def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a leading hash # at the beginning of every line in the source .<CODESPLIT>def _add_hash ( source ) : source = '\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return n size lists from a given list l<CODESPLIT>def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert val into a local datetime for tz Europe / Amsterdam .<CODESPLIT>def __to_localdatetime ( val ) : try : dt = datetime . strptime ( val , __DATE_FORMAT ) dt = pytz . timezone ( __TIMEZONE ) . localize ( dt ) return dt except ( ValueError , TypeError ) : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hex encode a binary string<CODESPLIT>def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts DB - API parameter values into query parameters .<CODESPLIT>def to_query_parameters ( parameters ) : if parameters is None : return [ ] if isinstance ( parameters , collections_abc . Mapping ) : return to_query_parameters_dict ( parameters ) return to_query_parameters_list ( parameters )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>from http : // stackoverflow . com / a / 14033137 / 623735 # gets the indices of the rows with nan values in a dataframe pd . isnull ( df ) . any ( 1 ) . nonzero () [ 0 ]<CODESPLIT>def table_nan_locs ( table ) : ans = [ ] for rownum , row in enumerate ( table ) : try : if pd . isnull ( row ) . any ( ) : colnums = pd . isnull ( row ) . nonzero ( ) [ 0 ] ans += [ ( rownum , colnum ) for colnum in colnums ] except AttributeError : # table is really just a sequence of scalars if pd . isnull ( row ) : ans += [ ( rownum , 0 ) ] return ans
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set cursor position<CODESPLIT>def set_cursor_position ( self , position ) : position = self . get_position ( position ) cursor = self . textCursor ( ) cursor . setPosition ( position ) self . setTextCursor ( cursor ) self . ensureCursorVisible ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the pythonic string type .<CODESPLIT>def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Return variable as a string to print with given precision .<CODESPLIT>def _strvar ( a , prec = '{:G}' ) : return ' ' . join ( [ prec . format ( i ) for i in np . atleast_1d ( a ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space .<CODESPLIT>def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokenizes * source * and returns the tokens as a list of lists .<CODESPLIT>def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the month start date a nd end date<CODESPLIT>def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field is not None .<CODESPLIT>def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether path is a directory to which the user has write access .<CODESPLIT>def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>linear regression calculation<CODESPLIT>def linregress ( x , y , return_stats = False ) : a1 , a0 , r_value , p_value , stderr = scipy . stats . linregress ( x , y ) retval = a1 , a0 if return_stats : retval += r_value , p_value , stderr return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merges two with identical columns .<CODESPLIT>def __add__ ( self , other ) : new_table = copy . copy ( self ) for row in other : new_table . Append ( row ) return new_table
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deinitialises the PulseIn and releases any hardware and software resources for reuse .<CODESPLIT>def deinit ( self ) : # Clean up after ourselves self . _process . terminate ( ) procs . remove ( self . _process ) self . _mq . remove ( ) queues . remove ( self . _mq )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provide a 2D block view to 2D array .<CODESPLIT>def block_view ( arr , block = ( 3 , 3 ) ) : # simple shape and strides computations may seem at first strange # unless one is able to recognize the 'tuple additions' involved ;-) shape = ( arr . shape [ 0 ] // block [ 0 ] , arr . shape [ 1 ] // block [ 1 ] ) + block strides = ( block [ 0 ] * arr . strides [ 0 ] , block [ 1 ] * arr . strides [ 1 ] ) + arr . strides return ast ( arr , shape = shape , strides = strides )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Should we skip logging for this handler?<CODESPLIT>def should_skip_logging ( func ) : disabled = strtobool ( request . headers . get ( "x-request-nolog" , "false" ) ) return disabled or getattr ( func , SKIP_LOGGING , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if arg is valid value for the class . If the string value is wrong for the enumeration the encoding will fail .<CODESPLIT>def is_valid ( cls , arg ) : return ( isinstance ( arg , ( int , long ) ) and ( arg >= 0 ) ) or isinstance ( arg , basestring )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get string from file .<CODESPLIT>def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the number of non - NA in this array along the given axis or axes<CODESPLIT>def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the largest real value h such that all elements in x are integer multiples of h .<CODESPLIT>def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns Gaussian smoothed image .<CODESPLIT>def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = "nearest" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If values in a series match a specified value change them to np . nan .<CODESPLIT>def na_if ( series , * values ) : series = pd . Series ( series ) series [ series . isin ( values ) ] = np . nan return series
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Covert numpy array to tensorflow tensor<CODESPLIT>def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>FOR USE BY PROCESSES THAT NEVER DIE UNLESS EXTERNAL SHUTDOWN IS REQUESTED<CODESPLIT>def wait_for_shutdown_signal ( self , please_stop = False , # ASSIGN SIGNAL TO STOP EARLY allow_exit = False , # ALLOW "exit" COMMAND ON CONSOLE TO ALSO STOP THE APP wait_forever = True # IGNORE CHILD THREADS, NEVER EXIT.  False => IF NO CHILD THREADS LEFT, THEN EXIT ) : self_thread = Thread . current ( ) if self_thread != MAIN_THREAD or self_thread != self : Log . error ( "Only the main thread can sleep forever (waiting for KeyboardInterrupt)" ) if isinstance ( please_stop , Signal ) : # MUTUAL SIGNALING MAKES THESE TWO EFFECTIVELY THE SAME SIGNAL self . please_stop . on_go ( please_stop . go ) please_stop . on_go ( self . please_stop . go ) else : please_stop = self . please_stop if not wait_forever : # TRIGGER SIGNAL WHEN ALL CHILDREN THEADS ARE DONE with self_thread . child_lock : pending = copy ( self_thread . children ) children_done = AndSignals ( please_stop , len ( pending ) ) children_done . signal . on_go ( self . please_stop . go ) for p in pending : p . stopped . on_go ( children_done . done ) try : if allow_exit : _wait_for_exit ( please_stop ) else : _wait_for_interrupt ( please_stop ) except KeyboardInterrupt as _ : Log . alert ( "SIGINT Detected!  Stopping..." ) except SystemExit as _ : Log . alert ( "SIGTERM Detected!  Stopping..." ) finally : self . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bernstein polynomial .<CODESPLIT>def Bernstein ( n , k ) : coeff = binom ( n , k ) def _bpoly ( x ) : return coeff * x ** k * ( 1 - x ) ** ( n - k ) return _bpoly
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple from parsing a b c d - > ( a b c d )<CODESPLIT>def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate time delta from latched time and current time<CODESPLIT>def elapsed_time_from ( start_time ) : time_then = make_time ( start_time ) time_now = datetime . utcnow ( ) . replace ( microsecond = 0 ) if time_then is None : return delta_t = time_now - time_then return delta_t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert file extension to lowercase .<CODESPLIT>def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Banana banana<CODESPLIT>def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s="%s"' % ( k , v ) for k , v in dict_ . items ( ) ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serve the datasets in a directory over HTTP .<CODESPLIT>def serve_dtool_directory ( directory , port ) : os . chdir ( directory ) server_address = ( "localhost" , port ) httpd = DtoolHTTPServer ( server_address , DtoolHTTPRequestHandler ) httpd . serve_forever ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the unit tests on an installed copy of unyt .<CODESPLIT>def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render an INPUT element of type SUBMIT which will post this form to the server .<CODESPLIT>def submitbutton ( self , request , tag ) : return tags . input ( type = 'submit' , name = '__submit__' , value = self . _getDescription ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7<CODESPLIT>def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG<CODESPLIT>def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Order the words from vocab by distinctiveness score ( Chuang et al . 2012 ) from least to most distinctive . Optionally only return the n least distinctive words .<CODESPLIT>def get_least_distinct_words ( vocab , topic_word_distrib , doc_topic_distrib , doc_lengths , n = None ) : return _words_by_distinctiveness_score ( vocab , topic_word_distrib , doc_topic_distrib , doc_lengths , n , least_to_most = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closest distance between a line segment and a point<CODESPLIT>def distance_to_line ( a , b , p ) : return distance ( closest_point ( a , b , p ) , p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check for semicolons at the end of lines .<CODESPLIT>def endline_semicolon_check ( self , original , loc , tokens ) : return self . check_strict ( "semicolon at end of line" , original , loc , tokens )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure that param_list is a list with the expected length . Raises a helpful ValueError if this is not the case .<CODESPLIT>def check_type_and_size_of_param_list ( param_list , expected_length ) : try : assert isinstance ( param_list , list ) assert len ( param_list ) == expected_length except AssertionError : msg = "param_list must be a list containing {} elements." raise ValueError ( msg . format ( expected_length ) ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Configuration - friendly boolean type converter .<CODESPLIT>def boolean ( value ) : if isinstance ( value , bool ) : return value if value == "" : return False return strtobool ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set window top - left corner position and size<CODESPLIT>def set_position ( self , x , y , width , height ) : SetWindowPos ( self . _hwnd , None , x , y , width , height , ctypes . c_uint ( 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a section a subsection and some text to the document .<CODESPLIT>def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param filename : The filename of the file to process : returns : The MD5 hash of the file<CODESPLIT>def file_md5sum ( filename ) : hash_md5 = hashlib . md5 ( ) with open ( filename , 'rb' ) as f : for chunk in iter ( lambda : f . read ( 1024 * 4 ) , b'' ) : hash_md5 . update ( chunk ) return hash_md5 . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the billing cycle prior to this one . May return None<CODESPLIT>def get_previous ( self ) : return BillingCycle . objects . filter ( date_range__lt = self . date_range ) . order_by ( 'date_range' ) . last ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param unicode fpath : : param unicode encoding : : rtype : dict | list<CODESPLIT>def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For Python3 compatibility of generator .<CODESPLIT>def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pad the text .<CODESPLIT>def _pad ( self , text ) : top_bottom = ( "\n" * self . _padding ) + " " right_left = " " * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check for Python 3 nonlocal statement .<CODESPLIT>def nonlocal_check ( self , original , loc , tokens ) : return self . check_py ( "3" , "nonlocal statement" , original , loc , tokens )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send a complete request to the server .<CODESPLIT>def request ( self , method , url , body = None , headers = { } ) : self . _send_request ( method , url , body , headers )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw<CODESPLIT>def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a object into dictionary with all of its readable attributes .<CODESPLIT>def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}<CODESPLIT>def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode .<CODESPLIT>def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a pandas . Series into an xarray . DataArray .<CODESPLIT>def from_series ( cls , series ) : # TODO: add a 'name' parameter name = series . name df = pd . DataFrame ( { name : series } ) ds = Dataset . from_dataframe ( df ) return ds [ name ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of bytes to represent this dtype .<CODESPLIT>def size ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'size' ) : return dtype . size return np . dtype ( dtype ) . itemsize
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform actions before parent main window is closed<CODESPLIT>def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load an object from a module by name<CODESPLIT>def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms an XML string it to python - zimbra dict format<CODESPLIT>def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a public RSA key from a PEM file .<CODESPLIT>def import_public_rsa_key_from_file ( filename ) : with open ( filename , "rb" ) as key_file : public_key = serialization . load_pem_public_key ( key_file . read ( ) , backend = default_backend ( ) ) return public_key
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a tuple ( hash and commit object )<CODESPLIT>def last_commit ( self ) -> Tuple : from libs . repos import git return git . get_last_commit ( repo_path = self . path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove commas from a float<CODESPLIT>def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a 1D list to a single long string for file output using the string . join function .<CODESPLIT>def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lookup a transitive parent object that is an instance of a given class .<CODESPLIT>def _lookup_parent ( self , cls ) : codeobj = self . parent while codeobj is not None and not isinstance ( codeobj , cls ) : codeobj = codeobj . parent return codeobj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Singleton definition .<CODESPLIT>def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check whether the item is list ( tuple ) and consist of list ( tuple ) elements<CODESPLIT>def is_list_of_list ( item ) : if ( type ( item ) in ( list , tuple ) and len ( item ) and isinstance ( item [ 0 ] , ( list , tuple ) ) ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a file is empty or not .<CODESPLIT>def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dot product of two vectors<CODESPLIT>def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .<CODESPLIT>def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts query strings into native Python objects<CODESPLIT>def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run manage . py using this component s specific Django settings<CODESPLIT>def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like dict . update but does not overwrite items<CODESPLIT>def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the title on the underlying matplotlib AxesSubplot .<CODESPLIT>def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all unwanted characters from text .<CODESPLIT>def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last weekday in a given month . e . g :<CODESPLIT>def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply the argument parser .<CODESPLIT>def apply_argument_parser ( argumentsParser , options = None ) : if options is not None : args = argumentsParser . parse_args ( options ) else : args = argumentsParser . parse_args ( ) return args
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run all Tests [ nose ]<CODESPLIT>def test ( ) : command = 'nosetests --with-coverage --cover-package=pwnurl' status = subprocess . call ( shlex . split ( command ) ) sys . exit ( status )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - negative integer .<CODESPLIT>def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to get bins for histplot .<CODESPLIT>def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pad the text .<CODESPLIT>def _pad ( self , text ) : top_bottom = ( "\n" * self . _padding ) + " " right_left = " " * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Order the words from vocab by distinctiveness score ( Chuang et al . 2012 ) from least to most distinctive . Optionally only return the n least distinctive words .<CODESPLIT>def get_least_distinct_words ( vocab , topic_word_distrib , doc_topic_distrib , doc_lengths , n = None ) : return _words_by_distinctiveness_score ( vocab , topic_word_distrib , doc_topic_distrib , doc_lengths , n , least_to_most = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>find the common elements in two lists . used to support auto align might be faster with sets<CODESPLIT>def get_common_elements ( list1 , list2 ) : #result = [] #for item in list1: #    if item in list2: #        result.append(item) #Return list(set(list1).intersection(set(list2))) set2 = set ( list2 ) result = [ item for item in list1 if item in set2 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The function compares strings ignoring case<CODESPLIT>def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wanted functionality from Counters ( new in Python 2 . 7 ) .<CODESPLIT>def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply Gaussian blur to the given data .<CODESPLIT>def GaussianBlur ( X , ksize_width , ksize_height , sigma_x , sigma_y ) : return image_transform ( X , cv2 . GaussianBlur , ksize = ( ksize_width , ksize_height ) , sigmaX = sigma_x , sigmaY = sigma_y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a Flask Response object containing a JSON representation of * resource * .<CODESPLIT>def jsonify ( resource ) : response = flask . jsonify ( resource . to_dict ( ) ) response = add_link_headers ( response , resource . links ( ) ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether a certain column exists<CODESPLIT>def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : img ( PIL Image ) : Image to be padded .<CODESPLIT>def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string from snake case to camel case .<CODESPLIT>def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Populate axis limits GUI with current plot values .<CODESPLIT>def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple from parsing a b c d - > ( a b c d )<CODESPLIT>def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Directly send utf8 bytes to stdout<CODESPLIT>def imp_print ( self , text , end ) : sys . stdout . write ( ( text + end ) . encode ( "utf-8" ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator for JSON - per - line in a file pattern<CODESPLIT>def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn an SQLAlchemy model into a dict of field names and values .<CODESPLIT>def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the last line of the document .<CODESPLIT>def remove_last_line ( self ) : editor = self . _editor text_cursor = editor . textCursor ( ) text_cursor . movePosition ( text_cursor . End , text_cursor . MoveAnchor ) text_cursor . select ( text_cursor . LineUnderCursor ) text_cursor . removeSelectedText ( ) text_cursor . deletePreviousChar ( ) editor . setTextCursor ( text_cursor )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing whitespace on each line .<CODESPLIT>def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\n' ) ] return '\n' . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the login credentials from the user if not specified while invoking the script .<CODESPLIT>def get_login_credentials ( args ) : if not args . username : args . username = raw_input ( "Enter Username: " ) if not args . password : args . password = getpass . getpass ( "Enter Password: " )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips trailing whitespace from string lowercases it and replaces spaces with underscores<CODESPLIT>def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\W+' , '_' , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a smt bit vector that represents a memory location .<CODESPLIT>def get_memory ( self , mode ) : mem = { "pre" : self . _translator . get_memory_init ( ) , "post" : self . _translator . get_memory_curr ( ) , } return mem [ mode ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a list of the top topn features in this : class : . Feature \ .<CODESPLIT>def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a symlink . Used for model shortcut links .<CODESPLIT>def symlink_remove ( link ) : # https://stackoverflow.com/q/26554135/6400719 if os . path . isdir ( path2str ( link ) ) and is_windows : # this should only be on Py2.7 and windows os . rmdir ( path2str ( link ) ) else : os . unlink ( path2str ( link ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the file is binary<CODESPLIT>def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\0' in data : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalized Gaussian<CODESPLIT>def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns names of object columns in the DataFrame .<CODESPLIT>def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to byte string .<CODESPLIT>def _to_bstr ( l ) : if isinstance ( l , str ) : l = l . encode ( 'ascii' , 'backslashreplace' ) elif not isinstance ( l , bytes ) : l = str ( l ) . encode ( 'ascii' , 'backslashreplace' ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provide a password prompt .<CODESPLIT>def getpass ( self , prompt , default = None ) : return click . prompt ( prompt , hide_input = True , default = default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return view of the recarray with all int32 cast to int64 .<CODESPLIT>def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Represent string / bytes s as base64 omitting newlines<CODESPLIT>def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( "utf-8" ) return binascii . b2a_base64 ( s ) [ : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of JSON values to a list of models<CODESPLIT>def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to read JSON file as OrderedDict<CODESPLIT>def _read_json_file ( self , json_file ) : self . log . debug ( "Reading '%s' JSON file..." % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a float to a precision<CODESPLIT>def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs the permission check .<CODESPLIT>def perform_permissions_check ( self , user , obj , perms ) : return self . request . forum_permission_handler . can_download_files ( obj , user )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scroll both categories Canvas and scrolling container<CODESPLIT>def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Paginate queryset .<CODESPLIT>def paginate ( self , request , offset = 0 , limit = None ) : return self . collection . offset ( offset ) . limit ( limit ) , self . collection . count ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if obj is a sequence but not a string or bytes .<CODESPLIT>def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Counts the word frequences in a list of sentences .<CODESPLIT>def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ctypes double pointer array to a numpy array .<CODESPLIT>def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sets the aspect ratio of the current zoom level of the imshow image<CODESPLIT>def image_set_aspect ( aspect = 1.0 , axes = "gca" ) : if axes is "gca" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for inserting int64 features into Example proto .<CODESPLIT>def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output<CODESPLIT>def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Respond to the client with a 301 message and redirect them with a Location header .<CODESPLIT>def respond_redirect ( self , location = '/' ) : self . send_response ( 301 ) self . send_header ( 'Content-Length' , 0 ) self . send_header ( 'Location' , location ) self . end_headers ( ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Repeat each item in iterable n times .<CODESPLIT>def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets<CODESPLIT>def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn bytes into base64<CODESPLIT>def bytes_base64 ( x ) : if six . PY2 : return base64 . encodestring ( x ) . replace ( '\n' , '' ) return base64 . encodebytes ( bytes_encode ( x ) ) . replace ( b'\n' , b'' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert notebook to python script<CODESPLIT>def nb_to_python ( nb_path ) : exporter = python . PythonExporter ( ) output , resources = exporter . from_filename ( nb_path ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a file and close it . Returns the file source .<CODESPLIT>def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Magnitude of a complex matrix .<CODESPLIT>def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively iterate through values in nested lists .<CODESPLIT>def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if this GO object has a parent GO ID .<CODESPLIT>def has_parent ( self , term ) : for parent in self . parents : if parent . item_id == term or parent . has_parent ( term ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flush the buffer and finalize the file .<CODESPLIT>def close ( self ) : if not self . closed : self . closed = True self . _flush ( finish = True ) self . _buffer = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Store the given custom value and call the setter function .<CODESPLIT>def call_fset ( self , obj , value ) -> None : vars ( obj ) [ self . name ] = self . fset ( obj , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Release lock on compilation directory .<CODESPLIT>def release_lock ( ) : get_lock . n_lock -= 1 assert get_lock . n_lock >= 0 # Only really release lock once all lock requests have ended. if get_lock . lock_is_enabled and get_lock . n_lock == 0 : get_lock . start_time = None get_lock . unlocker . unlock ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare by iteration<CODESPLIT>def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert version like string to a tuple of integers .<CODESPLIT>def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\D+' , value ) if _f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates data is a timestamp<CODESPLIT>def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maxheap version of a heappop .<CODESPLIT>def heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads UTF8 string : param reader : : return :<CODESPLIT>async def load_unicode ( reader ) : ivalue = await load_uvarint ( reader ) fvalue = bytearray ( ivalue ) await reader . areadinto ( fvalue ) return str ( fvalue , 'utf8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rewind the file to the start of the body ( if seekable ) .<CODESPLIT>def rewindbody ( self ) : if not self . seekable : raise IOError , "unseekable file" self . fp . seek ( self . startofbody )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check features data are not empty<CODESPLIT>def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the event loop .<CODESPLIT>def run ( self ) : self . signal_init ( ) self . listen_init ( ) self . logger . info ( 'starting' ) self . loop . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print just one that returns what you give it instead of None<CODESPLIT>def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print the message to the predefined log file without newline<CODESPLIT>def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output a networkx graph to a DOT file .<CODESPLIT>def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .<CODESPLIT>def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the http method that will be called from the requests library<CODESPLIT>def get_http_method ( self , method ) : return self . http_methods [ method ] ( self . url , * * self . http_method_args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Init a noise variable .<CODESPLIT>def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .<CODESPLIT>def input_int_default ( question = "" , default = 0 ) : answer = input_string ( question ) if answer == "" or answer == "yes" : return default else : return int ( answer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like map but also chains the results .<CODESPLIT>def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks to see if list is equal everywhere<CODESPLIT>def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the table names in the database .<CODESPLIT>def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( "SELECT name FROM sqlite_master WHERE type == 'table'" ) return [ name for ( name , ) in cursor ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the variance of values in a series .<CODESPLIT>def var ( series ) : if np . issubdtype ( series . dtype , np . number ) : return series . var ( ) else : return np . nan
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>underscore to mixed case notation<CODESPLIT>def case_us2mc ( x ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the title of the console window .<CODESPLIT>def title ( msg ) : if sys . platform . startswith ( "win" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads the images and latent values into Numpy arrays .<CODESPLIT>def _load_data ( filepath ) : with h5py . File ( filepath , "r" ) as h5dataset : image_array = np . array ( h5dataset [ "images" ] ) # The 'label' data set in the hdf5 file actually contains the float values # and not the class labels. values_array = np . array ( h5dataset [ "labels" ] ) return image_array , values_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage .<CODESPLIT>def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a region from a numpy array . : param array : : class : numpy . ndarray : param identifier : value representing the region to select in the array : returns : : class : jicimagelib . region . Region<CODESPLIT>def select_from_array ( cls , array , identifier ) : base_array = np . zeros ( array . shape ) array_coords = np . where ( array == identifier ) base_array [ array_coords ] = 1 return cls ( base_array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize representation of the table for local caching .<CODESPLIT>def to_dict ( self ) : return { 'schema' : self . schema , 'name' : self . name , 'columns' : [ col . to_dict ( ) for col in self . _columns ] , 'foreign_keys' : self . foreign_keys . to_dict ( ) , 'ref_keys' : self . ref_keys . to_dict ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the value of a float property .<CODESPLIT>def get_property_as_float ( self , name : str ) -> float : return float ( self . __instrument . get_property ( name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks for local config overrides for pylint and add them in the correct pylint options format .<CODESPLIT>def get_pylint_options ( config_dir = '.' ) : # type: (str) -> List[str] if PYLINT_CONFIG_NAME in os . listdir ( config_dir ) : pylint_config_path = PYLINT_CONFIG_NAME else : pylint_config_path = DEFAULT_PYLINT_CONFIG_PATH return [ '--rcfile={}' . format ( pylint_config_path ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build descriptor for Enum instance .<CODESPLIT>def describe_enum_value ( enum_value ) : enum_value_descriptor = EnumValueDescriptor ( ) enum_value_descriptor . name = six . text_type ( enum_value . name ) enum_value_descriptor . number = enum_value . number return enum_value_descriptor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the path distance from given set of points<CODESPLIT>def path_distance ( points ) : vecs = np . diff ( points , axis = 0 ) [ : , : 3 ] d2 = [ np . dot ( p , p ) for p in vecs ] return np . sum ( np . sqrt ( d2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test two dictionary is equal on values . ( ignore order )<CODESPLIT>def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts list to string with comma separated values . For string is no - op .<CODESPLIT>def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = "," . join ( value ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True<CODESPLIT>def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert spherical coordinates to cartesian unit vectors .<CODESPLIT>def angle_to_cartesian ( lon , lat ) : theta = np . array ( np . pi / 2. - lat ) return np . vstack ( ( np . sin ( theta ) * np . cos ( lon ) , np . sin ( theta ) * np . sin ( lon ) , np . cos ( theta ) ) ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a : py : class : datetime . datetime instance representing the current time .<CODESPLIT>def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rotate a 3D vector using quaternion algebra .<CODESPLIT>def qrot ( vector , quaternion ) : t = 2 * np . cross ( quaternion [ 1 : ] , vector ) v_rot = vector + quaternion [ 0 ] * t + np . cross ( quaternion [ 1 : ] , t ) return v_rot
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yields file name if matches a regular expression pattern .<CODESPLIT>def match_files ( files , pattern : Pattern ) : for name in files : if re . match ( pattern , name ) : yield name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for iterating numpy array<CODESPLIT>def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ "refs_ok" ] ) : c = a . item ( ) if c is not None : yield c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detokenize a string by removing spaces before punctuation .<CODESPLIT>def detokenize ( s ) : print ( s ) s = re . sub ( "\s+([;:,\.\?!])" , "\\1" , s ) s = re . sub ( "\s+(n't)" , "\\1" , s ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dotproduct between self and another vector .<CODESPLIT>def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restores the state of the batched queue for writing .<CODESPLIT>def enable_writes ( self ) : self . write_buffer = [ ] self . flush_lock = threading . RLock ( ) self . flush_thread = FlushThread ( self . max_batch_time , self . _flush_writes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Repeat each item in iterable n times .<CODESPLIT>def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the boundaries from a list of indexes<CODESPLIT>def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill NaNs with the previous value the next value or if all are NaN then 1 . 0<CODESPLIT>def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns names of object columns in the DataFrame .<CODESPLIT>def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the python representation of the obj<CODESPLIT>def _decode ( self , obj , context ) : return b'' . join ( map ( int2byte , [ c + 0x60 for c in bytearray ( obj ) ] ) ) . decode ( "utf8" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the maximum length of each column in the field table<CODESPLIT>def getFieldsColumnLengths ( self ) : nameLen = 0 descLen = 0 for f in self . fields : nameLen = max ( nameLen , len ( f [ 'title' ] ) ) descLen = max ( descLen , len ( f [ 'description' ] ) ) return ( nameLen , descLen )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a Mapper 1 - complex to a networkx graph .<CODESPLIT>def to_networkx ( graph ) : # import here so networkx is not always required. import networkx as nx nodes = graph [ "nodes" ] . keys ( ) edges = [ [ start , end ] for start , ends in graph [ "links" ] . items ( ) for end in ends ] g = nx . Graph ( ) g . add_nodes_from ( nodes ) nx . set_node_attributes ( g , dict ( graph [ "nodes" ] ) , "membership" ) g . add_edges_from ( edges ) return g
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To know the allocated memory at function termination .<CODESPLIT>def memory_used ( self ) : if self . _end_memory : memory_used = self . _end_memory - self . _start_memory return memory_used else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes a : py : class : . Series from the chart .<CODESPLIT>def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( "Cannot remove last series from %s" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper to clean up an input string<CODESPLIT>def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pop the heap value from the heap .<CODESPLIT>def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - negative integer .<CODESPLIT>def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a repr () for a list / tuple<CODESPLIT>def _tuple_repr ( data ) : if len ( data ) == 1 : return "(%s,)" % rpr ( data [ 0 ] ) else : return "(%s)" % ", " . join ( [ rpr ( x ) for x in data ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>WeChat access token<CODESPLIT>def access_token ( self ) : access_token = self . session . get ( self . access_token_key ) if access_token : if not self . expires_at : # user provided access_token, just return it return access_token timestamp = time . time ( ) if self . expires_at - timestamp > 60 : return access_token self . fetch_access_token ( ) return self . session . get ( self . access_token_key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the eigvals of mat and then find the center eigval difference .<CODESPLIT>def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a representation of the case in the Graphviz DOT language .<CODESPLIT>def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an item from a dict which contains just one item .<CODESPLIT>def get_single_item ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . iteritems ( d ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create environ dictionary from current os . environ and variables got from given env_file<CODESPLIT>def create_env ( env_file ) : environ = { } with open ( env_file , 'r' ) as f : for line in f . readlines ( ) : line = line . rstrip ( os . linesep ) if '=' not in line : continue if line . startswith ( '#' ) : continue key , value = line . split ( '=' , 1 ) environ [ key ] = parse_value ( value ) return environ
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This strategy uses an exponential approximation for cut - off frequency calculation found by matching the one - pole Laplace lowpass filter and mirroring the resulting filter to get a highpass .<CODESPLIT>def highpass ( cutoff ) : R = thub ( exp ( cutoff - pi ) , 2 ) return ( 1 - R ) / ( 1 + R * z ** - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Counts the word frequences in a list of sentences .<CODESPLIT>def count_words ( file ) : c = Counter ( ) with open ( file , 'r' ) as f : for l in f : words = l . strip ( ) . split ( ) c . update ( words ) return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns date range for the previous full month .<CODESPLIT>def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns January 1 of the given year .<CODESPLIT>def get_year_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( month = 1 ) . replace ( day = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An iterable of column names for a particular table or view .<CODESPLIT>def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifies column header format to be importable into a database : param column : raw column header : return : cleanedcolumn : reformatted column header<CODESPLIT>def columnclean ( column ) : cleanedcolumn = str ( column ) . replace ( '%' , 'percent' ) . replace ( '(' , '_' ) . replace ( ')' , '' ) . replace ( 'As' , 'Adenosines' ) . replace ( 'Cs' , 'Cytosines' ) . replace ( 'Gs' , 'Guanines' ) . replace ( 'Ts' , 'Thymines' ) . replace ( 'Ns' , 'Unknowns' ) . replace ( 'index' , 'adapterIndex' ) return cleanedcolumn
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes JSON formatted data converting it into native Python objects<CODESPLIT>def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A handy wrapper to get a remote file content<CODESPLIT>def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix inversion op .<CODESPLIT>def MatrixInverse ( a , adj ) : return np . linalg . inv ( a if not adj else _adjoint ( a ) ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a given file is available in the cache or not<CODESPLIT>def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like rotate but modifies l in - place .<CODESPLIT>def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param min_value : minimum value for update ( .. ) : param format : format specifier for the output : param width : width of the progress bar s ( excluding extra text ) : param barchar : character used to print the bar : param output : where to write the output to<CODESPLIT>def __init__ ( self , min_value , max_value , format = "%(bar)s: %(percentage) 6.2f%% %(timeinfo)s" , width = 40 , barchar = "#" , emptychar = "-" , output = sys . stdout ) : self . min_value = min_value self . max_value = max_value self . format = format self . width = width self . barchar = barchar self . emptychar = emptychar self . output = output self . firsttime = True self . prevtime = time . time ( ) self . starttime = self . prevtime self . prevfraction = 0 self . firsttimedone = False self . value = self . min_value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get longitudes from cartesian coordinates .<CODESPLIT>def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get letters from string only .<CODESPLIT>def return_letters_from_string ( text ) : out = "" for letter in text : if letter . isalpha ( ) : out += letter return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run a Tensorflow model on the Iris dataset .<CODESPLIT>def main ( argv = None ) : args = parse_arguments ( sys . argv if argv is None else argv ) tf . logging . set_verbosity ( tf . logging . INFO ) learn_runner . run ( experiment_fn = get_experiment_fn ( args ) , output_dir = args . job_dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear the database .<CODESPLIT>def delete_all_from_db ( ) : # The models.CASCADE property is set on all ForeignKey fields, so tables can # be deleted in any order without breaking constraints. for model in django . apps . apps . get_models ( ) : model . objects . all ( ) . delete ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>renders context aware template<CODESPLIT>def render_template ( content , context ) : rendered = Template ( content ) . render ( Context ( context ) ) return rendered
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an ARF timestamp to a datetime . datetime object ( naive local time )<CODESPLIT>def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Intersect dictionaries d1 and d2 by key * and * value .<CODESPLIT>def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the moving average of an array .<CODESPLIT>def moving_average ( array , n = 3 ) : ret = _np . cumsum ( array , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get domain part of an url .<CODESPLIT>def get_domain ( url ) : parse_result = urlparse ( url ) domain = "{schema}://{netloc}" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the width of the table that would be printed . : rtype : int<CODESPLIT>def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dictionary d s repr but with the items sorted . >>> pretty_dict ( { m : M a : A r : R k : K } ) { a : A k : K m : M r : R } >>> pretty_dict ( { z : C y : B x : A } ) { x : A y : B z : C }<CODESPLIT>def pretty_dict ( d ) : return '{%s}' % ', ' . join ( '%r: %r' % ( k , v ) for k , v in sorted ( d . items ( ) , key = repr ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Intended to be used going into post mortem routines . If sys . last_traceback is set we will return that and assume that this is what post - mortem will want . If sys . last_traceback has not been set then perhaps we * about * to raise an error and are fielding an exception . So assume that sys . exc_info () [ 2 ] is where we want to look .<CODESPLIT>def get_last_or_frame_exception ( ) : try : if inspect . istraceback ( sys . last_traceback ) : # We do have a traceback so prefer that. return sys . last_type , sys . last_value , sys . last_traceback except AttributeError : pass return sys . exc_info ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a list of strings and clear whitespace on each one . If a value in the list is not a string pass it through untouched .<CODESPLIT>def clean_strings ( iterable ) : retval = [ ] for val in iterable : try : retval . append ( val . strip ( ) ) except ( AttributeError ) : retval . append ( val ) return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used with lambda to sort fields<CODESPLIT>def es_field_sort ( fld_name ) : parts = fld_name . split ( "." ) if "_" not in parts [ - 1 ] : parts [ - 1 ] = "_" + parts [ - 1 ] return "." . join ( parts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from list while preserving order .<CODESPLIT>def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace boolean variables by the characters F / T<CODESPLIT>def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print all INDRA Statements collected by the processors .<CODESPLIT>def print_statements ( self ) : for i , stmt in enumerate ( self . statements ) : print ( "%s: %s" % ( i , stmt ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes a classname .<CODESPLIT>def js_classnameify ( s ) : if not '_' in s : return s return '' . join ( w [ 0 ] . upper ( ) + w [ 1 : ] . lower ( ) for w in s . split ( '_' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get domain part of an url .<CODESPLIT>def get_domain ( url ) : parse_result = urlparse ( url ) domain = "{schema}://{netloc}" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a horizontal line up to a given length .<CODESPLIT>def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip agents from a string .<CODESPLIT>def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforma una string con elementos separados por sep en una lista .<CODESPLIT>def string_to_list ( string , sep = "," , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not<CODESPLIT>def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = "json" ) is_json = True except : is_json = False return ( is_json )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display productpage with normal user and test user buttons<CODESPLIT>def index ( ) : global productpage table = json2html . convert ( json = json . dumps ( productpage ) , table_attributes = "class=\"table table-condensed table-bordered table-hover\"" ) return render_template ( 'index.html' , serviceTable = table )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the last stack element and delete it from the list<CODESPLIT>def pop ( self ) : if not self . empty ( ) : val = self . stack [ - 1 ] del self . stack [ - 1 ] return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connects to the PTY ( pseudo - TTY ) for a given container . Blocks until the user exits the PTY .<CODESPLIT>def interact ( self , container : Container ) -> None : cmd = "/bin/bash -c 'source /.environment && /bin/bash'" cmd = "docker exec -it {} {}" . format ( container . id , cmd ) subprocess . call ( cmd , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The AST comments .<CODESPLIT>def comments ( self ) : if self . _comments is None : self . _comments = [ c for c in self . grammar . children if c . is_type ( TokenType . comment ) ] return self . _comments
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a raw_connection and determine if it should be automatically closed .<CODESPLIT>def raw_connection_from ( engine_or_conn ) : if hasattr ( engine_or_conn , 'cursor' ) : return engine_or_conn , False if hasattr ( engine_or_conn , 'connection' ) : return engine_or_conn . connection , False return engine_or_conn . raw_connection ( ) , True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a float returns a rounded int . Should give the same result on both Py2 / 3<CODESPLIT>def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of the value at the Qth percentile in array a .<CODESPLIT>def percentile_index ( a , q ) : return np . where ( a == np . percentile ( a , q , interpolation = 'nearest' ) ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns min ( val1 val2 ) returning None only if both values are None<CODESPLIT>def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return flattened dictionary from MultiDict .<CODESPLIT>def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .<CODESPLIT>def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .<CODESPLIT>def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the maximum length between the example inputs and targets .<CODESPLIT>def _get_example_length ( example ) : length = tf . maximum ( tf . shape ( example [ 0 ] ) [ 0 ] , tf . shape ( example [ 1 ] ) [ 0 ] ) return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether another set contains this set .<CODESPLIT>def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try popping a key from a dict . Instead of raising KeyError just return the default value .<CODESPLIT>def dict_pop_or ( d , key , default = None ) : val = default with suppress ( KeyError ) : val = d . pop ( key ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a bool from a string .<CODESPLIT>def FromString ( self , string ) : if string . lower ( ) in ( "false" , "no" , "n" ) : return False if string . lower ( ) in ( "true" , "yes" , "y" ) : return True raise TypeValueError ( "%s is not recognized as a boolean value." % string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the index of an element in the list .<CODESPLIT>def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the first value in each row .<CODESPLIT>def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes dict keys which have have self as value .<CODESPLIT>def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs the function asynchronously taking care of exceptions .<CODESPLIT>def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register name as a type to validate as an instance of class cls .<CODESPLIT>def register_type ( cls , name ) : x = TypeDefinition ( name , ( cls , ) , ( ) ) Validator . types_mapping [ name ] = x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn the ring for a single position . For example [ a b c d ] becomes [ b c d a ] .<CODESPLIT>def turn ( self ) : first = self . _data . pop ( 0 ) self . _data . append ( first )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like many_until but must consume at least one of these .<CODESPLIT>def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether flyweight object with specified key has already been created .<CODESPLIT>def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls the specified Trigger of another Area with the optionally given parameters .<CODESPLIT>def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .<CODESPLIT>def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801<CODESPLIT>def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the clipboard s text on OS X .<CODESPLIT>def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \r line endings. Change them to \n. text = text . replace ( '\r' , '\n' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a yaml file s contents as a dictionary<CODESPLIT>def getYamlDocument ( filePath ) : with open ( filePath ) as stream : doc = yaml . load ( stream ) return doc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare by iteration<CODESPLIT>def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the leading numeric part of a string .<CODESPLIT>def numeric_part ( s ) : m = re_numeric_part . match ( s ) if m : return int ( m . group ( 1 ) ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>delete ( filething )<CODESPLIT>def delete ( filething ) : t = MP4 ( filething ) filething . fileobj . seek ( 0 ) t . delete ( filething )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Main funcion when executing this module as script<CODESPLIT>def main_func ( args = None ) : # we have to initialize a gui even if we dont need one right now. # as soon as you call maya.standalone.initialize(), a QApplication # with type Tty is created. This is the type for conosle apps. # Because i have not found a way to replace that, we just init the gui. guimain . init_gui ( ) main . init ( ) launcher = Launcher ( ) parsed , unknown = launcher . parse_args ( args ) parsed . func ( parsed , unknown )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a copy of model<CODESPLIT>def copy ( self ) : return self . __class__ ( field_type = self . get_field_type ( ) , data = self . export_data ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if arg is a valid file that already exists on the file system .<CODESPLIT>def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( "The file %s does not exist!" % arg ) else : return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a spent coin based on its index .<CODESPLIT>def DeleteIndex ( self , index ) : to_remove = None for i in self . Items : if i . index == index : to_remove = i if to_remove : self . Items . remove ( to_remove )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the received object as precise as possible .<CODESPLIT>def _repr ( obj ) : vals = ", " . join ( "{}={!r}" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = "{}(name={}, {})" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = "{}(name={})" . format ( obj . __class__ . __name__ , obj . name ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert the entire image to bytes . : rtype : bytes<CODESPLIT>def to_bytes ( self ) : chunks = [ PNG_SIGN ] chunks . extend ( c [ 1 ] for c in self . chunks ) return b"" . join ( chunks )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the year .<CODESPLIT>def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of ( key value ) pairs and turns it into a dict .<CODESPLIT>def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns is seq is sequence and not string .<CODESPLIT>def _is_proper_sequence ( seq ) : return ( isinstance ( seq , collections . abc . Sequence ) and not isinstance ( seq , str ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a number of query results . This is faster than . count () on the query<CODESPLIT>def get_count ( self , query ) : count_q = query . statement . with_only_columns ( [ func . count ( ) ] ) . order_by ( None ) count = query . session . execute ( count_q ) . scalar ( ) return count
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Store the user session for a client .<CODESPLIT>def save_session ( self , sid , session , namespace = None ) : return self . server . save_session ( sid , session , namespace = namespace or self . namespace )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an aiosqlite cursor wrapping a sqlite3 cursor object .<CODESPLIT>async def cursor ( self ) -> Cursor : return Cursor ( self , await self . _execute ( self . _conn . cursor ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Last modified timestamp as a UTC datetime<CODESPLIT>def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerce value to an JSON - compatible representation .<CODESPLIT>def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pure - Python implementation of itertools . combinations ( l 2 ) .<CODESPLIT>def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can edit this object<CODESPLIT>def has_edit_permission ( self , request ) : return request . user . is_authenticated and request . user . is_active and request . user . is_staff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if given string is a punctuation<CODESPLIT>def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clips a prefix from the beginning of a string if it exists .<CODESPLIT>def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>given a segment ( rectangle ) and an image returns it s corresponding subimage<CODESPLIT>def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorts this RDD by the given keyfunc<CODESPLIT>def sortBy ( self , keyfunc , ascending = True , numPartitions = None ) : return self . keyBy ( keyfunc ) . sortByKey ( ascending , numPartitions ) . values ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forget about the given canvas . Used by the canvas when closed .<CODESPLIT>def forget_canvas ( canvas ) : cc = [ c ( ) for c in canvasses if c ( ) is not None ] while canvas in cc : cc . remove ( canvas ) canvasses [ : ] = [ weakref . ref ( c ) for c in cc ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all the keys in a s3 bucket paginator page .<CODESPLIT>def get_bucket_page ( page ) : key_list = page . get ( 'Contents' , [ ] ) logger . debug ( "Retrieving page with {} keys" . format ( len ( key_list ) , ) ) return dict ( ( k . get ( 'Key' ) , k ) for k in key_list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move the cursor up a number of lines .<CODESPLIT>def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method for just changing font size .<CODESPLIT>def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get distance matrix given a matrix . Used in testing .<CODESPLIT>def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback to go to the next tab . Called by the accel key .<CODESPLIT>def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reseed factory . fuzzy s random generator .<CODESPLIT>def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to post a tweet<CODESPLIT>def post_tweet ( user_id , message , additional_params = { } ) : url = "https://api.twitter.com/1.1/statuses/update.json" params = { "status" : message } params . update ( additional_params ) r = make_twitter_request ( url , user_id , params , request_type = 'POST' ) print ( r . text ) return "Successfully posted a tweet {}" . format ( message )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to a redis instance .<CODESPLIT>def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the stretched data .<CODESPLIT>def show ( data , negate = False ) : from PIL import Image as pil data = np . array ( ( data - data . min ( ) ) * 255.0 / ( data . max ( ) - data . min ( ) ) , np . uint8 ) if negate : data = 255 - data img = pil . fromarray ( data ) img . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>arr_out = round_array ( array_in )<CODESPLIT>def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print list of strings to the predefined stdout .<CODESPLIT>def print_out ( self , * lst ) : self . print2file ( self . stdout , True , True , * lst )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of synsets of a word after lemmatization .<CODESPLIT>def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start the Django dev server .<CODESPLIT>def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a shell - escaped version of the string s .<CODESPLIT>def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if cnr or cns files are empty ( only have a header )<CODESPLIT>def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def get_element_attribute_or_empty ( element , attribute_name ) : return element . attributes [ attribute_name ] . value if element . hasAttribute ( attribute_name ) else ""
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute standard deviation with ddof degrees of freedom<CODESPLIT>def _std ( self , x ) : return np . nanstd ( x . values , ddof = self . _ddof )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate seed for random number generator<CODESPLIT>def generate_seed ( seed ) : if seed is None : random . seed ( ) seed = random . randint ( 0 , sys . maxsize ) random . seed ( a = seed ) return seed
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def parsed_args ( ) : parser = argparse . ArgumentParser ( description = """python runtime functions""" , epilog = "" ) parser . add_argument ( 'command' , nargs = '*' , help = "Name of the function to run with arguments" ) args = parser . parse_args ( ) return ( args , parser )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets all defaults for the given dictionary to those contained in a second defaults dictionary . This convenience method calls :<CODESPLIT>def setDictDefaults ( d , defaults ) : for key , val in defaults . items ( ) : d . setdefault ( key , val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resize and image to fit the passed in width keeping the aspect ratio the same<CODESPLIT>def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A basic slug version of a given parameter list .<CODESPLIT>def delistify ( x ) : if isinstance ( x , list ) : x = [ e . replace ( "'" , "" ) for e in x ] return '-' . join ( sorted ( x ) ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints the top row of a table<CODESPLIT>def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes a ( shell ) command in the background<CODESPLIT>def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .<CODESPLIT>def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( "lib2to3.fixes" , args = args . sources ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if something quacks like a list .<CODESPLIT>def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to convert list to tsv line with carriage return<CODESPLIT>def write_tsv_line_from_list ( linelist , outfp ) : line = '\t' . join ( linelist ) outfp . write ( line ) outfp . write ( '\n' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Just sends the request using its send method and returns its response .<CODESPLIT>def send ( r , stream = False ) : r . send ( stream = stream ) return r . response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callable function for the multiprocessing pool .<CODESPLIT>def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print security object information for a pdf document<CODESPLIT>def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a set of kwargs turns them into a string which can then be passed to a command . : param kwargs : kwargs from a function call . : return : outstr : A string which is if no kwargs were given and the kwargs in string format otherwise .<CODESPLIT>def kwargs_to_string ( kwargs ) : outstr = '' for arg in kwargs : outstr += ' -{} {}' . format ( arg , kwargs [ arg ] ) return outstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if two objects are equal .<CODESPLIT>def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an ARF timestamp to a datetime . datetime object ( naive local time )<CODESPLIT>def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate a CamelCase string from an underscore_string .<CODESPLIT>def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set an object s field to default if it doesn t have a value<CODESPLIT>def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this attribute present?<CODESPLIT>def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dump Python object as JSON string .<CODESPLIT>def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to read an XML file<CODESPLIT>def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y<CODESPLIT>def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for iterating only nonempty lines without line breaks<CODESPLIT>def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\r\n' ) if line : yield line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop redrawing the canvas at the previously set timed interval .<CODESPLIT>def stop_refresh ( self ) : self . logger . debug ( "stopping timed refresh" ) self . rf_flags [ 'done' ] = True self . rf_timer . clear ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns key for the bottommost rightmost cell with content<CODESPLIT>def get_last_filled_cell ( self , table = None ) : maxrow = 0 maxcol = 0 for row , col , tab in self . dict_grid : if table is None or tab == table : maxrow = max ( row , maxrow ) maxcol = max ( col , maxcol ) return maxrow , maxcol , table
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the absolute position of table top<CODESPLIT>def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( "pos" ) ) + table_height
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert version like string to a tuple of integers .<CODESPLIT>def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\D+' , value ) if _f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a serialised version of the model s fields which exist as local database columns ( i . e . excluding m2m and incoming foreign key relations )<CODESPLIT>def get_serializable_data_for_fields ( model ) : pk_field = model . _meta . pk # If model is a child via multitable inheritance, use parent's pk while pk_field . remote_field and pk_field . remote_field . parent_link : pk_field = pk_field . remote_field . model . _meta . pk obj = { 'pk' : get_field_value ( pk_field , model ) } for field in model . _meta . fields : if field . serialize : obj [ field . name ] = get_field_value ( field , model ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether this path is a symbolic link .<CODESPLIT>def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Region formed by taking border elements .<CODESPLIT>def border ( self ) : border_array = self . bitmap - self . inner . bitmap return Region ( border_array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def attr_cache_clear ( self ) : node = extract_node ( """def cache_clear(self): pass""" ) return BoundMethod ( proxy = node , bound = self . _instance . parent . scope ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the moving average ( rolling mean ) of an array of a certain window size .<CODESPLIT>def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print the object s representation .<CODESPLIT>def pretty ( obj , verbose = False , max_width = 79 , newline = '\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Receive the content of url parse it as JSON and return the object .<CODESPLIT>def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the centroid of set of points<CODESPLIT>def compute_centroid ( points ) : lats = [ p [ 1 ] for p in points ] lons = [ p [ 0 ] for p in points ] return Point ( np . mean ( lats ) , np . mean ( lons ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>str to bytes ( py3k )<CODESPLIT>def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a pdf of the current matplotlib figure .<CODESPLIT>def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if we need graphviz for different output format<CODESPLIT>def _check_graphviz_available ( output_format ) : try : subprocess . call ( [ "dot" , "-V" ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) except OSError : print ( "The output format '%s' is currently not available.\n" "Please install 'Graphviz' to have other output formats " "than 'dot' or 'vcg'." % output_format ) sys . exit ( 32 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>don t want to bother with a dsn? Use this method to make an interface available<CODESPLIT>def set_interface ( interface , name = '' ) : global interfaces if not interface : raise ValueError ( 'interface is empty' ) # close down the interface before we discard it if name in interfaces : interfaces [ name ] . close ( ) interfaces [ name ] = interface
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The title of this window<CODESPLIT>def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a given response header .<CODESPLIT>def getheader ( self , name , default = None ) : return self . aiohttp_response . headers . get ( name , default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers<CODESPLIT>def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write DOT comment .<CODESPLIT>def comment ( self , s , * * args ) : self . write ( u"// " ) self . writeln ( s = s , * * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all the unnamed columns<CODESPLIT>def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove legend for axes or gca .<CODESPLIT>def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a temporary filename based on filename .<CODESPLIT>def get_incomplete_path ( filename ) : random_suffix = "" . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) return filename + ".incomplete" + random_suffix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if outfile exists and is no older than base datetime .<CODESPLIT>def is_up_to_date ( outfile , basedatetime ) : # type: (AnyStr, datetime) -> bool if os . path . exists ( outfile ) : if os . path . getmtime ( outfile ) >= basedatetime : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform triple index into a 1 - D numpy array .<CODESPLIT>def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a string and dictionary . replaces all occurrences of i with j<CODESPLIT>def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pre - order depth - first<CODESPLIT>def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yields all permutations with replacement : list ( product ( cat repeat = 2 )) = > [ ( c c ) ( c a ) ( c t ) ( a c ) ( a a ) ( a t ) ( t c ) ( t a ) ( t t ) ]<CODESPLIT>def product ( * args , * * kwargs ) : p = [ [ ] ] for iterable in map ( tuple , args ) * kwargs . get ( "repeat" , 1 ) : p = [ x + [ y ] for x in p for y in iterable ] for p in p : yield tuple ( p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get final coefficient map array .<CODESPLIT>def getcoef ( self ) : global mp_Z_Y1 return np . swapaxes ( mp_Z_Y1 , 0 , self . xstep . cri . axisK + 1 ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deeply updates a dictionary . List values are concatenated .<CODESPLIT>def deep_update ( d , u ) : for k , v in u . items ( ) : if isinstance ( v , Mapping ) : d [ k ] = deep_update ( d . get ( k , { } ) , v ) elif isinstance ( v , list ) : existing_elements = d . get ( k , [ ] ) d [ k ] = existing_elements + [ ele for ele in v if ele not in existing_elements ] else : d [ k ] = v return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether any of the strings contains any of the candidates .<CODESPLIT>def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add suffix to a full file name<CODESPLIT>def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes and waits for subprocess to exit .<CODESPLIT>def _finish ( self ) : if self . _process . returncode is None : self . _process . stdin . flush ( ) self . _process . stdin . close ( ) self . _process . wait ( ) self . closed = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the received object as precise as possible .<CODESPLIT>def _repr ( obj ) : vals = ", " . join ( "{}={!r}" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = "{}(name={}, {})" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = "{}(name={})" . format ( obj . __class__ . __name__ , obj . name ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return random disposition point .<CODESPLIT>def _rndPointDisposition ( dx , dy ) : x = int ( random . uniform ( - dx , dx ) ) y = int ( random . uniform ( - dy , dy ) ) return ( x , y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs the basic endpoint requested<CODESPLIT>def process_request ( self , request , response ) : self . logger . info ( 'Requested: {0} {1} {2}' . format ( request . method , request . relative_uri , request . content_type ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises django . core . exceptions . ValidationError if any validation error exists<CODESPLIT>def validate ( self , obj ) : if not isinstance ( obj , self . model_class ) : raise ValidationError ( 'Invalid object(%s) for service %s' % ( type ( obj ) , type ( self ) ) ) LOG . debug ( u'Object %s state: %s' , self . model_class , obj . __dict__ ) obj . full_clean ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select item in the list<CODESPLIT>def _selectItem ( self , index ) : self . _selectedIndex = index self . setCurrentIndex ( self . model ( ) . createIndex ( index , 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads image specified by path into numpy . ndarray<CODESPLIT>def read_img ( path ) : img = cv2 . resize ( cv2 . imread ( path , 0 ) , ( 80 , 30 ) ) . astype ( np . float32 ) / 255 img = np . expand_dims ( img . transpose ( 1 , 0 ) , 0 ) return img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a modified list containing only the indices indicated .<CODESPLIT>def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not<CODESPLIT>def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = "json" ) is_json = True except : is_json = False return ( is_json )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Defines the time after which Exscript fails if it does not receive a prompt from the remote host .<CODESPLIT>def set_timeout ( scope , timeout ) : conn = scope . get ( '__connection__' ) conn . set_timeout ( int ( timeout [ 0 ] ) ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Order - preserving sorting function .<CODESPLIT>def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Digits needed to comforatbly display values in [ minval maxval ]<CODESPLIT>def _digits ( minval , maxval ) : if minval == maxval : return 3 else : return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts a base64 string to a file<CODESPLIT>def base64ToImage ( imgData , out_path , out_file ) : fh = open ( os . path . join ( out_path , out_file ) , "wb" ) fh . write ( imgData . decode ( 'base64' ) ) fh . close ( ) del fh return os . path . join ( out_path , out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if two images have the same height and width ( and optionally channels ) .<CODESPLIT>def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the exectuable bit on the given filename<CODESPLIT>def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implements the === operator .<CODESPLIT>def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .<CODESPLIT>def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a random element from seq n times . If n is None it continues indefinitly<CODESPLIT>def rand_elem ( seq , n = None ) : return map ( random . choice , repeat ( seq , n ) if n is not None else repeat ( seq ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds<CODESPLIT>def pprint ( self , seconds ) : return ( "%d:%02d:%02d.%03d" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split message to list by commas and trim whitespace .<CODESPLIT>def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = "" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( "," ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs a function s run time<CODESPLIT>def timed_call ( func , * args , log_level = 'DEBUG' , * * kwargs ) : start = time ( ) r = func ( * args , * * kwargs ) t = time ( ) - start log ( log_level , "Call to '{}' took {:0.6f}s" . format ( func . __name__ , t ) ) return r
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempts to convert given object to a string object<CODESPLIT>def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops the status update thread .<CODESPLIT>def _StopStatusUpdateThread ( self ) : self . _status_update_active = False if self . _status_update_thread . isAlive ( ) : self . _status_update_thread . join ( ) self . _status_update_thread = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a ctypes void pointer to the memory mapped region .<CODESPLIT>def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a file safely . If it s not present no - op .<CODESPLIT>def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the duplicates in a list .<CODESPLIT>def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if email is valid<CODESPLIT>def is_valid_email ( email ) : pattern = re . compile ( r'[\w\.-]+@[\w\.-]+[.]\w+' ) return bool ( pattern . match ( email ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises the supplied figure number or figure window .<CODESPLIT>def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new figure manager instance for the given figure .<CODESPLIT>def new_figure_manager_given_figure ( num , figure ) : fig = figure frame = FigureFrameWx ( num , fig ) figmgr = frame . get_figure_manager ( ) if matplotlib . is_interactive ( ) : figmgr . frame . Show ( ) return figmgr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse string into Identity dictionary .<CODESPLIT>def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request that the Outstation perform a cold restart . Command syntax is : restart<CODESPLIT>def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the previous quarter for dt<CODESPLIT>def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the lowercase chars in the given string .<CODESPLIT>def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean up any temporary files .<CODESPLIT>def cleanup ( self ) : for file in glob . glob ( self . basename + '*' ) : os . unlink ( file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all properties matching both key and value .<CODESPLIT>def remove_property ( self , key = None , value = None ) : for k , v in self . properties [ : ] : if ( key is None or key == k ) and ( value is None or value == v ) : del ( self . properties [ self . properties . index ( ( k , v ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses hostname from URL . : param url : URL : return : hostname<CODESPLIT>def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds passed value to node s globals<CODESPLIT>def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether stdin has any data to read .<CODESPLIT>def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP response for not - authorized access ( status code 403 )<CODESPLIT>def HttpResponse401 ( request , template = KEY_AUTH_401_TEMPLATE , content = KEY_AUTH_401_CONTENT , content_type = KEY_AUTH_401_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 401 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run func with argument fobj and measure execution time .<CODESPLIT>def run_test ( func , fobj ) : gc . disable ( ) try : begin = time . time ( ) func ( fobj ) end = time . time ( ) finally : gc . enable ( ) return end - begin
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to convert list to tsv line with carriage return<CODESPLIT>def write_tsv_line_from_list ( linelist , outfp ) : line = '\t' . join ( linelist ) outfp . write ( line ) outfp . write ( '\n' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emit a sine wave at the given frequency .<CODESPLIT>def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ctypes double pointer array to a numpy array .<CODESPLIT>def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>linear regression calculation<CODESPLIT>def linregress ( x , y , return_stats = False ) : a1 , a0 , r_value , p_value , stderr = scipy . stats . linregress ( x , y ) retval = a1 , a0 if return_stats : retval += r_value , p_value , stderr return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all rows from a cursor as a dict ( rather than a headerless table )<CODESPLIT>def dictfetchall ( cursor ) : desc = cursor . description return [ dict ( zip ( [ col [ 0 ] for col in desc ] , row ) ) for row in cursor . fetchall ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Segmented min op .<CODESPLIT>def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield a series of batches from iterable each size elements long .<CODESPLIT>def ibatch ( iterable , size ) : source = iter ( iterable ) while True : batch = itertools . islice ( source , size ) yield itertools . chain ( [ next ( batch ) ] , batch )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .<CODESPLIT>def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of tuples specifying the column name and type<CODESPLIT>def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( "PRAGMA table_info('%s');" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a tuple of numbers . e . g . vertices normals or teture coords .<CODESPLIT>def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a 3x3 cross - product matrix from a 3 - element vector .<CODESPLIT>def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Filters given query with the below regex and returns lists of quoted and unquoted strings<CODESPLIT>def filter_query ( s ) : matches = re . findall ( r'(?:"([^"]*)")|([^"]*)' , s ) result_quoted = [ t [ 0 ] . strip ( ) for t in matches if t [ 0 ] ] result_unquoted = [ t [ 1 ] . strip ( ) for t in matches if t [ 1 ] ] return result_quoted , result_unquoted
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the given name looks like the name of a builtin CSS function .<CODESPLIT>def is_builtin_css_function ( name ) : name = name . replace ( '_' , '-' ) if name in BUILTIN_FUNCTIONS : return True # Vendor-specific functions (-foo-bar) are always okay if name [ 0 ] == '-' and '-' in name [ 1 : ] : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle logging .<CODESPLIT>def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a . npy array .<CODESPLIT>def read_array ( path , mmap_mode = None ) : file_ext = op . splitext ( path ) [ 1 ] if file_ext == '.npy' : return np . load ( path , mmap_mode = mmap_mode ) raise NotImplementedError ( "The file extension `{}` " . format ( file_ext ) + "is not currently supported." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a function after a delay unless another function is set in the meantime .<CODESPLIT>def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the week start date and end date<CODESPLIT>def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalizes list<CODESPLIT>def normalize_array ( lst ) : np_arr = np . array ( lst ) x_normalized = np_arr / np_arr . max ( axis = 0 ) return list ( x_normalized )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the chars in the given string .<CODESPLIT>def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional<CODESPLIT>def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple method for handling exceptions raised by PyBankID .<CODESPLIT>def handle_exception ( error ) : response = jsonify ( error . to_dict ( ) ) response . status_code = error . status_code return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the absolute position of table top<CODESPLIT>def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( "pos" ) ) + table_height
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the name of the newest file given an iterable of file names .<CODESPLIT>def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provide the root module of a TF - 2 . 0 API for use within TensorBoard .<CODESPLIT>def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clone a bitset<CODESPLIT>def bit_clone ( bits ) : new = BitSet ( bits . size ) new . ior ( bits ) return new
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpickle a python object from the given path .<CODESPLIT>def unpickle ( pickle_file ) : pickle = None with open ( pickle_file , "rb" ) as pickle_f : pickle = dill . load ( pickle_f ) if not pickle : LOG . error ( "Could not load python object from file" ) return pickle
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience wrapper for database UPDATE .<CODESPLIT>def update ( table , values , where = ( ) , * * kwargs ) : where = dict ( where , * * kwargs ) . items ( ) sql , args = makeSQL ( "UPDATE" , table , values = values , where = where ) return execute ( sql , args ) . rowcount
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the clipboard s text on OS X .<CODESPLIT>def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \r line endings. Change them to \n. text = text . replace ( '\r' , '\n' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dotproduct of two vectors .<CODESPLIT>def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper parse action to convert tokens to lower case .<CODESPLIT>def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds an action to the parser cli .<CODESPLIT>def register_action ( action ) : sub = _subparsers . add_parser ( action . meta ( 'cmd' ) , help = action . meta ( 'help' ) ) sub . set_defaults ( cmd = action . meta ( 'cmd' ) ) for ( name , arg ) in action . props ( ) . items ( ) : sub . add_argument ( arg . name , arg . flag , * * arg . options ) _actions [ action . meta ( 'cmd' ) ] = action
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .<CODESPLIT>def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds / overwrites all the keys and values from the dictionary .<CODESPLIT>def update ( self , dictionary = None , * * kwargs ) : if not dictionary == None : kwargs . update ( dictionary ) for k in list ( kwargs . keys ( ) ) : self [ k ] = kwargs [ k ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Inserts spaces after each string of new lines in s and before the start of the string .<CODESPLIT>def indent ( s , spaces = 4 ) : new = re . sub ( '(\n+)' , '\\1%s' % ( ' ' * spaces ) , s ) return ( ' ' * spaces ) + new . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output a networkx graph to a DOT file .<CODESPLIT>def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test two dictionary is equal on values . ( ignore order )<CODESPLIT>def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801<CODESPLIT>def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set colouring on if STDOUT is a terminal device off otherwise<CODESPLIT>def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when asyncio . Protocol loses the network connection .<CODESPLIT>def connection_lost ( self , exc ) : if exc is None : self . log . warning ( 'eof from receiver?' ) else : self . log . warning ( 'Lost connection to receiver: %s' , exc ) self . transport = None if self . _connection_lost_callback : self . _loop . call_soon ( self . _connection_lost_callback )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of string which don t match the given regex .<CODESPLIT>def not_matching_list ( self ) : pre_result = comp ( self . regex ) return [ x for x in self . data if not pre_result . search ( str ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Push a new value into heap .<CODESPLIT>def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes flags returns indexes of True values<CODESPLIT>def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This parallel fetcher uses gevent one uses gevent<CODESPLIT>def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a string with comma or space - separated elements into a list .<CODESPLIT>def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the month start date a nd end date<CODESPLIT>def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns int () of val if val is not convertable to int use default instead<CODESPLIT>def safe_int ( val , default = None ) : try : val = int ( val ) except ( ValueError , TypeError ) : val = default return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the length of s when it is encoded with base64 .<CODESPLIT>def header_length ( bytearray ) : groups_of_3 , leftover = divmod ( len ( bytearray ) , 3 ) # 4 bytes out for each 3 bytes (or nonzero fraction thereof) in. n = groups_of_3 * 4 if leftover : n += 4 return n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .<CODESPLIT>def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean up processes after SIGTERM or SIGINT is received .<CODESPLIT>def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy the lib items into our font .<CODESPLIT>def setLib ( self , lib ) : for name , item in lib . items ( ) : self . font . lib [ name ] = item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implements the === operator .<CODESPLIT>def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the list have unique items only and maintains the order<CODESPLIT>def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP response for not - authorized access ( status code 403 )<CODESPLIT>def HttpResponse401 ( request , template = KEY_AUTH_401_TEMPLATE , content = KEY_AUTH_401_CONTENT , content_type = KEY_AUTH_401_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 401 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert json string representation into class instance .<CODESPLIT>def from_json_str ( cls , json_str ) : return cls . from_json ( json . loads ( json_str , cls = JsonDecoder ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Array of vector lengths<CODESPLIT>def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if all values in a sequence are equal .<CODESPLIT>def same ( * values ) : if not values : return True first , rest = values [ 0 ] , values [ 1 : ] return all ( value == first for value in rest )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same order unique list using only a list compression .<CODESPLIT>def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert file extension to lowercase .<CODESPLIT>def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert file extension to lowercase .<CODESPLIT>def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove arduino / examples / all directory .<CODESPLIT>def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute page boundary alignment : param int length : content length : rtype : int : return : aligned byte boundary<CODESPLIT>def page_align_content_length ( length ) : # type: (int) -> int mod = length % _PAGEBLOB_BOUNDARY if mod != 0 : return length + ( _PAGEBLOB_BOUNDARY - mod ) return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read text from file automatically detect encoding . chardet required .<CODESPLIT>def smartread ( path ) : with open ( path , "rb" ) as f : content = f . read ( ) result = chardet . detect ( content ) return content . decode ( result [ "encoding" ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a python_style_variable_name to lowerCamelCase .<CODESPLIT>def camelize ( key ) : return '' . join ( x . capitalize ( ) if i > 0 else x for i , x in enumerate ( key . split ( '_' ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Open a file .<CODESPLIT>def open_file ( file , mode ) : if hasattr ( file , "read" ) : return file if hasattr ( file , "open" ) : return file . open ( mode ) return open ( file , mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a function after a delay unless another function is set in the meantime .<CODESPLIT>def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate odd sized truncated Gaussian<CODESPLIT>def gaussian_kernel ( gstd ) : Nc = np . ceil ( gstd * 3 ) * 2 + 1 x = np . linspace ( - ( Nc - 1 ) / 2 , ( Nc - 1 ) / 2 , Nc , endpoint = True ) g = np . exp ( - .5 * ( ( x / gstd ) ** 2 ) ) g = g / np . sum ( g ) return g
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Integer dots per inch for the width of this image . Defaults to 72 when not present in the file as is often the case .<CODESPLIT>def horz_dpi ( self ) : pHYs = self . _chunks . pHYs if pHYs is None : return 72 return self . _dpi ( pHYs . units_specifier , pHYs . horz_px_per_unit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Escapes a filesystem path for use as a command - line argument<CODESPLIT>def escapePathForShell ( path ) : if platform . system ( ) == 'Windows' : return '"{}"' . format ( path . replace ( '"' , '""' ) ) else : return shellescape . quote ( path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>zfill ( x width ) - > string<CODESPLIT>def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge two dicts and return a new dict . Much like subclassing works .<CODESPLIT>def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Repeat each item in iterable n times .<CODESPLIT>def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Singleton definition .<CODESPLIT>def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string representation of the traceback .<CODESPLIT>def str_traceback ( error , tb ) : if not isinstance ( tb , types . TracebackType ) : return tb return '' . join ( traceback . format_exception ( error . __class__ , error , tb ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Repeat each item in iterable n times .<CODESPLIT>def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compress a file returning the new filename ( . gz )<CODESPLIT>def __gzip ( filename ) : zipname = filename + '.gz' file_pointer = open ( filename , 'rb' ) zip_pointer = gzip . open ( zipname , 'wb' ) zip_pointer . writelines ( file_pointer ) file_pointer . close ( ) zip_pointer . close ( ) return zipname
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply Gaussian blur to the given data .<CODESPLIT>def GaussianBlur ( X , ksize_width , ksize_height , sigma_x , sigma_y ) : return image_transform ( X , cv2 . GaussianBlur , ksize = ( ksize_width , ksize_height ) , sigmaX = sigma_x , sigmaY = sigma_y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert datetime to epoch seconds .<CODESPLIT>def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle many to many relationships<CODESPLIT>def handle_m2m ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . __class__ , instance )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert json string representation into class instance .<CODESPLIT>def from_json_str ( cls , json_str ) : return cls . from_json ( json . loads ( json_str , cls = JsonDecoder ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the length of the longest consecutive run of identical values .<CODESPLIT>def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans up the file entry .<CODESPLIT>def __del__ ( self ) : # __del__ can be invoked before __init__ has completed. if hasattr ( self , '_encoded_stream' ) : self . _encoded_stream . close ( ) self . _encoded_stream = None super ( EncodedStreamFileEntry , self ) . __del__ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the label from the last line read<CODESPLIT>def _get_current_label ( self ) : if len ( self . _last ) == 0 : raise StopIteration return self . _last [ : self . _last . find ( ":" ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def __next__ ( self ) : # Retrieve the row, thereby incrementing the line number: row = super ( UnicodeReaderWithLineNumber , self ) . __next__ ( ) return self . lineno + 1 , row
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Confusion matrix plot<CODESPLIT>def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a file exists and is non - empty .<CODESPLIT>def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rearrange the heap after the item at position i got updated .<CODESPLIT>def fix ( h , i ) : down ( h , i , h . size ( ) ) up ( h , i )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip out namespace data from an ElementTree .<CODESPLIT>def strip_xml_namespace ( root ) : try : root . tag = root . tag . split ( '}' ) [ 1 ] except IndexError : pass for element in root . getchildren ( ) : strip_xml_namespace ( element )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert json string representation into class instance .<CODESPLIT>def from_json_str ( cls , json_str ) : return cls . from_json ( json . loads ( json_str , cls = JsonDecoder ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the category of the item .<CODESPLIT>def get_category ( self ) : var = self . xmlnode . prop ( "category" ) if not var : var = "?" return var . decode ( "utf-8" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a list a certain size<CODESPLIT>def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If pyyaml > 5 . 1 use full_load to avoid warning<CODESPLIT>def load_yaml ( file ) : if hasattr ( yaml , "full_load" ) : return yaml . full_load ( file ) else : return yaml . load ( file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a float returns a rounded int . Should give the same result on both Py2 / 3<CODESPLIT>def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generalised logarithm<CODESPLIT>def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param fileobj : a file object : return : a hash of the file content<CODESPLIT>def hash_file ( fileobj ) : hasher = hashlib . md5 ( ) buf = fileobj . read ( 65536 ) while len ( buf ) > 0 : hasher . update ( buf ) buf = fileobj . read ( 65536 ) return hasher . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>append item and print it to stdout<CODESPLIT>def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap vertical table in a function for TabularOutputFormatter .<CODESPLIT>def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Starts the web server .<CODESPLIT>def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a modified list containing only the indices indicated .<CODESPLIT>def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes a naive datetime . datetime in a given time zone aware .<CODESPLIT>def make_aware ( value , timezone ) : if hasattr ( timezone , 'localize' ) and value not in ( datetime . datetime . min , datetime . datetime . max ) : # available for pytz time zones return timezone . localize ( value , is_dst = None ) else : # may be wrong around DST changes return value . replace ( tzinfo = timezone )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return manhattan distance between two lists of numbers .<CODESPLIT>def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print just one that returns what you give it instead of None<CODESPLIT>def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the modified time for a file as a datetime instance<CODESPLIT>def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the lines of file in reverse order .<CODESPLIT>def reversed_lines ( path ) : with open ( path , 'r' ) as handle : part = '' for block in reversed_blocks ( handle ) : for c in reversed ( block ) : if c == '\n' and part : yield part [ : : - 1 ] part = '' part += c if part : yield part [ : : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Should we skip logging for this handler?<CODESPLIT>def should_skip_logging ( func ) : disabled = strtobool ( request . headers . get ( "x-request-nolog" , "false" ) ) return disabled or getattr ( func , SKIP_LOGGING , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a US format date and return epoch .<CODESPLIT>def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , "%m/%d/%Y" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of unique items ( similar to set functionality ) .<CODESPLIT>def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when a new DropDownItem gets selected .<CODESPLIT>def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Debug log messages if debug = True<CODESPLIT>def _debug_log ( self , msg ) : if not self . debug : return sys . stderr . write ( '{}\n' . format ( msg ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate random string with specified length<CODESPLIT>def gen_random_string ( str_len ) : return '' . join ( random . choice ( string . ascii_letters + string . digits ) for _ in range ( str_len ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pads the output with an amount of indentation appropriate for the number of open element .<CODESPLIT>def _pad ( self ) : if self . _indent : self . whitespace ( self . _indent * len ( self . _open_elements ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encodes a given string with the proper standard out encoding If sys . stdout . encoding isn t specified it this defaults to @default<CODESPLIT>def stdout_encode ( u , default = 'utf-8' ) : # from http://stackoverflow.com/questions/3627793/best-output-type-and- #   encoding-practices-for-repr-functions encoding = sys . stdout . encoding or default return u . encode ( encoding , "replace" ) . decode ( encoding , "replace" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicities from deps list of the lists<CODESPLIT>def unique_deps ( deps ) : deps . sort ( ) return list ( k for k , _ in itertools . groupby ( deps ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether flyweight object with specified key has already been created .<CODESPLIT>def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the dictionary in json format : param fname : file to save to<CODESPLIT>def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts any object to JSON - like readable format ready to be printed for debugging purposes : param obj : Any object : return : string<CODESPLIT>def get_object_as_string ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , list ) : return '\r\n\;' . join ( [ get_object_as_string ( item ) for item in obj ] ) attrs = vars ( obj ) as_string = ', ' . join ( "%s: %s" % item for item in attrs . items ( ) ) return as_string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform triple index into a 1 - D numpy array .<CODESPLIT>def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a conda environment inside the current sandbox for the given list of dependencies and options .<CODESPLIT>def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ "conda" , "create" , "--yes" , "--copy" , "--quiet" , "-p" , env_dir ] + list ( options ) + dependencies log . info ( "Creating conda environment: " ) log . info ( "  command line: %s" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( "Environment created" ) return env_dir , env_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List of GPU device names detected by TensorFlow .<CODESPLIT>def available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .<CODESPLIT>def generate_unique_host_id ( ) : host = "." . join ( reversed ( socket . gethostname ( ) . split ( "." ) ) ) pid = os . getpid ( ) return "%s.%d" % ( host , pid )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises an AssertionError if expected is actual .<CODESPLIT>def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , "is" , extra )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .<CODESPLIT>def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap a function as an attribute .<CODESPLIT>def attribute ( func ) : attr = abc . abstractmethod ( func ) attr . __iattribute__ = True attr = _property ( attr ) return attr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove punctuation from string s .<CODESPLIT>def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = "" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return " " . join ( filter ( None , s . split ( " " ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the clipboard s text on OS X .<CODESPLIT>def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \r line endings. Change them to \n. text = text . replace ( '\r' , '\n' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return unique list of iterable items preserving order .<CODESPLIT>def uniqued ( iterable ) : seen = set ( ) return [ item for item in iterable if item not in seen and not seen . add ( item ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Instantiate a Pred from its quoted string representation .<CODESPLIT>def surface ( cls , predstr ) : lemma , pos , sense , _ = split_pred_string ( predstr ) return cls ( Pred . SURFACE , lemma , pos , sense , predstr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rescales a numpy array so that min is 0 and max is 255<CODESPLIT>def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove key from dict and return value .<CODESPLIT>def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Starts the web server .<CODESPLIT>def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find rightmost value less than x .<CODESPLIT>def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :<CODESPLIT>def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( "non-list value found where list is expected" ) return all ( isinstance ( x , str ) for x in arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the proxy handler given the option passed on the command line . If an empty string is passed it looks at the HTTP_PROXY environment variable .<CODESPLIT>def setup ( self , proxystr = '' , prompting = True ) : self . prompting = prompting proxy = self . get_proxy ( proxystr ) if proxy : proxy_support = urllib2 . ProxyHandler ( { "http" : proxy , "ftp" : proxy } ) opener = urllib2 . build_opener ( proxy_support , urllib2 . CacheFTPHandler ) urllib2 . install_opener ( opener )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A map to look up the index of a edge<CODESPLIT>def edge_index ( self ) : return dict ( ( edge , index ) for index , edge in enumerate ( self . edges ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the given colored string to standard out .<CODESPLIT>def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download file from http url link<CODESPLIT>def download_file ( save_path , file_url ) : r = requests . get ( file_url ) # create HTTP response object with open ( save_path , 'wb' ) as f : f . write ( r . content ) return save_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a character delimited version of the provided list as a Python string<CODESPLIT>def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an OrderedDict containing C values to a 1D array .<CODESPLIT>def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>webargs error handler that uses Flask - RESTful s abort function to return a JSON error response to the client .<CODESPLIT>def handle_request_parsing_error ( err , req , schema , error_status_code , error_headers ) : abort ( error_status_code , errors = err . messages )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get domain part of an url .<CODESPLIT>def get_domain ( url ) : parse_result = urlparse ( url ) domain = "{schema}://{netloc}" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a stream handler if it exists .<CODESPLIT>def find_console_handler ( logger ) : for handler in logger . handlers : if ( isinstance ( handler , logging . StreamHandler ) and handler . stream == sys . stderr ) : return handler
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all accent from a whole string .<CODESPLIT>def remove_accent_string ( string ) : return utils . join ( [ add_accent_char ( c , Accent . NONE ) for c in string ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch a query argument as a boolean .<CODESPLIT>def arg_bool ( name , default = False ) : v = request . args . get ( name , '' ) if not len ( v ) : return default return v in BOOL_TRUISH
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to extract keywords from the text provided .<CODESPLIT>def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if arg is a valid file that already exists on the file system .<CODESPLIT>def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( "The file %s does not exist!" % arg ) else : return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Seems to be significantly more expensive on cluster than locally<CODESPLIT>def show_partitioning ( rdd , show = True ) : if show : partitionCount = rdd . getNumPartitions ( ) try : valueCount = rdd . countApprox ( 1000 , confidence = 0.50 ) except : valueCount = - 1 try : name = rdd . name ( ) or None except : pass name = name or "anonymous" logging . info ( "For RDD %s, there are %d partitions with on average %s values" % ( name , partitionCount , int ( valueCount / float ( partitionCount ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JsonResponse . Make sure you have django installed first .<CODESPLIT>def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a list unique retaining order of initial appearance .<CODESPLIT>def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shortcut fot boolean like fields<CODESPLIT>def _type_bool ( label , default = False ) : return label , abstractSearch . nothing , abstractRender . boolen , default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>attempt to draw str on screen and ignore errors if they occur<CODESPLIT>def add_str ( window , line_num , str ) : try : window . addstr ( line_num , 0 , str ) except curses . error : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round to sig figs<CODESPLIT>def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new copied dictionary without the keys with None values from the given Mapping object .<CODESPLIT>def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses an HTTP date into a datetime object .<CODESPLIT>def parsehttpdate ( string_ ) : try : t = time . strptime ( string_ , "%a, %d %b %Y %H:%M:%S %Z" ) except ValueError : return None return datetime . datetime ( * t [ : 6 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : points : ( nx4 ) x2 Returns : nx4 boxes ( x1y1x2y2 )<CODESPLIT>def point8_to_box ( points ) : p = points . reshape ( ( - 1 , 4 , 2 ) ) minxy = p . min ( axis = 1 ) # nx2 maxxy = p . max ( axis = 1 ) # nx2 return np . concatenate ( ( minxy , maxxy ) , axis = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test the multiprocess<CODESPLIT>def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load an object from a module by name<CODESPLIT>def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple method for handling exceptions raised by PyBankID .<CODESPLIT>def handle_exception ( error ) : response = jsonify ( error . to_dict ( ) ) response . status_code = error . status_code return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses numpy . load to open the underlying file<CODESPLIT>def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to unpickle data from picklefile .<CODESPLIT>def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the CL log prior compute function .<CODESPLIT>def _get_log_prior_cl_func ( self ) : return SimpleCLFunction . from_string ( '''             mot_float_type _computeLogPrior(local const mot_float_type* x, void* data){                 return ''' + self . _log_prior_func . get_cl_function_name ( ) + '''(x, data);             }         ''' , dependencies = [ self . _log_prior_func ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A standard compound hash .<CODESPLIT>def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get version information for components used by Spyder<CODESPLIT>def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # "2.7.3" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>close socket immediately .<CODESPLIT>def shutdown ( self ) : if self . sock : self . sock . close ( ) self . sock = None self . connected = False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes a HEAD request to find the final destination of a URL after following any redirects<CODESPLIT>def dereference_url ( url ) : res = open_url ( url , method = 'HEAD' ) res . close ( ) return res . url
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function used for joins builds left and right join list for join function<CODESPLIT>def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the x - axis tick labels for a subplot .<CODESPLIT>def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register the reporter classes with the linter .<CODESPLIT>def register ( linter ) : linter . register_reporter ( TextReporter ) linter . register_reporter ( ParseableTextReporter ) linter . register_reporter ( VSTextReporter ) linter . register_reporter ( ColorizedTextReporter )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses hostname from URL . : param url : URL : return : hostname<CODESPLIT>def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the serial port e . g . : / dev / tty . usbserial - A4001ib8<CODESPLIT>def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the color of a given pixel<CODESPLIT>def get_pixel ( framebuf , x , y ) : index = ( y >> 3 ) * framebuf . stride + x offset = y & 0x07 return ( framebuf . buf [ index ] >> offset ) & 0x01
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove resource instance from internal cache<CODESPLIT>def __delitem__ ( self , resource ) : self . __caches [ type ( resource ) ] . pop ( resource . get_cache_internal_key ( ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility to generate enum classes used by annotations .<CODESPLIT>def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is an enum type .<CODESPLIT>def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts text that may be camelcased into an underscored format<CODESPLIT>def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\1_\2' , UNDERSCORE [ 0 ] . sub ( r'\1_\2' , text ) ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine ES type names from request data .<CODESPLIT>def determine_types ( self ) : from nefertari . elasticsearch import ES collections = self . get_collections ( ) resources = self . get_resources ( collections ) models = set ( [ res . view . Model for res in resources ] ) es_models = [ mdl for mdl in models if mdl and getattr ( mdl , '_index_enabled' , False ) ] types = [ ES . src2type ( mdl . __name__ ) for mdl in es_models ] return types
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Array of bytes<CODESPLIT>def barray ( iterlines ) : lst = [ line . encode ( 'utf-8' ) for line in iterlines ] arr = numpy . array ( lst ) return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted<CODESPLIT>def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>given a segment ( rectangle ) and an image returns it s corresponding subimage<CODESPLIT>def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to get a number out of a string and cast it .<CODESPLIT>def get_number ( s , cast = int ) : import string d = "" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to MySQL with retries .<CODESPLIT>def connect_mysql ( host , port , user , password , database ) : return pymysql . connect ( host = host , port = port , user = user , passwd = password , db = database )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .<CODESPLIT>def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - negative integer .<CODESPLIT>def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns elapsed time at update .<CODESPLIT>def _elapsed ( self ) : self . last_time = time . time ( ) return self . last_time - self . start
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure the cursor is within horizontal screen bounds .<CODESPLIT>def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until thread exit<CODESPLIT>def wait_until_exit ( self ) : if self . _timeout is None : raise Exception ( "Thread will never exit. Use stop or specify timeout when starting it!" ) self . _thread . join ( ) self . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines whether the passed value is a string safe for 2 / 3 .<CODESPLIT>def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>https : // picamera . readthedocs . io / en / release - 1 . 13 / recipes1 . html#capturing - to - a - pil - image<CODESPLIT>def read ( self ) : stream = BytesIO ( ) self . cam . capture ( stream , format = 'png' ) # "Rewind" the stream to the beginning so we can read its content stream . seek ( 0 ) return Image . open ( stream )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a formatted indented text .<CODESPLIT>def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of a geometry in a list of geometries avoiding expensive equality checks of in operator .<CODESPLIT>def find_geom ( geom , geoms ) : for i , g in enumerate ( geoms ) : if g is geom : return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encodes Unicode strings to byte strings if necessary .<CODESPLIT>def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of the earliest occurence of an item from a list in a string<CODESPLIT>def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Construct the adjacency matrix of the tree : param tree : : return :<CODESPLIT>def adjacency ( tree ) : dd = ids ( tree ) N = len ( dd ) A = np . zeros ( ( N , N ) ) def _adj ( node ) : if np . isscalar ( node ) : return elif isinstance ( node , tuple ) and len ( node ) == 2 : A [ dd [ node ] , dd [ node [ 0 ] ] ] = 1 A [ dd [ node [ 0 ] ] , dd [ node ] ] = 1 _adj ( node [ 0 ] ) A [ dd [ node ] , dd [ node [ 1 ] ] ] = 1 A [ dd [ node [ 1 ] ] , dd [ node ] ] = 1 _adj ( node [ 1 ] ) _adj ( tree ) return A
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flatten a nested list by yielding its scalar items .<CODESPLIT>def flatten ( nested , containers = ( list , tuple ) ) : for item in nested : if hasattr ( item , "next" ) or isinstance ( item , containers ) : for subitem in flatten ( item ) : yield subitem else : yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deprecated see make_2D_samples_gauss<CODESPLIT>def get_2D_samples_gauss ( n , m , sigma , random_state = None ) : return make_2D_samples_gauss ( n , m , sigma , random_state = None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a year is leap year .<CODESPLIT>def _is_leap_year ( year ) : isleap = ( ( np . mod ( year , 4 ) == 0 ) & ( ( np . mod ( year , 100 ) != 0 ) | ( np . mod ( year , 400 ) == 0 ) ) ) return isleap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of all keys in the dictionary .<CODESPLIT>def keys ( self ) : all_keys = [ k . decode ( 'utf-8' ) for k , v in self . rdb . hgetall ( self . session_hash ) . items ( ) ] return all_keys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get targets for loadable modules .<CODESPLIT>def _windowsLdmodTargets ( target , source , env , for_signature ) : return _dllTargets ( target , source , env , for_signature , 'LDMODULE' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python<CODESPLIT>def slugify ( string ) : string = re . sub ( '[^\w .-]' , '' , string ) string = string . replace ( " " , "-" ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raise this exception with the original traceback<CODESPLIT>def re_raise ( self ) : if self . exc_info is not None : six . reraise ( type ( self ) , self , self . exc_info [ 2 ] ) else : raise self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print each field and its value .<CODESPLIT>def _prt_line_detail ( self , prt , line , lnum = "" ) : data = zip ( self . flds , line . split ( '\t' ) ) txt = [ "{:2}) {:13} {}" . format ( i , hdr , val ) for i , ( hdr , val ) in enumerate ( data ) ] prt . write ( "{LNUM}\n{TXT}\n" . format ( LNUM = lnum , TXT = '\n' . join ( txt ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Receive the content of url parse it as JSON and return the object .<CODESPLIT>def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed<CODESPLIT>def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert special characters using %xx escape .<CODESPLIT>def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reshape data into ( num_example batch_size )<CODESPLIT>def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy the lib items into our font .<CODESPLIT>def setLib ( self , lib ) : for name , item in lib . items ( ) : self . font . lib [ name ] = item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure the cursor is within horizontal screen bounds .<CODESPLIT>def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parameters ---------- data_path : str<CODESPLIT>def read_raw ( data_path ) : with open ( data_path , 'rb' ) as f : data = pickle . load ( f ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to run commands synchronously for testing .<CODESPLIT>def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( "Event loop is already running." ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert any array into a 2d numpy array .<CODESPLIT>def make_2d ( ary ) : dim_0 ,  * _ = np . atleast_1d ( ary ) . shape return ary . reshape ( dim_0 , - 1 , order = "F" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Main funcion when executing this module as script<CODESPLIT>def main_func ( args = None ) : # we have to initialize a gui even if we dont need one right now. # as soon as you call maya.standalone.initialize(), a QApplication # with type Tty is created. This is the type for conosle apps. # Because i have not found a way to replace that, we just init the gui. guimain . init_gui ( ) main . init ( ) launcher = Launcher ( ) parsed , unknown = launcher . parse_args ( args ) parsed . func ( parsed , unknown )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list possibly nested to any level return it flattened .<CODESPLIT>def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dict mapping item - > indices .<CODESPLIT>def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load a texture from a file into a PIL image .<CODESPLIT>def _load_texture ( file_name , resolver ) : file_data = resolver . get ( file_name ) image = PIL . Image . open ( util . wrap_as_stream ( file_data ) ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return peak memory usage in MB<CODESPLIT>def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert snake case to camel case<CODESPLIT>def camel_case ( self , snake_case ) : components = snake_case . split ( '_' ) return components [ 0 ] + "" . join ( x . title ( ) for x in components [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge two dicts and return a new dict . Much like subclassing works .<CODESPLIT>def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HParams for training languagemodel_lm1b32k_packed . 880M Params .<CODESPLIT>def lmx_h1k_f64k ( ) : hparams = lmx_base ( ) hparams . hidden_size = 1024 hparams . filter_size = 65536 hparams . batch_size = 2048 return hparams
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the string is only composed of hex characters .<CODESPLIT>def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a datetime from GnuCash 2 . 6 date string<CODESPLIT>def get_from_gnucash26_date ( date_str : str ) -> date : date_format = "%Y%m%d" result = datetime . strptime ( date_str , date_format ) . date ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Original doc : A file to get the name of a file to save . Returns the name of a file or None if user chose to cancel .<CODESPLIT>def filesavebox ( msg = None , title = None , argInitialFile = None ) : return psidialogs . ask_file ( message = msg , title = title , default = argInitialFile , save = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set a restore point ( copy the object ) then call the method . : return : obj . do_method ( * args )<CODESPLIT>def do ( self ) : self . restore_point = self . obj . copy ( ) return self . do_method ( self . obj , * self . args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .<CODESPLIT>def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Short Time Fourier Transform for complex data .<CODESPLIT>def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft return stft . base ( transform = fft , inverse_transform = ifft ) ( func , * * kwparams )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adapts a Numpy array into an ARRAY string to put into the database .<CODESPLIT>def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that the Executor must be close () d elsewhere or join () will never return .<CODESPLIT>def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield directory file names .<CODESPLIT>def directory_files ( path ) : for entry in os . scandir ( path ) : if not entry . name . startswith ( '.' ) and entry . is_file ( ) : yield entry . name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type an integer type?<CODESPLIT>def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When the with statement ends .<CODESPLIT>def __exit__ ( self , type , value , traceback ) : if not self . asarfile : return self . asarfile . close ( ) self . asarfile = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get list of all uppercase non - private globals ( doesn t start with _ ) .<CODESPLIT>def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( "_" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterate through marshmallow schema fields .<CODESPLIT>def iter_fields ( self , schema : Schema ) -> Iterable [ Tuple [ str , Field ] ] : for name in sorted ( schema . fields . keys ( ) ) : field = schema . fields [ name ] yield field . dump_to or name , field
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator for simple in - place decorator mocking for tests<CODESPLIT>def tinsel ( to_patch , module_name , decorator = mock_decorator ) : def fn_decorator ( function ) : def wrapper ( * args , * * kwargs ) : with patch ( to_patch , decorator ) : m = importlib . import_module ( module_name ) reload ( m ) function ( * args , * * kwargs ) reload ( m ) return wrapper return fn_decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is a finite number .<CODESPLIT>def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the chars in the given string .<CODESPLIT>def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts data back into original format .<CODESPLIT>def reverse_transform ( self , col ) : output = pd . DataFrame ( ) output [ self . col_name ] = self . get_category ( col [ self . col_name ] ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render empty responses .<CODESPLIT>def render_none ( self , context , result ) : context . response . body = b'' del context . response . content_length return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize obj as a JSON formatted stream to fp<CODESPLIT>def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the absolute path to the directory containing the package data .<CODESPLIT>def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , "data" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits on multiple given separators .<CODESPLIT>def multi_split ( s , split ) : # type: (S, Iterable[S]) -> List[S] for r in split : s = s . replace ( r , "|" ) return [ i for i in s . split ( "|" ) if len ( i ) > 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case<CODESPLIT>def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format numpy array as a string .<CODESPLIT>def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( "," ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + "%s[%s]" % ( arr . dtype , shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same order unique list using only a list compression .<CODESPLIT>def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the last line of the cell a line with code?<CODESPLIT>def cell_ends_with_code ( lines ) : if not lines : return False if not lines [ - 1 ] . strip ( ) : return False if lines [ - 1 ] . startswith ( '#' ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a cleaned string with token sorted .<CODESPLIT>def _process_and_sort ( s , force_ascii , full_process = True ) : # pull tokens ts = utils . full_process ( s , force_ascii = force_ascii ) if full_process else s tokens = ts . split ( ) # sort tokens and join sorted_string = u" " . join ( sorted ( tokens ) ) return sorted_string . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) .<CODESPLIT>def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Project x and y<CODESPLIT>def __call__ ( self , xy ) : x , y = xy return ( self . x ( x ) , self . y ( y ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conveinience :<CODESPLIT>def get_tablenames ( cur ) : cur . execute ( "SELECT name FROM sqlite_master WHERE type='table'" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins a voice channel<CODESPLIT>async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a str and transform it into a byte array .<CODESPLIT>def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns is seq is sequence and not string .<CODESPLIT>def _is_proper_sequence ( seq ) : return ( isinstance ( seq , collections . abc . Sequence ) and not isinstance ( seq , str ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transparently unzip the file handle<CODESPLIT>def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x .<CODESPLIT>def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a dictionary of strings from a file<CODESPLIT>def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of synsets of a word after lemmatization .<CODESPLIT>def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string in boolean<CODESPLIT>def boolean ( flag ) : s = flag . lower ( ) if s in ( '1' , 'yes' , 'true' ) : return True elif s in ( '0' , 'no' , 'false' ) : return False raise ValueError ( 'Unknown flag %r' % s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts the string representation of a json number into its python object equivalent an int long float or whatever type suits .<CODESPLIT>def default_number_converter ( number_str ) : is_int = ( number_str . startswith ( '-' ) and number_str [ 1 : ] . isdigit ( ) ) or number_str . isdigit ( ) # FIXME: this handles a wider range of numbers than allowed by the json standard, # etc.: float('nan') and float('inf'). But is this a problem? return int ( number_str ) if is_int else float ( number_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple from parsing a b c d - > ( a b c d )<CODESPLIT>def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses CREATE INDEX CONCURRENTLY to create a duplicate index then tries to swap the new index for the original .<CODESPLIT>def cmd_reindex ( ) : db = connect ( args . database ) for idx in args . indexes : pg_reindex ( db , idx )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if arg is a valid file that already exists on the file system .<CODESPLIT>def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( "The folder %s does not exist!" % arg ) else : return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the given number in decimal format using a period and commas<CODESPLIT>def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books )<CODESPLIT>def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ "_shards" ] [ "failed" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return random lognormal variates .<CODESPLIT>def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an OrderedDict containing C values to a 1D array .<CODESPLIT>def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If pyyaml > 5 . 1 use full_load to avoid warning<CODESPLIT>def load_yaml ( file ) : if hasattr ( yaml , "full_load" ) : return yaml . full_load ( file ) else : return yaml . load ( file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801<CODESPLIT>def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize the string according to normalization list<CODESPLIT>def normalize ( self , string ) : return '' . join ( [ self . _normalize . get ( x , x ) for x in nfd ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tests if an object is a collection .<CODESPLIT>def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a stringified representation of this object .<CODESPLIT>def __repr__ ( self ) : return str ( { 'name' : self . _name , 'watts' : self . _watts , 'type' : self . _output_type , 'id' : self . _integration_id } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bitwise xor on equal length bytearrays .<CODESPLIT>def xor ( a , b ) : return bytearray ( i ^ j for i , j in zip ( a , b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>replace nan in a by val and returns the replaced array and the nan position<CODESPLIT>def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Match two names .<CODESPLIT>def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Random generator ( PyCrypto getrandbits wrapper ) . The result is a non - negative value .<CODESPLIT>def random_int ( maximum_value ) : if maximum_value == 0 : return 0 elif maximum_value == 1 : return random_bits ( 1 ) bits = math . floor ( math . log2 ( maximum_value ) ) result = random_bits ( bits ) + random_int ( maximum_value - ( ( 2 ** bits ) - 1 ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join list of columns into a string for a SQL query<CODESPLIT>def join_cols ( cols ) : return ", " . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply transformation and return if an update happened .<CODESPLIT>def apply ( self , node ) : new_node = self . run ( node ) return self . update , new_node
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send signal to process .<CODESPLIT>def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .<CODESPLIT>def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Banana banana<CODESPLIT>def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s="%s"' % ( k , v ) for k , v in dict_ . items ( ) ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an array . Keyword arguments as per : func : zarr . creation . zeros .<CODESPLIT>def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a date object and return the first day of the month .<CODESPLIT>def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get letters from string only .<CODESPLIT>def return_letters_from_string ( text ) : out = "" for letter in text : if letter . isalpha ( ) : out += letter return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from strings to integers<CODESPLIT>def str2int ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . str2int ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .<CODESPLIT>def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Array of vector lengths<CODESPLIT>def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>position in 3d space<CODESPLIT>def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return start and end date of this quarter .<CODESPLIT>def this_quarter ( ) : since = TODAY + delta ( day = 1 ) while since . month % 3 != 0 : since -= delta ( months = 1 ) until = since + delta ( months = 3 ) return Date ( since ) , Date ( until )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an interable of nodes with no edges pointing at them . This is helpful to find all nodes without dependencies .<CODESPLIT>def leaf_nodes ( self ) : # Now contains all nodes that contain dependencies. deps = { item for sublist in self . edges . values ( ) for item in sublist } # contains all nodes *without* any dependencies (leaf nodes) return self . nodes - deps
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Entry point for tappy command .<CODESPLIT>def main ( argv = sys . argv , stream = sys . stderr ) : args = parse_args ( argv ) suite = build_suite ( args ) runner = unittest . TextTestRunner ( verbosity = args . verbose , stream = stream ) result = runner . run ( suite ) return get_status ( result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter for dict note f should have signature : f :: key - > value - > bool<CODESPLIT>def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if arguments are tuple type .<CODESPLIT>def tuple_check ( * args , func = None ) : func = func or inspect . stack ( ) [ 2 ] [ 3 ] for var in args : if not isinstance ( var , ( tuple , collections . abc . Sequence ) ) : name = type ( var ) . __name__ raise TupleError ( f'Function {func} expected tuple, {name} got instead.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the size of remote files<CODESPLIT>def server ( self ) : try : tar = urllib2 . urlopen ( self . registry ) meta = tar . info ( ) return int ( meta . getheaders ( "Content-Length" ) [ 0 ] ) except ( urllib2 . URLError , IndexError ) : return " "
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all non - printable characters from a text string<CODESPLIT>def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simplified check to see if the text appears to be a URL .<CODESPLIT>def looks_like_url ( url ) : if not isinstance ( url , basestring ) : return False if not isinstance ( url , basestring ) or len ( url ) >= 1024 or not cre_url . match ( url ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return index of the nth match found of pattern in strings<CODESPLIT>def where_is ( strings , pattern , n = 1 , lookup_func = re . match ) : count = 0 for idx , item in enumerate ( strings ) : if lookup_func ( pattern , item ) : count += 1 if count == n : return idx return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterate through the results but if an exception occurs stop processing the results and instead replace the results with the output from the exception handler .<CODESPLIT>def trap_exceptions ( results , handler , exceptions = Exception ) : try : for result in results : yield result except exceptions as exc : for result in always_iterable ( handler ( exc ) ) : yield result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Release the lock on the file .<CODESPLIT>def Unlock ( fd , path ) : try : fcntl . flock ( fd , fcntl . LOCK_UN | fcntl . LOCK_NB ) except IOError as e : if e . errno == errno . EWOULDBLOCK : raise IOError ( 'Exception unlocking %s. Locked by another process.' % path ) else : raise IOError ( 'Exception unlocking %s. %s.' % ( path , str ( e ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to unpickle data from picklefile .<CODESPLIT>def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if cnr or cns files are empty ( only have a header )<CODESPLIT>def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the value in the request cache if the django cached response was a hit .<CODESPLIT>def _set_request_cache_if_django_cache_hit ( key , django_cached_response ) : if django_cached_response . is_found : DEFAULT_REQUEST_CACHE . set ( key , django_cached_response . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to get the location of a Python file .<CODESPLIT>def getScriptLocation ( ) : location = os . path . abspath ( "./" ) if __file__ . rfind ( "/" ) != - 1 : location = __file__ [ : __file__ . rfind ( "/" ) ] return location
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into separate words .<CODESPLIT>def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Go to parent directory<CODESPLIT>def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print synchronized .<CODESPLIT>def print ( cls , * args , * * kwargs ) : # pylint: disable=protected-access with _shared . _PRINT_LOCK : print ( * args , * * kwargs ) _sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a function that extracts the value for a column .<CODESPLIT>def get_extract_value_function ( column_identifier ) : def extract_value ( run_result ) : pos = None for i , column in enumerate ( run_result . columns ) : if column . title == column_identifier : pos = i break if pos is None : sys . exit ( 'CPU time missing for task {0}.' . format ( run_result . task_id [ 0 ] ) ) return Util . to_decimal ( run_result . values [ pos ] ) return extract_value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate table chape considering index levels .<CODESPLIT>def _shape ( self , df ) : row , col = df . shape return row + df . columns . nlevels , col + df . index . nlevels
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a ctypes void pointer to the memory mapped region .<CODESPLIT>def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Selectively log an accepted request .<CODESPLIT>def log_request ( self , code = '-' , size = '-' ) : if self . server . logRequests : BaseHTTPServer . BaseHTTPRequestHandler . log_request ( self , code , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test for greater than .<CODESPLIT>def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a variation from a base value<CODESPLIT>def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dump Python object as JSON string .<CODESPLIT>def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a horizontal line up to a given length .<CODESPLIT>def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert special characters using %xx escape .<CODESPLIT>def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Portable cast function .<CODESPLIT>def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the average value of a list of numbers Returns a float<CODESPLIT>def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of days since January 1 of the given year .<CODESPLIT>def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Push a new value into heap .<CODESPLIT>def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of dictionaries which are sorted for only unique entries .<CODESPLIT>def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function executes the request with the provided json payload and return the json response<CODESPLIT>def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts array into chunks with consecutive elements of given step size . http : // stackoverflow . com / questions / 7352684 / how - to - find - the - groups - of - consecutive - elements - from - an - array - in - numpy<CODESPLIT>def consecutive ( data , stepsize = 1 ) : return np . split ( data , np . where ( np . diff ( data ) != stepsize ) [ 0 ] + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set x - axis limits of a subplot .<CODESPLIT>def set_xlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_xlimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the percentile of a sorted list of values .<CODESPLIT>def percentile ( sorted_list , percent , key = lambda x : x ) : if not sorted_list : return None if percent == 1 : return float ( sorted_list [ - 1 ] ) if percent == 0 : return float ( sorted_list [ 0 ] ) n = len ( sorted_list ) i = percent * n if ceil ( i ) == i : i = int ( i ) return ( sorted_list [ i - 1 ] + sorted_list [ i ] ) / 2 return float ( sorted_list [ ceil ( i ) - 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns system clipboard contents .<CODESPLIT>def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Similar to print but prints to stderr .<CODESPLIT>def print_err ( * args , end = '\n' ) : print ( * args , end = end , file = sys . stderr ) sys . stderr . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes object obj from the index .<CODESPLIT>def _remove_from_index ( index , obj ) : try : index . value_map [ indexed_value ( index , obj ) ] . remove ( obj . id ) except KeyError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of keys in the database<CODESPLIT>def keys ( self , index = None ) : with self . _lmdb . begin ( ) as txn : return [ key . decode ( ) for key , _ in txn . cursor ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips spaces : param x : : return :<CODESPLIT>def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\t' , b'' ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Builds a resource object property .<CODESPLIT>def resource_property ( klass , name , * * kwargs ) : klass . PROPERTIES [ name ] = kwargs def getter ( self ) : return getattr ( self , '_%s' % name , kwargs . get ( 'default' , None ) ) if kwargs . get ( 'readonly' , False ) : setattr ( klass , name , property ( getter ) ) else : def setter ( self , value ) : setattr ( self , '_%s' % name , value ) setattr ( klass , name , property ( getter , setter ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manually specify the x - axis log tick values .<CODESPLIT>def set_logxticks_for_all ( self , row_column_list = None , logticks = None ) : if row_column_list is None : self . ticks [ 'x' ] = [ '1e%d' % u for u in logticks ] else : for row , column in row_column_list : self . set_logxticks ( row , column , logticks )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace all the ocurrences ( in a file ) of a string with another value .<CODESPLIT>def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the size of x along axis dimensions only .<CODESPLIT>def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return locale from GET lang param or automatically .<CODESPLIT>def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix multiplication using binary<CODESPLIT>def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current mouse location ( coordinates and screen number ) .<CODESPLIT>def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates RGB values from HSV values in line with a typical light spectrum .<CODESPLIT>def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connects to publisher<CODESPLIT>def connect ( self ) : self . client = redis . Redis ( host = self . host , port = self . port , password = self . password )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Concatenate list of columns into a string .<CODESPLIT>def cols_str ( columns ) : cols = "" for c in columns : cols = cols + wrap ( c ) + ', ' return cols [ : - 2 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return child elements of type tagName if found else []<CODESPLIT>def getChildElementsByTagName ( self , tagName ) : result = [ ] for child in self . childNodes : if isinstance ( child , Element ) : if child . tagName == tagName : result . append ( child ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if given string is a punctuation<CODESPLIT>def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>printdict<CODESPLIT>def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get string from file .<CODESPLIT>def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a * Polygon * instance out of a list of lists each sublist being populated with pyowm . utils . geo . Point instances : param list_of_lists : list : type : list_of_lists : iterable_of_polygons : returns : a * Polygon * instance<CODESPLIT>def from_points ( cls , list_of_lists ) : result = [ ] for l in list_of_lists : curve = [ ] for point in l : curve . append ( ( point . lon , point . lat ) ) result . append ( curve ) return Polygon ( result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructs an object holding a datetime / timestamp value .<CODESPLIT>def Timestamp ( year , month , day , hour , minute , second ) : return datetime . datetime ( year , month , day , hour , minute , second )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response .<CODESPLIT>def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == "POST" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == "OPTIONS" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the SHA1 hash of the given a file - like object as file . This will seek the file back to 0 when it s finished .<CODESPLIT>def _get_file_sha1 ( file ) : bits = file . read ( ) file . seek ( 0 ) h = hashlib . new ( 'sha1' , bits ) . hexdigest ( ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure file deleted also on * Windows * where read - only files need special treatment .<CODESPLIT>def rmfile ( path ) : if osp . isfile ( path ) : if is_win : os . chmod ( path , 0o777 ) os . remove ( path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Correct text in one language that is incorrectly - typed with a keyboard layout in another language . ( type Thai with English keyboard )<CODESPLIT>def thai_to_eng ( text : str ) -> str : return "" . join ( [ TH_EN_KEYB_PAIRS [ ch ] if ( ch in TH_EN_KEYB_PAIRS ) else ch for ch in text ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emulate lpop .<CODESPLIT>def rpop ( self , key ) : redis_list = self . _get_list ( key , 'RPOP' ) if self . _encode ( key ) not in self . redis : return None try : value = redis_list . pop ( ) if len ( redis_list ) == 0 : self . delete ( key ) return value except ( IndexError ) : # Redis returns nil if popping from an empty list return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace all the ocurrences ( in a file ) of a string with another value .<CODESPLIT>def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert datetime / str to date : param arg : : return :<CODESPLIT>def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a dict to a JSON file .<CODESPLIT>def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new dict from an existing dict that only has the given keys<CODESPLIT>def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decision Tree<CODESPLIT>def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if value is a valid UUID .<CODESPLIT>def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns ( module locals ) of the funciton depth frames away from the caller<CODESPLIT>def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert an image by applying a contour<CODESPLIT>def filter_contour ( imageFile , opFile ) : im = Image . open ( imageFile ) im1 = im . filter ( ImageFilter . CONTOUR ) im1 . save ( opFile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : int<CODESPLIT>def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last object in file .<CODESPLIT>def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert human readable string to datetime . datetime .<CODESPLIT>def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Populates an object s attributes using the provided dict<CODESPLIT>def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Direct access to byte data .<CODESPLIT>def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resets the combo box to the original selected value from the constructor ( or the first value if no selected value was specified ) .<CODESPLIT>def select_default ( self ) : if self . _default is None : if not self . _set_option_by_index ( 0 ) : utils . error_format ( self . description + "\n" + "Unable to select default option as the Combo is empty" ) else : if not self . _set_option ( self . _default ) : utils . error_format ( self . description + "\n" + "Unable to select default option as it doesnt exist in the Combo" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the fist ( left - hand ) digits in a string as a single integer ignoring sign ( + / - ) . >>> first_digits ( + 123 . 456 ) 123<CODESPLIT>def first_digits ( s , default = 0 ) : s = re . split ( r'[^0-9]+' , str ( s ) . strip ( ) . lstrip ( '+-' + charlist . whitespace ) ) if len ( s ) and len ( s [ 0 ] ) : return int ( s [ 0 ] ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the leftmost index of an element in a list using binary search .<CODESPLIT>def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first day of the given month .<CODESPLIT>def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of dimensions of a tensor<CODESPLIT>def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if numbers in the list are consecutive<CODESPLIT>def check_if_numbers_are_consecutive ( list_ ) : return all ( ( True if second - first == 1 else False for first , second in zip ( list_ [ : - 1 ] , list_ [ 1 : ] ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine with width in pixels of string .<CODESPLIT>def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print_tree : prints out structure of tree Args : indent ( int ) : What level of indentation at which to start printing Returns : None<CODESPLIT>def print_tree ( self , indent = 2 ) : config . LOGGER . info ( "{indent}{data}" . format ( indent = "   " * indent , data = str ( self ) ) ) for child in self . children : child . print_tree ( indent + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge all columns and place text string in widened cell .<CODESPLIT>def wr_row_mergeall ( self , worksheet , txtstr , fmt , row_idx ) : hdridxval = len ( self . hdrs ) - 1 worksheet . merge_range ( row_idx , 0 , row_idx , hdridxval , txtstr , fmt ) return row_idx + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convolve 2d gaussian .<CODESPLIT>def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resizes an image preserving the aspect ratio .<CODESPLIT>def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into separate words .<CODESPLIT>def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a list of the data types for each column in * data * .<CODESPLIT>def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to get a number out of a string and cast it .<CODESPLIT>def get_number ( s , cast = int ) : import string d = "" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Efficient cartesian product of a list of 1D arrays returning the expanded array views for each dimensions . By default arrays are flattened which may be controlled with the flat flag . The array views can be turned into regular arrays with the copy flag .<CODESPLIT>def cartesian_product ( arrays , flat = True , copy = False ) : arrays = np . broadcast_arrays ( * np . ix_ ( * arrays ) ) if flat : return tuple ( arr . flatten ( ) if copy else arr . flat for arr in arrays ) return tuple ( arr . copy ( ) if copy else arr for arr in arrays )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a datetime from GnuCash 2 . 6 date string<CODESPLIT>def get_from_gnucash26_date ( date_str : str ) -> date : date_format = "%Y%m%d" result = datetime . strptime ( date_str , date_format ) . date ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set a related object for an instance .<CODESPLIT>def __set__ ( self , instance , value ) : self . map [ id ( instance ) ] = ( weakref . ref ( instance ) , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get system root directory ( application installed root directory )<CODESPLIT>def get_system_root_directory ( ) : root = os . path . dirname ( __file__ ) root = os . path . dirname ( root ) root = os . path . abspath ( root ) return root
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>test if object is a list or tuple<CODESPLIT>def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if we need graphviz for different output format<CODESPLIT>def _check_graphviz_available ( output_format ) : try : subprocess . call ( [ "dot" , "-V" ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) except OSError : print ( "The output format '%s' is currently not available.\n" "Please install 'Graphviz' to have other output formats " "than 'dot' or 'vcg'." % output_format ) sys . exit ( 32 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if contents of the files are the same<CODESPLIT>def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize the length of a vector to one<CODESPLIT>def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get object if child already been read or get child .<CODESPLIT>def get_object_or_child_by_type ( self , * types ) : objects = self . get_objects_or_children_by_type ( * types ) return objects [ 0 ] if any ( objects ) else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if valid input tag or document .<CODESPLIT>def assert_valid_input ( cls , tag ) : # Fail on unexpected types. if not cls . is_tag ( tag ) : raise TypeError ( "Expected a BeautifulSoup 'Tag', but instead recieved type {}" . format ( type ( tag ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Configure a Domain registry entry .<CODESPLIT>def _config_win32_domain ( self , domain ) : # we call str() on domain to convert it from unicode to ascii self . domain = dns . name . from_text ( str ( domain ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the parent directory of a filename .<CODESPLIT>def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dispatch all HTTP methods to the proxy .<CODESPLIT>def dispatch ( self , request , * args , * * kwargs ) : self . request = DownstreamRequest ( request ) self . args = args self . kwargs = kwargs self . _verify_config ( ) self . middleware = MiddlewareSet ( self . proxy_middleware ) return self . proxy ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the local variables in the caller s frame .<CODESPLIT>def caller_locals ( ) : import inspect frame = inspect . currentframe ( ) try : return frame . f_back . f_back . f_locals finally : del frame
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param unicode fpath : : param unicode encoding : : rtype : dict | list<CODESPLIT>def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes dict keys which have have self as value .<CODESPLIT>def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Asynchronously run the worker does not close connections . Useful when testing .<CODESPLIT>async def async_run ( self ) -> None : self . main_task = self . loop . create_task ( self . main ( ) ) await self . main_task
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of bytes stored in the value of key within hash name<CODESPLIT>def hstrlen ( self , name , key ) : with self . pipe as pipe : return pipe . hstrlen ( self . redis_key ( name ) , key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like many_until but must consume at least one of these .<CODESPLIT>def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the first sunday of a month .<CODESPLIT>def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is an integer number .<CODESPLIT>def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns symbol instances corresponding to variables of the current scope .<CODESPLIT>def vars_ ( self ) : return [ x for x in self [ self . current_scope ] . values ( ) if x . class_ == CLASS . var ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>merge two dictionaries<CODESPLIT>def dictmerge ( x , y ) : z = x . copy ( ) z . update ( y ) return z
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip trailing component trailing from content if it exists . Used when generating names from view classes .<CODESPLIT>def remove_trailing_string ( content , trailing ) : if content . endswith ( trailing ) and content != trailing : return content [ : - len ( trailing ) ] return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the configuration dictionary to an output file .<CODESPLIT>def write_config ( self , outfile ) : utils . write_yaml ( self . config , outfile , default_flow_style = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shape a list of lists into the appropriate shape and data type<CODESPLIT>def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the number of non - NA in this array along the given axis or axes<CODESPLIT>def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate how much variance in returns do the values explain<CODESPLIT>def explained_variance ( returns , values ) : exp_var = 1 - torch . var ( returns - values ) / torch . var ( returns ) return exp_var . item ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to extract keywords from the text provided .<CODESPLIT>def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace #hashtag and<CODESPLIT>def urlize_twitter ( text ) : html = TwitterText ( text ) . autolink . auto_link ( ) return mark_safe ( html . replace ( 'twitter.com/search?q=' , 'twitter.com/search/realtime/' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the modulo value .<CODESPLIT>def mod ( value , arg ) : try : return valid_numeric ( value ) % valid_numeric ( arg ) except ( ValueError , TypeError ) : try : return value % arg except Exception : return ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert file extension to lowercase .<CODESPLIT>def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the error rate based on dense predictions and 1 - hot labels .<CODESPLIT>def error_rate ( predictions , labels ) : return 100.0 - ( 100.0 * np . sum ( np . argmax ( predictions , 1 ) == np . argmax ( labels , 1 ) ) / predictions . shape [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this attribute present?<CODESPLIT>def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn a list into a comma - and / or and - separated string .<CODESPLIT>def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks for local config overrides for pylint and add them in the correct pylint options format .<CODESPLIT>def get_pylint_options ( config_dir = '.' ) : # type: (str) -> List[str] if PYLINT_CONFIG_NAME in os . listdir ( config_dir ) : pylint_config_path = PYLINT_CONFIG_NAME else : pylint_config_path = DEFAULT_PYLINT_CONFIG_PATH return [ '--rcfile={}' . format ( pylint_config_path ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create the empty database ( tables ) .<CODESPLIT>def create_all ( self , check_first : bool = True ) : self . _metadata . create_all ( self . engine , checkfirst = check_first )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether this path is a symbolic link .<CODESPLIT>def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like many_until but must consume at least one of these .<CODESPLIT>def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places a legend box outside a matplotlib Axes instance .<CODESPLIT>def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of JSON values to a list of models<CODESPLIT>def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip accents to prepare for slugification .<CODESPLIT>def strip_accents ( s ) : nfkd = unicodedata . normalize ( 'NFKD' , unicode ( s ) ) return u'' . join ( ch for ch in nfkd if not unicodedata . combining ( ch ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from a list preserving the order .<CODESPLIT>def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get input from the user given an input function and an input string<CODESPLIT>def get_input ( input_func , input_str ) : val = input_func ( "Please enter your {0}: " . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( "You didn't enter a valid {0}, please try again: " . format ( input_str ) ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets a naive datetime from a datetime .<CODESPLIT>def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , "asdatetime" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the number of non - NA in this array along the given axis or axes<CODESPLIT>def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dict . update but which merges child dicts ( dict2 takes precedence where there s conflict ) .<CODESPLIT>def recursively_update ( d , d2 ) : for k , v in d2 . items ( ) : if k in d : if isinstance ( v , dict ) : recursively_update ( d [ k ] , v ) continue d [ k ] = v
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>variance of the values must have 2 or more entries .<CODESPLIT>def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert native python datetime . date object to a format supported by the API<CODESPLIT>def _convert_date_to_dict ( field_date ) : return { DAY : field_date . day , MONTH : field_date . month , YEAR : field_date . year }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if given function has more arguments than given . Call it with context as last argument or without it .<CODESPLIT>def call_with_context ( func , context , * args ) : return make_context_aware ( func , len ( args ) ) ( * args + ( context , ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the most common element in iterable .<CODESPLIT>def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>View the quaternion array as an array of floats<CODESPLIT>def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a re . match object if an empty comment was found on line .<CODESPLIT>def _match_space_at_line ( line ) : regex = re . compile ( r"^{0}$" . format ( _MDL_COMMENT ) ) return regex . match ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>See the descritpion of : func : validate for more details of parameters and return value .<CODESPLIT>def _validate ( data , schema , ac_schema_safe = True , * * options ) : try : jsonschema . validate ( data , schema , * * options ) except ( jsonschema . ValidationError , jsonschema . SchemaError , Exception ) as exc : if ac_schema_safe : return ( False , str ( exc ) ) # Validation was failed. raise return ( True , '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the value of each QuerySet but also add the # property to each return item .<CODESPLIT>def _unordered_iterator ( self ) : for i , qs in zip ( self . _queryset_idxs , self . _querysets ) : for item in qs : setattr ( item , '#' , i ) yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a bool determining if the process is in a running state or not<CODESPLIT>def is_running ( self ) : return self . state in [ self . STATE_IDLE , self . STATE_ACTIVE , self . STATE_SLEEPING ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write DOT comment .<CODESPLIT>def comment ( self , s , * * args ) : self . write ( u"// " ) self . writeln ( s = s , * * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrun True if x is a valid YYYYMMDD date ; otherwise return False .<CODESPLIT>def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert record array to a dictionaries<CODESPLIT>def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close our socket .<CODESPLIT>def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get element by name<CODESPLIT>def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether flyweight object with specified key has already been created .<CODESPLIT>def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Estimates the memory of the supplied array in bytes<CODESPLIT>def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an unsigned integer to a numpy binary array with the first element the MSB and the last element the LSB .<CODESPLIT>def to_bin ( data , width ) : data_str = bin ( data & ( 2 ** width - 1 ) ) [ 2 : ] . zfill ( width ) return [ int ( x ) for x in tuple ( data_str ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate the fill similarity over the image<CODESPLIT>def _sim_fill ( r1 , r2 , imsize ) : bbsize = ( ( max ( r1 [ "max_x" ] , r2 [ "max_x" ] ) - min ( r1 [ "min_x" ] , r2 [ "min_x" ] ) ) * ( max ( r1 [ "max_y" ] , r2 [ "max_y" ] ) - min ( r1 [ "min_y" ] , r2 [ "min_y" ] ) ) ) return 1.0 - ( bbsize - r1 [ "size" ] - r2 [ "size" ] ) / imsize
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the opposite of input condition .<CODESPLIT>def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a property by name<CODESPLIT>def get_propety_by_name ( pif , name ) : warn ( "This method has been deprecated in favor of get_property_by_name" ) return next ( ( x for x in pif . properties if x . name == name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalized Gaussian<CODESPLIT>def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a US format date and return epoch .<CODESPLIT>def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , "%m/%d/%Y" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Random normal variates .<CODESPLIT>def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close our socket .<CODESPLIT>def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>string dict / object / value to JSON<CODESPLIT>def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the ( name value ) pairs of the enum .<CODESPLIT>def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method to check if a set of types is the { AnyObject } singleton<CODESPLIT>def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes the connection<CODESPLIT>def exit ( self ) : self . pubsub . unsubscribe ( ) self . client . connection_pool . disconnect ( ) logger . info ( "Connection to Redis closed" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends a command and an ( optional ) sequence of arguments through to the delegated serial interface . Note that the arguments are passed through as data .<CODESPLIT>def command ( self , cmd , * args ) : self . _serial_interface . command ( cmd ) if len ( args ) > 0 : self . _serial_interface . data ( list ( args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Under UNIX : is a keystroke available?<CODESPLIT>def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes stopwords contained in a list of words .<CODESPLIT>def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips a figure into multiple figures with a trace on each of them<CODESPLIT>def strip_figures ( figure ) : fig = [ ] for trace in figure [ 'data' ] : fig . append ( dict ( data = [ trace ] , layout = figure [ 'layout' ] ) ) return fig
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the parent directory of a filename .<CODESPLIT>def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes the serial port .<CODESPLIT>def close ( self ) : if self . pyb and self . pyb . serial : self . pyb . serial . close ( ) self . pyb = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the length of the longest consecutive run of identical values .<CODESPLIT>def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function should be called instead of direct spio . loadmat as it cures the problem of not properly recovering python dictionaries from mat files . It calls the function check keys to cure all entries which are still mat - objects<CODESPLIT>def loadmat ( filename ) : data = sploadmat ( filename , struct_as_record = False , squeeze_me = True ) return _check_keys ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn a list into a comma - and / or and - separated string .<CODESPLIT>def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the directory path for the given package or module .<CODESPLIT>def path_for_import ( name ) : return os . path . dirname ( os . path . abspath ( import_module ( name ) . __file__ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update inplace widgets position when doing vertical scroll<CODESPLIT>def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python version independent function to obtain the parameters of a typing . Callable object . Returns as tuple : args result . Tested with CPython 2 . 7 3 . 5 3 . 6 and Jython 2 . 7 . 1 .<CODESPLIT>def get_Callable_args_res ( clb ) : try : return clb . __args__ , clb . __result__ except AttributeError : # Python 3.6 return clb . __args__ [ : - 1 ] , clb . __args__ [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the length of the list .<CODESPLIT>def llen ( self , name ) : with self . pipe as pipe : return pipe . llen ( self . redis_key ( name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Login to a docker registry with write permissions<CODESPLIT>def write_login ( collector , image , * * kwargs ) : docker_api = collector . configuration [ "harpoon" ] . docker_api collector . configuration [ "authentication" ] . login ( docker_api , image , is_pushing = True , global_docker = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Repeat each item in iterable n times .<CODESPLIT>def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : img ( PIL Image ) : Image to be padded .<CODESPLIT>def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an integer list into a string list .<CODESPLIT>def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list into a space - separated string and puts it in a dictionary<CODESPLIT>def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : " " . join ( str ( i ) for i in list_ ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert column name to index .<CODESPLIT>def _get_col_index ( name ) : index = string . ascii_uppercase . index col = 0 for c in name . upper ( ) : col = col * 26 + index ( c ) + 1 return col
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out system information ( version MAC addrs ) .<CODESPLIT>async def sysinfo ( dev : Device ) : click . echo ( await dev . get_system_info ( ) ) click . echo ( await dev . get_interface_information ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper funcation that converts text - based get response to tab separated values for additional manipulation .<CODESPLIT>def _tab ( content ) : response = _data_frame ( content ) . to_csv ( index = False , sep = '\t' ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the currently running Python version is new enough .<CODESPLIT>def check_python_version ( ) : # Required due to multiple with statements on one line req_version = ( 2 , 7 ) cur_version = sys . version_info if cur_version >= req_version : print ( "Python version... %sOK%s (found %s, requires %s)" % ( Bcolors . OKGREEN , Bcolors . ENDC , str ( platform . python_version ( ) ) , str ( req_version [ 0 ] ) + "." + str ( req_version [ 1 ] ) ) ) else : print ( "Python version... %sFAIL%s (found %s, requires %s)" % ( Bcolors . FAIL , Bcolors . ENDC , str ( cur_version ) , str ( req_version ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove commas from a float<CODESPLIT>def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to add timezone information to datetime so that datetime is comparable to other datetime objects in recent versions that now also have timezone information .<CODESPLIT>def datetime_from_timestamp ( timestamp , content ) : return set_date_tzinfo ( datetime . fromtimestamp ( timestamp ) , tz_name = content . settings . get ( 'TIMEZONE' , None ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the extension if the filename has it . None if not .<CODESPLIT>def get_file_extension ( filename ) : filename_x = filename . split ( '.' ) if len ( filename_x ) > 1 : if filename_x [ - 1 ] . strip ( ) is not '' : return filename_x [ - 1 ] return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download file from http url link<CODESPLIT>def download_file ( save_path , file_url ) : r = requests . get ( file_url ) # create HTTP response object with open ( save_path , 'wb' ) as f : f . write ( r . content ) return save_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds self as child of parent then adds parent .<CODESPLIT>def add_parent ( self , parent ) : parent . add_child ( self ) self . parent = parent return parent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the output shape from an array .<CODESPLIT>def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Always line buffer stdout so pipes and redirects are CLI friendly .<CODESPLIT>def linebuffered_stdout ( ) : if sys . stdout . line_buffering : return sys . stdout orig = sys . stdout new = type ( orig ) ( orig . buffer , encoding = orig . encoding , errors = orig . errors , line_buffering = True ) new . mode = orig . mode return new
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the previous quarter for dt<CODESPLIT>def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .<CODESPLIT>def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move to the end of the input history i . e . the line currently being entered .<CODESPLIT>def end_of_history ( event ) : event . current_buffer . history_forward ( count = 10 ** 100 ) buff = event . current_buffer buff . go_to_history ( len ( buff . _working_lines ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to read bytes until a certain end byte is hit<CODESPLIT>def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is the same functionality as int . from_bytes in python 3<CODESPLIT>def _from_bytes ( bytes , byteorder = "big" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove arduino / examples / all directory .<CODESPLIT>def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of values for the given selection .<CODESPLIT>def get_selected_values ( self , selection ) : return [ v for b , v in self . _choices if b & selection ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does openat read - only then does fdopen to get a file object<CODESPLIT>def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the request payload size<CODESPLIT>def calculate_size ( name , replace_existing_values ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += BOOLEAN_SIZE_IN_BYTES return data_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that verify if the header parameter is a essential header<CODESPLIT>def required_header ( header ) : if header in IGNORE_HEADERS : return False if header . startswith ( 'HTTP_' ) or header == 'CONTENT_TYPE' : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Order - preserving sorting function .<CODESPLIT>def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort files or folders by modified time<CODESPLIT>def sort_by_modified ( files_or_folders : list ) -> list : return sorted ( files_or_folders , key = os . path . getmtime , reverse = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .<CODESPLIT>def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ctypes int pointer array to a numpy array .<CODESPLIT>def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to lowercase and strip spaces<CODESPLIT>def lowstrip ( term ) : term = re . sub ( '\s+' , ' ' , term ) term = term . lower ( ) return term
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill an array from a list<CODESPLIT>def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set access and modification times on a file .<CODESPLIT>def set_file_mtime ( path , mtime , atime = None ) : if not atime : atime = mtime f = open ( path , 'a' ) try : os . utime ( path , ( atime , mtime ) ) finally : f . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip all the accents from the string<CODESPLIT>def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of rows of the main dataframe<CODESPLIT>def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , "Can not count data" ) return return num
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Clean up whitespace in column names . See better version at pugnlp . clean_columns<CODESPLIT>def normalize_column_names ( df ) : columns = df . columns if hasattr ( df , 'columns' ) else df columns = [ c . lower ( ) . replace ( ' ' , '_' ) for c in columns ] return columns
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _numbers_units ( 45 ) 123456789012345678901234567890123456789012345<CODESPLIT>def _numbers_units ( N ) : lst = range ( 1 , N + 1 ) return "" . join ( list ( map ( lambda i : str ( i % 10 ) , lst ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>determines whether the card number is valid .<CODESPLIT>def is_valid ( number ) : n = str ( number ) if not n . isdigit ( ) : return False return int ( n [ - 1 ] ) == get_check_digit ( n [ : - 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the input and output buffers<CODESPLIT>def __clear_buffers ( self ) : try : self . _port . reset_input_buffer ( ) self . _port . reset_output_buffer ( ) except AttributeError : #pySerial 2.7 self . _port . flushInput ( ) self . _port . flushOutput ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform get request handling rate limiting .<CODESPLIT>def _ratelimited_get ( self , * args , * * kwargs ) : with self . _ratelimiter : resp = self . session . get ( * args , * * kwargs ) # It's possible that Space-Track will return HTTP status 500 with a # query rate limit violation. This can happen if a script is cancelled # before it has finished sleeping to satisfy the rate limit and it is # started again. # # Let's catch this specific instance and retry once if it happens. if resp . status_code == 500 : # Let's only retry if the error page tells us it's a rate limit # violation. if 'violated your query rate limit' in resp . text : # Mimic the RateLimiter callback behaviour. until = time . time ( ) + self . _ratelimiter . period t = threading . Thread ( target = self . _ratelimit_callback , args = ( until , ) ) t . daemon = True t . start ( ) time . sleep ( self . _ratelimiter . period ) # Now retry with self . _ratelimiter : resp = self . session . get ( * args , * * kwargs ) return resp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list copy in which each item occurs only once ( in - order ) .<CODESPLIT>def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an SMTP servername guess from outgoing email address .<CODESPLIT>def get_server ( address = None ) : if address : domain = address . split ( "@" ) [ 1 ] try : return SMTP_SERVERS [ domain ] except KeyError : return ( "smtp." + domain , 465 ) return ( None , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A map to look up the index of a edge<CODESPLIT>def edge_index ( self ) : return dict ( ( edge , index ) for index , edge in enumerate ( self . edges ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare two strings while protecting against timing attacks<CODESPLIT>def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of rows of the main dataframe<CODESPLIT>def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , "Can not count data" ) return return num
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Similar to : attr : . Guild . me except it may return the : class : . ClientUser in private message contexts .<CODESPLIT>def me ( self ) : return self . guild . me if self . guild is not None else self . bot . user
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove an object from the bin folder .<CODESPLIT>def remove_from_lib ( self , name ) : self . __remove_path ( os . path . join ( self . root_dir , "lib" , name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run a demo doitlive session .<CODESPLIT>def demo ( quiet , shell , speed , prompt , commentecho ) : run ( DEMO , shell = shell , speed = speed , test_mode = TESTING , prompt_template = prompt , quiet = quiet , commentecho = commentecho , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An argparse type representing an email address .<CODESPLIT>def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( "{0} is not a valid email address" . format ( repr ( arg ) ) ) return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>determines whether the card number is valid .<CODESPLIT>def is_valid ( number ) : n = str ( number ) if not n . isdigit ( ) : return False return int ( n [ - 1 ] ) == get_check_digit ( n [ : - 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move cursor to this line in the current buffer .<CODESPLIT>def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the checkbox matching the CSS selector .<CODESPLIT>def check_by_selector ( self , selector ) : elem = find_element_by_jquery ( world . browser , selector ) if not elem . is_selected ( ) : elem . click ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string * s * into list of strings no longer than * length *<CODESPLIT>def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for iterating only nonempty lines without line breaks<CODESPLIT>def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\r\n' ) if line : yield line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resizes an image preserving the aspect ratio .<CODESPLIT>def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts and image to matrix ( one pixel per line )<CODESPLIT>def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a one element byte string to signed int for python 2 support .<CODESPLIT>def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( "b" , string ) [ 0 ] else : return struct . unpack ( "b" , bytes ( [ string ] ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the indent for standardized output : param message : ( str ) : return : ( str )<CODESPLIT>def indent ( self , message ) : indent = self . indent_char * self . indent_size return indent + message
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to read an XML file<CODESPLIT>def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins a voice channel<CODESPLIT>async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn bytes into base64<CODESPLIT>def bytes_base64 ( x ) : if six . PY2 : return base64 . encodestring ( x ) . replace ( '\n' , '' ) return base64 . encodebytes ( bytes_encode ( x ) ) . replace ( b'\n' , b'' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>updates the scale of all actors in the plotter<CODESPLIT>def update_scale ( self , value ) : self . plotter . set_scale ( self . x_slider_group . value , self . y_slider_group . value , self . z_slider_group . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add an object to Javascript .<CODESPLIT>def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a date into a datetime<CODESPLIT>def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute Pearson correlation coefficient .<CODESPLIT>def cor ( y_true , y_pred ) : y_true , y_pred = _mask_nan ( y_true , y_pred ) return np . corrcoef ( y_true , y_pred ) [ 0 , 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns json contents as string<CODESPLIT>def open_json ( file_name ) : with open ( file_name , "r" ) as json_data : data = json . load ( json_data ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test whether the current python environment is the correct lore env .<CODESPLIT>def launched ( ) : if not PREFIX : return False return os . path . realpath ( sys . prefix ) == os . path . realpath ( PREFIX )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log memory usage before and after a method .<CODESPLIT>def memory_usage ( method ) : def wrapper ( * args , * * kwargs ) : logging . info ( 'Memory before method %s is %s.' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) result = method ( * args , * * kwargs ) logging . info ( 'Memory after method %s is %s' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) return result return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns index tuple in histogram of bin which contains value<CODESPLIT>def get_bin_indices ( self , values ) : return tuple ( [ self . get_axis_bin_index ( values [ ax_i ] , ax_i ) for ax_i in range ( self . dimensions ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print format some XML so it s readable .<CODESPLIT>def pp_xml ( body ) : pretty = xml . dom . minidom . parseString ( body ) return pretty . toprettyxml ( indent = "  " )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply the coefficients from a linear fit to an array of x y positions .<CODESPLIT>def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the modified time for a file as a datetime instance<CODESPLIT>def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to uncheck a checkbox<CODESPLIT>def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for fast reading from sensor files .<CODESPLIT>def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Json - serializable dict representation of PhononDos .<CODESPLIT>def as_dict ( self ) : return { "@module" : self . __class__ . __module__ , "@class" : self . __class__ . __name__ , "frequencies" : list ( self . frequencies ) , "densities" : list ( self . densities ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield all items from iterable except the last one .<CODESPLIT>def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns unique values in a column<CODESPLIT>def unique_ ( self , col ) : try : df = self . df . drop_duplicates ( subset = [ col ] , inplace = False ) return list ( df [ col ] ) except Exception as e : self . err ( e , "Can not select unique data" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Guess string encoding .<CODESPLIT>def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implementaton of : func : scipy . linalg . cho_factor using a function supported in cupy .<CODESPLIT>def _cho_factor ( A , lower = True , check_finite = True ) : return cp . linalg . cholesky ( A ) , True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the modified time for a file as a datetime instance<CODESPLIT>def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>cv2 Image of current window screen<CODESPLIT>def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR   cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rotates an image by deg degrees<CODESPLIT>def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dict mapping item - > indices .<CODESPLIT>def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join the given iterable with<CODESPLIT>def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes // - comments and single - line C - style / * * / comments .<CODESPLIT>def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates RGB values from HSV values in line with a typical light spectrum .<CODESPLIT>def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Special case of version () when the executable is a JAR file .<CODESPLIT>def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out a neat targets dependency tree based on requested targets .<CODESPLIT>def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Install Postgres on remote<CODESPLIT>def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes a DOT graphviz file of the domain structure and returns the filename<CODESPLIT>def to_dotfile ( self ) : domain = self . get_domain ( ) filename = "%s.dot" % ( self . __class__ . __name__ ) nx . write_dot ( domain , filename ) return filename
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented .<CODESPLIT>def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parameters ---------- data_path : str<CODESPLIT>def read_raw ( data_path ) : with open ( data_path , 'rb' ) as f : data = pickle . load ( f ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets a horiztonal line<CODESPLIT>def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that the Executor must be close () d elsewhere or join () will never return .<CODESPLIT>def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Under UNIX : is a keystroke available?<CODESPLIT>def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies the sofplus activation function element - wise to the input .<CODESPLIT>def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matches a paren .<CODESPLIT>def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove non - alphanumerical characters from metric word . And trim excessive underscores .<CODESPLIT>def sanitize_word ( s ) : s = re . sub ( '[^\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message .<CODESPLIT>def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\r\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>searchs a value in a dicionary and returns the key of the first occurrence<CODESPLIT>def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Init a uniform noise variable .<CODESPLIT>def uniform_noise ( points ) : return np . random . rand ( 1 ) * np . random . uniform ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply a given function to the elements of one or several asynchronous sequences .<CODESPLIT>async def smap ( source , func , * more_sources ) : if more_sources : source = zip ( source , * more_sources ) async with streamcontext ( source ) as streamer : async for item in streamer : yield func ( * item ) if more_sources else func ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Underline the input<CODESPLIT>def underline ( self , msg ) : return click . style ( msg , underline = True ) if self . colorize else msg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set foreground - and background colors and intensity .<CODESPLIT>def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Searches for the specified method and returns its descriptor .<CODESPLIT>def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a Qt application .<CODESPLIT>def create_app ( ) : global QT_APP QT_APP = QApplication . instance ( ) if QT_APP is None : # pragma: no cover QT_APP = QApplication ( sys . argv ) return QT_APP
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transform mongoengine . QuerySet to json<CODESPLIT>def mongoqs_to_json ( qs , fields = None ) : l = list ( qs . as_pymongo ( ) ) for element in l : element . pop ( '_cls' ) # use DjangoJSONEncoder for transform date data type to datetime json_qs = json . dumps ( l , indent = 2 , ensure_ascii = False , cls = DjangoJSONEncoder ) return json_qs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value in the pandas DataFrame<CODESPLIT>def SetValue ( self , row , col , value ) : self . dataframe . iloc [ row , col ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>writes a string to file<CODESPLIT>def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An auxiliary function to construct a dictionary of Criteria<CODESPLIT>def atom_criteria ( * params ) : result = { } for index , param in enumerate ( params ) : if param is None : continue elif isinstance ( param , int ) : result [ index ] = HasAtomNumber ( param ) else : result [ index ] = param return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delayed close - won t close immediately but on the next reactor loop .<CODESPLIT>def delayed_close ( self ) : self . state = SESSION_STATE . CLOSING reactor . callLater ( 0 , self . close )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .<CODESPLIT>def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a single property to the file in Java properties format .<CODESPLIT>def write_property ( fh , key , value ) : if key is COMMENT : write_comment ( fh , value ) return _require_string ( key , 'keys' ) _require_string ( value , 'values' ) fh . write ( _escape_key ( key ) ) fh . write ( b'=' ) fh . write ( _escape_value ( value ) ) fh . write ( b'\n' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in string astr replace all occurences of thefind with thereplace<CODESPLIT>def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly .<CODESPLIT>def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove decoded instruction from instruction cache<CODESPLIT>def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the largest contig for each strain : param contig_lengths_dict : dictionary of strain name : reverse - sorted list of all contig lengths : return : longest_contig_dict : dictionary of strain name : longest contig<CODESPLIT>def find_largest_contig ( contig_lengths_dict ) : # Initialise the dictionary longest_contig_dict = dict ( ) for file_name , contig_lengths in contig_lengths_dict . items ( ) : # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict [ file_name ] = contig_lengths [ 0 ] return longest_contig_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get rid of all axis ticks lines etc .<CODESPLIT>def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple merge of samplesets .<CODESPLIT>def _merge_meta ( model1 , model2 ) : w1 = _get_meta ( model1 ) w2 = _get_meta ( model2 ) return metadata . merge ( w1 , w2 , metadata_conflicts = 'silent' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .<CODESPLIT>def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip excess spaces from a string<CODESPLIT>def strip_spaces ( s ) : return u" " . join ( [ c for c in s . split ( u' ' ) if c ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises the supplied figure number or figure window .<CODESPLIT>def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The relative path ( from environment root ) to python .<CODESPLIT>def _python_rpath ( self ) : # Windows virtualenv installation installs pip to the [Ss]cripts # folder. Here's a simple check to support: if sys . platform == 'win32' : return os . path . join ( 'Scripts' , 'python.exe' ) return os . path . join ( 'bin' , 'python' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>* Get the root path for this python package - used in unit testing code *<CODESPLIT>def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + "/../" return packagePath
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if value value is empty . Keyword arguments : value str -- the value of the associated field to compare<CODESPLIT>def run ( self , value ) : if self . pass_ and not value . strip ( ) : return True if not value : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function returns a pretty table used to display the port results .<CODESPLIT>def get_table ( ports ) : table = PrettyTable ( [ "Name" , "Port" , "Protocol" , "Description" ] ) table . align [ "Name" ] = "l" table . align [ "Description" ] = "l" table . padding_width = 1 for port in ports : table . add_row ( port ) return table
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns int () of val if val is not convertable to int use default instead<CODESPLIT>def safe_int ( val , default = None ) : try : val = int ( val ) except ( ValueError , TypeError ) : val = default return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if a system process identifer exists in process table .<CODESPLIT>def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform an underscore_case string to a mixedCase string<CODESPLIT>def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a square grid with values of the distance from the centre of the grid to each gridpoint<CODESPLIT>def RadiusGrid ( gridSize ) : x , y = np . mgrid [ 0 : gridSize , 0 : gridSize ] x = x - ( gridSize - 1.0 ) / 2.0 y = y - ( gridSize - 1.0 ) / 2.0 return np . abs ( x + 1j * y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an enum from a name Args : enum_name ( str ) : name of the enum Returns : Enum<CODESPLIT>def get_enum_from_name ( self , enum_name ) : return next ( ( e for e in self . enums if e . name == enum_name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function which returns an array with the Intervals boundaries .<CODESPLIT>def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the queue is full False otherwise ( not reliable! ) .<CODESPLIT>def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refresh the screen . You don t need to override this except to update only small portins of the screen .<CODESPLIT>def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accurate float rounding from http : // stackoverflow . com / a / 15398691 .<CODESPLIT>def round_float ( f , digits , rounding = ROUND_HALF_UP ) : return Decimal ( str ( f ) ) . quantize ( Decimal ( 10 ) ** ( - 1 * digits ) , rounding = rounding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dialogue box for choosing directory<CODESPLIT>def ask_dir ( self ) : args [ 'directory' ] = askdirectory ( * * self . dir_opt ) self . dir_text . set ( args [ 'directory' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Integer to two bytes<CODESPLIT>def intToBin ( i ) : # devide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return chr ( i1 ) + chr ( i2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get rid of parenthesis around timezone : ( GMT ) = > GMT<CODESPLIT>def remove_parenthesis_around_tz ( cls , timestr ) : parenthesis = cls . TIMEZONE_PARENTHESIS . match ( timestr ) if parenthesis is not None : return parenthesis . group ( 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an appropriate null value for this field s type . This is used internally when setting the field to None .<CODESPLIT>def _none_value ( self ) : if self . out_type == int : return 0 elif self . out_type == float : return 0.0 elif self . out_type == bool : return False elif self . out_type == six . text_type : return u''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts SoftLayer . CLI . formatting . Table instance to a prettytable .<CODESPLIT>def format_prettytable ( table ) : for i , row in enumerate ( table . rows ) : for j , item in enumerate ( row ) : table . rows [ i ] [ j ] = format_output ( item ) ptable = table . prettytable ( ) ptable . hrules = prettytable . FRAME ptable . horizontal_char = '.' ptable . vertical_char = ':' ptable . junction_char = ':' return ptable
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of all the image s colors .<CODESPLIT>def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn dict keys and values into native strings .<CODESPLIT>def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a random string of ASCII letters and digits .<CODESPLIT>def random_alphanum ( length ) : charset = string . ascii_letters + string . digits return random_string ( length , charset )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>wrapper to search_s<CODESPLIT>def query ( self , base , filterstr , attrlist = None ) : return self . conn . search_s ( base , ldap . SCOPE_SUBTREE , filterstr , attrlist )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a one - hot encoded array back to string<CODESPLIT>def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yields file name if matches a regular expression pattern .<CODESPLIT>def match_files ( files , pattern : Pattern ) : for name in files : if re . match ( pattern , name ) : yield name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove and return the item at index .<CODESPLIT>def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call Java Function<CODESPLIT>def callJavaFunc ( func , * args ) : gateway = _get_gateway ( ) args = [ _py2java ( gateway , a ) for a in args ] result = func ( * args ) return _java2py ( gateway , result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Integer dots per inch for the width of this image . Defaults to 72 when not present in the file as is often the case .<CODESPLIT>def horz_dpi ( self ) : pHYs = self . _chunks . pHYs if pHYs is None : return 72 return self . _dpi ( pHYs . units_specifier , pHYs . horz_px_per_unit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the media - type of the file at the given filepath<CODESPLIT>def guess_media_type ( filepath ) : o = subprocess . check_output ( [ 'file' , '--mime-type' , '-Lb' , filepath ] ) o = o . strip ( ) return o
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Boolean property if this action has expired<CODESPLIT>def expired ( self ) : if self . timeout is None : return False return monotonic ( ) - self . start_time > self . timeout
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorting logic for Quantity objects .<CODESPLIT>def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for inserting float features into Example proto .<CODESPLIT>def _float_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( float_list = tf . train . FloatList ( value = value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print object information using a namedtuple and a format pattern .<CODESPLIT>def _prtfmt ( self , item_id , dashes ) : ntprt = self . id2nt [ item_id ] dct = ntprt . _asdict ( ) self . prt . write ( '{DASHES:{N}}' . format ( DASHES = self . fmt_dashes . format ( DASHES = dashes , ID = self . nm2prtfmt [ 'ID' ] . format ( * * dct ) ) , N = self . dash_len ) ) self . prt . write ( "{INFO}\n" . format ( INFO = self . nm2prtfmt [ 'ITEM' ] . format ( * * dct ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends a PDF to a pyPDF writer . Legacy interface .<CODESPLIT>def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download the page into a string<CODESPLIT>def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts binary address to Ipv6 format .<CODESPLIT>def _get_ipv6_from_binary ( self , bin_addr ) : hi = bin_addr >> 64 lo = bin_addr & 0xFFFFFFFF return socket . inet_ntop ( socket . AF_INET6 , struct . pack ( "!QQ" , hi , lo ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shutdown the service with a reason .<CODESPLIT>def stop ( self , reason = None ) : self . logger . info ( 'stopping' ) self . loop . stop ( pyev . EVBREAK_ALL )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare by iteration<CODESPLIT>def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Old style use JSONTemplateResponse instead of this .<CODESPLIT>def json_template ( data , template_name , template_context ) : html = render_to_string ( template_name , template_context ) data = data or { } data [ 'html' ] = html return HttpResponse ( json_encode ( data ) , content_type = 'application/json' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output all sections of the page .<CODESPLIT>def Output ( self ) : self . Open ( ) self . Header ( ) self . Body ( ) self . Footer ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scale the image in a channel . Also see : meth : zoom_to .<CODESPLIT>def set_scale ( self , scale , no_reset = False ) : return self . scale_to ( * scale [ : 2 ] , no_reset = no_reset )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove prefix ( and space ) from line<CODESPLIT>def uncomment_line ( line , prefix ) : if not prefix : return line if line . startswith ( prefix + ' ' ) : return line [ len ( prefix ) + 1 : ] if line . startswith ( prefix ) : return line [ len ( prefix ) : ] return line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns min ( val1 val2 ) returning None only if both values are None<CODESPLIT>def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Locate the command s man page .<CODESPLIT>def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a numpy array from a base64 buffer<CODESPLIT>def decode_arr ( data ) : data = data . encode ( 'utf-8' ) return frombuffer ( base64 . b64decode ( data ) , float64 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly .<CODESPLIT>def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Google AppEngine Helper to convert a data type into a string .<CODESPLIT>def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve core and memory information for the current machine .<CODESPLIT>def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { "memory" : float ( "%.1f" % ( free_bytes / BYTES_IN_GIG ) ) , "cores" : multiprocessing . cpu_count ( ) , "name" : socket . gethostname ( ) } ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230<CODESPLIT>def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if the object is any kind of function or method .<CODESPLIT>def isroutine ( object ) : return ( isbuiltin ( object ) or isfunction ( object ) or ismethod ( object ) or ismethoddescriptor ( object ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns sequence of integer ids given a sequence of string ids .<CODESPLIT>def strids2ids ( tokens : Iterable [ str ] ) -> List [ int ] : return list ( map ( int , tokens ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scroll element into view<CODESPLIT>def scroll_element_into_view ( self ) : x = self . web_element . location [ 'x' ] y = self . web_element . location [ 'y' ] self . driver . execute_script ( 'window.scrollTo({0}, {1})' . format ( x , y ) ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>exit without breaking pipes .<CODESPLIT>def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>given an Nxm matrix containing boundary info between simplices compute indidence info matrix not very reusable ; should probably not be in this lib<CODESPLIT>def incidence ( boundary ) : return GroupBy ( boundary ) . split ( np . arange ( boundary . size ) // boundary . shape [ 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a directory if it s present . If it s not present no - op .<CODESPLIT>def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a string to a datetime .<CODESPLIT>def to_datetime ( value ) : if value is None : return None if isinstance ( value , six . integer_types ) : return parser . parse ( value ) return parser . isoparse ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invert mapping of dictionary ( i . e . map values to list of keys )<CODESPLIT>def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value<CODESPLIT>def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Version of load_result for multiple input files that will be loaded concurrently .<CODESPLIT>def load_results ( result_files , options , run_set_id = None , columns = None , columns_relevant_for_diff = set ( ) ) : return parallel . map ( load_result , result_files , itertools . repeat ( options ) , itertools . repeat ( run_set_id ) , itertools . repeat ( columns ) , itertools . repeat ( columns_relevant_for_diff ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips trailing whitespace from string lowercases it and replaces spaces with underscores<CODESPLIT>def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\W+' , '_' , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether a system service is available<CODESPLIT>def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a random walk and return True if the walker has returned to the origin after taking n steps .<CODESPLIT>def returned ( n ) : ## `takei` yield lazily so we can short-circuit and avoid computing the rest of the walk for pos in randwalk ( ) >> drop ( 1 ) >> takei ( xrange ( n - 1 ) ) : if pos == Origin : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books )<CODESPLIT>def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ "_shards" ] [ "failed" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string for various input types<CODESPLIT>def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether path is a directory to which the user has write access .<CODESPLIT>def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip the specified number of elements in the list .<CODESPLIT>def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show revision list<CODESPLIT>def show ( config ) : with open ( config , 'r' ) : main . show ( yaml . load ( open ( config ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns date range for the previous full month .<CODESPLIT>def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the king of the other side is attacked . Such a position is not valid and could only be reached by an illegal move .<CODESPLIT>def was_into_check ( self ) -> bool : king = self . king ( not self . turn ) return king is not None and self . is_attacked_by ( self . turn , king )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .<CODESPLIT>def generate_unique_host_id ( ) : host = "." . join ( reversed ( socket . gethostname ( ) . split ( "." ) ) ) pid = os . getpid ( ) return "%s.%d" % ( host , pid )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace accentuated chars in string by their non accentuated equivalent .<CODESPLIT>def unaccentuate ( s ) : return "" . join ( c for c in unicodedata . normalize ( "NFKD" , s ) if not unicodedata . combining ( c ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return sanitized Eidos text field for human readability .<CODESPLIT>def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete this message<CODESPLIT>async def delete ( self ) : return await self . bot . delete_message ( self . chat . id , self . message_id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log all data received from RFLink to file .<CODESPLIT>def log_all ( self , file ) : global rflink_log if file == None : rflink_log = None else : log . debug ( 'logging to: %s' , file ) rflink_log = open ( file , 'a' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge two dicts and return a new dict . Much like subclassing works .<CODESPLIT>def extend ( a : dict , b : dict ) -> dict : res = a . copy ( ) res . update ( b ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace one entire document matching the selector criteria .<CODESPLIT>def replace_one ( self , replacement ) : self . __bulk . add_replace ( self . __selector , replacement , upsert = True , collation = self . __collation )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap the methods atom to include method with key .<CODESPLIT>def __add_method ( m : lmap . Map , key : T , method : Method ) -> lmap . Map : return m . assoc ( key , method )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a float to a precision<CODESPLIT>def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns nr of first entry parseable to float in ll None otherwise<CODESPLIT>def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to run tasks in the event loop<CODESPLIT>def run ( * tasks : Awaitable , loop : asyncio . AbstractEventLoop = asyncio . get_event_loop ( ) ) : futures = [ asyncio . ensure_future ( task , loop = loop ) for task in tasks ] return loop . run_until_complete ( asyncio . gather ( * futures ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert list of key value lists to dict<CODESPLIT>def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hacked run function which installs the trace .<CODESPLIT>def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compile the pattern to regex .<CODESPLIT>def _compile ( pattern , flags ) : return re . compile ( WcParse ( pattern , flags & FLAG_MASK ) . parse ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def to_dict ( self ) : if self . childCount ( ) > 0 : value = { } for index in range ( self . childCount ( ) ) : value . update ( self . child ( index ) . to_dict ( ) ) else : value = self . value return { self . name : value }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim .<CODESPLIT>def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Traverse parent refs to top .<CODESPLIT>def find_root ( self ) : cmd = self while cmd . parent : cmd = cmd . parent return cmd
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decorator to convert a method taking a iterable to a * args one<CODESPLIT>def _iterable_to_varargs_method ( func ) : def wrapped ( self , * args , * * kwargs ) : return func ( self , args , * * kwargs ) return wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tries to encode images with ffmpeg to check if it works .<CODESPLIT>def ffmpeg_works ( ) : images = np . zeros ( ( 2 , 32 , 32 , 3 ) , dtype = np . uint8 ) try : _encode_gif ( images , 2 ) return True except ( IOError , OSError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object<CODESPLIT>def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( "." ) dt = datetime . strptime ( dt , "%Y-%m-%dT%H:%M:%S" ) return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Displayhook function for PIL Images rendered as PNG .<CODESPLIT>def display_pil_image ( im ) : from IPython . core import display b = BytesIO ( ) im . save ( b , format = 'png' ) data = b . getvalue ( ) ip_img = display . Image ( data = data , format = 'png' , embed = True ) return ip_img . _repr_png_ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a sentence into list of words .<CODESPLIT>def split_into_words ( s ) : s = re . sub ( r"\W+" , " " , s ) s = re . sub ( r"[_0-9]+" , " " , s ) return s . split ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of all predecessors of the given node<CODESPLIT>def predecessors ( self , node , graph = None ) : if graph is None : graph = self . graph return [ key for key in graph if node in graph [ key ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the serial port e . g . : / dev / tty . usbserial - A4001ib8<CODESPLIT>def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts an ARRAY string stored in the database back into a Numpy array .<CODESPLIT>def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the id of the last written row in table<CODESPLIT>def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( "SELECT seq FROM sqlite_sequence WHERE name='{0}'" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write image data to PNG JPG file<CODESPLIT>def write_image ( filename , image ) : data_format = get_data_format ( filename ) if data_format is MimeType . JPG : LOGGER . warning ( 'Warning: jpeg is a lossy format therefore saved data will be modified.' ) return Image . fromarray ( image ) . save ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r This function chooses whether to use ascii characters to represent a symbolic expression in the notebook or to use sympy s pprint .<CODESPLIT>def fprint ( expr , print_ascii = False ) : if print_ascii : pprint ( expr , use_unicode = False , num_columns = 120 ) else : return expr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type<CODESPLIT>def QA_util_datetime_to_strdate ( dt ) : strdate = "%04d-%02d-%02d" % ( dt . year , dt . month , dt . day ) return strdate
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse the input JSON data string into a python data structure . Args : data : An input data string lexer : An optional ply . lex instance that overrides the default lexer . Returns : A python dict or list representing the input JSON data .<CODESPLIT>def parse ( self , data , lexer = None , * args , * * kwargs ) : if lexer is None : lexer = self . lexer return self . parser . parse ( data , lexer = lexer , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict from entries in a scala . collection . immutable . Map<CODESPLIT>def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calcuate mean datetime from datetime list<CODESPLIT>def mean_date ( dt_list ) : dt_list_sort = sorted ( dt_list ) dt_list_sort_rel = [ dt - dt_list_sort [ 0 ] for dt in dt_list_sort ] avg_timedelta = sum ( dt_list_sort_rel , timedelta ( ) ) / len ( dt_list_sort_rel ) return dt_list_sort [ 0 ] + avg_timedelta
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the bounding box around nonzero elements in the given array<CODESPLIT>def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the singular form of a word the reverse of : func : pluralize .<CODESPLIT>def singularize ( word ) : for inflection in UNCOUNTABLES : if re . search ( r'(?i)\b(%s)\Z' % inflection , word ) : return word for rule , replacement in SINGULARS : if re . search ( rule , word ) : return re . sub ( rule , replacement , word ) return word
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the remote file exists .<CODESPLIT>def remote_file_exists ( self , url ) : status = requests . head ( url ) . status_code if status != 200 : raise RemoteFileDoesntExist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove non - alphanumerical characters from metric word . And trim excessive underscores .<CODESPLIT>def sanitize_word ( s ) : s = re . sub ( '[^\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .<CODESPLIT>def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a set of unique n - grams from a string .<CODESPLIT>def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recieving the JSON file from uulm<CODESPLIT>def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( "utf-8" ) data = json . loads ( data ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the number of quartets as n - choose - k . This is used in equal splits to decide whether a split should be exhaustively sampled or randomly sampled . Edges near tips can be exhaustive while highly nested edges probably have too many quartets<CODESPLIT>def n_choose_k ( n , k ) : return int ( reduce ( MUL , ( Fraction ( n - i , i + 1 ) for i in range ( k ) ) , 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books )<CODESPLIT>def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ "_shards" ] [ "failed" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a yaml file with the given content .<CODESPLIT>def generate_yaml_file ( filename , contents ) : with open ( filename , 'w' ) as file : file . write ( yaml . dump ( contents , default_flow_style = False ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connects to publisher<CODESPLIT>def connect ( self ) : self . client = redis . Redis ( host = self . host , port = self . port , password = self . password )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes the session to the database .<CODESPLIT>def unlock ( self ) : if not hasattr ( self , 'session' ) : raise RuntimeError ( 'Error detected! The session that you want to close does not exist any more!' ) logger . debug ( "Closed database session of '%s'" % self . _database ) self . session . close ( ) del self . session
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>non - recursively break spaces and remove newlines in the tag<CODESPLIT>def _breakRemNewlines ( tag ) : for i , c in enumerate ( tag . contents ) : if type ( c ) != bs4 . element . NavigableString : continue c . replace_with ( re . sub ( r' {2,}' , ' ' , c ) . replace ( '\n' , '' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple of strings that match the regular expression pattern .<CODESPLIT>def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>StringIO constructor shim for the async wrapper .<CODESPLIT>def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maxheap version of a heappop .<CODESPLIT>def heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add arrow to plot<CODESPLIT>def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the case as an Excel spreadsheet .<CODESPLIT>def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of rows of the main dataframe<CODESPLIT>def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , "Can not count data" ) return return num
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>left button down : report x y coords start zooming mode<CODESPLIT>def onLeftDown ( self , event = None ) : if event is None : return self . cursor_mode_action ( 'leftdown' , event = event ) self . ForwardEvent ( event = event . guiEvent )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorting logic for Quantity objects .<CODESPLIT>def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register callbacks for button press events and selection changed<CODESPLIT>def register_view ( self , view ) : super ( ListViewController , self ) . register_view ( view ) self . tree_view . connect ( 'button_press_event' , self . mouse_click )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check for filelikeness of an object .<CODESPLIT>def is_filelike ( ob ) : if hasattr ( ob , 'read' ) and callable ( ob . read ) : return True if hasattr ( ob , 'write' ) and callable ( ob . write ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean up after connection failure detected .<CODESPLIT>def _connection_failed ( self , error = "Error not specified!" ) : if not self . _error : LOG . error ( "Connection failed: %s" , str ( error ) ) self . _error = error
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given thing represents a date<CODESPLIT>def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a n + 1 dim one - hot array from n dim int - categorical array .<CODESPLIT>def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the file size of a given file<CODESPLIT>def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increments the main progress bar by amount .<CODESPLIT>def increment ( self , amount = 1 ) : self . _primaryProgressBar . setValue ( self . value ( ) + amount ) QApplication . instance ( ) . processEvents ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reads an RDF file into a graph<CODESPLIT>def load_graph_from_rdf ( fname ) : print ( "reading RDF from " + fname + "...." ) store = Graph ( ) store . parse ( fname , format = "n3" ) print ( "Loaded " + str ( len ( store ) ) + " tuples" ) return store
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper to clean up an input string<CODESPLIT>def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Main window move event<CODESPLIT>def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ "window_position" ] = repr ( position )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return index of sub_string in string .<CODESPLIT>def _find ( string , sub_string , start_index ) : result = string . find ( sub_string , start_index ) if result == - 1 : raise TokenError ( "expected '{0}'" . format ( sub_string ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes JSON formatted data converting it into native Python objects<CODESPLIT>def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the variable set with the given name .<CODESPLIT>def get_var ( self , name ) : for var in self . vars : if var . name == name : return var else : raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the queue is full False otherwise ( not reliable! ) .<CODESPLIT>def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a str if a bytes object is given .<CODESPLIT>def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cast integer and strings to timestamps<CODESPLIT>def execute_cast_simple_literal_to_timestamp ( op , data , type , * * kwargs ) : return pd . Timestamp ( data , tz = type . timezone )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a variation from a base value<CODESPLIT>def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the content of the zip - file at zip_path into target_folder .<CODESPLIT>def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isbool ( True ) True >>> _isbool ( False ) True >>> _isbool ( 1 ) False<CODESPLIT>def _isbool ( string ) : return isinstance ( string , _bool_type ) or ( isinstance ( string , ( _binary_type , _text_type ) ) and string in ( "True" , "False" ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x is a 2D sparse matrix with it s first shape equal to 1 .<CODESPLIT>def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given string is an url<CODESPLIT>def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output a networkx graph to a DOT file .<CODESPLIT>def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the value of a local variable somewhere in the call stack .<CODESPLIT>def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw header with underline<CODESPLIT>def draw_header ( self , stream , header ) : stream . writeln ( '=' * ( len ( header ) + 4 ) ) stream . writeln ( '| ' + header + ' |' ) stream . writeln ( '=' * ( len ( header ) + 4 ) ) stream . writeln ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the minimum of an array ignoring any NaNs .<CODESPLIT>def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encodes a list of strings to a single string . : type strs : List [ str ] : rtype : str<CODESPLIT>def encode ( strs ) : res = '' for string in strs . split ( ) : res += str ( len ( string ) ) + ":" + string return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a list of words given text removing punctuation .<CODESPLIT>def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns file group s create aware * datetime * in UTC format .<CODESPLIT>def datetime_created ( self ) : if self . info ( ) . get ( 'datetime_created' ) : return dateutil . parser . parse ( self . info ( ) [ 'datetime_created' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the length of the longest consecutive run of identical values .<CODESPLIT>def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the list have unique items only and maintains the order<CODESPLIT>def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If given environment key is defined print it out .<CODESPLIT>def print_env_info ( key , out = sys . stderr ) : value = os . getenv ( key ) if value is not None : print ( key , "=" , repr ( value ) , file = out )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Centre and normalize a given array .<CODESPLIT>def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to print sqlite queries before executing .<CODESPLIT>def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Temporarily hide the terminal cursor .<CODESPLIT>def hidden_cursor ( ) : if sys . stdout . isatty ( ) : _LOGGER . debug ( 'Hiding cursor.' ) print ( '\x1B[?25l' , end = '' ) sys . stdout . flush ( ) try : yield finally : if sys . stdout . isatty ( ) : _LOGGER . debug ( 'Showing cursor.' ) print ( '\n\x1B[?25h' , end = '' ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the unit tests .<CODESPLIT>def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether this path is a symbolic link .<CODESPLIT>def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorts the rows of a matrix by hierarchical clustering .<CODESPLIT>def hclust_linearize ( U ) : from scipy . cluster import hierarchy Z = hierarchy . ward ( U ) return hierarchy . leaves_list ( hierarchy . optimal_leaf_ordering ( Z , U ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The current position of the cursor .<CODESPLIT>def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Banana banana<CODESPLIT>def set_verbosity ( verbosity ) : Logger . _verbosity = min ( max ( 0 , WARNING - verbosity ) , 2 ) debug ( "Verbosity set to %d" % ( WARNING - Logger . _verbosity ) , 'logging' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - negative integer .<CODESPLIT>def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the provided value is a valid enum constant .<CODESPLIT>def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes log out at any arbitray level .<CODESPLIT>def log ( self , level , msg = None , * args , * * kwargs ) : return self . _log ( level , msg , args , kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if object is defined<CODESPLIT>def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the MD5 hash for a file .<CODESPLIT>def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the usage string for available options<CODESPLIT>def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indent a piece of text .<CODESPLIT>def indent ( text : str , num : int = 2 ) -> str : lines = text . splitlines ( ) return "\n" . join ( indent_iterable ( lines , num = num ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine with width in pixels of string .<CODESPLIT>def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>SQLite3 doesn t support direct truncate so we just use delete here<CODESPLIT>def truncate_table ( self , tablename ) : self . get ( tablename ) . remove ( ) self . db . commit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to return a path to static the static files compatible all the way back to Django 1 . 2 . If anyone has a cleaner or better way to do this let me know!<CODESPLIT>def compatible_staticpath ( path ) : if VERSION >= ( 1 , 10 ) : # Since Django 1.10, forms.Media automatically invoke static # lazily on the path if it is relative. return path try : # >= 1.4 from django . templatetags . static import static return static ( path ) except ImportError : pass try : # >= 1.3 return '%s/%s' % ( settings . STATIC_URL . rstrip ( '/' ) , path ) except AttributeError : pass try : return '%s/%s' % ( settings . PAGEDOWN_URL . rstrip ( '/' ) , path ) except AttributeError : pass return '%s/%s' % ( settings . MEDIA_URL . rstrip ( '/' ) , path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Private method for setting axis limits .<CODESPLIT>def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if arguments are complex numbers .<CODESPLIT>def complex_check ( * args , func = None ) : func = func or inspect . stack ( ) [ 2 ] [ 3 ] for var in args : if not isinstance ( var , numbers . Complex ) : name = type ( var ) . __name__ raise ComplexError ( f'Function {func} expected complex number, {name} got instead.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prints the top n lines of a file<CODESPLIT>def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Given a list of nested lists of arbitrary depth returns a single level or flat list .<CODESPLIT>def flat_list ( input_list ) : x = input_list if isinstance ( x , list ) : return [ a for i in x for a in flat_list ( i ) ] else : return [ x ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all the files and subdirectories in a directory .<CODESPLIT>def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the file exif<CODESPLIT>def information ( filename ) : check_if_this_file_exist ( filename ) filename = os . path . abspath ( filename ) result = get_json ( filename ) result = result [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is iterable and contains only integral types<CODESPLIT>def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch a subset of randomzied GUIDs from the whitelist<CODESPLIT>def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .<CODESPLIT>def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log out the active user<CODESPLIT>def logout ( ) : flogin . logout_user ( ) next = flask . request . args . get ( 'next' ) return flask . redirect ( next or flask . url_for ( "user" ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of point objects ( which must have x and y fields ) . Returns a list of 3 - tuples : the indices of the points that form a Delaunay triangle .<CODESPLIT>def computeDelaunayTriangulation ( points ) : siteList = SiteList ( points ) context = Context ( ) context . triangulate = True voronoi ( siteList , context ) return context . triangles
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is an integer number .<CODESPLIT>def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform log transform log ( x + 1 ) . Parameters ---------- data : array_like<CODESPLIT>def log_normalize ( data ) : if sp . issparse ( data ) : data = data . copy ( ) data . data = np . log2 ( data . data + 1 ) return data return np . log2 ( data . astype ( np . float64 ) + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if invoking supplied clang - apply - replacements binary works .<CODESPLIT>def check_clang_apply_replacements_binary ( args ) : try : subprocess . check_call ( [ args . clang_apply_replacements_binary , '--version' ] ) except : print ( 'Unable to run clang-apply-replacements. Is clang-apply-replacements ' 'binary correctly specified?' , file = sys . stderr ) traceback . print_exc ( ) sys . exit ( 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print a CSV file .<CODESPLIT>def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .<CODESPLIT>def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( "lib2to3.fixes" , args = args . sources ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move the cursor to the last item on the page .<CODESPLIT>def move_page_bottom ( self ) : self . nav . page_index = self . content . range [ 1 ] self . nav . cursor_index = 0 self . nav . inverted = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the default bucket from a list of buckets i . e . the largest bucket .<CODESPLIT>def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare two strings while protecting against timing attacks<CODESPLIT>def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close all files but the current one<CODESPLIT>def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the ( name value ) pairs of the enum .<CODESPLIT>def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Random normal variates .<CODESPLIT>def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the largest real value h such that all elements in x are integer multiples of h .<CODESPLIT>def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of a geometry in a list of geometries avoiding expensive equality checks of in operator .<CODESPLIT>def find_geom ( geom , geoms ) : for i , g in enumerate ( geoms ) : if g is geom : return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attribute referencing the root node of the tree .<CODESPLIT>def _root ( self ) : _n = self while _n . parent : _n = _n . parent return _n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this a string .<CODESPLIT>def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A more low - level form of open_websocket_server . You are responsible for closing this websocket .<CODESPLIT>async def create_websocket_server ( sock , filter = None ) : # pylint: disable=W0622 ws = Websocket ( ) await ws . start_server ( sock , filter = filter ) return ws
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location .<CODESPLIT>def get_mnist ( data_type = "train" , location = "/tmp/mnist" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a boolean indicating if the code is executed inside softimage .<CODESPLIT>def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the given multiquery .<CODESPLIT>async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a menu entry .<CODESPLIT>def add ( self , name , desc , func = None , args = None , krgs = None ) : self . entries . append ( MenuEntry ( name , desc , func , args or [ ] , krgs or { } ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values<CODESPLIT>def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a WAV file and returns the data and sample rate<CODESPLIT>def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate<CODESPLIT>def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) .<CODESPLIT>def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A dict of members expressed in literals<CODESPLIT>def _baseattrs ( self ) : result = super ( ) . _baseattrs result [ "params" ] = ", " . join ( self . parameters ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List all available backends .<CODESPLIT>def list_backends ( _ ) : backends = [ b . __name__ for b in available_backends ( ) ] print ( '\n' . join ( backends ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates perplexity by loss<CODESPLIT>def elmo_loss2ppl ( losses : List [ np . ndarray ] ) -> float : avg_loss = np . mean ( losses ) return float ( np . exp ( avg_loss ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a property by name<CODESPLIT>def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforma una string con elementos separados por sep en una lista .<CODESPLIT>def string_to_list ( string , sep = "," , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of unique items ( similar to set functionality ) .<CODESPLIT>def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a shell - escaped version of the string s .<CODESPLIT>def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a function after a delay unless another function is set in the meantime .<CODESPLIT>def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return Jinja sbatch template for the current tag<CODESPLIT>def sbatch_template ( self ) : template = self . sbatch_template_str if template . startswith ( '#!' ) : # script is embedded in YAML return jinja_environment . from_string ( template ) return jinja_environment . get_template ( template )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose the most common item from the list or the first item if all items are unique .<CODESPLIT>def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return only future Day objects .<CODESPLIT>def get_future_days ( self ) : today = timezone . now ( ) . date ( ) return Day . objects . filter ( date__gte = today )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>One dimenional log parabola model function<CODESPLIT>def eval ( e , amplitude , e_0 , alpha , beta ) : ee = e / e_0 eeponent = - alpha - beta * np . log ( ee ) return amplitude * ee ** eeponent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Index of the last occurrence of x in the sequence .<CODESPLIT>def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .<CODESPLIT>def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the ROI model to a FITS file .<CODESPLIT>def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the key ( aka database value ) of a human key ( aka Python identifier ) .<CODESPLIT>def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert all keys of the dict d to ( ascii - ) strings .<CODESPLIT>def clean_dict_keys ( d ) : new_d = { } for ( k , v ) in d . iteritems ( ) : new_d [ str ( k ) ] = v return new_d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value of the checkbox .<CODESPLIT>def set_value ( self , value ) : if value : self . setCheckState ( Qt . Checked ) else : self . setCheckState ( Qt . Unchecked )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like rotate but modifies l in - place .<CODESPLIT>def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates background color<CODESPLIT>def _update_bordercolor ( self , bordercolor ) : border_color = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_ACTIVEBORDER ) border_color . SetRGB ( bordercolor ) self . linecolor_choice . SetColour ( border_color )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the total size of all elements in objects .<CODESPLIT>def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( "IGNORING: type=%s; o=%s" % ( str ( type ( o ) ) , str ( o ) ) ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of string ranges to a list of [ low high ] tuples .<CODESPLIT>def _parse_ranges ( ranges ) : for txt in ranges : if '-' in txt : low , high = txt . split ( '-' ) else : low , high = txt , txt yield int ( low ) , int ( high )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hessian of func wrt two parameters p0 and p1 . ( see _graddoc )<CODESPLIT>def _hess_two_param ( self , funct , p0 , p1 , dl = 2e-5 , rts = False , * * kwargs ) : vals0 = self . get_values ( p0 ) vals1 = self . get_values ( p1 ) f00 = funct ( * * kwargs ) self . update ( p0 , vals0 + dl ) f10 = funct ( * * kwargs ) self . update ( p1 , vals1 + dl ) f11 = funct ( * * kwargs ) self . update ( p0 , vals0 ) f01 = funct ( * * kwargs ) if rts : self . update ( p0 , vals0 ) self . update ( p1 , vals1 ) return ( f11 - f10 - f01 + f00 ) / ( dl ** 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the response has been rate limited by CARTO APIs<CODESPLIT>def is_rate_limited ( response ) : if ( response . status_code == codes . too_many_requests and 'Retry-After' in response . headers and int ( response . headers [ 'Retry-After' ] ) >= 0 ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resizes an image preserving the aspect ratio .<CODESPLIT>def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Nested lists to single - level list does not split strings<CODESPLIT>def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modified form of the g format specifier .<CODESPLIT>def format_float ( value ) : # not used string = "{:g}" . format ( value ) . replace ( "e+" , "e" ) string = re . sub ( "e(-?)0*(\d+)" , r"e\1\2" , string ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move cursor to this line in the current buffer .<CODESPLIT>def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .<CODESPLIT>def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pyglet specific mouse motion callback . Forwards and traslates the event to the example<CODESPLIT>def on_mouse_motion ( self , x , y , dx , dy ) : # Screen coordinates relative to the lower-left corner  # so we have to flip the y axis to make this consistent with  # other window libraries  self . example . mouse_position_event ( x , self . buffer_height - y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns int () of val if val is not convertable to int use default instead<CODESPLIT>def safe_int ( val , default = None ) : try : val = int ( val ) except ( ValueError , TypeError ) : val = default return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of the earliest occurence of an item from a list in a string<CODESPLIT>def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if a line consists only of a single punctuation character .<CODESPLIT>def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures well - formedness of a key .<CODESPLIT>def _check_key ( self , key ) : if not len ( key ) == 2 : raise TypeError ( 'invalid key: %r' % key ) elif key [ 1 ] not in TYPES : raise TypeError ( 'invalid datatype: %s' % key [ 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Grab all escape codes from a string . Returns a list of all escape codes .<CODESPLIT>def get_codes ( s : Union [ str , 'ChainedBase' ] ) -> List [ str ] : return codegrabpat . findall ( str ( s ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>date to unix timestamp in milliseconds<CODESPLIT>def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Displayhook function for PIL Images rendered as PNG .<CODESPLIT>def display_pil_image ( im ) : from IPython . core import display b = BytesIO ( ) im . save ( b , format = 'png' ) data = b . getvalue ( ) ip_img = display . Image ( data = data , format = 'png' , embed = True ) return ip_img . _repr_png_ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return random lognormal variates .<CODESPLIT>def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A quick and dirty way to get a unique string<CODESPLIT>def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy the lib items into our font .<CODESPLIT>def setLib ( self , lib ) : for name , item in lib . items ( ) : self . font . lib [ name ] = item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>See : func : ~bitstruct . unpack_from () .<CODESPLIT>def unpack_from ( self , data , offset = 0 ) : return tuple ( [ v [ 1 ] for v in self . unpack_from_any ( data , offset ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the log relative frequency for a word form<CODESPLIT>def _relative_frequency ( self , word ) : count = self . type_counts . get ( word , 0 ) return math . log ( count / len ( self . type_counts ) ) if count > 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert seconds to human - readable time .<CODESPLIT>def seconds_to_hms ( input_seconds ) : minutes , seconds = divmod ( input_seconds , 60 ) hours , minutes = divmod ( minutes , 60 ) hours = int ( hours ) minutes = int ( minutes ) seconds = str ( int ( seconds ) ) . zfill ( 2 ) return hours , minutes , seconds
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Abort everything everywhere .<CODESPLIT>def abort ( err ) : if _debug : abort . _debug ( "abort %r" , err ) global local_controllers # tell all the local controllers to abort for controller in local_controllers . values ( ) : controller . abort ( err )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear the displayed image .<CODESPLIT>def clear ( self ) : self . _imgobj = None try : # See if there is an image on the canvas self . canvas . delete_object_by_tag ( self . _canvas_img_tag ) self . redraw ( ) except KeyError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Short Time Fourier Transform for real data keeping the full FFT block .<CODESPLIT>def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>itertools . starmap for deferred callables using cooperative multitasking<CODESPLIT>def asyncStarCmap ( asyncCallable , iterable ) : results = [ ] yield coopStar ( asyncCallable , results . append , iterable ) returnValue ( results )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Segmented min op .<CODESPLIT>def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does this filename match any of the patterns?<CODESPLIT>def file_matches ( filename , patterns ) : return any ( fnmatch . fnmatch ( filename , pat ) for pat in patterns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sample a colormap from matplotlib<CODESPLIT>def sample_colormap ( cmap_name , n_samples ) : colors = [ ] colormap = cm . cmap_d [ cmap_name ] for i in np . linspace ( 0 , 1 , n_samples ) : colors . append ( colormap ( i ) ) return colors
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tries to encode images with ffmpeg to check if it works .<CODESPLIT>def ffmpeg_works ( ) : images = np . zeros ( ( 2 , 32 , 32 , 3 ) , dtype = np . uint8 ) try : _encode_gif ( images , 2 ) return True except ( IOError , OSError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a Future whose result will say whether a next item is available .<CODESPLIT>def has_next_async ( self ) : if self . _fut is None : self . _fut = self . _iter . getq ( ) flag = True try : yield self . _fut except EOFError : flag = False raise tasklets . Return ( flag )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether given class or instance method has been marked with the<CODESPLIT>def _is_override ( meta , method ) : from taipan . objective . modifiers import _OverriddenMethod return isinstance ( method , _OverriddenMethod )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Respond to requests for the server s primary web page .<CODESPLIT>def server ( request ) : return direct_to_template ( request , 'server/index.html' , { 'user_url' : getViewURL ( request , idPage ) , 'server_xrds_url' : getViewURL ( request , idpXrds ) , } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the deepest level of nesting within a list of lists<CODESPLIT>def list_depth ( list_ , func = max , _depth = 0 ) : depth_list = [ list_depth ( item , func = func , _depth = _depth + 1 ) for item in list_ if util_type . is_listlike ( item ) ] if len ( depth_list ) > 0 : return func ( depth_list ) else : return _depth
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Erases n lines from the screen and moves the cursor up to follow<CODESPLIT>def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ "up" ] , end = "" ) print ( codes . cursor [ "eol" ] , end = "" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a year is leap year .<CODESPLIT>def _is_leap_year ( year ) : isleap = ( ( np . mod ( year , 4 ) == 0 ) & ( ( np . mod ( year , 100 ) != 0 ) | ( np . mod ( year , 400 ) == 0 ) ) ) return isleap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure that the file is writeable . Useful if our source is read - only .<CODESPLIT>def make_writeable ( filename ) : if not os . access ( filename , os . W_OK ) : st = os . stat ( filename ) new_permissions = stat . S_IMODE ( st . st_mode ) | stat . S_IWUSR os . chmod ( filename , new_permissions )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string containing the type and text of the exception .<CODESPLIT>def format_exception ( e ) : from . utils . printing import fill return '\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether an object is a path .<CODESPLIT>def _is_path ( s ) : if isinstance ( s , string_types ) : try : return op . exists ( s ) except ( OSError , ValueError ) : return False else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set limits for the x - axis .<CODESPLIT>def set_xlimits ( self , min = None , max = None ) : self . limits [ 'xmin' ] = min self . limits [ 'xmax' ] = max
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>__init__ : Performs basic initialisations<CODESPLIT>def __init__ ( self ) : # Root parser self . parser = argparse . ArgumentParser ( ) # Subparsers self . subparsers = self . parser . add_subparsers ( ) # Parser dictionary, to avoir overwriting existing parsers self . parsers = { }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether : tag : is a valid callable string tag .<CODESPLIT>def is_callable_tag ( tag ) : return ( isinstance ( tag , six . string_types ) and tag . strip ( ) . startswith ( '{{' ) and tag . strip ( ) . endswith ( '}}' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string representation of the traceback .<CODESPLIT>def str_traceback ( error , tb ) : if not isinstance ( tb , types . TracebackType ) : return tb return '' . join ( traceback . format_exception ( error . __class__ , error , tb ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether a certain column exists<CODESPLIT>def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a bool from a string .<CODESPLIT>def FromString ( self , string ) : if string . lower ( ) in ( "false" , "no" , "n" ) : return False if string . lower ( ) in ( "true" , "yes" , "y" ) : return True raise TypeValueError ( "%s is not recognized as a boolean value." % string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Outputs a string to the console ( stdout ) .<CODESPLIT>def out ( self , output , newline = True ) : click . echo ( output , nl = newline )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends a wheel event for the provided number of clicks . May be negative to reverse direction .<CODESPLIT>def wheel ( delta = 1 ) : location = get_position ( ) e = Quartz . CGEventCreateMouseEvent ( None , Quartz . kCGEventScrollWheel , location , Quartz . kCGMouseButtonLeft ) e2 = Quartz . CGEventCreateScrollWheelEvent ( None , Quartz . kCGScrollEventUnitLine , 1 , delta ) Quartz . CGEventPost ( Quartz . kCGHIDEventTap , e ) Quartz . CGEventPost ( Quartz . kCGHIDEventTap , e2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parameters ---------- data_path : str<CODESPLIT>def read_raw ( data_path ) : with open ( data_path , 'rb' ) as f : data = pickle . load ( f ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call an external binary and return its stdout .<CODESPLIT>def check_output ( args , env = None , sp = subprocess ) : log . debug ( 'calling %s with env %s' , args , env ) output = sp . check_output ( args = args , env = env ) log . debug ( 'output: %r' , output ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places a legend box outside a matplotlib Axes instance .<CODESPLIT>def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purge the named cache of all values . If no cache exists for object_type nothing is done<CODESPLIT>def purge_cache ( self , object_type ) : if object_type in self . mapping : cache = self . mapping [ object_type ] log . debug ( "Purging [{}] cache of {} values." . format ( object_type , len ( cache ) ) ) cache . purge ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates requests session user - agent with the driver s user agent<CODESPLIT>def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( "return navigator.userAgent;" ) self . headers . update ( { "user-agent" : selenium_user_agent } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A small helper function to convert a string to a numeric value if appropriate<CODESPLIT>def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same to log but this one centralizes the message first .<CODESPLIT>def clog ( color ) : logger = log ( color ) return lambda msg : logger ( centralize ( msg ) . rstrip ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redirect standard out to file .<CODESPLIT>def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper to create a proxy method in a class .<CODESPLIT>def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invert mapping of dictionary ( i . e . map values to list of keys )<CODESPLIT>def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : New branch / head instance<CODESPLIT>def mkhead ( repo , path ) : return git . Head ( repo , git . Head . to_full_path ( path ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a formatted straight line .<CODESPLIT>def straight_line_show ( title , length = 100 , linestyle = "=" , pad = 0 ) : print ( StrTemplate . straight_line ( title = title , length = length , linestyle = linestyle , pad = pad ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pop - up menu and wx . EVT_CLOSE closing event<CODESPLIT>def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return list of the key property names for a class<CODESPLIT>def get_keys_from_class ( cc ) : return [ prop . name for prop in cc . properties . values ( ) if 'key' in prop . qualifiers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if the string is a mathematical symbol .<CODESPLIT>def is_symbol ( string ) : return ( is_int ( string ) or is_float ( string ) or is_constant ( string ) or is_unary ( string ) or is_binary ( string ) or ( string == '(' ) or ( string == ')' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if login_time not set or seconds since login time is greater than 200 mins .<CODESPLIT>def session_expired ( self ) : if not self . _login_time or ( datetime . datetime . now ( ) - self . _login_time ) . total_seconds ( ) > 12000 : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the Location of the center of this region<CODESPLIT>def getCenter ( self ) : return Location ( self . x + ( self . w / 2 ) , self . y + ( self . h / 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Random uniform variates .<CODESPLIT>def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all records from a table . Use caution!<CODESPLIT>def wipe_table ( self , table : str ) -> int : sql = "DELETE FROM " + self . delimit ( table ) return self . db_exec ( sql )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for raising the correct exception under Python 3 while still being able to raise the same common exception class in Python 2 . 7 .<CODESPLIT>def raise_os_error ( _errno , path = None ) : msg = "%s: '%s'" % ( strerror ( _errno ) , path ) if path else strerror ( _errno ) raise OSError ( _errno , msg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if variable is a numpy array<CODESPLIT>def is_array ( self , key ) : data = self . model . get_data ( ) return isinstance ( data [ key ] , ( ndarray , MaskedArray ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Suppress warning about untrusted SSL certificate .<CODESPLIT>def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forward mouse cursor position events to the example<CODESPLIT>def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string from snake case to camel case .<CODESPLIT>def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>disassemble Python byte - code file ( . pyc )<CODESPLIT>def disassemble_file ( filename , outstream = None ) : filename = check_object_path ( filename ) ( version , timestamp , magic_int , co , is_pypy , source_size ) = load_module ( filename ) if type ( co ) == list : for con in co : disco ( version , con , outstream ) else : disco ( version , co , outstream , is_pypy = is_pypy ) co = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out a neat targets dependency tree based on requested targets .<CODESPLIT>def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flip an image horizontally or vertically .<CODESPLIT>def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>arr_out = round_array ( array_in )<CODESPLIT>def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display both SQLAlchemy and Python help statements<CODESPLIT>def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the value of a local variable somewhere in the call stack .<CODESPLIT>def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Downsample x by factor using striding .<CODESPLIT>def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of ( key value ) pairs and turns it into a dict .<CODESPLIT>def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes JSON formatted data converting it into native Python objects<CODESPLIT>def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is an object iterable like a list ( and not a string ) ?<CODESPLIT>def listlike ( obj ) : return hasattr ( obj , "__iter__" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if the given value is a scalar .<CODESPLIT>def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a unique ( within the graph ) identifer internal to graph generation .<CODESPLIT>def _unique_id ( self , prefix ) : _id = self . _id_gen self . _id_gen += 1 return prefix + str ( _id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a member from an object by ( string ) name<CODESPLIT>def get_member ( thing_obj , member_string ) : mems = { x [ 0 ] : x [ 1 ] for x in inspect . getmembers ( thing_obj ) } if member_string in mems : return mems [ member_string ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the topmost parent of the current category .<CODESPLIT>def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List of sections .<CODESPLIT>def sections ( self ) -> list : self . config . read ( self . filepath ) return self . config . sections ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like rotate but modifies l in - place .<CODESPLIT>def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the lastest updated date in the database .<CODESPLIT>def track_update ( self ) : metadata = self . info ( ) metadata . updated_at = dt . datetime . now ( ) self . commit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is a builtin one .<CODESPLIT>def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the value coresponding to the given enum name .<CODESPLIT>def Value ( self , name ) : if name in self . _enum_type . values_by_name : return self . _enum_type . values_by_name [ name ] . number raise ValueError ( 'Enum %s has no value defined for name %s' % ( self . _enum_type . name , name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return list of Logger classes .<CODESPLIT>def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read a simple text file from a private location to get username and password<CODESPLIT>def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\n' ) password = f . readline ( ) . strip ( '\n' ) return username , password
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the login credentials from the user if not specified while invoking the script .<CODESPLIT>def get_login_credentials ( args ) : if not args . username : args . username = raw_input ( "Enter Username: " ) if not args . password : args . password = getpass . getpass ( "Enter Password: " )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the re module can compile the given regular expression .<CODESPLIT>def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .<CODESPLIT>def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect and login to an FTP server and return ftplib . FTP object .<CODESPLIT>def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Underline the input<CODESPLIT>def underline ( self , msg ) : return click . style ( msg , underline = True ) if self . colorize else msg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is used to ensure that the return value of arr . tostring () is actually a string . This will prevent lots of if - checks in calling code . As of numpy v1 . 6 . 1 ( in Python 3 . 2 . 3 ) the tostring () function still returns type bytes not str as it advertises .<CODESPLIT>def ndarr2str ( arr , encoding = 'ascii' ) : # be fast, don't check - just assume 'arr' is a numpy array - the tostring # call will fail anyway if not retval = arr . tostring ( ) # would rather check "if isinstance(retval, bytes)", but support 2.5. # could rm the if PY3K check, but it makes this faster on 2.x. if PY3K and not isinstance ( retval , str ) : return retval . decode ( encoding ) else : # is str return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a list of filepaths and attach the files to a MIMEMultipart .<CODESPLIT>def _attach_files ( filepaths , email_ ) : for filepath in filepaths : base = os . path . basename ( filepath ) with open ( filepath , "rb" ) as file : part = MIMEApplication ( file . read ( ) , Name = base ) part [ "Content-Disposition" ] = 'attachment; filename="%s"' % base email_ . attach ( part )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a vector randomly within the given rectangle .<CODESPLIT>def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if git command is available .<CODESPLIT>def check_git ( ) : try : with open ( os . devnull , "wb" ) as devnull : subprocess . check_call ( [ "git" , "--version" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( "Please make sure git is installed and on your path." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save a matrix ( list of lists ) to a file as a CSV<CODESPLIT>def list_to_csv ( my_list , csv_file ) : if PY3 : csv_handler = open ( csv_file , 'w' , newline = '' ) else : csv_handler = open ( csv_file , 'wb' ) try : writer = csv . writer ( csv_handler , delimiter = ',' , quoting = csv . QUOTE_ALL ) writer . writerows ( my_list ) finally : csv_handler . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Request that the Outstation perform a cold restart . Command syntax is : restart<CODESPLIT>def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns :<CODESPLIT>def getAllTriples ( self ) : return [ ( str ( s ) , str ( p ) , str ( o ) ) for s , p , o in self ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print object information using a namedtuple and a format pattern .<CODESPLIT>def _prtfmt ( self , item_id , dashes ) : ntprt = self . id2nt [ item_id ] dct = ntprt . _asdict ( ) self . prt . write ( '{DASHES:{N}}' . format ( DASHES = self . fmt_dashes . format ( DASHES = dashes , ID = self . nm2prtfmt [ 'ID' ] . format ( * * dct ) ) , N = self . dash_len ) ) self . prt . write ( "{INFO}\n" . format ( INFO = self . nm2prtfmt [ 'ITEM' ] . format ( * * dct ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draws a sample of sums from a list of distributions .<CODESPLIT>def SampleSum ( dists , n ) : pmf = MakePmfFromList ( RandomSum ( dists ) for i in xrange ( n ) ) return pmf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if this enum has a particular name among its values .<CODESPLIT>def has_value_name ( self , name ) : for val , _ in self . _values : if val == name : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove files specified multiple times in a list .<CODESPLIT>def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ "path" ] not in seen : out . append ( x ) seen . add ( x [ "path" ] ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If output is string then print the string and also time used<CODESPLIT>def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7<CODESPLIT>def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert version like string to a tuple of integers .<CODESPLIT>def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\D+' , value ) if _f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the inner product between two tensors<CODESPLIT>def inner ( tensor0 : BKTensor , tensor1 : BKTensor ) -> BKTensor : # Note: Relying on fact that vdot flattens arrays return np . vdot ( tensor0 , tensor1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restore settings to default values .<CODESPLIT>def restore_default_settings ( ) : global __DEFAULTS __DEFAULTS . CACHE_DIR = defaults . CACHE_DIR __DEFAULTS . SET_SEED = defaults . SET_SEED __DEFAULTS . SEED = defaults . SEED logging . info ( 'Settings reverted to their default values.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted<CODESPLIT>def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '"' + i + '",' cmd = cmd [ : - 1 ] return cmd
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively iterate through values in nested lists .<CODESPLIT>def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the log of the magnitude spectrum of frames<CODESPLIT>def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display Bloch sphere and corresponding data sets .<CODESPLIT>def show ( self , title = '' ) : self . render ( title = title ) if self . fig : plt . show ( self . fig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rate limit a function .<CODESPLIT>def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert column to index . Eg : ConvertInIndex ( AB ) = 28<CODESPLIT>def ColumnToIndex ( col ) : ndx = 0 for c in col : ndx = ndx * 26 + ord ( c . upper ( ) ) - 64 return ndx
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cumulative distribution function .<CODESPLIT>def _cdf ( self , xloc , dist , base , cache ) : return evaluation . evaluate_forward ( dist , base ** xloc , cache = cache )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if end - of - file is reached for file fd .<CODESPLIT>def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>expects a _n . array returns the global minimum of ( value - array ) ^2<CODESPLIT>def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if the string is a mathematical symbol .<CODESPLIT>def is_symbol ( string ) : return ( is_int ( string ) or is_float ( string ) or is_constant ( string ) or is_unary ( string ) or is_binary ( string ) or ( string == '(' ) or ( string == ')' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>use before any custom printing when using the progress iter to ensure your print statement starts on a new line instead of at the end of a progress line<CODESPLIT>def ensure_newline ( self ) : DECTCEM_SHOW = '\033[?25h' # show cursor AT_END = DECTCEM_SHOW + '\n' if not self . _cursor_at_newline : self . write ( AT_END ) self . _cursor_at_newline = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build a C ++ binary executable<CODESPLIT>def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns x rounded to n significant figures .<CODESPLIT>def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the last line of the cell a line with code?<CODESPLIT>def cell_ends_with_code ( lines ) : if not lines : return False if not lines [ - 1 ] . strip ( ) : return False if lines [ - 1 ] . startswith ( '#' ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> argmax ( [ 4 2 - 5 ] ) 0 >>> argmax ( [ 4 2 - 5 ] key = abs ) 2 >>> argmax ( [ 4 2 - 5 ] key = abs both = True ) ( 2 5 )<CODESPLIT>def argmax ( iterable , key = None , both = False ) : if key is not None : it = imap ( key , iterable ) else : it = iter ( iterable ) score , argmax = reduce ( max , izip ( it , count ( ) ) ) if both : return argmax , score return argmax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For a given value the function finds the nearest value in the array and returns its index .<CODESPLIT>def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of all parsed comments in a file . Mostly for testing & interactive use .<CODESPLIT>def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the group associated to the file : param filename : : return : str<CODESPLIT>def get_file_extension_type ( filename ) : ext = get_file_extension ( filename ) if ext : for name , group in EXTENSIONS . items ( ) : if ext in group : return name return "OTHER"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of dimensions of a tensor<CODESPLIT>def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the exectuable bit on the given filename<CODESPLIT>def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes the specified file from the local filesystem .<CODESPLIT>def _delete_local ( self , filename ) : if os . path . exists ( filename ) : os . remove ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause for this many seconds<CODESPLIT>def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shortcut to create md5 hash : param s : : return :<CODESPLIT>def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy an array to the shared memory .<CODESPLIT>def copy ( a ) : shared = anonymousmemmap ( a . shape , dtype = a . dtype ) shared [ : ] = a [ : ] return shared
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adjust image balance and contrast<CODESPLIT>def lighting ( im , b , c ) : if b == 0 and c == 1 : return im mu = np . average ( im ) return np . clip ( ( im - mu ) * c + mu + b , 0. , 1. ) . astype ( np . float32 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If value is a datetime convert to timestamp<CODESPLIT>def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a sentence from a piece of text .<CODESPLIT>def _make_sentence ( txt ) : #Make sure first letter is capitalized txt = txt . strip ( ' ' ) txt = txt [ 0 ] . upper ( ) + txt [ 1 : ] + '.' return txt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve legend title header string from definitions .<CODESPLIT>def legend_title_header_element ( feature , parent ) : _ = feature , parent # NOQA header = legend_title_header [ 'string_format' ] return header . capitalize ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The number of days in the month of the given date<CODESPLIT>def _days_in_month ( date ) : if date . month == 12 : reference = type ( date ) ( date . year + 1 , 1 , 1 ) else : reference = type ( date ) ( date . year , date . month + 1 , 1 ) return ( reference - timedelta ( days = 1 ) ) . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine with width in pixels of string .<CODESPLIT>def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the index of an element in the list .<CODESPLIT>def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper that returns if parent / item is a directory .<CODESPLIT>def _IsDirectory ( parent , item ) : return tf . io . gfile . isdir ( os . path . join ( parent , item ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method to check if a set of types is the { AnyObject } singleton<CODESPLIT>def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the dot source representing the database in a string .<CODESPLIT>def _intermediary_to_dot ( tables , relationships ) : t = '\n' . join ( t . to_dot ( ) for t in tables ) r = '\n' . join ( r . to_dot ( ) for r in relationships ) return '{}\n{}\n{}\n}}' . format ( GRAPH_BEGINNING , t , r )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tries to load an encoded json string back into an object : param json_string : : return :<CODESPLIT>def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a stream handler if it exists .<CODESPLIT>def find_console_handler ( logger ) : for handler in logger . handlers : if ( isinstance ( handler , logging . StreamHandler ) and handler . stream == sys . stderr ) : return handler
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the virtualenv tool is installed .<CODESPLIT>def has_virtualenv ( self ) : with self . settings ( warn_only = True ) : ret = self . run_or_local ( 'which virtualenv' ) . strip ( ) return bool ( ret )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP DELETE operation to API endpoint .<CODESPLIT>def delete ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'DELETE' , endpoint , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Replace all ( frm to ) tuples in args in string s .<CODESPLIT>def replaceStrs ( s , * args ) : if args == ( ) : return s mapping = dict ( ( frm , to ) for frm , to in args ) return re . sub ( "|" . join ( map ( re . escape , mapping . keys ( ) ) ) , lambda match : mapping [ match . group ( 0 ) ] , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>shotcut to pull out useful info for interactive use<CODESPLIT>def stats ( self ) : printDebug ( "Classes.....: %d" % len ( self . all_classes ) ) printDebug ( "Properties..: %d" % len ( self . all_properties ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def stdoutwriteline ( * args ) : s = "" for i in args : s += str ( i ) + " " s = s . strip ( ) sys . stdout . write ( str ( s ) + "\n" ) sys . stdout . flush ( ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An array of all parameters ( including frozen parameters )<CODESPLIT>def parameter_vector ( self ) : return np . array ( [ getattr ( self , k ) for k in self . parameter_names ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return file name ( s ) from Tkinter s file open dialog .<CODESPLIT>def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function returns a truncated repr () of an object .<CODESPLIT>def _short_repr ( obj ) : stringified = pprint . saferepr ( obj ) if len ( stringified ) > 200 : return '%s... (%d bytes)' % ( stringified [ : 200 ] , len ( stringified ) ) return stringified
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the default matplotlib ticks .<CODESPLIT>def clear_matplotlib_ticks ( self , axis = "both" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a directory if it s present . If it s not present no - op .<CODESPLIT>def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add enough tabs to align in two columns<CODESPLIT>def get_margin ( length ) : if length > 23 : margin_left = "\t" chars = 1 elif length > 15 : margin_left = "\t\t" chars = 2 elif length > 7 : margin_left = "\t\t\t" chars = 3 else : margin_left = "\t\t\t\t" chars = 4 return margin_left
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple helper hash function<CODESPLIT>def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple helper hash function<CODESPLIT>def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves the Python library directory path .<CODESPLIT>def GetPythonLibraryDirectoryPath ( ) : path = sysconfig . get_python_lib ( True ) _ , _ , path = path . rpartition ( sysconfig . PREFIX ) if path . startswith ( os . sep ) : path = path [ 1 : ] return path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the pythonic string type .<CODESPLIT>def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a file descriptor from stdin or opening a file from a given path .<CODESPLIT>def file_or_stdin ( ) -> Callable : def parse ( path ) : if path is None or path == "-" : return sys . stdin else : return data_io . smart_open ( path ) return parse
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all values that are zero .<CODESPLIT>def remove_falsy_values ( counter : Mapping [ Any , int ] ) -> Mapping [ Any , int ] : return { label : count for label , count in counter . items ( ) if count }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .<CODESPLIT>def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places a legend box outside a matplotlib Axes instance .<CODESPLIT>def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>delete all the eggs in the directory specified<CODESPLIT>def delete_all_eggs ( self ) : path_to_delete = os . path . join ( self . egg_directory , "lib" , "python" ) if os . path . exists ( path_to_delete ) : shutil . rmtree ( path_to_delete )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a shell - escaped version of the string s .<CODESPLIT>def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether * obj * is iterable lazily such as generators range objects etc .<CODESPLIT>def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a context manager that hides the cursor while inside it and makes it visible on leaving .<CODESPLIT>def hidden_cursor ( self ) : self . stream . write ( self . hide_cursor ) try : yield finally : self . stream . write ( self . normal_cursor )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a name in camelCase return in snake_case<CODESPLIT>def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\1_\2' , name ) return ALL_CAP_REGEX . sub ( r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the date that a file was created .<CODESPLIT>def get_creation_datetime ( filepath ) : if platform . system ( ) == 'Windows' : return datetime . fromtimestamp ( os . path . getctime ( filepath ) ) else : stat = os . stat ( filepath ) try : return datetime . fromtimestamp ( stat . st_birthtime ) except AttributeError : # We're probably on Linux. No easy way to get creation dates here, # so we'll settle for when its content was last modified. return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return current free memory on the machine for windows .<CODESPLIT>def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A very thin wrapper around textwrap . fill to consistently wrap documentation text for display in a command line environment . The text is wrapped to 99 characters with an indentation depth of 4 spaces . Each line is wrapped independently in order to preserve manually added line breaks .<CODESPLIT>def format_doc_text ( text ) : return '\n' . join ( textwrap . fill ( line , width = 99 , initial_indent = '    ' , subsequent_indent = '    ' ) for line in inspect . cleandoc ( text ) . splitlines ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleanup the output directory<CODESPLIT>def cleanup ( ) : if _output_dir and os . path . exists ( _output_dir ) : log . msg_warn ( "Cleaning up output directory at '{output_dir}' ..." . format ( output_dir = _output_dir ) ) if not _dry_run : shutil . rmtree ( _output_dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute empirical covariance as baseline estimator .<CODESPLIT>def empirical ( X ) : print ( "Empirical" ) cov = np . dot ( X . T , X ) / n_samples return cov , np . linalg . inv ( cov )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I convert strings into integers floats and strings!<CODESPLIT>def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the last NoteContainer in the Bar .<CODESPLIT>def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread<CODESPLIT>async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a slice from a table column holding arrays . ( see : func : table . getcolslice )<CODESPLIT>def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flags that a function is linear wrt all args<CODESPLIT>def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function .<CODESPLIT>def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>apply a function to all non - dict values in a dictionary<CODESPLIT>def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DOES NOT WORK WELL WITH MOPIDY Hack from https : // www . daniweb . com / software - development / python / code / 260268 / restart - your - python - program to support updating the settings since mopidy is not able to do that yet Restarts the current program Note : this function does not return . Any cleanup action ( like saving data ) must be done before calling this function<CODESPLIT>def restart_program ( ) : python = sys . executable os . execl ( python , python , * sys . argv )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connects to the voice channel associated with this Player .<CODESPLIT>async def connect ( self ) : await self . node . join_voice_channel ( self . channel . guild . id , self . channel . id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a date object and return the first day of the month .<CODESPLIT>def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the keys that maps to the top n max values in the given dict .<CODESPLIT>def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether indicated file appears to be a gzipped FASTQ .<CODESPLIT>def is_gzipped_fastq ( file_name ) : _ , ext = os . path . splitext ( file_name ) return file_name . endswith ( ".fastq.gz" ) or file_name . endswith ( ".fq.gz" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>\ kills the child and exits<CODESPLIT>def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove punctuation from string s .<CODESPLIT>def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = "" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return " " . join ( filter ( None , s . split ( " " ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>zfill ( x width ) - > string<CODESPLIT>def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out a neat targets dependency tree based on requested targets .<CODESPLIT>def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Map prediction tensor to labels .<CODESPLIT>def postprocessor ( prediction ) : prediction = prediction . data . numpy ( ) [ 0 ] top_predictions = prediction . argsort ( ) [ - 3 : ] [ : : - 1 ] return [ labels [ prediction ] for prediction in top_predictions ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the absolute path to the directory containing the package data .<CODESPLIT>def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , "data" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split data into chunks of num chars each<CODESPLIT>def group ( data , num ) : return [ data [ i : i + num ] for i in range ( 0 , len ( data ) , num ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove comments and empty lines<CODESPLIT>def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a tuple that contains ( screen_width screen_height )<CODESPLIT>def getScreenDims ( self ) : width = ale_lib . getScreenWidth ( self . obj ) height = ale_lib . getScreenHeight ( self . obj ) return ( width , height )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Array of vector lengths<CODESPLIT>def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decide if the Ipython command line is running code .<CODESPLIT>def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , "function" , None ) == pkg_resources . load_entry_point ( "ipython" , "console_scripts" , "ipython" ) . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exchange a code ( and state token ) for a bearer token<CODESPLIT>def fetch_token ( self , * * kwargs ) : return super ( AsanaOAuth2Session , self ) . fetch_token ( self . token_url , client_secret = self . client_secret , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test out all the layers on local CPU .<CODESPLIT>def mtf_unitransformer_all_layers_tiny ( ) : hparams = mtf_unitransformer_tiny ( ) hparams . moe_num_experts = 4 hparams . moe_expert_x = 4 hparams . moe_expert_y = 4 hparams . moe_hidden_size = 512 hparams . layers = [ "self_att" , "local_self_att" , "moe_1d" , "moe_2d" , "drd" ] return hparams
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a random ( i . e . unique ) string identifier<CODESPLIT>def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Filter and ensure that the returned value is of type bool .<CODESPLIT>def filter_bool ( n : Node , query : str ) -> bool : return _scalariter2item ( n , query , bool )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting<CODESPLIT>def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal state reset . used e . g . in unittests<CODESPLIT>def internal_reset ( self ) : log . critical ( "PIA internal_reset()" ) self . empty_key_toggle = True self . current_input_char = None self . input_repead = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given two data points [ X Y ] linearly interpolate those at x .<CODESPLIT>def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dialogue box for choosing directory<CODESPLIT>def ask_dir ( self ) : args [ 'directory' ] = askdirectory ( * * self . dir_opt ) self . dir_text . set ( args [ 'directory' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Starts connection to server if not existent .<CODESPLIT>def start ( self , test_connection = True ) : if self . _context is None : self . _logger . debug ( 'Starting Client' ) self . _context = zmq . Context ( ) self . _poll = zmq . Poller ( ) self . _start_socket ( ) if test_connection : self . test_ping ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns system clipboard contents .<CODESPLIT>def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get from a list with an optional default value .<CODESPLIT>def list_get ( l , idx , default = None ) : try : if l [ idx ] : return l [ idx ] else : return default except IndexError : return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check features data are not empty<CODESPLIT>def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a string return true if it matches the supplied list of patterns .<CODESPLIT>def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an SArray that contains the last n elements in the SArray .<CODESPLIT>def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms an XML string it to python - zimbra dict format<CODESPLIT>def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends multiple non - blocking requests . Returns a list of responses .<CODESPLIT>def _async_requests ( urls ) : session = FuturesSession ( max_workers = 30 ) futures = [ session . get ( url ) for url in urls ] return [ future . result ( ) for future in futures ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a file exists and is non - empty .<CODESPLIT>def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day<CODESPLIT>def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager that suppresses stdout .<CODESPLIT>def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs a function s run time<CODESPLIT>def timed_call ( func , * args , log_level = 'DEBUG' , * * kwargs ) : start = time ( ) r = func ( * args , * * kwargs ) t = time ( ) - start log ( log_level , "Call to '{}' took {:0.6f}s" . format ( func . __name__ , t ) ) return r
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 )<CODESPLIT>def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove problem characters from string<CODESPLIT>def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\'' ] for c in remove : string = string . replace ( c , '_' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the attribute name identifier<CODESPLIT>def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins two dictionaries .<CODESPLIT>def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a C array using the given string .<CODESPLIT>def bytes_to_c_array ( data ) : chars = [ "'{}'" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the boundaries from a list of indexes<CODESPLIT>def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new image by copying the image on a * color * background .<CODESPLIT>def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( "RGB" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type an integer type?<CODESPLIT>def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return first row and also iterable with same items as original<CODESPLIT>def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : """Generator that returns first and proxy other items from source""" yield one while True : yield next ( it ) return ( one , gen ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method for just changing font size .<CODESPLIT>def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unwrap a Python 2 . 6 SSL socket so we can call shutdown ()<CODESPLIT>def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if valid input tag or document .<CODESPLIT>def assert_valid_input ( cls , tag ) : # Fail on unexpected types. if not cls . is_tag ( tag ) : raise TypeError ( "Expected a BeautifulSoup 'Tag', but instead recieved type {}" . format ( type ( tag ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if outfile exists and is no older than base datetime .<CODESPLIT>def is_up_to_date ( outfile , basedatetime ) : # type: (AnyStr, datetime) -> bool if os . path . exists ( outfile ) : if os . path . getmtime ( outfile ) >= basedatetime : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the log of the magnitude spectrum of frames<CODESPLIT>def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns given method name .<CODESPLIT>def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( "__" ) and not name . endswith ( "__" ) : name = "_{0}{1}" . format ( get_object_name ( method . im_class ) , name ) return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a dict of 1d array to a numpy recarray<CODESPLIT>def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into a list of tokens .<CODESPLIT>def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \t' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch all remaining rows .<CODESPLIT>async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate if non empty string<CODESPLIT>def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the number of leaves in a tree<CODESPLIT>def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression .<CODESPLIT>def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert axis coordinate to bin index .<CODESPLIT>def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hacky workaround for old installs of the library on systems without python - future that were keeping the 2to3 update from working after auto - update .<CODESPLIT>def bytes_hack ( buf ) : ub = None if sys . version_info > ( 3 , ) : ub = buf else : ub = bytes ( buf ) return ub
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .<CODESPLIT>def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the item is a placeholder or contains a placeholder .<CODESPLIT>def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Let the DBMS perform a sum on a queryset<CODESPLIT>def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get Querystring information from uri .<CODESPLIT>def get_querystring ( uri ) : parts = urlparse . urlsplit ( uri ) return urlparse . parse_qs ( parts . query )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a section a subsection and some text to the document .<CODESPLIT>def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A generator that combines two iterables .<CODESPLIT>def combine ( self , a , b ) : for l in ( a , b ) : for x in l : yield x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrun True if x is a valid YYYYMMDD date ; otherwise return False .<CODESPLIT>def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )<CODESPLIT>def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Private method for setting axis limits .<CODESPLIT>def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize time in arbitrary timezone to UTC naive object .<CODESPLIT>def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to read bytes until a certain end byte is hit<CODESPLIT>def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse an ISO8601 - formatted datetime string and return a datetime . time object .<CODESPLIT>def from_iso_time ( timestring , use_dateutil = True ) : if not _iso8601_time_re . match ( timestring ) : raise ValueError ( 'Not a valid ISO8601-formatted time string' ) if dateutil_available and use_dateutil : return parser . parse ( timestring ) . time ( ) else : if len ( timestring ) > 8 : # has microseconds fmt = '%H:%M:%S.%f' else : fmt = '%H:%M:%S' return datetime . datetime . strptime ( timestring , fmt ) . time ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs a bash script in the local directory<CODESPLIT>def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( "bash {}" . format ( filename ) , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type a string type?<CODESPLIT>def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Confusion matrix plot<CODESPLIT>def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalizes the given vector . The vector given may have any number of dimensions .<CODESPLIT>def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rounds float to closest int : rtype : int : param n : float<CODESPLIT>def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an empty array with appropriate shape .<CODESPLIT>def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function to display sympy expression using display style LaTeX in PNG .<CODESPLIT>def print_display_png ( o ) : s = latex ( o , mode = 'plain' ) s = s . strip ( '$' ) # As matplotlib does not support display style, dvipng backend is # used here. png = latex_to_png ( '$$%s$$' % s , backend = 'dvipng' ) return png
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for iterating numpy array<CODESPLIT>def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ "refs_ok" ] ) : c = a . item ( ) if c is not None : yield c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make the given theme current .<CODESPLIT>def use_theme ( theme ) : global current current = theme import scene if scene . current is not None : scene . current . stylize ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the difference in seconds between now and the given time .<CODESPLIT>def timediff ( time ) : now = datetime . datetime . utcnow ( ) diff = now - time diff_sec = diff . total_seconds ( ) return diff_sec
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds an approximate centroid for a region that is within the region . Parameters ---------- region : np . ndarray ( shape = ( m n ) dtype = bool ) mask of the region .<CODESPLIT>def find_centroid ( region ) : x , y = center_of_mass ( region ) w = np . argwhere ( region ) i , j = w [ np . argmin ( np . linalg . norm ( w - ( x , y ) , axis = 1 ) ) ] return i , j
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resursively create a named directory .<CODESPLIT>def makedirs ( directory ) : parent = os . path . dirname ( os . path . abspath ( directory ) ) if not os . path . exists ( parent ) : makedirs ( parent ) os . mkdir ( directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert human readable string to datetime . datetime .<CODESPLIT>def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Packs a list of triple indexes into a 2D numpy array .<CODESPLIT>def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the name of the object s type . For some recognized singletons the name of the object is returned instead . ( For example for None and Ellipsis ) .<CODESPLIT>def object_type_repr ( obj ) : if obj is None : return 'None' elif obj is Ellipsis : return 'Ellipsis' if obj . __class__ . __module__ == '__builtin__' : name = obj . __class__ . __name__ else : name = obj . __class__ . __module__ + '.' + obj . __class__ . __name__ return '%s object' % name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins two dictionaries .<CODESPLIT>def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function which returns an array with the Intervals boundaries .<CODESPLIT>def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set limits for the x - axis .<CODESPLIT>def set_xlimits ( self , min = None , max = None ) : self . limits [ 'xmin' ] = min self . limits [ 'xmax' ] = max
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decode string encoded by unicode_string<CODESPLIT>def decode_unicode_string ( string ) : if string . startswith ( '[BASE64-DATA]' ) and string . endswith ( '[/BASE64-DATA]' ) : return base64 . b64decode ( string [ len ( '[BASE64-DATA]' ) : - len ( '[/BASE64-DATA]' ) ] ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokenizes * source * and returns the tokens as a list of lists .<CODESPLIT>def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fast median operation for masked array using 50th - percentile<CODESPLIT>def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>steps value up / down by a single step . Single step is defined in singleStep () .<CODESPLIT>def stepBy ( self , steps ) : self . setValue ( self . value ( ) + steps * self . singleStep ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a python file and returns a awslambda . Code object : param python_file : : return :<CODESPLIT>def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\n' , lambda_function ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resets all assigned data for the current message .<CODESPLIT>def _clear ( self ) : self . _finished = False self . _measurement = None self . _message = None self . _message_body = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets a horiztonal line<CODESPLIT>def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Automatically resizes widget to display at most max_height_items items<CODESPLIT>def _checkSize ( self ) : if self . _item_height is not None : sz = min ( self . _max_height_items , self . count ( ) ) * self . _item_height + 5 sz = max ( sz , 20 ) self . setMinimumSize ( 0 , sz ) self . setMaximumSize ( 1000000 , sz ) self . resize ( self . width ( ) , sz )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Commit all records .<CODESPLIT>def _records_commit ( record_ids ) : for record_id in record_ids : record = Record . get_record ( record_id ) record . commit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a name which includes the module name and function name .<CODESPLIT>def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Did the user depress and release the button to signify a click? MouseStateType is the button to query . Values found under StateTypes . py<CODESPLIT>def is_clicked ( self , MouseStateType ) : return self . previous_mouse_state . query_state ( MouseStateType ) and ( not self . current_mouse_state . query_state ( MouseStateType ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: rtype : numpy matrix<CODESPLIT>def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\t' , skiprows = 9 ) return data . as_matrix ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return memory usage of python process in MB<CODESPLIT>def memory_usage ( ) : try : import psutil import os except ImportError : return _memory_usage_ps ( ) process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) [ 0 ] / float ( 2 ** 20 ) return mem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Installs a Blended plugin from GitHub<CODESPLIT>def install_plugin ( username , repo ) : print ( "Installing plugin from " + username + "/" + repo ) pip . main ( [ 'install' , '-U' , "git+git://github.com/" + username + "/" + repo + ".git" ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .<CODESPLIT>def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return "\n" . join ( centered )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple helper hash function<CODESPLIT>def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DEBUG FUNC modify argv to look like you ran a command<CODESPLIT>def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts text that may be camelcased into an underscored format<CODESPLIT>def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\1_\2' , UNDERSCORE [ 0 ] . sub ( r'\1_\2' , text ) ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate nonce number<CODESPLIT>def generate_nonce ( ) : nonce = '' . join ( [ str ( randint ( 0 , 9 ) ) for i in range ( 8 ) ] ) return HMAC ( nonce . encode ( ) , "secret" . encode ( ) , sha1 ) . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>bytes to unicode<CODESPLIT>def b2u ( string ) : if ( isinstance ( string , bytes ) or ( PY2 and isinstance ( string , str ) ) ) : return string . decode ( 'utf-8' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets tail<CODESPLIT>def get_tail ( self ) : node = self . head last_node = self . head while node is not None : last_node = node node = node . next_node return last_node
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds parent folder of file<CODESPLIT>def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of a geometry in a list of geometries avoiding expensive equality checks of in operator .<CODESPLIT>def find_geom ( geom , geoms ) : for i , g in enumerate ( geoms ) : if g is geom : return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the number of rows in 2D arrays that contain any nan values .<CODESPLIT>def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert list of key value lists to dict<CODESPLIT>def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a Path or string is a file on the file system .<CODESPLIT>def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call an external binary and return its stdout .<CODESPLIT>def check_output ( args , env = None , sp = subprocess ) : log . debug ( 'calling %s with env %s' , args , env ) output = sp . check_output ( args = args , env = env ) log . debug ( 'output: %r' , output ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the average vector of a list of vectors .<CODESPLIT>def ave_list_v3 ( vec_list ) : vec = Vec3 ( 0 , 0 , 0 ) for v in vec_list : vec += v num_vecs = float ( len ( vec_list ) ) vec = Vec3 ( vec . x / num_vecs , vec . y / num_vecs , vec . z / num_vecs ) return vec
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>SwitchToThisWindow from Win32 . handle : int the handle of a native window .<CODESPLIT>def SwitchToThisWindow ( handle : int ) -> None : ctypes . windll . user32 . SwitchToThisWindow ( ctypes . c_void_p ( handle ) , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a file and close it . Returns the file source .<CODESPLIT>def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Probability density function ( normal distribution )<CODESPLIT>def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of dicionaries . See set_order .<CODESPLIT>def get_order ( self ) : return [ dict ( reverse = r [ 0 ] , key = r [ 1 ] ) for r in self . get_model ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a password is valid<CODESPLIT>def is_password_valid ( password ) : pattern = re . compile ( r"^.{4,75}$" ) return bool ( pattern . match ( password ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove non - alphanumerical characters from metric word . And trim excessive underscores .<CODESPLIT>def sanitize_word ( s ) : s = re . sub ( '[^\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Linear model m is [ slope nugget ]<CODESPLIT>def linear_variogram_model ( m , d ) : slope = float ( m [ 0 ] ) nugget = float ( m [ 1 ] ) return slope * d + nugget
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets next week day<CODESPLIT>def get_next_weekday ( self , including_today = False ) : weekday = self . date_time . weekday ( ) return Weekday . get_next ( weekday , including_today = including_today )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the opposite of input condition .<CODESPLIT>def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get list of all uppercase non - private globals ( doesn t start with _ ) .<CODESPLIT>def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( "_" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Any reduction op .<CODESPLIT>def Any ( a , axis , keep_dims ) : return np . any ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to restore index information after collection . Doesn t use self so we can serialize this .<CODESPLIT>def _update_index_on_df ( df , index_names ) : if index_names : df = df . set_index ( index_names ) # Remove names from unnamed indexes index_names = _denormalize_index_names ( index_names ) df . index . names = index_names return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>internal state reset . used e . g . in unittests<CODESPLIT>def internal_reset ( self ) : log . critical ( "PIA internal_reset()" ) self . empty_key_toggle = True self . current_input_char = None self . input_repead = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string to datetime object .<CODESPLIT>def convert_date ( date ) : date = convert_month ( date , shorten = False ) clean_string = convert_string ( date ) return datetime . strptime ( clean_string , DATE_FMT . replace ( '-' , '' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of entries in a table by counting them .<CODESPLIT>def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = "SELECT COUNT (*) FROM `%s`" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assert that a value must be a given type .<CODESPLIT>def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rotates an image by deg degrees<CODESPLIT>def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download file from http url link<CODESPLIT>def download_file ( save_path , file_url ) : r = requests . get ( file_url ) # create HTTP response object with open ( save_path , 'wb' ) as f : f . write ( r . content ) return save_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given string is an url<CODESPLIT>def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a str and transform it into a byte array .<CODESPLIT>def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if the pathname refers to an existing directory .<CODESPLIT>def isdir ( s ) : try : st = os . stat ( s ) except os . error : return False return stat . S_ISDIR ( st . st_mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restores the object from the given JSON .<CODESPLIT>def from_json ( cls , s ) : d = json . loads ( s ) return get_dict_handler ( d [ "type" ] ) ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if a line consists only of a single punctuation character .<CODESPLIT>def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert camelcase names to underscore<CODESPLIT>def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provides an iterator over all values in a nested structure .<CODESPLIT>def _iterate_flattened_values ( value ) : if isinstance ( value , six . string_types ) : yield value return if isinstance ( value , collections . Mapping ) : value = collections . ValuesView ( value ) if isinstance ( value , collections . Iterable ) : for nested_value in value : for nested_nested_value in _iterate_flattened_values ( nested_value ) : yield nested_nested_value yield value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a random date between two dates<CODESPLIT>def date ( start , end ) : stime = date_to_timestamp ( start ) etime = date_to_timestamp ( end ) ptime = stime + random . random ( ) * ( etime - stime ) return datetime . date . fromtimestamp ( ptime )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds an unordered list to the readme<CODESPLIT>def add_ul ( text , ul ) : text += "\n" for li in ul : text += "- " + li + "\n" text += "\n" return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield all items from iterable except the last one .<CODESPLIT>def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def copy ( obj ) : def copy ( self ) : """         Copy self to a new object.         """ from copy import deepcopy return deepcopy ( self ) obj . copy = copy return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from a list preserving the order .<CODESPLIT>def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reseed factory . fuzzy s random generator .<CODESPLIT>def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a copy of this Text instance with invalid characters removed .<CODESPLIT>def clean ( self ) : return Text ( self . __text_cleaner . clean ( self [ TEXT ] ) , * * self . __kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>assert that the mock was called at least once<CODESPLIT>def assert_called ( _mock_self ) : self = _mock_self if self . call_count == 0 : msg = ( "Expected '%s' to have been called." % self . _mock_name or 'mock' ) raise AssertionError ( msg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Error handler<CODESPLIT>def on_error ( e ) : # pragma: no cover exname = { 'RuntimeError' : 'Runtime error' , 'Value Error' : 'Value error' } sys . stderr . write ( '{}: {}\n' . format ( exname [ e . __class__ . __name__ ] , str ( e ) ) ) sys . stderr . write ( 'See file slam_error.log for additional details.\n' ) sys . exit ( 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to read an XML file<CODESPLIT>def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap an AST Call node to lambda expression node . call : ast . Call node<CODESPLIT>def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all database table names found in an SQLAlchemy : class : MetaData object .<CODESPLIT>def get_table_names_from_metadata ( metadata : MetaData ) -> List [ str ] : return [ table . name for table in metadata . tables . values ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove legend for axes or gca .<CODESPLIT>def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops iterating before yielding the specified idx .<CODESPLIT>def stop_at ( iterable , idx ) : for i , item in enumerate ( iterable ) : if i == idx : return yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the stream object seems to have a working fileno ()<CODESPLIT>def _has_fileno ( stream ) : try : stream . fileno ( ) except ( AttributeError , OSError , IOError , io . UnsupportedOperation ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shorcut for self . run .<CODESPLIT>def __call__ ( self , func , * args , * * kwargs ) : return self . run ( func , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : the string value of the element or element tree<CODESPLIT>def element_to_string ( element , include_declaration = True , encoding = DEFAULT_ENCODING , method = 'xml' ) : if isinstance ( element , ElementTree ) : element = element . getroot ( ) elif not isinstance ( element , ElementType ) : element = get_element ( element ) if element is None : return u'' element_as_string = tostring ( element , encoding , method ) . decode ( encoding = encoding ) if include_declaration : return element_as_string else : return strip_xml_declaration ( element_as_string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the current OS a Windows?<CODESPLIT>def _platform_is_windows ( platform = sys . platform ) : matched = platform in ( 'cygwin' , 'win32' , 'win64' ) if matched : error_msg = "Windows isn't supported yet" raise OSError ( error_msg ) return matched
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the size of x along axis dimensions only .<CODESPLIT>def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns obj . field data as a dict<CODESPLIT>def _basic_field_data ( field , obj ) : value = field . value_from_object ( obj ) return { Field . TYPE : FieldType . VAL , Field . VALUE : value }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an ISO - 8601 formatted string from the provided datetime object<CODESPLIT>def isoformat ( dt ) : if not isinstance ( dt , datetime . datetime ) : raise TypeError ( "Must provide datetime.datetime object to isoformat" ) if dt . tzinfo is None : raise ValueError ( "naive datetime objects are not allowed beyond the library boundaries" ) return dt . isoformat ( ) . replace ( "+00:00" , "Z" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge all the strings . Put space between them .<CODESPLIT>def join ( mapping , bind , values ) : return [ ' ' . join ( [ six . text_type ( v ) for v in values if v is not None ] ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compile the pattern to regex .<CODESPLIT>def _compile ( pattern , flags ) : return re . compile ( WcParse ( pattern , flags & FLAG_MASK ) . parse ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Construction from a string raise a TypeError if not possible<CODESPLIT>def construct_from_string ( cls , string ) : if string == cls . name : return cls ( ) raise TypeError ( "Cannot construct a '{}' from " "'{}'" . format ( cls , string ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes object obj from the index .<CODESPLIT>def _remove_from_index ( index , obj ) : try : index . value_map [ indexed_value ( index , obj ) ] . remove ( obj . id ) except KeyError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a UUID .<CODESPLIT>def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print dicttree in Json - like format . keys are sorted<CODESPLIT>def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( "," , ": " ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test whether the current python environment is the correct lore env .<CODESPLIT>def launched ( ) : if not PREFIX : return False return os . path . realpath ( sys . prefix ) == os . path . realpath ( PREFIX )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Upload a local file on the remote host .<CODESPLIT>def send_file ( self , local_path , remote_path , user = 'root' , unix_mode = None ) : self . enable_user ( user ) return self . ssh_pool . send_file ( user , local_path , remote_path , unix_mode = unix_mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator for JSON - per - line in a file pattern<CODESPLIT>def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convolve an array with a kernel using FFT . Implemntation based on the convolve_fft function from astropy .<CODESPLIT>def convolve_fft ( array , kernel ) : array = np . asarray ( array , dtype = np . complex ) kernel = np . asarray ( kernel , dtype = np . complex ) if array . ndim != kernel . ndim : raise ValueError ( "Image and kernel must have same number of " "dimensions" ) array_shape = array . shape kernel_shape = kernel . shape new_shape = np . array ( array_shape ) + np . array ( kernel_shape ) array_slices = [ ] kernel_slices = [ ] for ( new_dimsize , array_dimsize , kernel_dimsize ) in zip ( new_shape , array_shape , kernel_shape ) : center = new_dimsize - ( new_dimsize + 1 ) // 2 array_slices += [ slice ( center - array_dimsize // 2 , center + ( array_dimsize + 1 ) // 2 ) ] kernel_slices += [ slice ( center - kernel_dimsize // 2 , center + ( kernel_dimsize + 1 ) // 2 ) ] array_slices = tuple ( array_slices ) kernel_slices = tuple ( kernel_slices ) if not np . all ( new_shape == array_shape ) : big_array = np . zeros ( new_shape , dtype = np . complex ) big_array [ array_slices ] = array else : big_array = array if not np . all ( new_shape == kernel_shape ) : big_kernel = np . zeros ( new_shape , dtype = np . complex ) big_kernel [ kernel_slices ] = kernel else : big_kernel = kernel array_fft = np . fft . fftn ( big_array ) kernel_fft = np . fft . fftn ( np . fft . ifftshift ( big_kernel ) ) rifft = np . fft . ifftn ( array_fft * kernel_fft ) return rifft [ array_slices ] . real
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all database table names found in an SQLAlchemy : class : MetaData object .<CODESPLIT>def get_table_names_from_metadata ( metadata : MetaData ) -> List [ str ] : return [ table . name for table in metadata . tables . values ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array .<CODESPLIT>def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string representing a numpy array of 0 s and 1 s<CODESPLIT>def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises the supplied figure number or figure window .<CODESPLIT>def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort data rows and order columns<CODESPLIT>def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes dict keys which have have self as value .<CODESPLIT>def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Time execution of function . Returns ( res seconds ) .<CODESPLIT>def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the modified time of a file<CODESPLIT>def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)  mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>React to a docstring event and append contracts to it .<CODESPLIT>def process_docstring ( app , what , name , obj , options , lines ) : # pylint: disable=unused-argument # pylint: disable=too-many-arguments lines . extend ( _format_contracts ( what = what , obj = obj ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints a human readable version of the filter .<CODESPLIT>def Print ( self , output_writer ) : if self . _filters : output_writer . Write ( 'Filters:\n' ) for file_entry_filter in self . _filters : file_entry_filter . Print ( output_writer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the number of non - NA in this array along the given axis or axes<CODESPLIT>def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logout from the remote server .<CODESPLIT>def logout ( self ) : self . client . write ( 'exit\r\n' ) self . client . read_all ( ) self . client . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed<CODESPLIT>def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i )))<CODESPLIT>def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adapts a Numpy array into an ARRAY string to put into the database .<CODESPLIT>def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds noise to Y<CODESPLIT>def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return peak memory usage in MB<CODESPLIT>def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>round to closest resolution<CODESPLIT>def roundClosestValid ( val , res , decimals = None ) : if decimals is None and "." in str ( res ) : decimals = len ( str ( res ) . split ( '.' ) [ 1 ] ) return round ( round ( val / res ) * res , decimals )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all unwanted characters from text .<CODESPLIT>def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convolve 2d gaussian .<CODESPLIT>def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether another set contains this set .<CODESPLIT>def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause for this many seconds<CODESPLIT>def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns : a triple of integers from a version tag<CODESPLIT>def version_triple ( tag ) : groups = re . match ( r'v?(\d+)\.(\d+)\.(\d+)' , tag ) . groups ( ) return tuple ( int ( n ) for n in groups )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminate a running script .<CODESPLIT>async def terminate ( self ) : self . proc . terminate ( ) await asyncio . wait_for ( self . proc . wait ( ) , self . kill_delay ) if self . proc . returncode is None : self . proc . kill ( ) await self . proc . wait ( ) await super ( ) . terminate ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last n rows in the table<CODESPLIT>def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializer for consistency<CODESPLIT>def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day<CODESPLIT>def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to a list with sanitization .<CODESPLIT>def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close session shutdown pool .<CODESPLIT>def close ( self , wait = False ) : self . session . close ( ) self . pool . shutdown ( wait = wait )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Concatenate a sequence of arrays .<CODESPLIT>def uconcatenate ( arrs , axis = 0 ) : v = np . concatenate ( arrs , axis = axis ) v = _validate_numpy_wrapper_units ( v , arrs ) return v
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the keys that maps to the top n max values in the given dict .<CODESPLIT>def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sum the total number of cycles over a list of tokens .<CODESPLIT>def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert JSON string to an ordered defaultdict .<CODESPLIT>def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Order - preserving sorting function .<CODESPLIT>def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>View the quaternion array as an array of floats<CODESPLIT>def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserializes a JSONified : obj : numpy . ndarray that was created using numpy s : obj : save function .<CODESPLIT>def deserialize_ndarray_npy ( d ) : with io . BytesIO ( ) as f : f . write ( json . loads ( d [ 'npy' ] ) . encode ( 'latin-1' ) ) f . seek ( 0 ) return np . load ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the y - axis tick labels for a subplot .<CODESPLIT>def show_yticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_yticklabels ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns seconds since 0h00 .<CODESPLIT>def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the screen resolution of the primary screen .<CODESPLIT>def get_screen_resolution ( self ) : widget = QDesktopWidget ( ) geometry = widget . availableGeometry ( widget . primaryScreen ( ) ) return geometry . width ( ) , geometry . height ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets last change time for a single file<CODESPLIT>def get_single_file_info ( self , rel_path ) : f_path = self . get_full_file_path ( rel_path ) return get_single_file_info ( f_path , rel_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disable event loop integration with wxPython .<CODESPLIT>def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load proxy list from configured proxy source<CODESPLIT>def load ( self ) : self . _list = self . _source . load ( ) self . _list_iter = itertools . cycle ( self . _list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable or disable automatic rate - limit handling .<CODESPLIT>def wait_on_rate_limit ( self , value ) : check_type ( value , bool , may_be_none = False ) self . _wait_on_rate_limit = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins a voice channel<CODESPLIT>async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete log file .<CODESPLIT>def DeleteLog ( ) -> None : if os . path . exists ( Logger . FileName ) : os . remove ( Logger . FileName )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Counts up sequentially from a number based on the current time<CODESPLIT>def seq ( ) : current_frame = inspect . currentframe ( ) . f_back trace_string = "" while current_frame . f_back : trace_string = trace_string + current_frame . f_back . f_code . co_name current_frame = current_frame . f_back return counter . get_from_trace ( trace_string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend the list with another list . Each member of the list must be a string .<CODESPLIT>def extend ( self , item ) : if not isinstance ( item , list ) : raise TypeError ( 'You can only extend lists with lists. ' 'You supplied \"%s\"' % type ( item ) ) for entry in item : if not isinstance ( entry , str ) : raise TypeError ( 'Members of this object must be strings. ' 'You supplied \"%s\"' % type ( entry ) ) list . append ( self , entry )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a string return true if it matches the supplied list of patterns .<CODESPLIT>def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Configure a Domain registry entry .<CODESPLIT>def _config_win32_domain ( self , domain ) : # we call str() on domain to convert it from unicode to ascii self . domain = dns . name . from_text ( str ( domain ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>wrapper to search_s<CODESPLIT>def query ( self , base , filterstr , attrlist = None ) : return self . conn . search_s ( base , ldap . SCOPE_SUBTREE , filterstr , attrlist )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a dictionary from a URL params<CODESPLIT>def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap vertical table in a function for TabularOutputFormatter .<CODESPLIT>def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator version of get_list_column<CODESPLIT>def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert a ctypes structure to a dictionary<CODESPLIT>def struct2dict ( struct ) : return { x : getattr ( struct , x ) for x in dict ( struct . _fields_ ) . keys ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same order unique list using only a list compression .<CODESPLIT>def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the current OS a Windows?<CODESPLIT>def _platform_is_windows ( platform = sys . platform ) : matched = platform in ( 'cygwin' , 'win32' , 'win64' ) if matched : error_msg = "Windows isn't supported yet" raise OSError ( error_msg ) return matched
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a generator that spits an iteratable into n - sized chunks . The last chunk may have less than n elements .<CODESPLIT>def split_every ( n , iterable ) : items = iter ( iterable ) return itertools . takewhile ( bool , ( list ( itertools . islice ( items , n ) ) for _ in itertools . count ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively loop through a directory to find all python script files . When one is found it is analyzed for import statements : param path : string : return : generator<CODESPLIT>def search_script_directory ( self , path ) : for subdir , dirs , files in os . walk ( path ) : for file_name in files : if file_name . endswith ( ".py" ) : self . search_script_file ( subdir , file_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string with terminal colors .<CODESPLIT>def stringc ( text , color ) : if has_colors : text = str ( text ) return "\033[" + codeCodes [ color ] + "m" + text + "\033[0m" else : return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Double click on a given square in the map<CODESPLIT>def OnDoubleClick ( self , event ) : node = HotMapNavigator . findNodeAtPosition ( self . hot_map , event . GetPosition ( ) ) if node : wx . PostEvent ( self , SquareActivationEvent ( node = node , point = event . GetPosition ( ) , map = self ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function for creating hash functions .<CODESPLIT>def _hash_the_file ( hasher , filename ) : BUF_SIZE = 65536 with open ( filename , 'rb' ) as f : buf = f . read ( BUF_SIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = f . read ( BUF_SIZE ) return hasher
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure all logging output has been flushed<CODESPLIT>def flush ( self ) : if len ( self . _buffer ) > 0 : self . logger . log ( self . level , self . _buffer ) self . _buffer = str ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple of strings that match the regular expression pattern .<CODESPLIT>def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the most common element in iterable .<CODESPLIT>def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a function after a delay unless another function is set in the meantime .<CODESPLIT>def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the title of the console window .<CODESPLIT>def title ( msg ) : if sys . platform . startswith ( "win" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert input argument to bytes<CODESPLIT>def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the parent directory of a filename .<CODESPLIT>def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is a finite number .<CODESPLIT>def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Not meant to be used directly use : meth : Instaloader . save_session_to_file .<CODESPLIT>def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a view into the memory<CODESPLIT>def read ( self , start_position : int , size : int ) -> memoryview : return memoryview ( self . _bytes ) [ start_position : start_position + size ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the SQL command and return the data rows as tuples<CODESPLIT>def execute ( self , cmd , * args , * * kwargs ) : self . cursor . execute ( cmd , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the item exists .<CODESPLIT>def exists ( self ) : try : return self . metadata is not None except datalab . utils . RequestException : return False except Exception as e : raise e
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the sentence or fragment begins with one of the parts of speech in the list else False<CODESPLIT>def _begins_with_one_of ( sentence , parts_of_speech ) : doc = nlp ( sentence ) if doc [ 0 ] . tag_ in parts_of_speech : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .<CODESPLIT>def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make text tex safe<CODESPLIT>def escape_tex ( value ) : newval = value for pattern , replacement in LATEX_SUBS : newval = pattern . sub ( replacement , newval ) return newval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate random id numbers .<CODESPLIT>def generate_random_id ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return "" . join ( random . choice ( chars ) for x in range ( size ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A static value ( does not change at runtime ) which is known at compile time<CODESPLIT>def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>More important level : default for print and save<CODESPLIT>def info ( self , message , * args , * * kwargs ) : self . _log ( logging . INFO , message , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the event loop .<CODESPLIT>def run ( self ) : self . signal_init ( ) self . listen_init ( ) self . logger . info ( 'starting' ) self . loop . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Left addition .<CODESPLIT>def __add__ ( self , other ) : return chaospy . poly . collection . arithmetics . add ( self , other )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yields file name if matches a regular expression pattern .<CODESPLIT>def match_files ( files , pattern : Pattern ) : for name in files : if re . match ( pattern , name ) : yield name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dotproduct between self and another vector .<CODESPLIT>def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return BGR image read by opencv<CODESPLIT>def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create database tables from sqlalchemy models<CODESPLIT>def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fit a Gaussian to the data<CODESPLIT>def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply last 2D transforms<CODESPLIT>def post_process ( self ) : self . image . putdata ( self . pixels ) self . image = self . image . transpose ( Image . ROTATE_90 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scroll both categories Canvas and scrolling container<CODESPLIT>def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python<CODESPLIT>def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips and filters empty or commented lines .<CODESPLIT>def ignore_comments ( iterator ) : for line in iterator : line = COMMENT_RE . sub ( '' , line ) line = line . strip ( ) if line : yield line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the root node contains no child elements no text and no attributes other than ** type ** . Returns False if any are present .<CODESPLIT>def is_empty ( self ) : non_type_attributes = [ attr for attr in self . node . attrib . keys ( ) if attr != 'type' ] return len ( self . node ) == 0 and len ( non_type_attributes ) == 0 and not self . node . text and not self . node . tail
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Diag op .<CODESPLIT>def Diag ( a ) : r = np . zeros ( 2 * a . shape , dtype = a . dtype ) for idx , v in np . ndenumerate ( a ) : r [ 2 * idx ] = v return r ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the forecasted float from json section .<CODESPLIT>def __get_float ( section , name ) : try : return float ( section [ name ] ) except ( ValueError , TypeError , KeyError ) : return float ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove non - alphanumerical characters from metric word . And trim excessive underscores .<CODESPLIT>def sanitize_word ( s ) : s = re . sub ( '[^\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle linear / log scale for Y - axis .<CODESPLIT>def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a dirty little template function generator that turns single - brace Mustache - style template strings into functions that interpolate dict keys :<CODESPLIT>def templategetter ( tmpl ) : tmpl = tmpl . replace ( '{' , '%(' ) tmpl = tmpl . replace ( '}' , ')s' ) return lambda data : tmpl % data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function should be called instead of direct spio . loadmat as it cures the problem of not properly recovering python dictionaries from mat files . It calls the function check keys to cure all entries which are still mat - objects<CODESPLIT>def loadmat ( filename ) : data = sploadmat ( filename , struct_as_record = False , squeeze_me = True ) return _check_keys ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Similar to print but prints to stderr .<CODESPLIT>def print_err ( * args , end = '\n' ) : print ( * args , end = end , file = sys . stderr ) sys . stderr . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Suppress warning about untrusted SSL certificate .<CODESPLIT>def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminate all workers and threads .<CODESPLIT>def terminate ( self ) : for t in self . _threads : t . quit ( ) self . _thread = [ ] self . _workers = [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Segmented max op .<CODESPLIT>def SegmentMax ( a , ids ) : func = lambda idxs : np . amax ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a dictionary of attributes in the DOT format<CODESPLIT>def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '"%s"="%s"' % item ) for item in sorted ( d . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raw print to sys . __stdout__ otherwise identical interface to print () .<CODESPLIT>def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate a method to write the configuration in yaml to the method desired<CODESPLIT>def generate_write_yaml_to_file ( file_name ) : def write_yaml ( config ) : with open ( file_name , 'w+' ) as fh : fh . write ( yaml . dump ( config ) ) return write_yaml
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializes and writes given Python objects to a multi - document YAML file .<CODESPLIT>def WriteManyToPath ( objs , filepath ) : with io . open ( filepath , mode = "w" , encoding = "utf-8" ) as filedesc : WriteManyToFile ( objs , filedesc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops the analysis as soon as possible .<CODESPLIT>def stop ( self ) -> None : if self . _stop and not self . _posted_kork : self . _stop ( ) self . _stop = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random color between min and max .<CODESPLIT>def random_color ( _min = MIN_COLOR , _max = MAX_COLOR ) : return color ( random . randint ( _min , _max ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a datetime from GnuCash 2 . 6 date string<CODESPLIT>def get_from_gnucash26_date ( date_str : str ) -> date : date_format = "%Y%m%d" result = datetime . strptime ( date_str , date_format ) . date ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute a python code object in the given environment .<CODESPLIT>def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create the chart bounds with min max horizontal and vertical values<CODESPLIT>def __init__ ( self , xmin = 0 , ymin = 0 , xmax = 1 , ymax = 1 ) : self . _xmin = xmin self . _ymin = ymin self . _xmax = xmax self . _ymax = ymax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the querystring from the end of a URL .<CODESPLIT>def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + "://" + p . netloc + p . path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If output is string then print the string and also time used<CODESPLIT>def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a documented teleport version of the schema .<CODESPLIT>def document ( schema ) : teleport_schema = from_val ( schema ) return json . dumps ( teleport_schema , sort_keys = True , indent = 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalizes the given vector . The vector given may have any number of dimensions .<CODESPLIT>def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the distance of a given image to the original image .<CODESPLIT>def normalized_distance ( self , image ) : return self . __distance ( self . __original_image_for_distance , image , bounds = self . bounds ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete periodically workers in workers bag .<CODESPLIT>def _clean_workers ( self ) : while self . _bag_collector : self . _bag_collector . popleft ( ) self . _timer_worker_delete . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate angle between two vectors<CODESPLIT>def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .<CODESPLIT>def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invoked when determining whether a specific key is in the dictionary using key in d .<CODESPLIT>def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterate through lines of file .<CODESPLIT>def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dict mapping item - > indices .<CODESPLIT>def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Random normal variates .<CODESPLIT>def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get adjacency matrix .<CODESPLIT>def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the date from a value that could be a date object or a string .<CODESPLIT>def get_date ( date ) : if type ( date ) is str : return datetime . strptime ( date , '%Y-%m-%d' ) . date ( ) else : return date
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict from entries in a scala . collection . immutable . Map<CODESPLIT>def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This removes newlines and multiple spaces from a string .<CODESPLIT>def normalize_value ( text ) : result = text . replace ( '\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to the jinja2 render method from a template file<CODESPLIT>def render ( template , context ) : path , filename = os . path . split ( template ) return jinja2 . Environment ( loader = jinja2 . FileSystemLoader ( path or './' ) ) . get_template ( filename ) . render ( context )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializes and writes given Python object to the specified YAML file .<CODESPLIT>def WriteToPath ( obj , filepath ) : with io . open ( filepath , mode = "w" , encoding = "utf-8" ) as filedesc : WriteToFile ( obj , filedesc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set python logging library config .<CODESPLIT>def set_logging_config ( log_level , handlers ) : logging . basicConfig ( format = '%(asctime)s %(levelname)s:%(name)s:%(funcName)s: %(message)s' , datefmt = '%Y-%m-%d %H:%M:%S' , level = log_level , handlers = handlers )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the current image<CODESPLIT>def clearImg ( self ) : self . img . setImage ( np . array ( [ [ 0 ] ] ) ) self . img . image = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for matplotlib imshow<CODESPLIT>def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms a DataFrame in place . Computes all outputs of the DataFrame .<CODESPLIT>def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make setuptools . Extension .<CODESPLIT>def _extension ( modpath : str ) -> setuptools . Extension : return setuptools . Extension ( modpath , [ modpath . replace ( "." , "/" ) + ".py" ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize a file / dir name for comparison purposes<CODESPLIT>def normalize_path ( filename ) : return os . path . normcase ( os . path . realpath ( os . path . normpath ( _cygwin_patch ( filename ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>* A datetime stamp in MySQL format : YYYY - MM - DDTHH : MM : SS *<CODESPLIT>def get_now_sql_datetime ( ) : ## > IMPORTS ## from datetime import datetime , date , time now = datetime . now ( ) now = now . strftime ( "%Y-%m-%dT%H:%M:%S" ) return now
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace all the ocurrences ( in a file ) of a string with another value .<CODESPLIT>def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Debug a single doctest docstring in argument src<CODESPLIT>def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if Cython or Pyrex can be imported .<CODESPLIT>def have_pyrex ( ) : pyrex_impls = 'Cython.Distutils.build_ext' , 'Pyrex.Distutils.build_ext' for pyrex_impl in pyrex_impls : try : # from (pyrex_impl) import build_ext __import__ ( pyrex_impl , fromlist = [ 'build_ext' ] ) . build_ext return True except Exception : pass return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts and image to matrix ( one pixel per line )<CODESPLIT>def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230<CODESPLIT>def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function for conversion of various data types into numeric representation .<CODESPLIT>def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Re - index every document in a named index .<CODESPLIT>def update_index ( index ) : logger . info ( "Updating search index: '%s'" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( "Updating search index model: '%s'" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = "index" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( "chunk_size" ) ) responses . append ( response ) return responses
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This removes newlines and multiple spaces from a string .<CODESPLIT>def normalize_value ( text ) : result = text . replace ( '\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a Vector as the product of the vector and a real number .<CODESPLIT>def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get letters from string only .<CODESPLIT>def return_letters_from_string ( text ) : out = "" for letter in text : if letter . isalpha ( ) : out += letter return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close log<CODESPLIT>def close_log ( log , verbose = True ) : if verbose : print ( 'Closing log file:' , log . name ) # Send closing message. log . info ( 'The log file has been closed.' ) # Remove all handlers from log. [ log . removeHandler ( handler ) for handler in log . handlers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the conda executable robustly across conda versions .<CODESPLIT>def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get data from json file<CODESPLIT>def json_get_data ( filename ) : with open ( filename ) as fp : json_data = json . load ( fp ) return json_data return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG<CODESPLIT>def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the width of the table that would be printed . : rtype : int<CODESPLIT>def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the minimum of an array ignoring any NaNs .<CODESPLIT>def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raw print to sys . __stdout__ otherwise identical interface to print () .<CODESPLIT>def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a str and transform it into a byte array .<CODESPLIT>def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return full mask where True marks pixels within the given shape .<CODESPLIT>def get_shape_mask ( self , shape_obj ) : wd , ht = self . get_size ( ) yi = np . mgrid [ : ht ] . reshape ( - 1 , 1 ) xi = np . mgrid [ : wd ] . reshape ( 1 , - 1 ) pts = np . asarray ( ( xi , yi ) ) . T contains = shape_obj . contains_pts ( pts ) return contains
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helps us to create a movie .<CODESPLIT>def create_movie ( fig , update_figure , filename , title , fps = 15 , dpi = 100 ) : FFMpegWriter = manimation . writers [ 'ffmpeg' ] metadata = dict ( title = title ) writer = FFMpegWriter ( fps = fps , metadata = metadata ) with writer . saving ( fig , filename , dpi ) : t = 0 while True : if update_figure ( t ) : writer . grab_frame ( ) t += 1 else : break
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return random disposition point .<CODESPLIT>def _rndPointDisposition ( dx , dy ) : x = int ( random . uniform ( - dx , dx ) ) y = int ( random . uniform ( - dy , dy ) ) return ( x , y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether flyweight object with specified key has already been created .<CODESPLIT>def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List the usb id of all android devices connected to the computer that are detected by adb .<CODESPLIT>def list_adb_devices_by_usb_id ( ) : out = adb . AdbProxy ( ) . devices ( [ '-l' ] ) clean_lines = new_str ( out , 'utf-8' ) . strip ( ) . split ( '\n' ) results = [ ] for line in clean_lines : tokens = line . strip ( ) . split ( ) if len ( tokens ) > 2 and tokens [ 1 ] == 'device' : results . append ( tokens [ 2 ] ) return results
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove multiple elements from a list and return result . This implementation is faster than the alternative below . Also note the creation of a new list to avoid altering the original . We don t have any current use for the original intact list but may in the future ...<CODESPLIT>def remove_elements ( target , indices ) : copied = list ( target ) for index in reversed ( indices ) : del copied [ index ] return copied
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read in file contents and set the current string .<CODESPLIT>def load_file ( self , filename ) : with open ( filename , 'r' ) as sourcefile : self . set_string ( sourcefile . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a str of decimal with two digits after a decimal mark .<CODESPLIT>def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return "%1.2f" % ( float ( value ) / 100 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .<CODESPLIT>def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>initializes 3D plot<CODESPLIT>def plot3d_init ( fignum ) : from mpl_toolkits . mplot3d import Axes3D fig = plt . figure ( fignum ) ax = fig . add_subplot ( 111 , projection = '3d' ) return ax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make the Python instance take ownership of the GIBaseInfo . i . e . unref if the python instance gets gc ed .<CODESPLIT>def _take_ownership ( self ) : if self : ptr = cast ( self . value , GIBaseInfo ) _UnrefFinalizer . track ( self , ptr ) self . __owns = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds a positional argument named dest to the parser .<CODESPLIT>def add_argument ( self , dest , nargs = 1 , obj = None ) : if obj is None : obj = dest self . _args . append ( Argument ( dest = dest , nargs = nargs , obj = obj ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an inverted dictionary where former values are keys and former keys are values .<CODESPLIT>def invert ( dict_ ) : ensure_mapping ( dict_ ) return dict_ . __class__ ( izip ( itervalues ( dict_ ) , iterkeys ( dict_ ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize path slashes .<CODESPLIT>def norm_slash ( name ) : if isinstance ( name , str ) : return name . replace ( '/' , "\\" ) if not is_case_sensitive ( ) else name else : return name . replace ( b'/' , b"\\" ) if not is_case_sensitive ( ) else name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first day of the given month .<CODESPLIT>def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter for dict note f should have signature : f :: key - > value - > bool<CODESPLIT>def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>MAD -- Median absolute deviation . More robust than standard deviation .<CODESPLIT>def mad ( v ) : return np . median ( np . abs ( v - np . median ( v ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reimplement Qt method<CODESPLIT>def contextMenuEvent ( self , event ) : self . menu . popup ( event . globalPos ( ) ) event . accept ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Paints a cube at a certain position a color .<CODESPLIT>def paint_cube ( self , x , y ) : # get the color color = self . next_color ( ) # calculate the position cube_pos = [ x , y , x + self . cube_size , y + self . cube_size ] # draw the cube draw = ImageDraw . Draw ( im = self . image ) draw . rectangle ( xy = cube_pos , fill = color )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName<CODESPLIT>def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to run commands synchronously for testing .<CODESPLIT>def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( "Event loop is already running." ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a str and transform it into a byte array .<CODESPLIT>def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a sorted list of all system font names<CODESPLIT>def get_font_list ( ) : font_map = pangocairo . cairo_font_map_get_default ( ) font_list = [ f . get_name ( ) for f in font_map . list_families ( ) ] font_list . sort ( ) return font_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether any of the strings contains any of the candidates .<CODESPLIT>def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log in to the API .<CODESPLIT>async def login ( username : str , password : str , brand : str , websession : ClientSession = None ) -> API : api = API ( brand , websession ) await api . authenticate ( username , password ) return api
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>matching of datetimes in time columns for data filtering<CODESPLIT>def datetime_match ( data , dts ) : dts = dts if islistable ( dts ) else [ dts ] if any ( [ not isinstance ( i , datetime . datetime ) for i in dts ] ) : error_msg = ( "`time` can only be filtered by datetimes" ) raise TypeError ( error_msg ) return data . isin ( dts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes a dictionary to a yaml file : param dictionary : the dictionary to be written : param path : the absolute path of the target yaml file : param kwargs : optional additional parameters for dumper<CODESPLIT>def write_dict_to_yaml ( dictionary , path , * * kwargs ) : with open ( path , 'w' ) as f : yaml . dump ( dictionary , f , indent = 4 , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shuffle the data .<CODESPLIT>def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge all the PDF files in pdf_filepaths in a new PDF file out_filepath .<CODESPLIT>def merge_pdfs ( pdf_filepaths , out_filepath ) : merger = PdfFileMerger ( ) for pdf in pdf_filepaths : merger . append ( PdfFileReader ( open ( pdf , 'rb' ) ) ) merger . write ( out_filepath ) return out_filepath
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Standard first line in a PDF .<CODESPLIT>def _put_header ( self ) : self . session . _out ( '%%PDF-%s' % self . pdf_version ) if self . session . compression : self . session . buffer += '%' + chr ( 235 ) + chr ( 236 ) + chr ( 237 ) + chr ( 238 ) + "\n"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date<CODESPLIT>def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create directories if they do not exist otherwise do nothing .<CODESPLIT>def makedirs ( path ) : if not os . path . isdir ( path ) : os . makedirs ( path ) return path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to timestamp .<CODESPLIT>async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if a system process identifer exists in process table .<CODESPLIT>def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def parsed_args ( ) : parser = argparse . ArgumentParser ( description = """python runtime functions""" , epilog = "" ) parser . add_argument ( 'command' , nargs = '*' , help = "Name of the function to run with arguments" ) args = parser . parse_args ( ) return ( args , parser )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the filename exists under the path .<CODESPLIT>def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assert an alert is showing with the given text .<CODESPLIT>def check_alert ( self , text ) : try : alert = Alert ( world . browser ) if alert . text != text : raise AssertionError ( "Alert text expected to be {!r}, got {!r}." . format ( text , alert . text ) ) except WebDriverException : # PhantomJS is kinda poor pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize Flask application .<CODESPLIT>def init_app ( self , app ) : app . config . from_pyfile ( '{0}.cfg' . format ( app . name ) , silent = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>One - hot encode labels from input<CODESPLIT>def one_hot_encoding ( input_tensor , num_labels ) : xview = input_tensor . view ( - 1 , 1 ) . to ( torch . long ) onehot = torch . zeros ( xview . size ( 0 ) , num_labels , device = input_tensor . device , dtype = torch . float ) onehot . scatter_ ( 1 , xview , 1 ) return onehot . view ( list ( input_tensor . shape ) + [ - 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new dict from an existing dict that only has the given keys<CODESPLIT>def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python 3 input () / Python 2 raw_input ()<CODESPLIT>def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assert that a value must be a given type .<CODESPLIT>def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of bytes stored in the value of key within hash name<CODESPLIT>def hstrlen ( self , name , key ) : with self . pipe as pipe : return pipe . hstrlen ( self . redis_key ( name ) , key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return frequencies for DFT<CODESPLIT>def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run manage . py using this component s specific Django settings<CODESPLIT>def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the magnitude of a vector .<CODESPLIT>def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as unicode string .<CODESPLIT>def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge any number of dictionaries<CODESPLIT>def merge_dict ( data , * args ) : results = { } for current in ( data , ) + args : results . update ( current ) return results
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y<CODESPLIT>def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Estimates the memory of the supplied array in bytes<CODESPLIT>def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the bounding box around nonzero elements in the given array<CODESPLIT>def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix solve op .<CODESPLIT>def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the text .<CODESPLIT>def check ( text ) : err = "malapropisms.misc" msg = u"'{}' is a malapropism." illogics = [ "the infinitesimal universe" , "a serial experience" , "attack my voracity" , ] return existence_check ( text , illogics , err , msg , offset = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an appropriate positive infinity for this dtype .<CODESPLIT>def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flip an image horizontally or vertically .<CODESPLIT>def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conveinience :<CODESPLIT>def get_tablenames ( cur ) : cur . execute ( "SELECT name FROM sqlite_master WHERE type='table'" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this attribute present?<CODESPLIT>def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bytes are encoded as a long followed by that many bytes of data .<CODESPLIT>def read_bytes ( fo , writer_schema = None , reader_schema = None ) : size = read_long ( fo ) return fo . read ( size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a Cache containing the entries of self that are not in other .<CODESPLIT>def __sub__ ( self , other ) : return self . __class__ ( [ elem for elem in self if elem not in other ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a hash of a NumPy array .<CODESPLIT>def np_hash ( a ) : if a is None : return hash ( None ) # Ensure that hashes are equal whatever the ordering in memory (C or # Fortran) a = np . ascontiguousarray ( a ) # Compute the digest and return a decimal int return int ( hashlib . sha1 ( a . view ( a . dtype ) ) . hexdigest ( ) , 16 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializer for consistency<CODESPLIT>def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of JSON values to a list of models<CODESPLIT>def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits a %s : %d string and returns the string and number .<CODESPLIT>def parse_scale ( x ) : match = re . match ( r'^(.+?):(\d+)$' , x ) if not match : raise ValueError ( 'Invalid scale "%s".' % x ) return match . group ( 1 ) , int ( match . group ( 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate a method to write the configuration in yaml to the method desired<CODESPLIT>def generate_write_yaml_to_file ( file_name ) : def write_yaml ( config ) : with open ( file_name , 'w+' ) as fh : fh . write ( yaml . dump ( config ) ) return write_yaml
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return frequencies for DFT<CODESPLIT>def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if invoking supplied clang - apply - replacements binary works .<CODESPLIT>def check_clang_apply_replacements_binary ( args ) : try : subprocess . check_call ( [ args . clang_apply_replacements_binary , '--version' ] ) except : print ( 'Unable to run clang-apply-replacements. Is clang-apply-replacements ' 'binary correctly specified?' , file = sys . stderr ) traceback . print_exc ( ) sys . exit ( 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a csv and returns a List of Dicts with keys given by header row .<CODESPLIT>def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download the page into a string<CODESPLIT>def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a mapping from indices to labels .<CODESPLIT>def make_indices_to_labels ( labels : Set [ str ] ) -> Dict [ int , str ] : return { index : label for index , label in enumerate ( [ "pad" ] + sorted ( list ( labels ) ) ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>SNAGGED FROM traceback . py<CODESPLIT>def _extract_traceback ( start ) : tb = sys . exc_info ( ) [ 2 ] for i in range ( start ) : tb = tb . tb_next return _parse_traceback ( tb )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a prettier version of obj<CODESPLIT>def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y<CODESPLIT>def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>computes factorial of n<CODESPLIT>def computeFactorial ( n ) : sleep_walk ( 10 ) ret = 1 for i in range ( n ) : ret = ret * ( i + 1 ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to handle what to do when the stop button is pressed<CODESPLIT>def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging  if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> l = [ 1 1 1 ] >>> obj_in_list_always ( l 1 ) True >>> l . append ( 2 ) >>> obj_in_list_always ( l 1 ) False<CODESPLIT>def obj_in_list_always ( target_list , obj ) : for item in set ( target_list ) : if item is not obj : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dfdatetime . Filetime : creation time or None if not set .<CODESPLIT>def creation_time ( self ) : timestamp = self . _fsntfs_attribute . get_creation_time_as_integer ( ) return dfdatetime_filetime . Filetime ( timestamp = timestamp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable a default web proxy<CODESPLIT>def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if filename1 and filename2 point to the same file object . There can be false negatives ie . the result is False but it is the same file anyway . Reason is that network filesystems can create different paths to the same physical file .<CODESPLIT>def is_same_file ( filename1 , filename2 ) : if filename1 == filename2 : return True if os . name == 'posix' : return os . path . samefile ( filename1 , filename2 ) return is_same_filename ( filename1 , filename2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets value of key key to value in both session and cookies .<CODESPLIT>def save_config_value ( request , response , key , value ) : request . session [ key ] = value response . set_cookie ( key , value , expires = one_year_from_now ( ) ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to a list with sanitization .<CODESPLIT>def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes all the integer factors of the number n<CODESPLIT>def factors ( n ) : return set ( reduce ( list . __add__ , ( [ i , n // i ] for i in range ( 1 , int ( n ** 0.5 ) + 1 ) if n % i == 0 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is an enum type .<CODESPLIT>def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a string of the form 305 . 48b into a Python float . The terminal letter if present indicates e . g . billions .<CODESPLIT>def parse_float ( float_str ) : factor = __get_factor ( float_str ) if factor != 1 : float_str = float_str [ : - 1 ] try : return float ( float_str . replace ( ',' , '' ) ) * factor except ValueError : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Aggregation function to get the first non - zero value .<CODESPLIT>def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out memory usage at this point in time<CODESPLIT>def m ( name = '' , * * kwargs ) : with Reflect . context ( * * kwargs ) as r : kwargs [ "name" ] = name instance = M_CLASS ( r , stream , * * kwargs ) instance ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert an image by applying a contour<CODESPLIT>def filter_contour ( imageFile , opFile ) : im = Image . open ( imageFile ) im1 = im . filter ( ImageFilter . CONTOUR ) im1 . save ( opFile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return random disposition point .<CODESPLIT>def _rndPointDisposition ( dx , dy ) : x = int ( random . uniform ( - dx , dx ) ) y = int ( random . uniform ( - dy , dy ) ) return ( x , y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this attribute present?<CODESPLIT>def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove files specified multiple times in a list .<CODESPLIT>def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ "path" ] not in seen : out . append ( x ) seen . add ( x [ "path" ] ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Truncates a value to a number of decimals places<CODESPLIT>def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket<CODESPLIT>def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decode base64 string to byte array .<CODESPLIT>def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes the base color of a widget ( background ) . : param widget : widget to modify : param color : the color to apply<CODESPLIT>def _set_widget_background_color ( widget , color ) : pal = widget . palette ( ) pal . setColor ( pal . Base , color ) widget . setPalette ( pal )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .<CODESPLIT>def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .<CODESPLIT>def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the lowercase chars in the given string .<CODESPLIT>def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the files with the commas removed .<CODESPLIT>def readCommaList ( fileList ) : names = fileList . split ( ',' ) fileList = [ ] for item in names : fileList . append ( item ) return fileList
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to camel case .<CODESPLIT>def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + "" . join ( x . title ( ) for x in split [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str<CODESPLIT>def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a list in tabular format Based on https : // stackoverflow . com / a / 8356620<CODESPLIT>def __print_table ( table ) : col_width = [ max ( len ( x ) for x in col ) for col in zip ( * table ) ] print ( "| " + " | " . join ( "{:{}}" . format ( x , col_width [ i ] ) for i , x in enumerate ( table [ 0 ] ) ) + " |" ) print ( "| " + " | " . join ( "{:{}}" . format ( '-' * col_width [ i ] , col_width [ i ] ) for i , x in enumerate ( table [ 0 ] ) ) + " |" ) for line in table [ 1 : ] : print ( "| " + " | " . join ( "{:{}}" . format ( x , col_width [ i ] ) for i , x in enumerate ( line ) ) + " |" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the day name<CODESPLIT>def get_day_name ( self ) -> str : weekday = self . value . isoweekday ( ) - 1 return calendar . day_name [ weekday ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build the lexer .<CODESPLIT>def build ( self , * * kwargs ) : self . lexer = ply . lex . lex ( object = self , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip comments from json string .<CODESPLIT>def strip_comments ( string , comment_symbols = frozenset ( ( '#' , '//' ) ) ) : lines = string . splitlines ( ) for k in range ( len ( lines ) ) : for symbol in comment_symbols : lines [ k ] = strip_comment_line_with_symbol ( lines [ k ] , start = symbol ) return '\n' . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param unicode fpath : : param unicode encoding : : rtype : dict | list<CODESPLIT>def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print warning about interrupt and empty the job queue .<CODESPLIT>def finish ( ) : out . warn ( "Interrupted!" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( "Waiting for download threads to finish." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Private method that sets the value currently of the property<CODESPLIT>def _set_property ( self , val , * args ) : val = UserClassAdapter . _set_property ( self , val , * args ) if val : Adapter . _set_property ( self , val , * args ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .<CODESPLIT>def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Suppress warning about untrusted SSL certificate .<CODESPLIT>def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a duration in seconds .<CODESPLIT>def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace regex with string .<CODESPLIT>def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Isolates x from its equivalence class .<CODESPLIT>def isolate_element ( self , x ) : members = list ( self . members ( x ) ) self . delete_set ( x ) self . union ( * ( v for v in members if v != x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indent given text using custom spacing default is set to 4 .<CODESPLIT>def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python 3 input () / Python 2 raw_input ()<CODESPLIT>def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build a C ++ binary executable<CODESPLIT>def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill NaNs with the previous value the next value or if all are NaN then 1 . 0<CODESPLIT>def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph .<CODESPLIT>def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all documents from the given index .<CODESPLIT>def all_documents ( index = INDEX_NAME ) : query = { 'query' : { 'match_all' : { } } } for result in raw_query ( query , index = index ) : yield result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encodes numpy images into gif string .<CODESPLIT>def _encode_gif ( images , fps ) : writer = WholeVideoWriter ( fps ) writer . write_multi ( images ) return writer . finish ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers<CODESPLIT>def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting<CODESPLIT>def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes key cell<CODESPLIT>def delete_cell ( self , key ) : try : self . code_array . pop ( key ) except KeyError : pass self . grid . code_array . result_cache . clear ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a stream handler if it exists .<CODESPLIT>def find_console_handler ( logger ) : for handler in logger . handlers : if ( isinstance ( handler , logging . StreamHandler ) and handler . stream == sys . stderr ) : return handler
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of dimensions of a tensor<CODESPLIT>def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts array into chunks with consecutive elements of given step size . http : // stackoverflow . com / questions / 7352684 / how - to - find - the - groups - of - consecutive - elements - from - an - array - in - numpy<CODESPLIT>def consecutive ( data , stepsize = 1 ) : return np . split ( data , np . where ( np . diff ( data ) != stepsize ) [ 0 ] + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method to check if a set of types is the { AnyObject } singleton<CODESPLIT>def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the root node contains no child elements no text and no attributes other than ** type ** . Returns False if any are present .<CODESPLIT>def is_empty ( self ) : non_type_attributes = [ attr for attr in self . node . attrib . keys ( ) if attr != 'type' ] return len ( self . node ) == 0 and len ( non_type_attributes ) == 0 and not self . node . text and not self . node . tail
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type<CODESPLIT>def QA_util_datetime_to_strdate ( dt ) : strdate = "%04d-%02d-%02d" % ( dt . year , dt . month , dt . day ) return strdate
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read the lines from a file into a list<CODESPLIT>def get_list_from_file ( file_name ) : with open ( file_name , mode = 'r' , encoding = 'utf-8' ) as f1 : lst = f1 . readlines ( ) return lst
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .<CODESPLIT>def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the value of a local variable somewhere in the call stack .<CODESPLIT>def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>format mpv s title<CODESPLIT>def _format_title_string ( self , title_string ) : return self . _title_string_format_text_tag ( title_string . replace ( self . icy_tokkens [ 0 ] , self . icy_title_prefix ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether path is a directory to which the user has write access .<CODESPLIT>def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log memory usage before and after a method .<CODESPLIT>def memory_usage ( method ) : def wrapper ( * args , * * kwargs ) : logging . info ( 'Memory before method %s is %s.' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) result = method ( * args , * * kwargs ) logging . info ( 'Memory after method %s is %s' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) return result return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Support instance methods<CODESPLIT>def __get__ ( self , obj , objtype ) : import functools return functools . partial ( self . __call__ , obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if two pathes represent the same file .<CODESPLIT>def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r A function to support exiting from exit hooks .<CODESPLIT>def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops the process status RPC server .<CODESPLIT>def Stop ( self ) : self . _Close ( ) if self . _rpc_thread . isAlive ( ) : self . _rpc_thread . join ( ) self . _rpc_thread = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get line count of file<CODESPLIT>def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the queue is full<CODESPLIT>def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string from camel case to snake case .<CODESPLIT>def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\1' , s ) . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230<CODESPLIT>def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prompt the user for input and handle any abort exceptions .<CODESPLIT>def prompt ( * args , * * kwargs ) : try : return click . prompt ( * args , * * kwargs ) except click . Abort : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts the table to a dict .<CODESPLIT>def to_dict ( self ) : return { "name" : self . table_name , "kind" : self . table_kind , "data" : [ r . to_dict ( ) for r in self ] }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the unit tests on an installed copy of unyt .<CODESPLIT>def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the mean value across a list of dictionaries<CODESPLIT>def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DFS detect connected component recursive implementation<CODESPLIT>def dfs_recursive ( graph , node , seen ) : seen [ node ] = True for neighbor in graph [ node ] : if not seen [ neighbor ] : dfs_recursive ( graph , neighbor , seen )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique items from iterable * seq * ( in order ) .<CODESPLIT>def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A messy way to import library - specific classes . TODO : I should really make a factory class or something but I m lazy . Plus factories remind me a lot of java ...<CODESPLIT>def _import ( module , cls ) : global Scanner try : cls = str ( cls ) mod = __import__ ( str ( module ) , globals ( ) , locals ( ) , [ cls ] , 1 ) Scanner = getattr ( mod , cls ) except ImportError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prints the top n lines of a file<CODESPLIT>def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the given colored string to standard out .<CODESPLIT>def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A basic slug version of a given parameter list .<CODESPLIT>def delistify ( x ) : if isinstance ( x , list ) : x = [ e . replace ( "'" , "" ) for e in x ] return '-' . join ( sorted ( x ) ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set an object s field to default if it doesn t have a value<CODESPLIT>def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the median of a list of values Returns a float / int<CODESPLIT>def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close all connections .<CODESPLIT>def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close our socket .<CODESPLIT>def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply re . sub to bunch of ( pattern repl )<CODESPLIT>def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def run_time ( ) -> timedelta : delta = start_time if start_time else datetime . utcnow ( ) return datetime . utcnow ( ) - delta
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return password from pipe if not on TTY else False .<CODESPLIT>def pass_from_pipe ( cls ) : is_pipe = not sys . stdin . isatty ( ) return is_pipe and cls . strip_last_newline ( sys . stdin . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string * s * into list of strings no longer than * length *<CODESPLIT>def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates the returned positional object<CODESPLIT>def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ "seqname" , "position" , "strand" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( "int64" ) assert df . strand . dtype == np . dtype ( "O" ) assert df . seqname . dtype == np . dtype ( "O" ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until thread exit<CODESPLIT>def wait_until_exit ( self ) : if self . _timeout is None : raise Exception ( "Thread will never exit. Use stop or specify timeout when starting it!" ) self . _thread . join ( ) self . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make bars in horizontal bar chart thinner<CODESPLIT>def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if enough time has elapsed to perform a check () .<CODESPLIT>def needs_check ( self ) : if self . lastcheck is None : return True return time . time ( ) - self . lastcheck >= self . ipchangedetection_sleep
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose k random elements of array .<CODESPLIT>def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns int () of val if val is not convertable to int use default instead<CODESPLIT>def safe_int ( val , default = None ) : try : val = int ( val ) except ( ValueError , TypeError ) : val = default return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JavaRDD of Object by unpickling<CODESPLIT>def _to_java_object_rdd ( rdd ) : rdd = rdd . _reserialize ( AutoBatchedSerializer ( PickleSerializer ( ) ) ) return rdd . ctx . _jvm . org . apache . spark . mllib . api . python . SerDe . pythonToJava ( rdd . _jrdd , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Populates an object s attributes using the provided dict<CODESPLIT>def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print an object as YAML .<CODESPLIT>def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in string astr replace all occurences of thefind with thereplace<CODESPLIT>def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rewind the file to the start of the body ( if seekable ) .<CODESPLIT>def rewindbody ( self ) : if not self . seekable : raise IOError , "unseekable file" self . fp . seek ( self . startofbody )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>connect to the given server e . g . : \\ connect localhost : 4200<CODESPLIT>def _connect ( self , servers ) : self . _do_connect ( servers . split ( ' ' ) ) self . _verify_connection ( verbose = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear only any cached global data .<CODESPLIT>def clear_global ( self ) : vname = self . varname logger . debug ( f'global clearning {vname}' ) if vname in globals ( ) : logger . debug ( 'removing global instance var: {}' . format ( vname ) ) del globals ( ) [ vname ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>As a convenience turn Python lists and tuples into NumPy arrays .<CODESPLIT>def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads an array from bytestring with big - endian data .<CODESPLIT>def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To know the allocated memory at function termination .<CODESPLIT>def memory_used ( self ) : if self . _end_memory : memory_used = self . _end_memory - self . _start_memory return memory_used else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of the earliest occurence of an item from a list in a string<CODESPLIT>def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse an ISO format date ( YYYY - mm - dd ) .<CODESPLIT>def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Let user select a directory .<CODESPLIT>def popup ( self , title , callfn , initialdir = None ) : super ( DirectorySelection , self ) . popup ( title , callfn , initialdir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns this programs current memory usage in bytes<CODESPLIT>def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function : to be called with each stream element as its only argument<CODESPLIT>def __init__ ( self , function ) : super ( filter , self ) . __init__ ( ) self . function = function
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback for comboboxes : notifies us that a combobox for the given item and column has changed<CODESPLIT>def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of entries in a table by counting them .<CODESPLIT>def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = "SELECT COUNT (*) FROM `%s`" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rounds float to closest int : rtype : int : param n : float<CODESPLIT>def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>clear plot<CODESPLIT>def clear ( self ) : self . axes . cla ( ) self . conf . ntrace = 0 self . conf . xlabel = '' self . conf . ylabel = '' self . conf . title = ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print the message to the predefined log file without newline<CODESPLIT>def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string of data after gzip decoding<CODESPLIT>def ungzip_data ( input_data ) : buf = StringIO ( input_data ) f = gzip . GzipFile ( fileobj = buf ) return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .<CODESPLIT>def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper that clears the composition .<CODESPLIT>def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = "black" ) del draw
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all files in a given directory<CODESPLIT>def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes a method until the retry limit is hit or not None is returned .<CODESPLIT>def retry_until_not_none_or_limit_reached ( method , limit , sleep_s = 1 , catch_exceptions = ( ) ) : return retry_until_valid_or_limit_reached ( method , limit , lambda x : x is not None , sleep_s , catch_exceptions )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the width of the table that would be printed . : rtype : int<CODESPLIT>def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpickling function for auto - generated PVec / PSet field types .<CODESPLIT>def _restore_seq_field_pickle ( checked_class , item_type , data ) : type_ = _seq_field_types [ checked_class , item_type ] return _restore_pickle ( type_ , data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>call a func with args and kwargs print name of func and how long it took .<CODESPLIT>def time_func ( func , name , * args , * * kwargs ) : tic = time . time ( ) out = func ( * args , * * kwargs ) toc = time . time ( ) print ( '%s took %0.2f seconds' % ( name , toc - tic ) ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause the music<CODESPLIT>def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like a bulk : meth : forceput .<CODESPLIT>def forceupdate ( self , * args , * * kw ) : self . _update ( False , self . _ON_DUP_OVERWRITE , * args , * * kw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the string name of an enum value .<CODESPLIT>def EnumValueName ( self , enum , value ) : return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read and return the data from a corpus json file .<CODESPLIT>def read_corpus ( file_name ) : with io . open ( file_name , encoding = 'utf-8' ) as data_file : return yaml . load ( data_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a dtype is a subclass of the numpy datetime types<CODESPLIT>def is_datetime_like ( dtype ) : return ( np . issubdtype ( dtype , np . datetime64 ) or np . issubdtype ( dtype , np . timedelta64 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>string dict / object / value to JSON<CODESPLIT>def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the _force_vertical flag when rendering axes<CODESPLIT>def _axes ( self ) : self . view . _force_vertical = True super ( HorizontalGraph , self ) . _axes ( ) self . view . _force_vertical = False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the display length of a string . This can differ from the character length if the string contains wide characters .<CODESPLIT>def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :<CODESPLIT>def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( "non-list value found where list is expected" ) return all ( isinstance ( x , str ) for x in arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a Django project is being managed with manage . py or django - admin scripts<CODESPLIT>def is_managed ( ) : for item in sys . argv : if re . search ( r'manage.py|django-admin|django' , item ) is not None : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates converts to a masked array<CODESPLIT>def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find rightmost value less than x .<CODESPLIT>def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manipulate json data on the fly<CODESPLIT>def set_json_item ( key , value ) : data = get_json ( ) data [ key ] = value request = get_request ( ) request [ "BODY" ] = json . dumps ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the index of an element in the list .<CODESPLIT>def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closest values<CODESPLIT>def closest_values ( L ) : assert len ( L ) >= 2 L . sort ( ) valmin , argmin = min ( ( L [ i ] - L [ i - 1 ] , i ) for i in range ( 1 , len ( L ) ) ) return L [ argmin - 1 ] , L [ argmin ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a tuple for a kind name and kind display name of an entity . By default uses the app_label and model of the model object s content type as the kind .<CODESPLIT>def get_entity_kind ( self , model_obj ) : model_obj_ctype = ContentType . objects . get_for_model ( self . queryset . model ) return ( u'{0}.{1}' . format ( model_obj_ctype . app_label , model_obj_ctype . model ) , u'{0}' . format ( model_obj_ctype ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns response into a properly formatted json or text object<CODESPLIT>async def json_or_text ( response ) : text = await response . text ( ) if response . headers [ 'Content-Type' ] == 'application/json; charset=utf-8' : return json . loads ( text ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Integer to two bytes<CODESPLIT>def intToBin ( i ) : # devide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return chr ( i1 ) + chr ( i2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Labels plots and saves file<CODESPLIT>def label_saves ( name ) : plt . legend ( loc = 0 ) plt . ylim ( [ 0 , 1.025 ] ) plt . xlabel ( '$U/D$' , fontsize = 20 ) plt . ylabel ( '$Z$' , fontsize = 20 ) plt . savefig ( name , dpi = 300 , format = 'png' , transparent = False , bbox_inches = 'tight' , pad_inches = 0.05 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True<CODESPLIT>def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the absolute position of table top<CODESPLIT>def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( "pos" ) ) + table_height
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the fully - qualified name of a function .<CODESPLIT>def _fullname ( o ) : return o . __module__ + "." + o . __name__ if o . __module__ else o . __name__
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to print sqlite queries before executing .<CODESPLIT>def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An iterable of column names for a particular table or view .<CODESPLIT>def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the distance between two points on earth .<CODESPLIT>def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorts a dict by value .<CODESPLIT>def sort_dict ( d , key = None , reverse = False ) : kv_items = [ kv for kv in d . items ( ) ] # Sort kv_items according to key. if key is None : kv_items . sort ( key = lambda t : t [ 1 ] , reverse = reverse ) else : kv_items . sort ( key = key , reverse = reverse ) # Build ordered dict. return collections . OrderedDict ( kv_items )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates sql datetime2 object from Python datetime object ignoring timezone<CODESPLIT>def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flatten a 4d - tensor into a 3d - tensor by joining width and height .<CODESPLIT>def flatten4d3d ( x ) : xshape = shape_list ( x ) result = tf . reshape ( x , [ xshape [ 0 ] , xshape [ 1 ] * xshape [ 2 ] , xshape [ 3 ] ] ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lock connection from being used else where<CODESPLIT>def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build argument parsers .<CODESPLIT>def build_parser ( ) : parser = argparse . ArgumentParser ( "Release packages to pypi" ) parser . add_argument ( '--check' , '-c' , action = "store_true" , help = "Do a dry run without uploading" ) parser . add_argument ( 'component' , help = "The component to release as component-version" ) return parser
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is iterable and contains only integral types<CODESPLIT>def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into a list of tokens .<CODESPLIT>def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \t' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Populates the ListView with a string list .<CODESPLIT>def new_from_list ( cls , items , * * kwargs ) : obj = cls ( * * kwargs ) for item in items : obj . append ( ListItem ( item ) ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return group content .<CODESPLIT>def _read_group_h5 ( filename , groupname ) : with h5py . File ( filename , 'r' ) as h5f : data = h5f [ groupname ] [ ( ) ] return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a sorted list of all system font names<CODESPLIT>def get_font_list ( ) : font_map = pangocairo . cairo_font_map_get_default ( ) font_list = [ f . get_name ( ) for f in font_map . list_families ( ) ] font_list . sort ( ) return font_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a formatted indented text .<CODESPLIT>def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read and return filename in root dir of project and return string<CODESPLIT>def read ( filename ) : return codecs . open ( os . path . join ( __DIR__ , filename ) , 'r' ) . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if two objects are equal based on a comparison of the specified attributes attrs .<CODESPLIT>def simple_eq ( one : Instance , two : Instance , attrs : List [ str ] ) -> bool : return all ( getattr ( one , a ) == getattr ( two , a ) for a in attrs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create or load an object if necessary .<CODESPLIT>def load ( obj , cls , default_factory ) : if obj is None : return default_factory ( ) if isinstance ( obj , dict ) : return cls . load ( obj ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like rotate but modifies l in - place .<CODESPLIT>def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple helper hash function<CODESPLIT>def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if email is valid<CODESPLIT>def is_valid_email ( email ) : pattern = re . compile ( r'[\w\.-]+@[\w\.-]+[.]\w+' ) return bool ( pattern . match ( email ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .<CODESPLIT>def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the width of the table including padding and borders .<CODESPLIT>def table_width ( self ) : outer_widths = max_dimensions ( self . table_data , self . padding_left , self . padding_right ) [ 2 ] outer_border = 2 if self . outer_border else 0 inner_border = 1 if self . inner_column_border else 0 return table_width ( outer_widths , outer_border , inner_border )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the a string with the data type of a value for Graph data<CODESPLIT>def gtype ( n ) : t = type ( n ) . __name__ return str ( t ) if t != 'Literal' else 'Literal, {}' . format ( n . language )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the size of a multidimansional array .<CODESPLIT>def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets value of key key to value in both session and cookies .<CODESPLIT>def save_config_value ( request , response , key , value ) : request . session [ key ] = value response . set_cookie ( key , value , expires = one_year_from_now ( ) ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a pdf of the current matplotlib figure .<CODESPLIT>def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shape of histogram s data .<CODESPLIT>def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set yaxis limits .<CODESPLIT>def ylim ( self , low , high , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'range' ] = [ low , high ] return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Construct the adjacency matrix of the tree : param tree : : return :<CODESPLIT>def adjacency ( tree ) : dd = ids ( tree ) N = len ( dd ) A = np . zeros ( ( N , N ) ) def _adj ( node ) : if np . isscalar ( node ) : return elif isinstance ( node , tuple ) and len ( node ) == 2 : A [ dd [ node ] , dd [ node [ 0 ] ] ] = 1 A [ dd [ node [ 0 ] ] , dd [ node ] ] = 1 _adj ( node [ 0 ] ) A [ dd [ node ] , dd [ node [ 1 ] ] ] = 1 A [ dd [ node [ 1 ] ] , dd [ node ] ] = 1 _adj ( node [ 1 ] ) _adj ( tree ) return A
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>cgi . FieldStorage from wsgi . input .<CODESPLIT>def fieldstorage ( self ) : if self . _fieldstorage is None : if self . _body is not None : raise ReadBodyTwiceError ( ) self . _fieldstorage = cgi . FieldStorage ( environ = self . _environ , fp = self . _environ [ 'wsgi.input' ] ) return self . _fieldstorage
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes a ( shell ) command in the background<CODESPLIT>def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Integrate a Gaussian profile .<CODESPLIT>def gauss_box_model ( x , amplitude = 1.0 , mean = 0.0 , stddev = 1.0 , hpix = 0.5 ) : z = ( x - mean ) / stddev z2 = z + hpix / stddev z1 = z - hpix / stddev return amplitude * ( norm . cdf ( z2 ) - norm . cdf ( z1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of active CPUs on a Darwin system .<CODESPLIT>def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts html content to plain text<CODESPLIT>def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that value is an instance of basestring for Python 2 or str for Python 3 .<CODESPLIT>def validate_string ( option , value ) : if isinstance ( value , string_type ) : return value raise TypeError ( "Wrong type for %s, value must be " "an instance of %s" % ( option , string_type . __name__ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the files with the commas removed .<CODESPLIT>def readCommaList ( fileList ) : names = fileList . split ( ',' ) fileList = [ ] for item in names : fileList . append ( item ) return fileList
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return True if the current distribution is running on debian like OS .<CODESPLIT>def is_archlinux ( ) : if platform . system ( ) . lower ( ) == 'linux' : if platform . linux_distribution ( ) == ( '' , '' , '' ) : # undefined distribution. Fixed in python 3. if os . path . exists ( '/etc/arch-release' ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current time .<CODESPLIT>def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( "%Y-%m-%d %H:%M:%S" ) return datetime . datetime . now ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .<CODESPLIT>def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flatten dict with defined key join symbol .<CODESPLIT>def flatten_dict_join_keys ( dct , join_symbol = " " ) : return dict ( flatten_dict ( dct , join = lambda a , b : a + join_symbol + b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detect the presence of the dot utility to make a png graph .<CODESPLIT>def exit_if_missing_graphviz ( self ) : ( out , err ) = utils . capture_shell ( "which dot" ) if "dot" not in out : ui . error ( c . MESSAGES [ "dot_missing" ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as unicode string .<CODESPLIT>def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators<CODESPLIT>def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y<CODESPLIT>def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a sentence into list of words .<CODESPLIT>def split_into_words ( s ) : s = re . sub ( r"\W+" , " " , s ) s = re . sub ( r"[_0-9]+" , " " , s ) return s . split ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds<CODESPLIT>def pprint ( self , seconds ) : return ( "%d:%02d:%02d.%03d" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resets all assigned data for the current message .<CODESPLIT>def _clear ( self ) : self . _finished = False self . _measurement = None self . _message = None self . _message_body = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a numeric value to the display . If value is negative it will be printed with a leading minus sign . Decimal digits is the desired number of digits after the decimal point .<CODESPLIT>def print_float ( self , value , decimal_digits = 2 , justify_right = True ) : format_string = '{{0:0.{0}F}}' . format ( decimal_digits ) self . print_number_str ( format_string . format ( value ) , justify_right )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function that reads a local file and generates a SHA256 hash digest for it<CODESPLIT>def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to get the location of a Python file .<CODESPLIT>def getScriptLocation ( ) : location = os . path . abspath ( "./" ) if __file__ . rfind ( "/" ) != - 1 : location = __file__ [ : __file__ . rfind ( "/" ) ] return location
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill an array from a list<CODESPLIT>def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function used for joins builds left and right join list for join function<CODESPLIT>def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the magnitude of a vector .<CODESPLIT>def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set window top - left corner position and size<CODESPLIT>def set_position ( self , x , y , width , height ) : SetWindowPos ( self . _hwnd , None , x , y , width , height , ctypes . c_uint ( 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert this confusion matrix into a 2x2 plain list of values .<CODESPLIT>def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the given object is a Pandas Data Frame .<CODESPLIT>def is_dataframe ( obj ) : try : # This is the best method of type checking from pandas import DataFrame return isinstance ( obj , DataFrame ) except ImportError : # Pandas is not a dependency, so this is scary return obj . __class__ . __name__ == "DataFrame"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list possibly nested to any level return it flattened .<CODESPLIT>def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transpose matrix<CODESPLIT>def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be an iterable ( list array tuple )<CODESPLIT>def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a hash of the contents of a dictionary<CODESPLIT>def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the probability matrix of substitutions i - > j over time t given the normalised generator diagonalisation .<CODESPLIT>def get_pij_matrix ( t , diag , A , A_inv ) : return A . dot ( np . diag ( np . exp ( diag * t ) ) ) . dot ( A_inv )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds parent folder of file<CODESPLIT>def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first day of the given month .<CODESPLIT>def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .<CODESPLIT>def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return string as a comment<CODESPLIT>def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return "# " + ( "%s# " % linesep ) . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .<CODESPLIT>def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert comma - delimited list / string into a list of strings<CODESPLIT>def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pop the heap value from the heap .<CODESPLIT>def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute timestamp from a datetime object that could be timezone aware or unaware .<CODESPLIT>def timestamp_from_datetime ( dt ) : try : utc_dt = dt . astimezone ( pytz . utc ) except ValueError : utc_dt = dt . replace ( tzinfo = pytz . utc ) return timegm ( utc_dt . timetuple ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>From itertools cookbook . [ a b c ... ] - > ( a b ) ( b c ) ...<CODESPLIT>def pairwise ( iterable ) : first , second = tee ( iterable ) next ( second , None ) return zip ( first , second )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform actions before parent main window is closed<CODESPLIT>def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wraps jsonschema . validate returning the same object passed in .<CODESPLIT>def validate ( request : Union [ Dict , List ] , schema : dict ) -> Union [ Dict , List ] : jsonschema_validate ( request , schema ) return request
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates a rough guess of runtime based on product of parameters<CODESPLIT>def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Translate an image in fourier - space with plane waves<CODESPLIT>def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get from a list with an optional default value .<CODESPLIT>def list_get ( l , idx , default = None ) : try : if l [ idx ] : return l [ idx ] else : return default except IndexError : return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set y - axis limits of a subplot .<CODESPLIT>def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Linspace op .<CODESPLIT>def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the input filename with path is a file and is not empty .<CODESPLIT>def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ConfigParser to a dictionary .<CODESPLIT>def config_parser_to_dict ( config_parser ) : response = { } for section in config_parser . sections ( ) : for option in config_parser . options ( section ) : response . setdefault ( section , { } ) [ option ] = config_parser . get ( section , option ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the received object as precise as possible .<CODESPLIT>def _repr ( obj ) : vals = ", " . join ( "{}={!r}" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = "{}(name={}, {})" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = "{}(name={})" . format ( obj . __class__ . __name__ , obj . name ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all HTTP / 1 . 1 Hop - by - Hop headers from a list or : class : Headers object . This operation works in - place .<CODESPLIT>def remove_hop_by_hop_headers ( headers ) : headers [ : ] = [ ( key , value ) for key , value in headers if not is_hop_by_hop_header ( key ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an OrderedDict containing C values to a 1D array .<CODESPLIT>def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send signal to process .<CODESPLIT>def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bulk insert or update .<CODESPLIT>def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a single boolean for arg1 == arg2 even for numpy arrays using element - wise comparison .<CODESPLIT>def all_equal ( arg1 , arg2 ) : if all ( hasattr ( el , '_infinitely_iterable' ) for el in [ arg1 , arg2 ] ) : return arg1 == arg2 try : return all ( a1 == a2 for a1 , a2 in zip ( arg1 , arg2 ) ) except TypeError : return arg1 == arg2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Directly send utf8 bytes to stdout<CODESPLIT>def imp_print ( self , text , end ) : sys . stdout . write ( ( text + end ) . encode ( "utf-8" ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plot the empirical histogram versus best - fit distribution s PDF .<CODESPLIT>def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Upermutate 1 - D data that is sorted by indices_of_increasing .<CODESPLIT>def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .<CODESPLIT>def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all unwanted characters from text .<CODESPLIT>def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pads the output with an amount of indentation appropriate for the number of open element .<CODESPLIT>def _pad ( self ) : if self . _indent : self . whitespace ( self . _indent * len ( self . _open_elements ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If the statement is false raise the given exception .<CODESPLIT>def assert_or_raise ( stmt : bool , exception : Exception , * exception_args , * * exception_kwargs ) -> None : if not stmt : raise exception ( * exception_args , * * exception_kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect and login to an FTP server and return ftplib . FTP object .<CODESPLIT>def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A fast approximation of sigmoid<CODESPLIT>def elliot_function ( signal , derivative = False ) : s = 1 # steepness abs_signal = ( 1 + np . abs ( signal * s ) ) if derivative : return 0.5 * s / abs_signal ** 2 else : # Return the activation signal return 0.5 * ( signal * s ) / abs_signal + 0.5
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the dataset name is valid .<CODESPLIT>def name_is_valid ( name ) : # The name can only be 80 characters long. if len ( name ) > MAX_NAME_LENGTH : return False return bool ( NAME_VALID_CHARS_REGEX . match ( name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate n values between start and end .<CODESPLIT>def _xxrange ( self , start , end , step_count ) : _step = ( end - start ) / float ( step_count ) return ( start + ( i * _step ) for i in xrange ( int ( step_count ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Max reduction op .<CODESPLIT>def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scale the input array<CODESPLIT>def _rescale_array ( self , array , scale , zero ) : if scale != 1.0 : sval = numpy . array ( scale , dtype = array . dtype ) array *= sval if zero != 0.0 : zval = numpy . array ( zero , dtype = array . dtype ) array += zval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts query strings into native Python objects<CODESPLIT>def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True when the graph has the given edge .<CODESPLIT>def has_edge ( self , p_from , p_to ) : return p_from in self . _edges and p_to in self . _edges [ p_from ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns x rounded to n significant figures .<CODESPLIT>def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>writes a string to file<CODESPLIT>def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Queries should be a list of GraphQL objects<CODESPLIT>def graphql_queries_to_json ( * queries ) : rtn = { } for i , query in enumerate ( queries ) : rtn [ "q{}" . format ( i ) ] = query . value return json . dumps ( rtn )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves the text cursor to given line .<CODESPLIT>def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the given cached item is invalid .<CODESPLIT>def needs_update ( self , cache_key ) : if not self . cacheable ( cache_key ) : # An uncacheable CacheKey is always out of date. return True return self . _read_sha ( cache_key ) != cache_key . hash
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses a date string formatted like YYYY - MM - DD .<CODESPLIT>def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the current branch<CODESPLIT>def get_current_branch ( ) : cmd = [ "git" , "rev-parse" , "--abbrev-ref" , "HEAD" ] output = subprocess . check_output ( cmd , stderr = subprocess . STDOUT ) return output . strip ( ) . decode ( "utf-8" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a Listbox with a vertical scrollbar .<CODESPLIT>def __init__ ( self , master = None , compound = tk . RIGHT , autohidescrollbar = True , * * kwargs ) : ttk . Frame . __init__ ( self , master ) self . columnconfigure ( 1 , weight = 1 ) self . rowconfigure ( 0 , weight = 1 ) self . listbox = tk . Listbox ( self , * * kwargs ) if autohidescrollbar : self . scrollbar = AutoHideScrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) else : self . scrollbar = ttk . Scrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) self . config_listbox ( yscrollcommand = self . scrollbar . set ) if compound is not tk . LEFT and compound is not tk . RIGHT : raise ValueError ( "Invalid compound value passed: {0}" . format ( compound ) ) self . __compound = compound self . _grid_widgets ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new dict from an existing dict that only has the given keys<CODESPLIT>def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fit a Gaussian to the data<CODESPLIT>def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads and returns foreign library .<CODESPLIT>def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flags that a function is linear wrt all args<CODESPLIT>def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokenizes * source * and returns the tokens as a list of lists .<CODESPLIT>def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all filenames under recursively found in a directory<CODESPLIT>def recursively_get_files_from_directory ( directory ) : return [ os . path . join ( root , filename ) for root , directories , filenames in os . walk ( directory ) for filename in filenames ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket<CODESPLIT>def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns a Python unicode string list into a Java String array .<CODESPLIT>def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( "java/lang/String" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get screen width and height<CODESPLIT>def display ( self ) : w , h = self . session . window_size ( ) return Display ( w * self . scale , h * self . scale )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Intersect dictionaries d1 and d2 by key * and * value .<CODESPLIT>def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get width and height of a PDF<CODESPLIT>def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert camelCase ( used in PHP ) to Python - standard snake_case .<CODESPLIT>def c2u ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , name ) s1 = re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( ) return s1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can edit this object<CODESPLIT>def has_edit_permission ( self , request ) : return request . user . is_authenticated and request . user . is_active and request . user . is_staff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>* Get the root path for this python package - used in unit testing code *<CODESPLIT>def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + "/../" return packagePath
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserializes a JSONified : obj : numpy . ndarray that was created using numpy s : obj : save function .<CODESPLIT>def deserialize_ndarray_npy ( d ) : with io . BytesIO ( ) as f : f . write ( json . loads ( d [ 'npy' ] ) . encode ( 'latin-1' ) ) f . seek ( 0 ) return np . load ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function : to be called with each stream element as its only argument<CODESPLIT>def __init__ ( self , function ) : super ( filter , self ) . __init__ ( ) self . function = function
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .<CODESPLIT>def energy_string_to_float ( string ) : energy_re = re . compile ( "(-?\d+\.\d+)" ) return float ( energy_re . match ( string ) . group ( 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns x rounded to n significant figures .<CODESPLIT>def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes the base color of a widget ( background ) . : param widget : widget to modify : param color : the color to apply<CODESPLIT>def _set_widget_background_color ( widget , color ) : pal = widget . palette ( ) pal . setColor ( pal . Base , color ) widget . setPalette ( pal )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dump single enum type . Keyword arguments : top -- top namespace<CODESPLIT>def _dump_enum ( self , e , top = '' ) : self . _print ( ) self . _print ( 'enum {} {{' . format ( e . name ) ) self . defines . append ( '{}.{}' . format ( top , e . name ) ) self . tabs += 1 for v in e . value : self . _print ( '{} = {};' . format ( v . name , v . number ) ) self . tabs -= 1 self . _print ( '}' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace placeholders in text by using the data mapping . Other placeholders that is not represented by data is left untouched .<CODESPLIT>def template_substitute ( text , * * kwargs ) : for name , value in kwargs . items ( ) : placeholder_pattern = "{%s}" % name if placeholder_pattern in text : text = text . replace ( placeholder_pattern , value ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to timestamp .<CODESPLIT>async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform relative pathnames into absolute pathnames .<CODESPLIT>def get_absolute_path ( * args ) : directory = os . path . dirname ( os . path . abspath ( __file__ ) ) return os . path . join ( directory , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip the whitespace from all column names in the given DataFrame and return the result .<CODESPLIT>def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a legal python name for the given name for use as a unit key .<CODESPLIT>def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of active CPUs on a Darwin system .<CODESPLIT>def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in comparison to argrelmax () more simple and reliable peak finder<CODESPLIT>def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a 1D list to a single long string for file output using the string . join function .<CODESPLIT>def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provides the color corresponding to value x in the form of a tuple ( R G B A ) with int values between 0 and 255 .<CODESPLIT>def rgba_bytes_tuple ( self , x ) : return tuple ( int ( u * 255.9999 ) for u in self . rgba_floats_tuple ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send a test error to APM Server<CODESPLIT>def handle_test ( self , command , * * options ) : # can't be async for testing config = { "async_mode" : False } for key in ( "service_name" , "secret_token" ) : if options . get ( key ) : config [ key ] = options [ key ] client = DjangoClient ( * * config ) client . error_logger = ColoredLogger ( self . stderr ) client . logger = ColoredLogger ( self . stderr ) self . write ( "Trying to send a test error to APM Server using these settings:\n\n" "SERVICE_NAME:\t%s\n" "SECRET_TOKEN:\t%s\n" "SERVER:\t\t%s\n\n" % ( client . config . service_name , client . config . secret_token , client . config . server_url ) ) try : raise TestException ( "Hi there!" ) except TestException : client . capture_exception ( ) if not client . error_logger . errors : self . write ( "Success! We tracked the error successfully! You should be" " able to see it in a few seconds at the above URL" ) finally : client . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get adjacency matrix .<CODESPLIT>def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Release lock on compilation directory .<CODESPLIT>def release_lock ( ) : get_lock . n_lock -= 1 assert get_lock . n_lock >= 0 # Only really release lock once all lock requests have ended. if get_lock . lock_is_enabled and get_lock . n_lock == 0 : get_lock . start_time = None get_lock . unlocker . unlock ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a random ( i . e . unique ) string identifier<CODESPLIT>def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Handles whitespace cleanup .<CODESPLIT>def handle_whitespace ( text ) : text = re_retab . sub ( sub_retab , text ) text = re_whitespace . sub ( '' , text ) . strip ( ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the moving average ( rolling mean ) of an array of a certain window size .<CODESPLIT>def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of dimensions of a tensor<CODESPLIT>def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns are under the ROC curve<CODESPLIT>def roc_auc ( y_true , y_score ) : notnull = ~ np . isnan ( y_true ) fpr , tpr , thresholds = sklearn . metrics . roc_curve ( y_true [ notnull ] , y_score [ notnull ] ) return sklearn . metrics . auc ( fpr , tpr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate M random numbers in [ - pi pi ) .<CODESPLIT>def _uniform_phi ( M ) : return np . random . uniform ( - np . pi , np . pi , M )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the prime factor of given integer<CODESPLIT>def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pads a hex string up to the given bit_size<CODESPLIT>def pad_hex ( value , bit_size ) : value = remove_0x_prefix ( value ) return add_0x_prefix ( value . zfill ( int ( bit_size / 4 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return minimal quantum of a number as defined by precision .<CODESPLIT>def get_decimal_quantum ( precision ) : assert isinstance ( precision , ( int , decimal . Decimal ) ) return decimal . Decimal ( 10 ) ** ( - precision )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True positive rate tp / ( tp + fn )<CODESPLIT>def tpr ( y , z ) : tp , tn , fp , fn = contingency_table ( y , z ) return tp / ( tp + fn )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .<CODESPLIT>def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator version of get_list_column<CODESPLIT>def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets a param from kwargs or uses a default_value . if found it s removed from kwargs<CODESPLIT>def param ( self , param , kwargs , default_value = False ) : if param in kwargs : value = kwargs [ param ] del kwargs [ param ] else : value = default_value setattr ( self , param , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load the correct module according to the version<CODESPLIT>def load_library ( version ) : check_version ( version ) module_name = SUPPORTED_LIBRARIES [ version ] lib = sys . modules . get ( module_name ) if lib is None : lib = importlib . import_module ( module_name ) return lib
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a stdout and print it s lines to output if lines are present .<CODESPLIT>def report_stdout ( host , stdout ) : lines = stdout . readlines ( ) if lines : print ( "STDOUT from {host}:" . format ( host = host ) ) for line in lines : print ( line . rstrip ( ) , file = sys . stdout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logarithmic loss with non - necessarily - binary labels .<CODESPLIT>def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch all remaining rows .<CODESPLIT>async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a given number of 32 - bits unsigned integers from the given file with the given endianness .<CODESPLIT>def read_data ( file , endian , num = 1 ) : res = struct . unpack ( endian + 'L' * num , file . read ( num * 4 ) ) if len ( res ) == 1 : return res [ 0 ] return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats a list of elements using the given line style<CODESPLIT>def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a naive datetime object for the given timezone . A timezone is any pytz - like or datetime . tzinfo - like timezone object . If no timezone is given then UTC is assumed .<CODESPLIT>def now ( timezone = None ) : d = datetime . datetime . utcnow ( ) if not timezone : return d return to_timezone ( d , timezone ) . replace ( tzinfo = None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield directory file names .<CODESPLIT>def directory_files ( path ) : for entry in os . scandir ( path ) : if not entry . name . startswith ( '.' ) and entry . is_file ( ) : yield entry . name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last weekday in a given month . e . g :<CODESPLIT>def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns ( module locals ) of the funciton depth frames away from the caller<CODESPLIT>def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves a list of member - like objects ( members or properties ) that are publically exposed .<CODESPLIT>def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( "_" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether another set contains this set .<CODESPLIT>def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Efficient cartesian product of a list of 1D arrays returning the expanded array views for each dimensions . By default arrays are flattened which may be controlled with the flat flag . The array views can be turned into regular arrays with the copy flag .<CODESPLIT>def cartesian_product ( arrays , flat = True , copy = False ) : arrays = np . broadcast_arrays ( * np . ix_ ( * arrays ) ) if flat : return tuple ( arr . flatten ( ) if copy else arr . flat for arr in arrays ) return tuple ( arr . copy ( ) if copy else arr for arr in arrays )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap a string at a line length<CODESPLIT>def wrap ( string , length , indent ) : newline = "\n" + " " * indent return newline . join ( ( string [ i : i + length ] for i in range ( 0 , len ( string ) , length ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip a section<CODESPLIT>def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dataframe that is a cross between dataframes df1 and df2<CODESPLIT>def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserialize s ( a str ) to a Python object .<CODESPLIT>def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads an array from bytestring with big - endian data .<CODESPLIT>def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return string as a comment<CODESPLIT>def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return "# " + ( "%s# " % linesep ) . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encodes numpy images into gif string .<CODESPLIT>def _encode_gif ( images , fps ) : writer = WholeVideoWriter ( fps ) writer . write_multi ( images ) return writer . finish ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given the python representation of a JSONschema as defined in the swagger spec validate that the schema complies to spec . If target is provided that target will be validated against the provided schema .<CODESPLIT>def validate ( raw_schema , target = None , * * kwargs ) : schema = schema_validator ( raw_schema , * * kwargs ) if target is not None : validate_object ( target , schema = schema , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>RETURN field SEQUENCE AS STRING<CODESPLIT>def join_field ( path ) : output = "." . join ( [ f . replace ( "." , "\\." ) for f in path if f != None ] ) return output if output else "."
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the list of modes .<CODESPLIT>def __iter__ ( self ) : return iter ( [ v for k , v in sorted ( self . _modes . items ( ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the longest string size for a string entry across data .<CODESPLIT>def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method asserts that only one value of the provided list is True .<CODESPLIT>def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add suffix to a full file name<CODESPLIT>def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a list of the data types for each column in * data * .<CODESPLIT>def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until all task are executed .<CODESPLIT>async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enforces a process memory limit .<CODESPLIT>def _EnforceProcessMemoryLimit ( self , memory_limit ) : # Resource is not supported on Windows. if resource : if memory_limit is None : memory_limit = 4 * 1024 * 1024 * 1024 elif memory_limit == 0 : memory_limit = resource . RLIM_INFINITY resource . setrlimit ( resource . RLIMIT_DATA , ( memory_limit , memory_limit ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a Stripe API timestamp response ( unix epoch ) to a native datetime .<CODESPLIT>def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the string is only composed of hex characters .<CODESPLIT>def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method allows printing several images in one shot . This is useful if the client code does not want the printer to make pause during printing<CODESPLIT>def print_images ( self , * printable_images ) : printable_image = reduce ( lambda x , y : x . append ( y ) , list ( printable_images ) ) self . print_image ( printable_image )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a percentile range from an array of values .<CODESPLIT>def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1<CODESPLIT>def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a system command in the background disown it and hide it s output .<CODESPLIT>def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Install venv + deps .<CODESPLIT>def venv ( ) : try : import virtualenv # NOQA except ImportError : sh ( "%s -m pip install virtualenv" % PYTHON ) if not os . path . isdir ( "venv" ) : sh ( "%s -m virtualenv venv" % PYTHON ) sh ( "venv\\Scripts\\pip install -r %s" % ( REQUIREMENTS_TXT ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize data .<CODESPLIT>def normalize ( self ) : if self . preprocessed_data . empty : data = self . original_data else : data = self . preprocessed_data data = pd . DataFrame ( preprocessing . normalize ( data ) , columns = data . columns , index = data . index ) self . preprocessed_data = data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Directly gets a variable from a parent frame - scope .<CODESPLIT>def get_parent_var ( name , global_ok = False , default = None , skip_frames = 0 ) : scope = get_parent_scope_from_var ( name , global_ok = global_ok , skip_frames = skip_frames + 1 ) if not scope : return default if name in scope . locals : return scope . locals . get ( name , default ) return scope . globals . get ( name , default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Idempotent and None - safe version of strict_bool .<CODESPLIT>def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit without garbage collection this speeds up exit by about 10ms for things like bash completion .<CODESPLIT>def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates one element of the collection<CODESPLIT>def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u"$set" in doc : doc = doc [ u"$set" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str<CODESPLIT>def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>StringIO constructor shim for the async wrapper .<CODESPLIT>def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create new bucket .<CODESPLIT>def touch ( ) : from . models import Bucket bucket = Bucket . create ( ) db . session . commit ( ) click . secho ( str ( bucket ) , fg = 'green' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update conda packages in a conda env<CODESPLIT>def update ( packages , env = None , user = None ) : packages = ' ' . join ( packages . split ( ',' ) ) cmd = _create_conda_cmd ( 'update' , args = [ packages , '--yes' , '-q' ] , env = env , user = user ) return _execcmd ( cmd , user = user )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( Point Point ) - > Point Return the point that lies in between the two input points .<CODESPLIT>def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Under UNIX : is a keystroke available?<CODESPLIT>def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Upermutate 1 - D data that is sorted by indices_of_increasing .<CODESPLIT>def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until all the threads are finished .<CODESPLIT>def wait_until_exit ( self ) : [ t . join ( ) for t in self . threads ] self . threads = list ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>load an nparray object from a json filename<CODESPLIT>def from_file ( filename ) : f = open ( filename , 'r' ) j = json . load ( f ) f . close ( ) return from_dict ( j )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>We have a full length slice .<CODESPLIT>def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates RGB values from HSV values in line with a typical light spectrum .<CODESPLIT>def hsv2rgb_spectrum ( hsv ) : h , s , v = hsv return hsv2rgb_raw ( ( ( h * 192 ) >> 8 , s , v ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values<CODESPLIT>def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( "Error getting image size {}" . format ( url ) , exc_info = True ) return w_h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>apply a function to all non - dict values in a dictionary<CODESPLIT>def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A handy wrapper to get a remote file content<CODESPLIT>def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Opens the file and reads the value<CODESPLIT>def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the minimum of an array ignoring any NaNs .<CODESPLIT>def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if given value is a list tries to convert if it is not .<CODESPLIT>def to_list ( var ) : if var is None : return [ ] if isinstance ( var , str ) : var = var . split ( '\n' ) elif not isinstance ( var , list ) : try : var = list ( var ) except TypeError : raise ValueError ( "{} cannot be converted to the list." . format ( var ) ) return var
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>renames newick from numbers to sample names<CODESPLIT>def _renamer ( self , tre ) : ## get the tre with numbered tree tip labels names = tre . get_leaves ( ) ## replace numbered names with snames for name in names : name . name = self . samples [ int ( name . name ) ] ## return with only topology and leaf labels return tre . write ( format = 9 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the first location in our array that is not empty<CODESPLIT>def find_start_point ( self ) : for i , row in enumerate ( self . data ) : for j , _ in enumerate ( row ) : if self . data [ i , j ] != 0 : # or not np.isfinite(self.data[i,j]): return i , j
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear the database .<CODESPLIT>def delete_all_from_db ( ) : # The models.CASCADE property is set on all ForeignKey fields, so tables can # be deleted in any order without breaking constraints. for model in django . apps . apps . get_models ( ) : model . objects . all ( ) . delete ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Using the size of the y axis return a fraction of that size .<CODESPLIT>def vertical_percent ( plot , percent = 0.1 ) : plot_bottom , plot_top = plot . get_ylim ( ) return percent * ( plot_top - plot_bottom )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plot the empirical histogram versus best - fit distribution s PDF .<CODESPLIT>def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a callable that sends the actual API request internally .<CODESPLIT>def __getattr__ ( self , item : str ) -> Callable : return functools . partial ( self . call_action , item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the longest path in a dag between two nodes<CODESPLIT>def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the querystring from the end of a URL .<CODESPLIT>def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + "://" + p . netloc + p . path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads and returns foreign library .<CODESPLIT>def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for iterating only nonempty lines without line breaks<CODESPLIT>def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\r\n' ) if line : yield line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes a classname<CODESPLIT>def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete index entirely ( removes all documents and mapping ) .<CODESPLIT>def delete_index ( index ) : logger . info ( "Deleting search index: '%s'" , index ) client = get_client ( ) return client . indices . delete ( index = index )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render the graph as JavaScript in a Jupyter Notebook .<CODESPLIT>def to_jupyter ( graph : BELGraph , chart : Optional [ str ] = None ) -> Javascript : with open ( os . path . join ( HERE , 'render_with_javascript.js' ) , 'rt' ) as f : js_template = Template ( f . read ( ) ) return Javascript ( js_template . render ( * * _get_context ( graph , chart = chart ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .<CODESPLIT>def seq_to_str ( obj , sep = "," ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find a check box and uncheck it . The check box can be found via name id or label text . ::<CODESPLIT>def uncheck ( self , locator = None , allow_label_click = None , * * kwargs ) : self . _check_with_label ( "checkbox" , False , locator = locator , allow_label_click = allow_label_click , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if we are in a tty .<CODESPLIT>def intty ( cls ) : # XXX: temporary hack until we can detect if we are in a pipe or not return True if hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the prefix from the text if it exists .<CODESPLIT>def remove_prefix ( text , prefix ) : null , prefix , rest = text . rpartition ( prefix ) return rest
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get a value from a tag ( if it exists )<CODESPLIT>def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts from hex to hsv<CODESPLIT>def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Empty a table by deleting all of its rows .<CODESPLIT>def truncate ( self , table ) : if isinstance ( table , ( list , set , tuple ) ) : for t in table : self . _truncate ( t ) else : self . _truncate ( table )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort the data .<CODESPLIT>def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Directly reads text data from url<CODESPLIT>def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Represent data as a masked array .<CODESPLIT>def ma ( self ) : a = self . array return numpy . ma . MaskedArray ( a , mask = numpy . logical_not ( numpy . isfinite ( a ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for pymongo . Collection . ensure_index<CODESPLIT>def ensure_index ( self , key , unique = False ) : return self . collection . ensure_index ( key , unique = unique )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn a list to list of list<CODESPLIT>def splitBy ( data , num ) : return [ data [ i : i + num ] for i in range ( 0 , len ( data ) , num ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the mean and the standard deviation of the given samples .<CODESPLIT>def fit_gaussian ( samples , ddof = 0 ) : if len ( samples . shape ) == 1 : return np . mean ( samples ) , np . std ( samples , ddof = ddof ) return np . mean ( samples , axis = 1 ) , np . std ( samples , axis = 1 , ddof = ddof )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset the instance<CODESPLIT>def reset ( self ) : self . _hline_string = None self . _row_size = None self . _header = [ ] self . _rows = [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates text font color button<CODESPLIT>def _update_fontcolor ( self , fontcolor ) : textcolor = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_WINDOWTEXT ) textcolor . SetRGB ( fontcolor ) self . textcolor_choice . SetColour ( textcolor )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of a geometry in a list of geometries avoiding expensive equality checks of in operator .<CODESPLIT>def find_geom ( geom , geoms ) : for i , g in enumerate ( geoms ) : if g is geom : return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns value of a sine wave at a given frequency and framerate for a given sample i<CODESPLIT>def sine_wave ( i , frequency = FREQUENCY , framerate = FRAMERATE , amplitude = AMPLITUDE ) : omega = 2.0 * pi * float ( frequency ) sine = sin ( omega * ( float ( i ) / float ( framerate ) ) ) return float ( amplitude ) * sine
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts html content to plain text<CODESPLIT>def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return a boolean if we have a nested object e . g . a Series with 1 or more Series elements<CODESPLIT>def is_nested_object ( obj ) : if isinstance ( obj , ABCSeries ) and is_object_dtype ( obj ) : if any ( isinstance ( v , ABCSeries ) for v in obj . values ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return index of sub_string in string .<CODESPLIT>def _find ( string , sub_string , start_index ) : result = string . find ( sub_string , start_index ) if result == - 1 : raise TokenError ( "expected '{0}'" . format ( sub_string ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the id of the last written row in table<CODESPLIT>def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( "SELECT seq FROM sqlite_sequence WHERE name='{0}'" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type a string type?<CODESPLIT>def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .<CODESPLIT>def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the file is binary<CODESPLIT>def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\0' in data : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of characters in two strings that don t exactly match<CODESPLIT>def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the location of the static data directory .<CODESPLIT>def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , "static" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the memory per process in megabytes<CODESPLIT>def set_mem_per_proc ( self , mem_mb ) : super ( ) . set_mem_per_proc ( mem_mb ) self . qparams [ "mem_per_cpu" ] = self . mem_per_proc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return grandparent s path string<CODESPLIT>def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return data as a JSON string .<CODESPLIT>def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return time in milliseconds from start_time<CODESPLIT>def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: rtype : numpy matrix<CODESPLIT>def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\t' , skiprows = 9 ) return data . as_matrix ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate input data with input schema .<CODESPLIT>def validate ( schema , data , owner = None ) : schema . _validate ( data = data , owner = owner )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokenize an input string into a list of words ( with punctuation removed ) .<CODESPLIT>def tokenize_words ( self , text ) : return [ self . strip_punctuation ( word ) for word in text . split ( ' ' ) if self . strip_punctuation ( word ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the re module can compile the given regular expression .<CODESPLIT>def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scrolls up to element<CODESPLIT>def scroll_up ( self , locator ) : driver = self . _current_application ( ) element = self . _element_find ( locator , True , True ) driver . execute_script ( "mobile: scroll" , { "direction" : 'up' , 'element' : element . id } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all non - printable characters from a text string<CODESPLIT>def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function to generate the latex representation of sympy expressions .<CODESPLIT>def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\dag' , '\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a repr () for a list / tuple<CODESPLIT>def _tuple_repr ( data ) : if len ( data ) == 1 : return "(%s,)" % rpr ( data [ 0 ] ) else : return "(%s)" % ", " . join ( [ rpr ( x ) for x in data ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if list contains either values of type vtype or None .<CODESPLIT>def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Not meant to be used directly use : meth : Instaloader . save_session_to_file .<CODESPLIT>def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indicate whether the specified image file is valid or not .<CODESPLIT>def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes a file if it doesn t already exist with the same content .<CODESPLIT>def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( "Not overwriting {} because it is unchanged" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip a single frame from the trajectory<CODESPLIT>def _skip_frame ( self ) : size = self . read_size ( ) for i in range ( size + 1 ) : line = self . _f . readline ( ) if len ( line ) == 0 : raise StopIteration
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yields all permutations with replacement : list ( product ( cat repeat = 2 )) = > [ ( c c ) ( c a ) ( c t ) ( a c ) ( a a ) ( a t ) ( t c ) ( t a ) ( t t ) ]<CODESPLIT>def product ( * args , * * kwargs ) : p = [ [ ] ] for iterable in map ( tuple , args ) * kwargs . get ( "repeat" , 1 ) : p = [ x + [ y ] for x in p for y in iterable ] for p in p : yield tuple ( p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets<CODESPLIT>def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Efficient conversion from scipy sparse matrix to cvxopt sparse matrix<CODESPLIT>def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a legal python name for the given name for use as a unit key .<CODESPLIT>def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine with width in pixels of string .<CODESPLIT>def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Directly reads text data from url<CODESPLIT>def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms an XML string it to python - zimbra dict format<CODESPLIT>def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the keys that maps to the top n max values in the given dict .<CODESPLIT>def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all items .<CODESPLIT>def clear ( self ) : self . _fwdm . clear ( ) self . _invm . clear ( ) self . _sntl . nxt = self . _sntl . prv = self . _sntl
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple directory walker<CODESPLIT>def get_files ( dir_name ) : return [ ( os . path . join ( '.' , d ) , [ os . path . join ( d , f ) for f in files ] ) for d , _ , files in os . walk ( dir_name ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert val out of numpy time for use in to_dict . Needed because of numpy bug GH#7619<CODESPLIT>def ensure_us_time_resolution ( val ) : if np . issubdtype ( val . dtype , np . datetime64 ) : val = val . astype ( 'datetime64[us]' ) elif np . issubdtype ( val . dtype , np . timedelta64 ) : val = val . astype ( 'timedelta64[us]' ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the column mapped by db_field name<CODESPLIT>def _get_column_by_db_name ( cls , name ) : return cls . _columns . get ( cls . _db_map . get ( name , name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim left - right given string<CODESPLIT>def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( "" , somestr ) tmp = RE_TSPACES . sub ( "" , tmp ) return str ( tmp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disable event loop integration with wxPython .<CODESPLIT>def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the progress ratio and percentage .<CODESPLIT>def ratio_and_percentage ( current , total , time_remaining ) : return "{} / {} ({}% completed)" . format ( current , total , int ( current / total * 100 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Click the element<CODESPLIT>def click ( self ) : try : self . wait_until_clickable ( ) . web_element . click ( ) except StaleElementReferenceException : # Retry if element has changed self . web_element . click ( ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies maspy . xml . clearTag () to the tag attribute of the element and recursively to all child elements .<CODESPLIT>def recClearTag ( element ) : children = element . getchildren ( ) if len ( children ) > 0 : for child in children : recClearTag ( child ) element . tag = clearTag ( element . tag )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get hue value of HSL color .<CODESPLIT>def _hue ( color , * * kwargs ) : h = colorsys . rgb_to_hls ( * [ x / 255.0 for x in color . value [ : 3 ] ] ) [ 0 ] return NumberValue ( h * 360.0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a chunked PUT request to url with requests . session This is specifically to upload files .<CODESPLIT>def rest_put_stream ( self , url , stream , headers = None , session = None , verify = True , cert = None ) : res = session . put ( url , headers = headers , data = stream , verify = verify , cert = cert ) return res . text , res . status_code
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close child subprocess<CODESPLIT>def close ( self ) : if self . _subprocess is not None : os . killpg ( self . _subprocess . pid , signal . SIGTERM ) self . _subprocess = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lasso Regression<CODESPLIT>def cric__lasso ( ) : model = sklearn . linear_model . LogisticRegression ( penalty = "l1" , C = 0.002 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator to run a function with timing info .<CODESPLIT>def timed ( log = sys . stderr , limit = 2.0 ) : return lambda func : timeit ( func , log , limit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Builds instance from dictionary of properties .<CODESPLIT>def fromDict ( cls , _dict ) : obj = cls ( ) obj . __dict__ . update ( _dict ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get milliseconds from a timedelta .<CODESPLIT>def timedelta2millisecond ( td ) : milliseconds = td . days * 24 * 60 * 60 * 1000 milliseconds += td . seconds * 1000 milliseconds += td . microseconds / 1000 return milliseconds
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap itertools . groupby to make life easier .<CODESPLIT>def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Covert numpy array to tensorflow tensor<CODESPLIT>def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close the db and release memory<CODESPLIT>def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse file specified by constructor .<CODESPLIT>def parse ( self ) : f = open ( self . parse_log_path , "r" ) self . parse2 ( f ) f . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the unnormalized PDF of the normal distribution .<CODESPLIT>def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If item is not in lst add item to list at its sorted position<CODESPLIT>def insort_no_dup ( lst , item ) : import bisect ix = bisect . bisect_left ( lst , item ) if lst [ ix ] != item : lst [ ix : ix ] = [ item ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shutdown the service with a reason .<CODESPLIT>def stop ( self , reason = None ) : self . logger . info ( 'stopping' ) self . loop . stop ( pyev . EVBREAK_ALL )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if val is of integer type .<CODESPLIT>def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove null items from a dictionary<CODESPLIT>def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of tuples describing a table into a HTML string<CODESPLIT>def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorting logic for Quantity objects .<CODESPLIT>def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns dictionary with number of connections for each database .<CODESPLIT>def getConnectionStats ( self ) : cur = self . _conn . cursor ( ) cur . execute ( """SELECT datname,numbackends FROM pg_stat_database;""" ) rows = cur . fetchall ( ) if rows : return dict ( rows ) else : return { }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the MD5 hash for a file .<CODESPLIT>def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to uncheck a checkbox<CODESPLIT>def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute tokenwise ( elementwise ) accuracy .<CODESPLIT>def token_accuracy ( labels , outputs ) : weights = tf . to_float ( tf . not_equal ( labels , 0 ) ) return tf . metrics . accuracy ( labels , outputs , weights = weights )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Natural log of scipy norm function truncated at zero<CODESPLIT>def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return list of Logger classes .<CODESPLIT>def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle logging .<CODESPLIT>def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True<CODESPLIT>def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a slice from a table column holding arrays . ( see : func : table . getcolslice )<CODESPLIT>def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempts to convert given object to a string object<CODESPLIT>def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a given record is indexed .<CODESPLIT>def can_elasticsearch ( record ) : search = request . _methodview . search_class ( ) search = search . get_record ( str ( record . id ) ) return search . count ( ) == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the gradient of the current model using the training set<CODESPLIT>def compute_gradient ( self ) : delta = self . predict ( self . X ) - self . y return delta . dot ( self . X ) / len ( self . X )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate new UUID<CODESPLIT>def generate_id ( ) : # TODO: Use six.string_type to Py3 compat try : return unicode ( uuid1 ( ) ) . replace ( u"-" , u"" ) except NameError : return str ( uuid1 ( ) ) . replace ( u"-" , u"" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return default argument value as given by argparse s add_argument () .<CODESPLIT>def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .<CODESPLIT>def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove instance from model<CODESPLIT>def remove_instance ( self , item ) : self . instances . remove ( item ) self . remove_item ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test the multiprocess<CODESPLIT>def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add Builders and construction variables for SGI MIPS C ++ to an Environment .<CODESPLIT>def generate ( env ) : cplusplus . generate ( env ) env [ 'CXX' ] = 'CC' env [ 'CXXFLAGS' ] = SCons . Util . CLVar ( '-LANG:std' ) env [ 'SHCXX' ] = '$CXX' env [ 'SHOBJSUFFIX' ] = '.o' env [ 'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME' ] = 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the parenthetical change of level ( num closes - num opens ) .<CODESPLIT>def paren_change ( inputstring , opens = opens , closes = closes ) : count = 0 for c in inputstring : if c in opens : # open parens/brackets/braces count -= 1 elif c in closes : # close parens/brackets/braces count += 1 return count
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a set of variables by name from another frame .<CODESPLIT>def extract_vars_above ( * names ) : callerNS = sys . _getframe ( 2 ) . f_locals return dict ( ( k , callerNS [ k ] ) for k in names )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python<CODESPLIT>def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert axis coordinate to bin index .<CODESPLIT>def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str<CODESPLIT>def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tags the current version .<CODESPLIT>def git_tag ( tag ) : print ( 'Tagging "{}"' . format ( tag ) ) msg = '"Released version {}"' . format ( tag ) Popen ( [ 'git' , 'tag' , '-s' , '-m' , msg , tag ] ) . wait ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if running on windows whether in cygwin or not .<CODESPLIT>def on_windows ( ) : if bjam . variable ( "NT" ) : return True elif bjam . variable ( "UNIX" ) : uname = bjam . variable ( "JAMUNAME" ) if uname and uname [ 0 ] . startswith ( "CYGWIN" ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Align the given integer number to the closest page offset which usually is 4096 bytes .<CODESPLIT>def align_to_mmap ( num , round_up ) : res = ( num // ALLOCATIONGRANULARITY ) * ALLOCATIONGRANULARITY if round_up and ( res != num ) : res += ALLOCATIONGRANULARITY # END handle size return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a JSON file First remove comments and then use the json module package Comments look like : // ... or / * ... * /<CODESPLIT>def parse_json ( filename ) : # Regular expression for comments comment_re = re . compile ( '(^)?[^\S\n]*/(?:\*(.*?)\*/[^\S\n]*|/[^\n]*)($)?' , re . DOTALL | re . MULTILINE ) with open ( filename ) as f : content = '' . join ( f . readlines ( ) ) ## Looking for comments match = comment_re . search ( content ) while match : # single line comment content = content [ : match . start ( ) ] + content [ match . end ( ) : ] match = comment_re . search ( content ) # Return json file return json . loads ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) .<CODESPLIT>def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops playback<CODESPLIT>def stop ( self ) : if self . isPlaying is True : self . _execute ( "stop" ) self . _changePlayingState ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a Stripe API timestamp response ( unix epoch ) to a native datetime .<CODESPLIT>def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the class is a date type .<CODESPLIT>def is_date_type ( cls ) : if not isinstance ( cls , type ) : return False return issubclass ( cls , date ) and not issubclass ( cls , datetime )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compile and return a Module s code object .<CODESPLIT>def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is an asyncio adapted version of pyserial read . It provides a non - blocking read and returns a line of data read .<CODESPLIT>async def readline ( self ) : future = asyncio . Future ( ) data_available = False while True : if not data_available : if not self . my_serial . inWaiting ( ) : await asyncio . sleep ( self . sleep_tune ) else : data_available = True data = self . my_serial . readline ( ) future . set_result ( data ) else : if not future . done ( ) : await asyncio . sleep ( self . sleep_tune ) else : return future . result ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function for loading yaml - encoded data from disk .<CODESPLIT>def load_yaml ( filepath ) : with open ( filepath ) as f : txt = f . read ( ) return yaml . load ( txt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flush all items from cache .<CODESPLIT>def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day<CODESPLIT>def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the the number of columns required to display a string<CODESPLIT>def _visual_width ( line ) : return len ( re . sub ( colorama . ansitowin32 . AnsiToWin32 . ANSI_CSI_RE , "" , line ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : dt : a datetime Returns : tuple of the datetime s year and quarter<CODESPLIT>def datetime_to_year_quarter ( dt ) : year = dt . year quarter = int ( math . ceil ( float ( dt . month ) / 3 ) ) return ( year , quarter )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>updates the scale of all actors in the plotter<CODESPLIT>def update_scale ( self , value ) : self . plotter . set_scale ( self . x_slider_group . value , self . y_slider_group . value , self . z_slider_group . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates in a list .<CODESPLIT>def _uniquify ( _list ) : seen = set ( ) result = [ ] for x in _list : if x not in seen : result . append ( x ) seen . add ( x ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hides the main window of the terminal and sets the visible flag to False .<CODESPLIT>def hide ( self ) : if not HidePrevention ( self . window ) . may_hide ( ) : return self . hidden = True self . get_widget ( 'window-root' ) . unstick ( ) self . window . hide ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Grab data in TensorProto and convert to numpy array .<CODESPLIT>def _parse_array ( self , tensor_proto ) : try : from onnx . numpy_helper import to_array except ImportError as e : raise ImportError ( "Unable to import onnx which is required {}" . format ( e ) ) np_array = to_array ( tensor_proto ) . reshape ( tuple ( tensor_proto . dims ) ) return mx . nd . array ( np_array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return only the part of the row which should be printed .<CODESPLIT>def _get_printable_columns ( columns , row ) : if not columns : return row # Extract the column values, in the order specified. return tuple ( row [ c ] for c in columns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Filter the dict * d * to remove keys not in * keys * .<CODESPLIT>def filter_dict_by_key ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given object conforms to the Serializable protocol .<CODESPLIT>def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract table names from an SQL query .<CODESPLIT>def extract_table_names ( query ) : # a good old fashioned regex. turns out this worked better than actually parsing the code tables_blocks = re . findall ( r'(?:FROM|JOIN)\s+(\w+(?:\s*,\s*\w+)*)' , query , re . IGNORECASE ) tables = [ tbl for block in tables_blocks for tbl in re . findall ( r'\w+' , block ) ] return set ( tables )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if dtype is a numeric type .<CODESPLIT>def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flatten dict with defined key join symbol .<CODESPLIT>def flatten_dict_join_keys ( dct , join_symbol = " " ) : return dict ( flatten_dict ( dct , join = lambda a , b : a + join_symbol + b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set up neccessary environment variables<CODESPLIT>def setup_environment ( ) : osinter = ostool . get_interface ( ) pypath = osinter . get_maya_envpath ( ) for p in sys . path : pypath = os . pathsep . join ( ( pypath , p ) ) os . environ [ 'PYTHONPATH' ] = pypath
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close all files but the current one<CODESPLIT>def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns min ( val1 val2 ) returning None only if both values are None<CODESPLIT>def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of coded value from a key . If several keys of the same name are present the total sum is returned .<CODESPLIT>def codes_get_size ( handle , key ) : # type: (cffi.FFI.CData, str) -> int size = ffi . new ( 'size_t *' ) _codes_get_size ( handle , key . encode ( ENC ) , size ) return size [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an instance from a dictionary .<CODESPLIT>def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file is a regular file and is readable .<CODESPLIT>def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is a finite number .<CODESPLIT>def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Specify that this function returns a typed value .<CODESPLIT>def return_type ( type_name , formatter = None ) : def _returns ( func ) : annotated ( func ) func . metadata . typed_returnvalue ( type_name , formatter ) return func return _returns
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if cnr or cns files are empty ( only have a header )<CODESPLIT>def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the title on the underlying matplotlib AxesSubplot .<CODESPLIT>def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raise ( or re - raises ) an exception .<CODESPLIT>def raise_ ( exception = ABSENT , * args , * * kwargs ) : if exception is ABSENT : raise else : if inspect . isclass ( exception ) : raise exception ( * args , * * kwargs ) else : if args or kwargs : raise TypeError ( "can't pass arguments along with " "exception object to raise_()" ) raise exception
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Install Postgres on remote<CODESPLIT>def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a dictionary of strings from a file<CODESPLIT>def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lookup a transitive parent object that is an instance of a given class .<CODESPLIT>def _lookup_parent ( self , cls ) : codeobj = self . parent while codeobj is not None and not isinstance ( codeobj , cls ) : codeobj = codeobj . parent return codeobj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all documents from the given index .<CODESPLIT>def all_documents ( index = INDEX_NAME ) : query = { 'query' : { 'match_all' : { } } } for result in raw_query ( query , index = index ) : yield result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize every item of the list .<CODESPLIT>def serialize ( self , value , * * kwargs ) : return [ self . item_type . serialize ( val , * * kwargs ) for val in value ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Similar to : attr : . Guild . me except it may return the : class : . ClientUser in private message contexts .<CODESPLIT>def me ( self ) : return self . guild . me if self . guild is not None else self . bot . user
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple helper hash function<CODESPLIT>def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the shape of img .<CODESPLIT>def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get width and height of a PDF<CODESPLIT>def dimensions ( path ) : pdf = PdfFileReader ( path ) size = pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a slug for each Event already in the DB .<CODESPLIT>def set_slug ( apps , schema_editor ) : Event = apps . get_model ( 'spectator_events' , 'Event' ) for e in Event . objects . all ( ) : e . slug = generate_slug ( e . pk ) e . save ( update_fields = [ 'slug' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply function to nodes<CODESPLIT>def map_tree ( visitor , tree ) : newn = [ map_tree ( visitor , node ) for node in tree . nodes ] return visitor ( tree , newn )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert any timestamp to UTC ( with tzinfo ) .<CODESPLIT>def to_utc ( self , dt ) : if dt . tzinfo is None : return dt . replace ( tzinfo = self . utc ) return dt . astimezone ( self . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize a date / time value into an ISO8601 text representation adjusted ( if needed ) to UTC timezone .<CODESPLIT>def timestamp_with_tzinfo ( dt ) : utc = tzutc ( ) if dt . tzinfo : dt = dt . astimezone ( utc ) . replace ( tzinfo = None ) return dt . isoformat ( ) + 'Z'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Google AppEngine Helper to convert a data type into a string .<CODESPLIT>def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Concatenate url and argument dictionary regardless of whether url has existing query parameters .<CODESPLIT>def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the given number in decimal format using a period and commas<CODESPLIT>def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a JSON file First remove comments and then use the json module package Comments look like : // ... or / * ... * /<CODESPLIT>def parse_json ( filename ) : # Regular expression for comments comment_re = re . compile ( '(^)?[^\S\n]*/(?:\*(.*?)\*/[^\S\n]*|/[^\n]*)($)?' , re . DOTALL | re . MULTILINE ) with open ( filename ) as f : content = '' . join ( f . readlines ( ) ) ## Looking for comments match = comment_re . search ( content ) while match : # single line comment content = content [ : match . start ( ) ] + content [ match . end ( ) : ] match = comment_re . search ( content ) # Return json file return json . loads ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans up the name according to the rules specified in this exact function . Uses self . naughty a list of naughty characters .<CODESPLIT>def _clean_up_name ( self , name ) : for n in self . naughty : name = name . replace ( n , '_' ) return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When the with statement ends .<CODESPLIT>def __exit__ ( self , type , value , traceback ) : if not self . asarfile : return self . asarfile . close ( ) self . asarfile = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether a system service is available<CODESPLIT>def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: raises docker . exceptions . APIError<CODESPLIT>def running_containers ( name_filter : str ) -> List [ str ] : return [ container . short_id for container in docker_client . containers . list ( filters = { "name" : name_filter } ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds params to url<CODESPLIT>def add_params_to_url ( url , params ) : url_parts = list ( urlparse . urlparse ( url ) ) # get url parts query = dict ( urlparse . parse_qsl ( url_parts [ 4 ] ) ) # get url query query . update ( params ) # add new params url_parts [ 4 ] = urlencode ( query ) return urlparse . urlunparse ( url_parts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function that removes a dicts keys that have falsy values<CODESPLIT>def _clean_dict ( target_dict , whitelist = None ) : assert isinstance ( target_dict , dict ) return { ustr ( k ) . strip ( ) : ustr ( v ) . strip ( ) for k , v in target_dict . items ( ) if v not in ( None , Ellipsis , [ ] , ( ) , "" ) and ( not whitelist or k in whitelist ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A magic method to implement shallow copy behavior .<CODESPLIT>def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get max for queryset .<CODESPLIT>def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a prefix to a list of values .<CODESPLIT>def prefix_list ( self , prefix , values ) : return list ( map ( lambda value : prefix + " " + value , values ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modified form of the g format specifier .<CODESPLIT>def format_float ( value ) : # not used string = "{:g}" . format ( value ) . replace ( "e+" , "e" ) string = re . sub ( "e(-?)0*(\d+)" , r"e\1\2" , string ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places all the child widgets in the appropriate positions .<CODESPLIT>def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = "nswe" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = "ns" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an old style protocol buffer object .<CODESPLIT>def AsPrimitiveProto ( self ) : if self . protobuf : result = self . protobuf ( ) result . ParseFromString ( self . SerializeToString ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A tensorflow variable tranfomed to be constrained in a L2 unit ball .<CODESPLIT>def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implementation of map that recurses . This tests the same keys at every level of dict and in lists : param f : 2 - ary function expecting a key and value and returns a modified key : param dct : Dict for deep processing : return : Modified dct with matching props mapped<CODESPLIT>def map_keys_deep ( f , dct ) : return _map_deep ( lambda k , v : [ f ( k , v ) , v ] , dct )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the variable set with the given name .<CODESPLIT>def get_var ( self , name ) : for var in self . vars : if var . name == name : return var else : raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserialize the object from a JSON string .<CODESPLIT>def from_json ( cls , json_str ) : d = json . loads ( json_str ) return cls . from_dict ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split Python source into chunks .<CODESPLIT>def _split_python ( python ) : python = _preprocess ( python ) if not python : return [ ] lexer = PythonSplitLexer ( ) lexer . read ( python ) return lexer . chunks
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes functions that are invoked when the user or OS wants to kill this process . : return :<CODESPLIT>def set_stop_handler ( self ) : signal . signal ( signal . SIGTERM , self . graceful_stop ) signal . signal ( signal . SIGABRT , self . graceful_stop ) signal . signal ( signal . SIGINT , self . graceful_stop )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the negated mask . If elements of input mask have 0 and non - zero values then the returned matrix will have all elements 0 ( 1 ) where the original one has non - zero ( 0 ) . : param mask : Input mask : type mask : np . array : return : array of same shape and dtype = int8 as input array : rtype : np . array<CODESPLIT>def negate_mask ( mask ) : res = np . ones ( mask . shape , dtype = np . int8 ) res [ mask > 0 ] = 0 return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace all the ocurrences ( in a file ) of a string with another value .<CODESPLIT>def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to a list with sanitization .<CODESPLIT>def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dump bel specification dictionary using YAML<CODESPLIT>def _dump_spec ( spec ) : with open ( "spec.yaml" , "w" ) as f : yaml . dump ( spec , f , Dumper = MyDumper , default_flow_style = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of characters at the beginning of text that are whitespace .<CODESPLIT>def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a UUID .<CODESPLIT>def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the approximate size of the queue ( not reliable! ) .<CODESPLIT>def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether this path is a symbolic link .<CODESPLIT>def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply re . sub to bunch of ( pattern repl )<CODESPLIT>def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves a value by name .<CODESPLIT>def GetValueByName ( self , name ) : pyregf_value = self . _pyregf_key . get_value_by_name ( name ) if not pyregf_value : return None return REGFWinRegistryValue ( pyregf_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when a new DropDownItem gets selected .<CODESPLIT>def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse the code parameter from the a URL<CODESPLIT>def parse_code ( url ) : result = urlparse ( url ) query = parse_qs ( result . query ) return query [ 'code' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when the service is being shut down .<CODESPLIT>def SvcStop ( self ) -> None : # tell the SCM we're shutting down # noinspection PyUnresolvedReferences self . ReportServiceStatus ( win32service . SERVICE_STOP_PENDING ) # fire the stop event win32event . SetEvent ( self . h_stop_event )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute boxplot for given pandas Series .<CODESPLIT>def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = "|" . join ( map ( str , stats [ 'fliers' ] ) ) return stats
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a copy of the tuple as a list<CODESPLIT>def to_json ( value , * * kwargs ) : serial_list = [ val . serialize ( * * kwargs ) if isinstance ( val , HasProperties ) else val for val in value ] return serial_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if two objects are equal .<CODESPLIT>def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return IPython s guess for the default encoding for bytes as text .<CODESPLIT>def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is largely copied from bokeh . sphinxext . bokeh_plot . run<CODESPLIT>def get_code_language ( self ) : js_source = self . get_js_source ( ) if self . options . get ( "include_html" , False ) : resources = get_sphinx_resources ( include_bokehjs_api = True ) html_source = BJS_HTML . render ( css_files = resources . css_files , js_files = resources . js_files , bjs_script = js_source ) return [ html_source , "html" ] else : return [ js_source , "javascript" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs a mouse out the element .<CODESPLIT>def mouse_out ( self ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . move_by_offset ( 0 , 0 ) . click ( ) . perform ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a datetime object and returns a string<CODESPLIT>def serialize ( self , value ) : if isinstance ( value , str ) : return value return value . strftime ( DATETIME_FORMAT )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like rotate but modifies l in - place .<CODESPLIT>def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Random gamma variates .<CODESPLIT>def rgamma ( alpha , beta , size = None ) : return np . random . gamma ( shape = alpha , scale = 1. / beta , size = size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket<CODESPLIT>def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new copied dictionary without the keys with None values from the given Mapping object .<CODESPLIT>def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Populate axis limits GUI with current plot values .<CODESPLIT>def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Double integrate .<CODESPLIT>def trapz2 ( f , x = None , y = None , dx = 1.0 , dy = 1.0 ) : return numpy . trapz ( numpy . trapz ( f , x = y , dx = dy ) , x = x , dx = dx )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a hack to monkey patch sdproperty to work as expected with instance methods .<CODESPLIT>def sdmethod ( meth ) : sd = singledispatch ( meth ) def wrapper ( obj , * args , * * kwargs ) : return sd . dispatch ( args [ 0 ] . __class__ ) ( obj , * args , * * kwargs ) wrapper . register = sd . register wrapper . dispatch = sd . dispatch wrapper . registry = sd . registry wrapper . _clear_cache = sd . _clear_cache functools . update_wrapper ( wrapper , meth ) return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send data to statsd .<CODESPLIT>def _send ( self , data ) : if not self . _sock : self . connect ( ) self . _do_send ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get user name provide by operating system<CODESPLIT>def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dumps a representation of the Model on standard output .<CODESPLIT>def dump ( self , * args , * * kwargs ) : lxml . etree . dump ( self . _obj , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Portable cast function .<CODESPLIT>def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a new page in x if key is not a page of x otherwise add value to x [ key ]<CODESPLIT>def smartSum ( x , key , value ) : if key not in list ( x . keys ( ) ) : x [ key ] = value else : x [ key ] += value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like map but also chains the results .<CODESPLIT>def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load a new copy of a document from the database . does not replace the old one<CODESPLIT>def refresh ( self , document ) : try : old_cache_size = self . cache_size self . cache_size = 0 obj = self . query ( type ( document ) ) . filter_by ( mongo_id = document . mongo_id ) . one ( ) finally : self . cache_size = old_cache_size self . cache_write ( obj ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if string could be a valid python identifier<CODESPLIT>def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allow \ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :<CODESPLIT>def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield successive chunks from array / list / string . Final chunk may be truncated if array is not evenly divisible by chunk_size .<CODESPLIT>def pieces ( array , chunk_size ) : for i in range ( 0 , len ( array ) , chunk_size ) : yield array [ i : i + chunk_size ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given thing represents a date<CODESPLIT>def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve core and memory information for the current machine .<CODESPLIT>def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { "memory" : float ( "%.1f" % ( free_bytes / BYTES_IN_GIG ) ) , "cores" : multiprocessing . cpu_count ( ) , "name" : socket . gethostname ( ) } ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the object s parent window . Returns None if no window found .<CODESPLIT>def get_window ( self ) : x = self while not x . _parent == None and not isinstance ( x . _parent , Window ) : x = x . _parent return x . _parent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the SSE to the cluster center<CODESPLIT>def _cal_dist2center ( X , center ) : dmemb2cen = scipy . spatial . distance . cdist ( X , center . reshape ( 1 , X . shape [ 1 ] ) , metric = 'seuclidean' ) return ( np . sum ( dmemb2cen ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if string matches this argument s format .<CODESPLIT>def __is__ ( cls , s ) : return s . startswith ( cls . delims ( ) [ 0 ] ) and s . endswith ( cls . delims ( ) [ 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all input nodes from a network .<CODESPLIT>def get_input_nodes ( G : nx . DiGraph ) -> List [ str ] : return [ n for n , d in G . in_degree ( ) if d == 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the number of significant figures used to print Pint Pandas and NumPy quantities .<CODESPLIT>def set_sig_figs ( n = 4 ) : u . default_format = '.' + str ( n ) + 'g' pd . options . display . float_format = ( '{:,.' + str ( n ) + '}' ) . format
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms a DataFrame in place . Computes all outputs of the DataFrame .<CODESPLIT>def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rounds float to closest int : rtype : int : param n : float<CODESPLIT>def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show ( print out ) current environment variables .<CODESPLIT>def show ( ) : env = get_environment ( ) for key , val in sorted ( env . env . items ( ) , key = lambda item : item [ 0 ] ) : click . secho ( '%s = %s' % ( key , val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dot product of two vectors<CODESPLIT>def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a single property to the file in Java properties format .<CODESPLIT>def write_property ( fh , key , value ) : if key is COMMENT : write_comment ( fh , value ) return _require_string ( key , 'keys' ) _require_string ( value , 'values' ) fh . write ( _escape_key ( key ) ) fh . write ( b'=' ) fh . write ( _escape_value ( value ) ) fh . write ( b'\n' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if object is defined<CODESPLIT>def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator that injects parsed arguments into a view function or method .<CODESPLIT>def use_kwargs ( self , * args , * * kwargs ) -> typing . Callable : return super ( ) . use_kwargs ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a random paragraph .<CODESPLIT>def paragraph ( separator = '\n\n' , wrap_start = '' , wrap_end = '' , html = False , sentences_quantity = 3 ) : return paragraphs ( quantity = 1 , separator = separator , wrap_start = wrap_start , wrap_end = wrap_end , html = html , sentences_quantity = sentences_quantity )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return True if the current distribution is running on debian like OS .<CODESPLIT>def is_archlinux ( ) : if platform . system ( ) . lower ( ) == 'linux' : if platform . linux_distribution ( ) == ( '' , '' , '' ) : # undefined distribution. Fixed in python 3. if os . path . exists ( '/etc/arch-release' ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if Glances is running in standalone mode .<CODESPLIT>def is_standalone ( self ) : return ( not self . args . client and not self . args . browser and not self . args . server and not self . args . webserver )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Suppress warning about untrusted SSL certificate .<CODESPLIT>def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of days since January 1 of the given year .<CODESPLIT>def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>data preparation<CODESPLIT>def transformer ( data , label ) : data = mx . image . imresize ( data , IMAGE_SIZE , IMAGE_SIZE ) data = mx . nd . transpose ( data , ( 2 , 0 , 1 ) ) data = data . astype ( np . float32 ) / 128.0 - 1 return data , label
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply a delaunay 2D filter along the best fitting plane . This extracts the grid s points and perfoms the triangulation on those alone .<CODESPLIT>def delaunay_2d ( self , tol = 1e-05 , alpha = 0.0 , offset = 1.0 , bound = False ) : return PolyData ( self . points ) . delaunay_2d ( tol = tol , alpha = alpha , offset = offset , bound = bound )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if given filename is an image .<CODESPLIT>def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a : py : class : datetime . datetime instance representing the current time .<CODESPLIT>def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print list of namedtuples into a table using prtfmt .<CODESPLIT>def prt_nts ( data_nts , prtfmt = None , prt = sys . stdout , nt_fields = None , * * kws ) : prt_txt ( prt , data_nts , prtfmt , nt_fields , * * kws )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper that returns if parent / item is a directory .<CODESPLIT>def _IsDirectory ( parent , item ) : return tf . io . gfile . isdir ( os . path . join ( parent , item ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager to temporarily disable certificate validation in the standard SSL library .<CODESPLIT>def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to get a number out of a string and cast it .<CODESPLIT>def get_number ( s , cast = int ) : import string d = "" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Any normal python logic which runs a loop . Can take arguments .<CODESPLIT>def main ( idle ) : while True : LOG . debug ( "Sleeping for {0} seconds." . format ( idle ) ) time . sleep ( idle )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a n + 1 dim one - hot array from n dim int - categorical array .<CODESPLIT>def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a : py : class : datetime . datetime instance representing the current time .<CODESPLIT>def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty - print an error .<CODESPLIT>def err ( msg ) : click . echo ( click . style ( msg , fg = "red" , bold = True ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace {{ variable - name }} with stored value .<CODESPLIT>def replace_variables ( self , source : str , variables : dict ) -> str : try : replaced = re . sub ( "{{(.*?)}}" , lambda m : variables . get ( m . group ( 1 ) , "" ) , source ) except TypeError : replaced = source return replaced
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>position in 3d space<CODESPLIT>def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for iterating only nonempty lines without line breaks<CODESPLIT>def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\r\n' ) if line : yield line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a message indicating failure in red color to STDERR .<CODESPLIT>def print_failure_message ( message ) : try : import colorama print ( colorama . Fore . RED + message + colorama . Fore . RESET , file = sys . stderr ) except ImportError : print ( message , file = sys . stderr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns file name of file at given url .<CODESPLIT>def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the byte wise exclusive of of two : class : bytes objects of the same length .<CODESPLIT>def xor_bytes ( a , b ) : assert len ( a ) == len ( b ) return bytes ( map ( operator . xor , a , b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>consider the distance between two mapPoints ignoring all terrain pathing issues<CODESPLIT>def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Google AppEngine Helper to convert a data type into a string .<CODESPLIT>def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provides the color corresponding to value x in the form of a tuple ( R G B A ) with int values between 0 and 255 .<CODESPLIT>def rgba_bytes_tuple ( self , x ) : return tuple ( int ( u * 255.9999 ) for u in self . rgba_floats_tuple ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute boxplot for given pandas Series .<CODESPLIT>def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = "|" . join ( map ( str , stats [ 'fliers' ] ) ) return stats
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render our pages as a jinja template for fancy templating goodness .<CODESPLIT>def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a one element byte string to signed int for python 2 support .<CODESPLIT>def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( "b" , string ) [ 0 ] else : return struct . unpack ( "b" , bytes ( [ string ] ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean up processes after SIGTERM or SIGINT is received .<CODESPLIT>def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>safe version of pow<CODESPLIT>def safe_pow ( base , exp ) : if exp > MAX_EXPONENT : raise RuntimeError ( "Invalid exponent, max exponent is {}" . format ( MAX_EXPONENT ) ) return base ** exp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a blank row with only an index value to self . df . This is done inplace .<CODESPLIT>def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write DOT comment .<CODESPLIT>def comment ( self , s , * * args ) : self . write ( u"// " ) self . writeln ( s = s , * * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable the editing buttons to add / remove rows / columns and to edit the data .<CODESPLIT>def enableEditing ( self , enabled ) : for button in self . buttons [ 1 : ] : button . setEnabled ( enabled ) if button . isChecked ( ) : button . setChecked ( False ) model = self . tableView . model ( ) if model is not None : model . enableEditing ( enabled )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert comma - delimited list / string into a list of strings<CODESPLIT>def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a one element byte string to signed int for python 2 support .<CODESPLIT>def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( "b" , string ) [ 0 ] else : return struct . unpack ( "b" , bytes ( [ string ] ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True<CODESPLIT>def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds an accuracy op to the model<CODESPLIT>def AddAccuracy ( model , softmax , label ) : accuracy = brew . accuracy ( model , [ softmax , label ] , "accuracy" ) return accuracy
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hacked run function which installs the trace .<CODESPLIT>def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output<CODESPLIT>def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load a geotiff raster keeping ndv values using a masked array<CODESPLIT>def load_tiff ( file ) : ndv , xsize , ysize , geot , projection , datatype = get_geo_info ( file ) data = gdalnumeric . LoadFile ( file ) data = np . ma . masked_array ( data , mask = data == ndv , fill_value = ndv ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy an array to the shared memory .<CODESPLIT>def copy ( a ) : shared = anonymousmemmap ( a . shape , dtype = a . dtype ) shared [ : ] = a [ : ] return shared
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the absolute path to the directory containing the package data .<CODESPLIT>def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , "data" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : img ( PIL Image ) : Image to be padded .<CODESPLIT>def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return type may come from any boolop operand .<CODESPLIT>def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string * s * into list of strings no longer than * length *<CODESPLIT>def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move to the end of the input history i . e . the line currently being entered .<CODESPLIT>def end_of_history ( event ) : event . current_buffer . history_forward ( count = 10 ** 100 ) buff = event . current_buffer buff . go_to_history ( len ( buff . _working_lines ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>abstract method<CODESPLIT>def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .<CODESPLIT>def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Natural log of scipy norm function truncated at zero<CODESPLIT>def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python 3 input () / Python 2 raw_input ()<CODESPLIT>def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the angle between vector x and y<CODESPLIT>def angle_between_vectors ( x , y ) : dp = dot_product ( x , y ) if dp == 0 : return 0 xm = magnitude ( x ) ym = magnitude ( y ) return math . acos ( dp / ( xm * ym ) ) * ( 180. / math . pi )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop the progress bar .<CODESPLIT>def stop ( self ) : if self . _progressing : self . _progressing = False self . _thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load and execute a python file .<CODESPLIT>def load_files ( files ) : for py_file in files : LOG . debug ( "exec %s" , py_file ) execfile ( py_file , globals ( ) , locals ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>FIXME : How to test this ?<CODESPLIT>def copen ( filepath , flag = 'r' , encoding = None ) : if encoding is None : encoding = locale . getdefaultlocale ( ) [ 1 ] return codecs . open ( filepath , flag , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start the Django dev server .<CODESPLIT>def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert comma - delimited list / string into a list of strings<CODESPLIT>def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Has a 50 / 50 chance of calling a function<CODESPLIT>def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the request payload size<CODESPLIT>def calculate_size ( name , count ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += INT_SIZE_IN_BYTES return data_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shuffle the data .<CODESPLIT>def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all Labels .<CODESPLIT>def clear_all ( self ) : logger . info ( "Clearing ALL Labels and LabelKeys." ) self . session . query ( Label ) . delete ( synchronize_session = "fetch" ) self . session . query ( LabelKey ) . delete ( synchronize_session = "fetch" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>zeros out states that should be identical<CODESPLIT>def _zerosamestates ( self , A ) : for pair in self . samestates : A [ pair [ 0 ] , pair [ 1 ] ] = 0 A [ pair [ 1 ] , pair [ 0 ] ] = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a 20 char passphrase with easily typeable chars .<CODESPLIT>def GeneratePassphrase ( length = 20 ) : valid_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" valid_chars += "0123456789 ,-_&$#" return "" . join ( random . choice ( valid_chars ) for i in range ( length ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add arrow to plot<CODESPLIT>def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle linear / log scale for Y - axis .<CODESPLIT>def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random positive integer ( for a Django PositiveIntegerField )<CODESPLIT>def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to make map () behave the same on Py2 and Py3 .<CODESPLIT>def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the distance between two points coord1 and coord2 . These parameters are assumed to be ( x y ) tuples .<CODESPLIT>def _distance ( coord1 , coord2 ) : xdist = coord1 [ 0 ] - coord2 [ 0 ] ydist = coord1 [ 1 ] - coord2 [ 1 ] return sqrt ( xdist * xdist + ydist * ydist )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes occurrence of character ( sep ) from a line of text<CODESPLIT>def strip_line ( line , sep = os . linesep ) : try : return line . strip ( sep ) except TypeError : return line . decode ( 'utf-8' ) . strip ( sep )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a file exists and is non - empty .<CODESPLIT>def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Primary entry point to turn kwargs into properties<CODESPLIT>def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip a single frame from the trajectory<CODESPLIT>def _skip_frame ( self ) : size = self . read_size ( ) for i in range ( size + 1 ) : line = self . _f . readline ( ) if len ( line ) == 0 : raise StopIteration
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the case as an Excel spreadsheet .<CODESPLIT>def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Advance the iterator without returning the old head .<CODESPLIT>def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load the state from the given file moving to the file s directory during load ( temporarily moving back after loaded )<CODESPLIT>def load ( filename ) : path , name = os . path . split ( filename ) path = path or '.' with util . indir ( path ) : return pickle . load ( open ( name , 'rb' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set all fields readonly .<CODESPLIT>def get_readonly_fields ( self , request , obj = None ) : return list ( self . readonly_fields ) + [ field . name for field in obj . _meta . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print warning about interrupt and empty the job queue .<CODESPLIT>def finish ( ) : out . warn ( "Interrupted!" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( "Waiting for download threads to finish." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) .<CODESPLIT>def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string into list of strings by specified number .<CODESPLIT>def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of tuples specifying the column name and type<CODESPLIT>def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( "PRAGMA table_info('%s');" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the width of the table including padding and borders .<CODESPLIT>def table_width ( self ) : outer_widths = max_dimensions ( self . table_data , self . padding_left , self . padding_right ) [ 2 ] outer_border = 2 if self . outer_border else 0 inner_border = 1 if self . inner_column_border else 0 return table_width ( outer_widths , outer_border , inner_border )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if value is an integer .<CODESPLIT>def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Captures screen area of this region at least the part that is on the screen<CODESPLIT>def getBitmap ( self ) : return PlatformManager . getBitmapFromRect ( self . x , self . y , self . w , self . h )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add global variables to JavaScript about the location and latest version of transpiled files . Usage :: { % static_urls_js % }<CODESPLIT>def static_urls_js ( ) : if apps . is_installed ( 'django.contrib.staticfiles' ) : from django . contrib . staticfiles . storage import staticfiles_storage static_base_url = staticfiles_storage . base_url else : static_base_url = PrefixNode . handle_simple ( "STATIC_URL" ) transpile_base_url = urljoin ( static_base_url , 'js/transpile/' ) return { 'static_base_url' : static_base_url , 'transpile_base_url' : transpile_base_url , 'version' : LAST_RUN [ 'version' ] }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Transform a simple index into a human - readable position in a string .<CODESPLIT>def text_coords ( string , position ) : line_start = string . rfind ( '\n' , 0 , position ) + 1 line_end = string . find ( '\n' , position ) lineno = string . count ( '\n' , 0 , position ) columnno = position - line_start line = string [ line_start : line_end ] return ( lineno , columnno , line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a copy of this list with each element copied to new memory<CODESPLIT>def copy ( self ) : out = type ( self ) ( ) for series in self : out . append ( series . copy ( ) ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse string into Identity dictionary .<CODESPLIT>def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return flattened dictionary from MultiDict .<CODESPLIT>def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Efficient conversion from scipy sparse matrix to cvxopt sparse matrix<CODESPLIT>def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put curly brackets round an indented text<CODESPLIT>def dumped ( text , level , indent = 2 ) : return indented ( "{\n%s\n}" % indented ( text , level + 1 , indent ) or "None" , level , indent ) + "\n"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the screen resolution of the primary screen .<CODESPLIT>def get_screen_resolution ( self ) : widget = QDesktopWidget ( ) geometry = widget . availableGeometry ( widget . primaryScreen ( ) ) return geometry . width ( ) , geometry . height ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a datetime from GnuCash 2 . 6 date string<CODESPLIT>def get_from_gnucash26_date ( date_str : str ) -> date : date_format = "%Y%m%d" result = datetime . strptime ( date_str , date_format ) . date ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the object s parent window . Returns None if no window found .<CODESPLIT>def get_window ( self ) : x = self while not x . _parent == None and not isinstance ( x . _parent , Window ) : x = x . _parent return x . _parent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like pretty but print to stdout .<CODESPLIT>def pprint ( obj , verbose = False , max_width = 79 , newline = '\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns a werkzeug . MultiDict or django . MultiValueDict into a dict with list values : param d : a MultiDict or MultiValueDict instance : return : a dict instance<CODESPLIT>def multidict_to_dict ( d ) : return dict ( ( k , v [ 0 ] if len ( v ) == 1 else v ) for k , v in iterlists ( d ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>expects a _n . array returns the global minimum of ( value - array ) ^2<CODESPLIT>def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return minimal quantum of a number as defined by precision .<CODESPLIT>def get_decimal_quantum ( precision ) : assert isinstance ( precision , ( int , decimal . Decimal ) ) return decimal . Decimal ( 10 ) ** ( - precision )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of processors on this machine .<CODESPLIT>def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( "SC_NPROCESSORS_CONF" ) except ( AttributeError , ValueError ) : pass gen_log . error ( "Could not detect number of processors; assuming 1" ) return 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a set of attributes for a multiple items in multiple tables using their primary keys .<CODESPLIT>def batch_get_item ( self , batch_list ) : request_items = self . dynamize_request_items ( batch_list ) return self . layer1 . batch_get_item ( request_items , object_hook = item_object_hook )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Beta distirbution probability density function .<CODESPLIT>def beta_pdf ( x , a , b ) : bc = 1 / beta ( a , b ) fc = x ** ( a - 1 ) sc = ( 1 - x ) ** ( b - 1 ) return bc * fc * sc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get dimension of an array getting the number of rows and the max num of columns .<CODESPLIT>def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list consisting of the cumulative sum of the items in the passed list .<CODESPLIT>def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Insert many items at once into a temporary table .<CODESPLIT>def insert_many ( self , items ) : return SessionContext . session . execute ( self . insert ( values = [ to_dict ( item , self . c ) for item in items ] ) , ) . rowcount
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the scroll region on the canvas<CODESPLIT>def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw<CODESPLIT>def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save a Keras model definition to JSON with given path<CODESPLIT>def save_keras_definition ( keras_model , path ) : model_json = keras_model . to_json ( ) with open ( path , "w" ) as json_file : json_file . write ( model_json )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets RAM memory usage<CODESPLIT>def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increment some indices in a 1D vector of non - negative integers . Repeated indices are taken into account .<CODESPLIT>def _increment ( arr , indices ) : arr = _as_array ( arr ) indices = _as_array ( indices ) bbins = np . bincount ( indices ) arr [ : len ( bbins ) ] += bbins return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I check to see if a method on a TestCase has been disabled via nose s convention for disabling a TestCase . This makes it so that users can mix nose s parameterized tests with green as a runner .<CODESPLIT>def isTestCaseDisabled ( test_case_class , method_name ) : test_method = getattr ( test_case_class , method_name ) return getattr ( test_method , "__test__" , 'not nose' ) is False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts py2 unicode / py3 bytestring into str Args : string ( unicode byte_string ) : string to be converted Returns : ( str )<CODESPLIT>def ub_to_str ( string ) : if not isinstance ( string , str ) : if six . PY2 : return str ( string ) else : return string . decode ( ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>searchs a value in a dicionary and returns the key of the first occurrence<CODESPLIT>def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is the same functionality as int . from_bytes in python 3<CODESPLIT>def _from_bytes ( bytes , byteorder = "big" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal method to directly add a _NamespaceInfo object to this set . No sanity checks are done ( e . g . checking for prefix conflicts ) so be sure to do it yourself before calling this .<CODESPLIT>def __add_namespaceinfo ( self , ni ) : self . __ns_uri_map [ ni . uri ] = ni for prefix in ni . prefixes : self . __prefix_map [ prefix ] = ni
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create new bucket .<CODESPLIT>def touch ( ) : from . models import Bucket bucket = Bucket . create ( ) db . session . commit ( ) click . secho ( str ( bucket ) , fg = 'green' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values<CODESPLIT>def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( "Error getting image size {}" . format ( url ) , exc_info = True ) return w_h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given extension is one of the watched extensions<CODESPLIT>def watched_extension ( extension ) : for ext in hamlpy . VALID_EXTENSIONS : if extension . endswith ( '.' + ext ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns type of the data for the given FeatureType .<CODESPLIT>def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper that clears the composition .<CODESPLIT>def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = "black" ) del draw
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>adds a line of text to a file<CODESPLIT>def append_text ( self , txt ) : with open ( self . fullname , "a" ) as myfile : myfile . write ( txt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the latitude and longitude corresponding to a screen point : param x : screen x : param y : screen y : return : latitude and longitude at x y<CODESPLIT>def screen_to_latlon ( self , x , y ) : xtile = 1. * x / TILE_SIZE + self . xtile ytile = 1. * y / TILE_SIZE + self . ytile return self . num2deg ( xtile , ytile , self . zoom )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dict mapping item - > indices .<CODESPLIT>def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reads the zip file determines compression and unzips recursively until source files are extracted<CODESPLIT>def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>quit crash<CODESPLIT>def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get rid of all axis ticks lines etc .<CODESPLIT>def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :<CODESPLIT>def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( "non-list value found where list is expected" ) return all ( isinstance ( x , str ) for x in arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modified form of the g format specifier .<CODESPLIT>def format_float ( value ) : # not used string = "{:g}" . format ( value ) . replace ( "e+" , "e" ) string = re . sub ( "e(-?)0*(\d+)" , r"e\1\2" , string ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sample data from given histogram and min max values within range<CODESPLIT>def inverseHistogram ( hist , bin_range ) : data = hist . astype ( float ) / np . min ( hist [ np . nonzero ( hist ) ] ) new_data = np . empty ( shape = np . sum ( data , dtype = int ) ) i = 0 xvals = np . linspace ( bin_range [ 0 ] , bin_range [ 1 ] , len ( data ) ) for d , x in zip ( data , xvals ) : new_data [ i : i + d ] = x i += int ( d ) return new_data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all attribute members ( attribute property style method ) .<CODESPLIT>def get_all_attributes ( klass_or_instance ) : pairs = list ( ) for attr , value in inspect . getmembers ( klass_or_instance , lambda x : not inspect . isroutine ( x ) ) : if not ( attr . startswith ( "__" ) or attr . endswith ( "__" ) ) : pairs . append ( ( attr , value ) ) return pairs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback to go to the next tab . Called by the accel key .<CODESPLIT>def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if object is defined<CODESPLIT>def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rotate the given point by angle<CODESPLIT>def rotate_point ( xorigin , yorigin , x , y , angle ) : rotx = ( x - xorigin ) * np . cos ( angle ) - ( y - yorigin ) * np . sin ( angle ) roty = ( x - yorigin ) * np . sin ( angle ) + ( y - yorigin ) * np . cos ( angle ) return rotx , roty
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>load an nparray object from a json filename<CODESPLIT>def from_file ( filename ) : f = open ( filename , 'r' ) j = json . load ( f ) f . close ( ) return from_dict ( j )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get list of datetime objects extracted from a filename<CODESPLIT>def get_dt_list ( fn_list ) : dt_list = np . array ( [ fn_getdatetime ( fn ) for fn in fn_list ] ) return dt_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param unicode fpath : : param unicode encoding : : rtype : dict | list<CODESPLIT>def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str<CODESPLIT>def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to print sqlite queries before executing .<CODESPLIT>def execute ( cur , * args ) : stmt = args [ 0 ] if len ( args ) > 1 : stmt = stmt . replace ( '%' , '%%' ) . replace ( '?' , '%r' ) print ( stmt % ( args [ 1 ] ) ) return cur . execute ( * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a blank row with only an index value to self . df . This is done inplace .<CODESPLIT>def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the longest string size for a string entry across data .<CODESPLIT>def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Linear oldstyle interpolation of the transform matrix .<CODESPLIT>def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list where the duplicates have been removed .<CODESPLIT>def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an integer list into a string list .<CODESPLIT>def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ctypes int pointer array to a numpy array .<CODESPLIT>def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as lazy_binmap except the parameters are flipped for the binary function<CODESPLIT>def lazy_reverse_binmap ( f , xs ) : return ( f ( y , x ) for x , y in zip ( xs , xs [ 1 : ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>this day last year<CODESPLIT>def today ( year = None ) : return datetime . date ( int ( year ) , _date . month , _date . day ) if year else _date
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split text into list of sentences .<CODESPLIT>def split_into_sentences ( s ) : s = re . sub ( r"\s+" , " " , s ) s = re . sub ( r"[\\.\\?\\!]" , "\n" , s ) return s . split ( "\n" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requests - mock requests . post wrapper .<CODESPLIT>def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set text direction left to right .<CODESPLIT>def set_left_to_right ( self ) : self . displaymode |= LCD_ENTRYLEFT self . write8 ( LCD_ENTRYMODESET | self . displaymode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A static value ( does not change at runtime ) which is known at compile time<CODESPLIT>def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a graph and save it into a file<CODESPLIT>def draw ( graph , fname ) : ag = networkx . nx_agraph . to_agraph ( graph ) ag . draw ( fname , prog = 'dot' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Autoconnect slot activated when tbSourceDir is clicked .<CODESPLIT>def on_source_directory_chooser_clicked ( self ) : title = self . tr ( 'Set the source directory for script and scenario' ) self . choose_directory ( self . source_directory , title )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert json string representation into class instance .<CODESPLIT>def from_json_str ( cls , json_str ) : return cls . from_json ( json . loads ( json_str , cls = JsonDecoder ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .<CODESPLIT>def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( "to_dataframe requires the optional dependency Pandas." ) return pd . DataFrame . from_dict ( products , orient = 'index' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interpolate the given slice of the larger array .<CODESPLIT>def interpolate_slice ( slice_rows , slice_cols , interpolator ) : fine_rows = np . arange ( slice_rows . start , slice_rows . stop , slice_rows . step ) fine_cols = np . arange ( slice_cols . start , slice_cols . stop , slice_cols . step ) return interpolator ( fine_cols , fine_rows )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flushes the prompt before requesting the input<CODESPLIT>def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return string with compressed whitespace .<CODESPLIT>def clean_whitespace ( string , compact = False ) : for a , b in ( ( '\r\n' , '\n' ) , ( '\r' , '\n' ) , ( '\n\n' , '\n' ) , ( '\t' , ' ' ) , ( '  ' , ' ' ) ) : string = string . replace ( a , b ) if compact : for a , b in ( ( '\n' , ' ' ) , ( '[ ' , '[' ) , ( '  ' , ' ' ) , ( '  ' , ' ' ) , ( '  ' , ' ' ) ) : string = string . replace ( a , b ) return string . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sum reduction op .<CODESPLIT>def Sum ( a , axis , keep_dims ) : return np . sum ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>world coords to view coords ; v an eu . Vector2 returns ( float float )<CODESPLIT>def world_to_view ( v ) : return v . x * config . scale_x , v . y * config . scale_y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a C array using the given string .<CODESPLIT>def bytes_to_c_array ( data ) : chars = [ "'{}'" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a shallow copy .<CODESPLIT>def copy ( self ) : return self . __class__ ( self . operations . copy ( ) , self . collection , self . document )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the embeddings for a given JPEG image .<CODESPLIT>def calculate_embedding ( self , batch_image_bytes ) : return self . tf_session . run ( self . embedding , feed_dict = { self . input_jpeg : batch_image_bytes } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make bars in horizontal bar chart thinner<CODESPLIT>def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .<CODESPLIT>def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flat nested list of lists into a single list .<CODESPLIT>def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if this node has no children or if all of its children are ParseNode instances and are empty .<CODESPLIT>def is_empty ( self ) : return all ( isinstance ( c , ParseNode ) and c . is_empty for c in self . children )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if a file is located within the given directory .<CODESPLIT>def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forward mouse cursor position events to the example<CODESPLIT>def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extracts a function s indentation as a string In contrast to an inspect . indentsize based implementation this function preserves tabs if present .<CODESPLIT>def get_indentation ( func ) : src_lines = getsourcelines ( func ) [ 0 ] for line in src_lines : if not ( line . startswith ( '@' ) or line . startswith ( 'def' ) or line . lstrip ( ) . startswith ( '#' ) ) : return line [ : len ( line ) - len ( line . lstrip ( ) ) ] return pytypes . default_indent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quits the application ( called when the last window is closed )<CODESPLIT>def quit ( self ) : logger . debug ( "ArgosApplication.quit called" ) assert len ( self . mainWindows ) == 0 , "Bug: still {} windows present at application quit!" . format ( len ( self . mainWindows ) ) self . qApplication . quit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return only the part of the row which should be printed .<CODESPLIT>def _get_printable_columns ( columns , row ) : if not columns : return row # Extract the column values, in the order specified. return tuple ( row [ c ] for c in columns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send a close message to the external process and join it .<CODESPLIT>def close ( self ) : try : self . _conn . send ( ( self . _CLOSE , None ) ) self . _conn . close ( ) except IOError : # The connection was already closed. pass self . _process . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the input filename with path is a file and is not empty .<CODESPLIT>def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a normal old python function to return the Nth fibonacci number .<CODESPLIT>def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to get return code of a url<CODESPLIT>def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for iterating only nonempty lines without line breaks<CODESPLIT>def iter_lines ( file_like : Iterable [ str ] ) -> Generator [ str , None , None ] : for line in file_like : line = line . rstrip ( '\r\n' ) if line : yield line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get domain part of an url .<CODESPLIT>def get_domain ( url ) : parse_result = urlparse ( url ) domain = "{schema}://{netloc}" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an numpy . string_ to str .<CODESPLIT>def np2str ( value ) : if hasattr ( value , 'dtype' ) and issubclass ( value . dtype . type , ( np . string_ , np . object_ ) ) and value . size == 1 : value = np . asscalar ( value ) if not isinstance ( value , str ) : # python 3 - was scalar numpy array of bytes # otherwise python 2 - scalar numpy array of 'str' value = value . decode ( ) return value else : raise ValueError ( "Array is not a string type or is larger than 1" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert file extension to lowercase .<CODESPLIT>def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current mouse location ( coordinates and screen number ) .<CODESPLIT>def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the item is a placeholder or contains a placeholder .<CODESPLIT>def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crops and / or pads an image to a target width and height .<CODESPLIT>def resize_image_with_crop_or_pad ( img , target_height , target_width ) : h , w = target_height , target_width max_h , max_w , c = img . shape # crop img = crop_center ( img , min ( max_h , h ) , min ( max_w , w ) ) # pad padded_img = np . zeros ( shape = ( h , w , c ) , dtype = img . dtype ) padded_img [ : img . shape [ 0 ] , : img . shape [ 1 ] , : img . shape [ 2 ] ] = img return padded_img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans up a test logger object by removing all of its handlers .<CODESPLIT>def kill_test_logger ( logger ) : for h in list ( logger . handlers ) : logger . removeHandler ( h ) if isinstance ( h , logging . FileHandler ) : h . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>write a cache object to the fileobj as a lal cache file<CODESPLIT>def tofile ( self , fileobj ) : for entry in self : print >> fileobj , str ( entry ) fileobj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a camelcase string to a list .<CODESPLIT>def camelcase2list ( s , lower = False ) : s = re . findall ( r'([A-Z][a-z0-9]+)' , s ) return [ w . lower ( ) for w in s ] if lower else s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>As a convenience turn Python lists and tuples into NumPy arrays .<CODESPLIT>def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return maximum nesting depth<CODESPLIT>def maxlevel ( lst ) : maxlev = 0 def f ( lst , level ) : nonlocal maxlev if isinstance ( lst , list ) : level += 1 maxlev = max ( level , maxlev ) for item in lst : f ( item , level ) f ( lst , 0 ) return maxlev
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a string and dictionary . replaces all occurrences of i with j<CODESPLIT>def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Additional check for the dimension model to ensure that attributes given as the key and label attribute on the dimension exist .<CODESPLIT>def check_attribute_exists ( instance ) : attributes = instance . get ( 'attributes' , { } ) . keys ( ) if instance . get ( 'key_attribute' ) not in attributes : return False label_attr = instance . get ( 'label_attribute' ) if label_attr and label_attr not in attributes : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete an image .<CODESPLIT>def cli ( env , identifier ) : image_mgr = SoftLayer . ImageManager ( env . client ) image_id = helpers . resolve_id ( image_mgr . resolve_ids , identifier , 'image' ) image_mgr . delete_image ( image_id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses hostname from URL . : param url : URL : return : hostname<CODESPLIT>def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return list of Logger classes .<CODESPLIT>def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save pickled model to file .<CODESPLIT>def save ( self , f ) : return pickle . dump ( ( self . perceptron . weights , self . tagdict , self . classes , self . clusters ) , f , protocol = pickle . HIGHEST_PROTOCOL )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implements the context manager protocol . Specially useful for asserting exceptions<CODESPLIT>def __enter__ ( self ) : clone = self . clone ( ) self . _contexts . append ( clone ) self . reset ( ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return geohash for given point with self . precision : param point : GeoPoint instance : return : string<CODESPLIT>def get_point_hash ( self , point ) : return geohash . encode ( point . latitude , point . longitude , self . precision )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A basic check of if the program is running in interactive mode<CODESPLIT>def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\r' try : import threading except ImportError : return False else : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates a count of the number of times each unique item appears in a list<CODESPLIT>def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value of the checkbox .<CODESPLIT>def set_value ( self , value ) : if value : self . setChecked ( Qt . Checked ) else : self . setChecked ( Qt . Unchecked )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether this RangeSet contains another set .<CODESPLIT>def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invokes callback for KEY_DOWN event related to the given key . For details see hook .<CODESPLIT>def on_press_key ( key , callback , suppress = False ) : return hook_key ( key , lambda e : e . event_type == KEY_UP or callback ( e ) , suppress = suppress )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .<CODESPLIT>def restart ( self , reset = False ) : # Get start path to use in restart script  spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started  # Note: Variables defined in bootstrap.py and spyder/app/start.py  env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder  pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py  if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess  env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS  if os . name == 'nt' : # Hide flashing command prompt  startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '"{0}" "{1}"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and  # the error can be inspected in the internal console  print ( error ) # spyder: test-skip  print ( command )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Natural logarithm<CODESPLIT>def log ( x ) : if isinstance ( x , UncertainFunction ) : mcpts = np . log ( x . _mcpts ) return UncertainFunction ( mcpts ) else : return np . log ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>unload the previously loaded shared library<CODESPLIT>def cleanup_lib ( self ) : if not self . using_openmp : #this if statement is necessary because shared libraries that use #OpenMP will core dump when unloaded, this is a well-known issue with OpenMP logging . debug ( 'unloading shared library' ) _ctypes . dlclose ( self . lib . _handle )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If Python 2 replace non - ascii characters and return encoded string .<CODESPLIT>def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\u2019' , "'" ) return uni . encode ( 'utf-8' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert comma - delimited list / string into a list of strings<CODESPLIT>def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to camel_case<CODESPLIT>def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause the music<CODESPLIT>def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove Elasticsearch index associated to the campaign<CODESPLIT>def remove_index ( self ) : self . index_client . close ( self . index_name ) self . index_client . delete ( self . index_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a datetime object to a multiple of a timedelta dt : datetime . datetime object default now .<CODESPLIT>def __round_time ( self , dt ) : round_to = self . _resolution . total_seconds ( ) seconds = ( dt - dt . min ) . seconds rounding = ( seconds + round_to / 2 ) // round_to * round_to return dt + timedelta ( 0 , rounding - seconds , - dt . microsecond )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the default bucket from a list of buckets i . e . the largest bucket .<CODESPLIT>def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all build components ; the package cache package builds bootstrap builds and distributions .<CODESPLIT>def clean_all ( self , args ) : self . clean_dists ( args ) self . clean_builds ( args ) self . clean_download_cache ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this a string .<CODESPLIT>def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This callback is invoked when the user checks the Use Scrollbars box in the preferences pane .<CODESPLIT>def set_scrollbars_cb ( self , w , tf ) : scrollbars = 'on' if tf else 'off' self . t_ . set ( scrollbars = scrollbars )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks to see if a 2D list is a valid 2D matrix<CODESPLIT>def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove arduino / examples / all directory .<CODESPLIT>def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract from the given iterable of lines the list of words .<CODESPLIT>def extract_words ( lines ) : for line in lines : for word in re . findall ( r"\w+" , line ) : yield word
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerces JSON string to boolean<CODESPLIT>def from_json ( value , * * kwargs ) : if isinstance ( value , string_types ) : value = value . upper ( ) if value in ( 'TRUE' , 'Y' , 'YES' , 'ON' ) : return True if value in ( 'FALSE' , 'N' , 'NO' , 'OFF' ) : return False if isinstance ( value , int ) : return value raise ValueError ( 'Could not load boolean from JSON: {}' . format ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manually specify the x - axis tick values .<CODESPLIT>def set_xticks_for_all ( self , row_column_list = None , ticks = None ) : if row_column_list is None : self . ticks [ 'x' ] = ticks else : for row , column in row_column_list : self . set_xticks ( row , column , ticks )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove ( and un - index ) an object<CODESPLIT>def remove_item ( self , item ) : self . unindex_item ( item ) self . items . pop ( item . uuid , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compile and return a Module s code object .<CODESPLIT>def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Monkey - patch urllib3 with SecureTransport - backed SSL - support .<CODESPLIT>def inject_into_urllib3 ( ) : util . ssl_ . SSLContext = SecureTransportContext util . HAS_SNI = HAS_SNI util . ssl_ . HAS_SNI = HAS_SNI util . IS_SECURETRANSPORT = True util . ssl_ . IS_SECURETRANSPORT = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read_byte_data ( addr cmd ) - > result<CODESPLIT>def read_byte_data ( self , addr , cmd ) : self . _set_addr ( addr ) res = SMBUS . i2c_smbus_read_byte_data ( self . _fd , ffi . cast ( "__u8" , cmd ) ) if res == - 1 : raise IOError ( ffi . errno ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the distance between two points coord1 and coord2 . These parameters are assumed to be ( x y ) tuples .<CODESPLIT>def _distance ( coord1 , coord2 ) : xdist = coord1 [ 0 ] - coord2 [ 0 ] ydist = coord1 [ 1 ] - coord2 [ 1 ] return sqrt ( xdist * xdist + ydist * ydist )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load a model from an installed package .<CODESPLIT>def load_model_from_package ( name , * * overrides ) : cls = importlib . import_module ( name ) return cls . load ( * * overrides )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as : meth : random . choice but also supports : class : set type to be passed as sequence .<CODESPLIT>def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is iterable and contains only integral types<CODESPLIT>def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Builds instance from dictionary of properties .<CODESPLIT>def fromDict ( cls , _dict ) : obj = cls ( ) obj . __dict__ . update ( _dict ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scan through string looking for a location where this word produces a match and return a corresponding MatchObject instance . Return None if no position in the string matches the pattern ; note that this is different from finding a zero - length match at some point in the string .<CODESPLIT>def find_whole_word ( w ) : return re . compile ( r'\b({0})\b' . format ( w ) , flags = re . IGNORECASE ) . search
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>These actions will be done after SIGTERM .<CODESPLIT>def sigterm ( self , signum , frame ) : self . logger . warning ( "Caught signal %s. Stopping daemon." % signum ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert record array to a dictionaries<CODESPLIT>def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean up processes after SIGTERM or SIGINT is received .<CODESPLIT>def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initial state of the network<CODESPLIT>def zero_state ( self , batch_size ) : return torch . zeros ( batch_size , self . state_dim , dtype = torch . float32 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1<CODESPLIT>def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a sentence into list of words .<CODESPLIT>def split_into_words ( s ) : s = re . sub ( r"\W+" , " " , s ) s = re . sub ( r"[_0-9]+" , " " , s ) return s . split ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform column - stacking on a list of 2d data blocks .<CODESPLIT>def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Translate a string with the current locale .<CODESPLIT>def gettext ( self , string , domain = None , * * variables ) : t = self . get_translations ( domain ) return t . ugettext ( string ) % variables
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return default argument value as given by argparse s add_argument () .<CODESPLIT>def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>load an nparray object from a json filename<CODESPLIT>def from_file ( filename ) : f = open ( filename , 'r' ) j = json . load ( f ) f . close ( ) return from_dict ( j )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the write permissions for the given file for owner groups and others .<CODESPLIT>def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for pulling a keyed value off various types of objects<CODESPLIT>def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield all items from iterable except the last one .<CODESPLIT>def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .<CODESPLIT>def seq_to_str ( obj , sep = "," ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return total data length of the list and its headers .<CODESPLIT>def __len__ ( self ) : return self . chunk_length ( ) + len ( self . type ) + len ( self . header ) + 4
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shorcut for self . run .<CODESPLIT>def __call__ ( self , func , * args , * * kwargs ) : return self . run ( func , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if cnr or cns files are empty ( only have a header )<CODESPLIT>def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a boolean index with True if the value is masked .<CODESPLIT>def maskIndex ( self ) : if isinstance ( self . mask , bool ) : return np . full ( self . data . shape , self . mask , dtype = np . bool ) else : return self . mask
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .<CODESPLIT>def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins two dictionaries .<CODESPLIT>def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes text to a file .<CODESPLIT>def write_text ( filename : str , text : str ) -> None : with open ( filename , 'w' ) as f : # type: TextIO print ( text , file = f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs sphinx - apidoc to auto - generate documentation .<CODESPLIT>def RunSphinxAPIDoc ( _ ) : current_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) module = os . path . join ( current_directory , '..' , 'plaso' ) api_directory = os . path . join ( current_directory , 'sources' , 'api' ) apidoc . main ( [ '-o' , api_directory , module , '--force' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the percentile of a list of values .<CODESPLIT>def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .<CODESPLIT>def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return "\n" . join ( centered )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like dict but does not hold any null values .<CODESPLIT>def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the user is rooted .<CODESPLIT>def _is_root ( ) : import os import ctypes try : return os . geteuid ( ) == 0 except AttributeError : return ctypes . windll . shell32 . IsUserAnAdmin ( ) != 0 return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset analyzer state<CODESPLIT>def reset ( self ) : self . prevframe = None self . wasmoving = False self . t0 = 0 self . ismoving = False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the year .<CODESPLIT>def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Populate the ranks key .<CODESPLIT>def ranks ( self , key , value ) : return [ normalize_rank ( el ) for el in force_list ( value . get ( 'a' ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for fast reading from sensor files .<CODESPLIT>def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .<CODESPLIT>def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check features data are not empty<CODESPLIT>def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the RMS of the audio<CODESPLIT>def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns path to packaged static files<CODESPLIT>def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Error handler<CODESPLIT>def on_error ( e ) : # pragma: no cover exname = { 'RuntimeError' : 'Runtime error' , 'Value Error' : 'Value error' } sys . stderr . write ( '{}: {}\n' . format ( exname [ e . __class__ . __name__ ] , str ( e ) ) ) sys . stderr . write ( 'See file slam_error.log for additional details.\n' ) sys . exit ( 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>unload the previously loaded shared library<CODESPLIT>def cleanup_lib ( self ) : if not self . using_openmp : #this if statement is necessary because shared libraries that use #OpenMP will core dump when unloaded, this is a well-known issue with OpenMP logging . debug ( 'unloading shared library' ) _ctypes . dlclose ( self . lib . _handle )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the given multiquery .<CODESPLIT>async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a dict to a JSON file .<CODESPLIT>def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dotproduct between self and another vector .<CODESPLIT>def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given HTML markup return a list of hrefs for each anchor tag .<CODESPLIT>def get_anchor_href ( markup ) : soup = BeautifulSoup ( markup , 'lxml' ) return [ '%s' % link . get ( 'href' ) for link in soup . find_all ( 'a' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string * s * into list of strings no longer than * length *<CODESPLIT>def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .<CODESPLIT>async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increment a frame of the animation .<CODESPLIT>def increment_frame ( self ) : self . current_frame += 1 if self . current_frame >= self . end_frame : # Wrap back to the beginning of the animation. self . current_frame = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A sys . stdout that accepts bytes .<CODESPLIT>def binary_stdout ( ) : # First there is a Python3 issue. try : stdout = sys . stdout . buffer except AttributeError : # Probably Python 2, where bytes are strings. stdout = sys . stdout # On Windows the C runtime file orientation needs changing. if sys . platform == "win32" : import msvcrt import os msvcrt . setmode ( sys . stdout . fileno ( ) , os . O_BINARY ) return stdout
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print the header for the CSV table .<CODESPLIT>def printheader ( h = None ) : writer = csv . writer ( sys . stdout ) writer . writerow ( header_fields ( h ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Step over the next statement<CODESPLIT>def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the received object as precise as possible .<CODESPLIT>def _repr ( obj ) : vals = ", " . join ( "{}={!r}" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = "{}(name={}, {})" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = "{}(name={})" . format ( obj . __class__ . __name__ , obj . name ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show image ( item is a PIL image )<CODESPLIT>def show_image ( self , key ) : data = self . model . get_data ( ) data [ key ] . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read text from stdin and print a helpful message for ttys .<CODESPLIT>def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve contents of each page of PDF<CODESPLIT>def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .<CODESPLIT>def generate_unique_host_id ( ) : host = "." . join ( reversed ( socket . gethostname ( ) . split ( "." ) ) ) pid = os . getpid ( ) return "%s.%d" % ( host , pid )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves an animation<CODESPLIT>def save ( self , * args , * * kwargs ) : self . timeline . index -= 1 # required for proper starting point for save self . animation . save ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects<CODESPLIT>def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : xml_str : str DataONE API XML doc .<CODESPLIT>def str_is_well_formed ( xml_str ) : try : str_to_etree ( xml_str ) except xml . etree . ElementTree . ParseError : return False else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple measure of similarity : Number of letters in common / max length<CODESPLIT>def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the index of an element in the list .<CODESPLIT>def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find and kill child processes of a process .<CODESPLIT>def kill_process_children ( pid ) : if sys . platform == "darwin" : kill_process_children_osx ( pid ) elif sys . platform == "linux" : kill_process_children_unix ( pid ) else : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a lowercased string with non alphabetic chars removed .<CODESPLIT>def _to_lower_alpha_only ( s ) : s = re . sub ( r'\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\s]' , '' , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the Jaccard similarity coefficient of 2 given sets .<CODESPLIT>def compute_jaccard_index ( x_set , y_set ) : if not x_set or not y_set : return 0.0 intersection_cardinal = len ( x_set & y_set ) union_cardinal = len ( x_set | y_set ) return intersection_cardinal / float ( union_cardinal )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a property of the device .<CODESPLIT>def getprop ( self , prop_name ) : return self . shell ( [ 'getprop' , prop_name ] , timeout = DEFAULT_GETPROP_TIMEOUT_SEC ) . decode ( 'utf-8' ) . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique items from iterable * seq * ( in order ) .<CODESPLIT>def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: rtype : numpy matrix<CODESPLIT>def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\t' , skiprows = 9 ) return data . as_matrix ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books )<CODESPLIT>def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ "_shards" ] [ "failed" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the name of an object including the module name if available .<CODESPLIT>def class_name ( obj ) : name = obj . __name__ module = getattr ( obj , '__module__' ) if module : name = f'{module}.{name}' return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the given multiquery .<CODESPLIT>async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the digest of a single file in a memory - efficient manner .<CODESPLIT>def update_hash ( cls , filelike , digest ) : block_size = digest . block_size * 1024 for chunk in iter ( lambda : filelike . read ( block_size ) , b'' ) : digest . update ( chunk )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get line count of file<CODESPLIT>def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert Matrix attributes which are array - like or buffer to array .<CODESPLIT>def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper parse action to convert tokens to upper case .<CODESPLIT>def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Translate dicts to scala Maps<CODESPLIT>def translate_dict ( cls , val ) : escaped = ', ' . join ( [ "{} -> {}" . format ( cls . translate_str ( k ) , cls . translate ( v ) ) for k , v in val . items ( ) ] ) return 'Map({})' . format ( escaped )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets all defaults for the given dictionary to those contained in a second defaults dictionary . This convenience method calls :<CODESPLIT>def setDictDefaults ( d , defaults ) : for key , val in defaults . items ( ) : d . setdefault ( key , val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last n items in readline history .<CODESPLIT>def get_readline_tail ( self , n = 10 ) : end = self . shell . readline . get_current_history_length ( ) + 1 start = max ( end - n , 1 ) ghi = self . shell . readline . get_history_item return [ ghi ( x ) for x in range ( start , end ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stringifies a Python object into its YAML representation .<CODESPLIT>def Dump ( obj ) : text = yaml . safe_dump ( obj , default_flow_style = False , allow_unicode = True ) if compatibility . PY2 : text = text . decode ( "utf-8" ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hex encode a binary string<CODESPLIT>def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first value of a series .<CODESPLIT>def first ( series , order_by = None ) : if order_by is not None : series = order_series_by ( series , order_by ) first_s = series . iloc [ 0 ] return first_s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter for dict note f should have signature : f :: key - > value - > bool<CODESPLIT>def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves dictionary as CSV file .<CODESPLIT>def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cached search compile .<CODESPLIT>def _cached_search_compile ( pattern , re_verbose , re_version , pattern_type ) : return _bregex_parse . _SearchParser ( pattern , re_verbose , re_version ) . parse ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a multiline string into a list excluding blank lines .<CODESPLIT>def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\n' ) ) if element ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears globals and reloads modules<CODESPLIT>def clear_globals_reload_modules ( self ) : self . code_array . clear_globals ( ) self . code_array . reload_modules ( ) # Clear result cache self . code_array . result_cache . clear ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send files using the config . ini settings .<CODESPLIT>async def send_files_preconf ( filepaths , config_path = CONFIG_PATH ) : config = read_config ( config_path ) subject = "PDF files from pdfebc" message = "" await send_with_attachments ( subject , message , filepaths , config )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove multiple elements from a list and return result . This implementation is faster than the alternative below . Also note the creation of a new list to avoid altering the original . We don t have any current use for the original intact list but may in the future ...<CODESPLIT>def remove_elements ( target , indices ) : copied = list ( target ) for index in reversed ( indices ) : del copied [ index ] return copied
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conver a path string to a list of path elements .<CODESPLIT>def path_to_list ( pathstr ) : return [ elem for elem in pathstr . split ( os . path . pathsep ) if elem ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a StrictRedis connection instance .<CODESPLIT>def get_connection ( self , host , port , db ) : return redis . StrictRedis ( host = host , port = port , db = db , decode_responses = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try popping a key from a dict . Instead of raising KeyError just return the default value .<CODESPLIT>def dict_pop_or ( d , key , default = None ) : val = default with suppress ( KeyError ) : val = d . pop ( key ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Synthesize white noise<CODESPLIT>def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>it returns a 500 http response<CODESPLIT>def view_500 ( request , url = None ) : res = render_to_response ( "500.html" , context_instance = RequestContext ( request ) ) res . status_code = 500 return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a docstring for the composition of fs .<CODESPLIT>def _composed_doc ( fs ) : if not fs : # Argument name for the docstring. return 'n' return '{f}({g})' . format ( f = fs [ 0 ] . __name__ , g = _composed_doc ( fs [ 1 : ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove decoded instruction from instruction cache<CODESPLIT>def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to camel case .<CODESPLIT>def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + "" . join ( x . title ( ) for x in split [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I strip extra whitespace off multi - line strings if they are ready to be stripped!<CODESPLIT>def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a dict of 1d array to a numpy recarray<CODESPLIT>def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get max for queryset .<CODESPLIT>def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random color between min and max .<CODESPLIT>def random_color ( _min = MIN_COLOR , _max = MAX_COLOR ) : return color ( random . randint ( _min , _max ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle fullscreen from outside the GUI causes the GUI to updated and run all its actions .<CODESPLIT>def trigger_fullscreen_action ( self , fullscreen ) : action = self . action_group . get_action ( 'fullscreen' ) action . set_active ( fullscreen )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the folder exisits . If not create the folder<CODESPLIT>def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ability to provide dynamic styling of the cell based on its value . : param cbfct : function ( cell_value ) should return a dict of format commands to apply to that cell : return : self<CODESPLIT>def apply_conditional_styles ( self , cbfct ) : for ridx in range ( self . nrows ) : for cidx in range ( self . ncols ) : fmts = cbfct ( self . actual_values . iloc [ ridx , cidx ] ) fmts and self . iloc [ ridx , cidx ] . apply_styles ( fmts ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>* A datetime stamp in MySQL format : YYYY - MM - DDTHH : MM : SS *<CODESPLIT>def get_now_sql_datetime ( ) : ## > IMPORTS ## from datetime import datetime , date , time now = datetime . now ( ) now = now . strftime ( "%Y-%m-%dT%H:%M:%S" ) return now
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause for this many seconds<CODESPLIT>def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Paste before cursor .<CODESPLIT>def yank ( event ) : event . current_buffer . paste_clipboard_data ( event . cli . clipboard . get_data ( ) , count = event . arg , paste_mode = PasteMode . EMACS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redirect standard out to file .<CODESPLIT>def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the dictionary in json format : param fname : file to save to<CODESPLIT>def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Go to the end of the current line and create a new line<CODESPLIT>def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7<CODESPLIT>def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the parent directory of a filename .<CODESPLIT>def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the text for the given root node ( xml . dom . minidom ) .<CODESPLIT>def __get_xml_text ( root ) : txt = "" for e in root . childNodes : if ( e . nodeType == e . TEXT_NODE ) : txt += e . data return txt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove dangerous URL schemes like javascript : and escape afterwards .<CODESPLIT>def escape_link ( url ) : lower_url = url . lower ( ) . strip ( '\x00\x1a \n\r\t' ) for scheme in _scheme_blacklist : if lower_url . startswith ( scheme ) : return '' return escape ( url , quote = True , smart_amp = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Memory usage of my values<CODESPLIT>def memory_usage ( self , deep = False ) : return self . _codes . nbytes + self . dtype . categories . memory_usage ( deep = deep )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into a list of tokens .<CODESPLIT>def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \t' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .<CODESPLIT>def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return set of common words between two word sets .<CODESPLIT>def has_common ( self , other ) : if not isinstance ( other , WordSet ) : raise ValueError ( 'Can compare only WordSets' ) return self . term_set & other . term_set
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterate through lines of file .<CODESPLIT>def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scale the image in a channel . Also see : meth : zoom_to .<CODESPLIT>def set_scale ( self , scale , no_reset = False ) : return self . scale_to ( * scale [ : 2 ] , no_reset = no_reset )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper to clean up an input string<CODESPLIT>def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a SndRcv list filtered by a truth function<CODESPLIT>def filter ( self , func ) : return self . __class__ ( [ i for i in self . res if func ( * i ) ] , name = 'filtered %s' % self . listname )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prepare the api specification for request and response validation .<CODESPLIT>def load_schema ( schema_path ) : with open ( schema_path , 'r' ) as schema_file : schema = simplejson . load ( schema_file ) resolver = RefResolver ( '' , '' , schema . get ( 'models' , { } ) ) return build_request_to_validator_map ( schema , resolver )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerce value to an JSON - compatible representation .<CODESPLIT>def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( "ascii" ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a normal old python function to return the Nth fibonacci number .<CODESPLIT>def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerce value to an JSON - compatible representation .<CODESPLIT>def _date_to_json ( value ) : if isinstance ( value , datetime . date ) : value = value . isoformat ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The standard deviation of a set of values . Pass in the mean if you already know it .<CODESPLIT>def stddev ( values , meanval = None ) : #from AI: A Modern Appproach if meanval == None : meanval = mean ( values ) return math . sqrt ( sum ( [ ( x - meanval ) ** 2 for x in values ] ) / ( len ( values ) - 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace all the ocurrences ( in a file ) of a string with another value .<CODESPLIT>def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip a single frame from the trajectory<CODESPLIT>def _skip_frame ( self ) : size = self . read_size ( ) for i in range ( size + 1 ) : line = self . _f . readline ( ) if len ( line ) == 0 : raise StopIteration
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get list of all uppercase non - private globals ( doesn t start with _ ) .<CODESPLIT>def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( "_" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull comma separated string values out of a text file and converts them to float list<CODESPLIT>def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the item is a placeholder or contains a placeholder .<CODESPLIT>def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of tuples specifying the column name and type<CODESPLIT>def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( "PRAGMA table_info('%s');" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Searches for the specified method and returns its descriptor .<CODESPLIT>def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all whitespace from the end of the line .<CODESPLIT>def _delete_whitespace ( self ) : while isinstance ( self . _lines [ - 1 ] , ( self . _Space , self . _LineBreak , self . _Indent ) ) : del self . _lines [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the least recently used file handle from the cache . The pop method removes an element from the right of the deque . Returns the name of the file that has been removed .<CODESPLIT>def _removeLru ( self ) : ( dataFile , handle ) = self . _cache . pop ( ) handle . close ( ) return dataFile
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty output of nested dictionaries .<CODESPLIT>def pretty_dict_string ( d , indent = 0 ) : s = '' for key , value in sorted ( d . items ( ) ) : s += '    ' * indent + str ( key ) if isinstance ( value , dict ) : s += '\n' + pretty_dict_string ( value , indent + 1 ) else : s += '=' + str ( value ) + '\n' return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ends an indentation block leaving an empty line afterwards<CODESPLIT>def end_block ( self ) : self . current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self . auto_added_line : self . writeln ( ) self . auto_added_line = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Advances to next line .<CODESPLIT>def advance_one_line ( self ) : current_line = self . _current_token . line_number while current_line == self . _current_token . line_number : self . _current_token = ConfigParser . Token ( * next ( self . _token_generator ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print just one that returns what you give it instead of None<CODESPLIT>def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from a list preserving the order .<CODESPLIT>def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get element by name<CODESPLIT>def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts string presented in camel case to snake case .<CODESPLIT>def camel_to_snake_case ( string ) : s = _1 . sub ( r'\1_\2' , string ) return _2 . sub ( r'\1_\2' , s ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets main window icon to given wx . Bitmap<CODESPLIT>def set_icon ( self , bmp ) : _icon = wx . EmptyIcon ( ) _icon . CopyFromBitmap ( bmp ) self . SetIcon ( _icon )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )<CODESPLIT>def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the host s ip number .<CODESPLIT>def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( "8.8.8.8" , 80 ) ) except socket . gaierror : ip_ = "127.0.0.1" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the last item of a sequence .<CODESPLIT>def do_last ( environment , seq ) : try : return next ( iter ( reversed ( seq ) ) ) except StopIteration : return environment . undefined ( 'No last item, sequence was empty.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>average of the values must have more than 0 entries .<CODESPLIT>def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( "ERROR: no content in array to take average\n" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .<CODESPLIT>def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Close last created figure alias to plt . close () .<CODESPLIT>def close ( * args , * * kwargs ) : _ , plt , _ = _import_plt ( ) plt . close ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a timezone - aware datetime object from a datetime string .<CODESPLIT>def parse_datetime ( dt_str , format ) : t = time . strptime ( dt_str , format ) return datetime ( t [ 0 ] , t [ 1 ] , t [ 2 ] , t [ 3 ] , t [ 4 ] , t [ 5 ] , t [ 6 ] , pytz . UTC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For a given value the function finds the nearest value in the array and returns its index .<CODESPLIT>def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean up name so it works for a Python identifier .<CODESPLIT>def identifierify ( name ) : name = name . lower ( ) name = re . sub ( '[^a-z0-9]' , '_' , name ) return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the latest modification time of all files / subdirectories in a directory<CODESPLIT>def dir_modtime ( dpath ) : return max ( os . path . getmtime ( d ) for d , _ , _ in os . walk ( dpath ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compress a file returning the new filename ( . gz )<CODESPLIT>def __gzip ( filename ) : zipname = filename + '.gz' file_pointer = open ( filename , 'rb' ) zip_pointer = gzip . open ( zipname , 'wb' ) zip_pointer . writelines ( file_pointer ) file_pointer . close ( ) zip_pointer . close ( ) return zipname
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function merge another object s values with this instance<CODESPLIT>def merge ( self , obj ) : for attribute in dir ( obj ) : if '__' in attribute : continue setattr ( self , attribute , getattr ( obj , attribute ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raise the open file handles permitted by the Dusty daemon process and its child processes . The number we choose here needs to be within the OS X default kernel hard limit which is 10240 .<CODESPLIT>def _increase_file_handle_limit ( ) : logging . info ( 'Increasing file handle limit to {}' . format ( constants . FILE_HANDLE_LIMIT ) ) resource . setrlimit ( resource . RLIMIT_NOFILE , ( constants . FILE_HANDLE_LIMIT , resource . RLIM_INFINITY ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle conversion of pymongo cursor into a JSON object formatted for UI consumption<CODESPLIT>def _obj_cursor_to_dictionary ( self , cursor ) : if not cursor : return cursor cursor = json . loads ( json . dumps ( cursor , cls = BSONEncoder ) ) if cursor . get ( "_id" ) : cursor [ "id" ] = cursor . get ( "_id" ) del cursor [ "_id" ] return cursor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether stdin has any data to read .<CODESPLIT>def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a character delimited version of the provided list as a Python string<CODESPLIT>def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .<CODESPLIT>def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts markdown content to text<CODESPLIT>def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run security . py -- demonstrate the SECURITY extension<CODESPLIT>def test_security ( self ) : self . assertEqual ( run_example ( examples_folder + "security.py --generate" ) , 0 ) self . assertEqual ( run_example ( examples_folder + "security.py --revoke" ) , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove text nodes containing only whitespace<CODESPLIT>def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prepare a context for the serialization .<CODESPLIT>def _get_context ( argspec , kwargs ) : if argspec . keywords is not None : return kwargs return dict ( ( arg , kwargs [ arg ] ) for arg in argspec . args if arg in kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reshape data into ( num_example batch_size )<CODESPLIT>def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns type of the data for the given FeatureType .<CODESPLIT>def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert the entire image to bytes . : rtype : bytes<CODESPLIT>def to_bytes ( self ) : chunks = [ PNG_SIGN ] chunks . extend ( c [ 1 ] for c in self . chunks ) return b"" . join ( chunks )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( Point Point ) - > Point Return the point that lies in between the two input points .<CODESPLIT>def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function used to fit the exponential decay .<CODESPLIT>def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join list of columns into a string for a SQL query<CODESPLIT>def join_cols ( cols ) : return ", " . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the distance between two points .<CODESPLIT>def dist ( x1 , x2 , axis = 0 ) : return np . linalg . norm ( x2 - x1 , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a leading hash # at the beginning of every line in the source .<CODESPLIT>def _add_hash ( source ) : source = '\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provide the root module of a TF - 2 . 0 API for use within TensorBoard .<CODESPLIT>def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of coded value from a key . If several keys of the same name are present the total sum is returned .<CODESPLIT>def codes_get_size ( handle , key ) : # type: (cffi.FFI.CData, str) -> int size = ffi . new ( 'size_t *' ) _codes_get_size ( handle , key . encode ( ENC ) , size ) return size [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>View the quaternion array as an array of floats<CODESPLIT>def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check different items in matrix classes .<CODESPLIT>def class_check ( vector ) : for i in vector : if not isinstance ( i , type ( vector [ 0 ] ) ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether this is a complex floating point type .<CODESPLIT>def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scipy norm function<CODESPLIT>def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return string as a comment<CODESPLIT>def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return "# " + ( "%s# " % linesep ) . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns time in seconds as a string formatted HHHH : MM : SS .<CODESPLIT>def time_string ( seconds ) : s = int ( round ( seconds ) ) # round to nearest second h , s = divmod ( s , 3600 ) # get hours and remainder m , s = divmod ( s , 60 ) # split remainder into minutes and seconds return "%2i:%02i:%02i" % ( h , m , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reseed factory . fuzzy s random generator .<CODESPLIT>def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the attribute of namespace corresponding to value .<CODESPLIT>def _lookup_enum_in_ns ( namespace , value ) : for attribute in dir ( namespace ) : if getattr ( namespace , attribute ) == value : return attribute
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an ISO - 8601 formatted string from the provided datetime object<CODESPLIT>def isoformat ( dt ) : if not isinstance ( dt , datetime . datetime ) : raise TypeError ( "Must provide datetime.datetime object to isoformat" ) if dt . tzinfo is None : raise ValueError ( "naive datetime objects are not allowed beyond the library boundaries" ) return dt . isoformat ( ) . replace ( "+00:00" , "Z" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ajout d un message de log de type DEBUG<CODESPLIT>def debug ( self , text ) : self . logger . debug ( "{}{}" . format ( self . message_prefix , text ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if we already have an opened tab with the same name .<CODESPLIT>def _name_exists ( self , name ) : for i in range ( self . count ( ) ) : if self . tabText ( i ) == name : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A wrapper of os . makedirs () .<CODESPLIT>def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add suffix to a full file name<CODESPLIT>def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if value is an instance or subclass of the class Type .<CODESPLIT>def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all unwanted characters from text .<CODESPLIT>def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as unicode string .<CODESPLIT>def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the name of an EVREvent enum value<CODESPLIT>def getEventTypeNameFromEnum ( self , eType ) : fn = self . function_table . getEventTypeNameFromEnum result = fn ( eType ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List APIs in account .<CODESPLIT>def list_apis ( awsclient ) : client_api = awsclient . get_client ( 'apigateway' ) apis = client_api . get_rest_apis ( ) [ 'items' ] for api in apis : print ( json2table ( api ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a blank row with only an index value to self . df . This is done inplace .<CODESPLIT>def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to read JSON file as OrderedDict<CODESPLIT>def _read_json_file ( self , json_file ) : self . log . debug ( "Reading '%s' JSON file..." % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert ip v4 string to integer .<CODESPLIT>def _ipv4_text_to_int ( self , ip_text ) : if ip_text is None : return None assert isinstance ( ip_text , str ) return struct . unpack ( '!I' , addrconv . ipv4 . text_to_bin ( ip_text ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets up the python include paths to include src<CODESPLIT>def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , "src" ) ] + sys . path pass return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move the virtual cursor .<CODESPLIT>def move ( self , x , y ) : self . _cursor = self . _normalizePoint ( x , y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate image data using PIL<CODESPLIT>def get_img_data ( f , maxsize = ( 1200 , 850 ) , first = False ) : img = Image . open ( f ) img . thumbnail ( maxsize ) if first : # tkinter is inactive the first time bio = io . BytesIO ( ) img . save ( bio , format = "PNG" ) del img return bio . getvalue ( ) return ImageTk . PhotoImage ( img )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove ticks tick labels and frame from axis<CODESPLIT>def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns this programs current memory usage in bytes<CODESPLIT>def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip out namespace data from an ElementTree .<CODESPLIT>def strip_xml_namespace ( root ) : try : root . tag = root . tag . split ( '}' ) [ 1 ] except IndexError : pass for element in root . getchildren ( ) : strip_xml_namespace ( element )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructor .<CODESPLIT>def __init__ ( self , ba = None ) : self . bytearray = ba or ( bytearray ( b'\0' ) * self . SIZEOF )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns data as : class : numpy . recarray .<CODESPLIT>def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse an ISO format date ( YYYY - mm - dd ) .<CODESPLIT>def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes SQL ; returns the first value of the first row or None .<CODESPLIT>def fetchvalue ( self , sql : str , * args ) -> Optional [ Any ] : row = self . fetchone ( sql , * args ) if row is None : return None return row [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the confusion matrix .<CODESPLIT>def confusion_matrix ( links_true , links_pred , total = None ) : links_true = _get_multiindex ( links_true ) links_pred = _get_multiindex ( links_pred ) tp = true_positives ( links_true , links_pred ) fp = false_positives ( links_true , links_pred ) fn = false_negatives ( links_true , links_pred ) if total is None : tn = numpy . nan else : tn = true_negatives ( links_true , links_pred , total ) return numpy . array ( [ [ tp , fn ] , [ fp , tn ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG<CODESPLIT>def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forget all loaded coordinates .<CODESPLIT>def forget_coords ( self ) : self . w . ntotal . set_text ( '0' ) self . coords_dict . clear ( ) self . redo ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return string as a comment<CODESPLIT>def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return "# " + ( "%s# " % linesep ) . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if an http server runs on a given port .<CODESPLIT>def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the leftmost index of an element in a list using binary search .<CODESPLIT>def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this attribute present?<CODESPLIT>def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the given number in decimal format using a period and commas<CODESPLIT>def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrive first element in List .<CODESPLIT>def head ( self ) -> Any : lambda_list = self . _get_value ( ) return lambda_list ( lambda head , _ : head )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x is a 2D sparse matrix with it s first shape equal to 1 .<CODESPLIT>def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generator for reading from standard input in nonblocking mode .<CODESPLIT>def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parameters ---------- data_path : str<CODESPLIT>def read_raw ( data_path ) : with open ( data_path , 'rb' ) as f : data = pickle . load ( f ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>numeric denotes typed literals with datatypes xsd : integer xsd : decimal xsd : float and xsd : double .<CODESPLIT>def is_strict_numeric ( n : Node ) -> bool : return is_typed_literal ( n ) and cast ( Literal , n ) . datatype in [ XSD . integer , XSD . decimal , XSD . float , XSD . double ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a key from S3<CODESPLIT>def read_key ( self , key , bucket_name = None ) : obj = self . get_key ( key , bucket_name ) return obj . get ( ) [ 'Body' ] . read ( ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure a a file exists and if not make the relevant path<CODESPLIT>def ensure_dir ( f ) : d = os . path . dirname ( f ) if not os . path . exists ( d ) : os . makedirs ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if all the args are functions and / or subroutines<CODESPLIT>def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1 - farthest apart ( same number of words all diff ) . 0 - same<CODESPLIT>def levenshtein_distance_metric ( a , b ) : return ( levenshtein_distance ( a , b ) / ( 2.0 * max ( len ( a ) , len ( b ) , 1 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates Camera . aspect to match the viewport s aspect ratio .<CODESPLIT>def match_aspect_to_viewport ( self ) : viewport = self . viewport self . aspect = float ( viewport . width ) / viewport . height
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This removes newlines and multiple spaces from a string .<CODESPLIT>def normalize_value ( text ) : result = text . replace ( '\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeros in the list of integers and returns a new list of integers<CODESPLIT>def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds index of nearest value in array . Args : array : numpy array value : Returns : int http : // stackoverflow . com / questions / 2566412 / find - nearest - value - in - numpy - array<CODESPLIT>def index_nearest ( array , value ) : idx = ( np . abs ( array - value ) ) . argmin ( ) return idx
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>simple method to determine if a url is relative or absolute<CODESPLIT>def is_relative_url ( url ) : if url . startswith ( "#" ) : return None if url . find ( "://" ) > 0 or url . startswith ( "//" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert numbers to floats whether the decimal point is . or<CODESPLIT>def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator version of get_list_column<CODESPLIT>def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints DB data representation of the object .<CODESPLIT>def prnt ( self ) : print ( "= = = =\n\n%s object key: \033[32m%s\033[0m" % ( self . __class__ . __name__ , self . key ) ) pprnt ( self . _data or self . clean_value ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yields tokens from input string .<CODESPLIT>def get_tokens ( line : str ) -> Iterator [ str ] : for token in line . rstrip ( ) . split ( ) : if len ( token ) > 0 : yield token
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This method removes columns in data<CODESPLIT>def remove_columns ( self , data , columns ) : for column in columns : if column in data . columns : data = data . drop ( column , axis = 1 ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is called when a return trap is set here .<CODESPLIT>def user_return ( self , frame , return_value ) : pdb . Pdb . user_return ( self , frame , return_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Displayhook function for PIL Images rendered as PNG .<CODESPLIT>def display_pil_image ( im ) : from IPython . core import display b = BytesIO ( ) im . save ( b , format = 'png' ) data = b . getvalue ( ) ip_img = display . Image ( data = data , format = 'png' , embed = True ) return ip_img . _repr_png_ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses a date string formatted like YYYY - MM - DD .<CODESPLIT>def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply re . sub to bunch of ( pattern repl )<CODESPLIT>def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an enum from a name Args : enum_name ( str ) : name of the enum Returns : Enum<CODESPLIT>def get_enum_from_name ( self , enum_name ) : return next ( ( e for e in self . enums if e . name == enum_name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats Python code to conform to the PEP 8 style guide .<CODESPLIT>def rpc_fix_code ( self , source , directory ) : source = get_source ( source ) return fix_code ( source , directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip a single frame from the trajectory<CODESPLIT>def _skip_frame ( self ) : size = self . read_size ( ) for i in range ( size + 1 ) : line = self . _f . readline ( ) if len ( line ) == 0 : raise StopIteration
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim a PIL image and remove white space .<CODESPLIT>def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate size of all files in path .<CODESPLIT>def _calc_dir_size ( path ) : dir_size = 0 for ( root , dirs , files ) in os . walk ( path ) : for fn in files : full_fn = os . path . join ( root , fn ) dir_size += os . path . getsize ( full_fn ) return dir_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Touches the project to trigger refreshing its cauldron . json state .<CODESPLIT>def touch_project ( ) : r = Response ( ) project = cd . project . get_internal_project ( ) if project : project . refresh ( ) else : r . fail ( code = 'NO_PROJECT' , message = 'No open project to refresh' ) return r . update ( sync_time = sync_status . get ( 'time' , 0 ) ) . flask_serialize ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Region formed by taking border elements .<CODESPLIT>def border ( self ) : border_array = self . bitmap - self . inner . bitmap return Region ( border_array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Item assignment sets the return value and removes any side effect<CODESPLIT>def __setitem__ ( self , _ignored , return_value ) : self . mock . return_value = return_value self . mock . side_effect = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a camelcase string to a list .<CODESPLIT>def camelcase2list ( s , lower = False ) : s = re . findall ( r'([A-Z][a-z0-9]+)' , s ) return [ w . lower ( ) for w in s ] if lower else s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fit a Gaussian to the data<CODESPLIT>def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scale the image so that the smallest axis is of size targ .<CODESPLIT>def scale_min ( im , targ , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape ratio = targ / min ( r , c ) sz = ( scale_to ( c , ratio , targ ) , scale_to ( r , ratio , targ ) ) return cv2 . resize ( im , sz , interpolation = interpolation )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert this confusion matrix into a 2x2 plain list of values .<CODESPLIT>def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the integer index of * series * in this sequence .<CODESPLIT>def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns json contents as string<CODESPLIT>def open_json ( file_name ) : with open ( file_name , "r" ) as json_data : data = json . load ( json_data ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch the value of a binary key .<CODESPLIT>def _internal_kv_get ( key ) : worker = ray . worker . get_global_worker ( ) if worker . mode == ray . worker . LOCAL_MODE : return _local . get ( key ) return worker . redis_client . hget ( key , "value" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )<CODESPLIT>def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object<CODESPLIT>def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( "." ) dt = datetime . strptime ( dt , "%Y-%m-%dT%H:%M:%S" ) return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a blank row with only an index value to self . df . This is done inplace .<CODESPLIT>def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns number rounded to digits digits .<CODESPLIT>def round_to_x_digits ( number , digits ) : return round ( number * math . pow ( 10 , digits ) ) / math . pow ( 10 , digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator to run a function with timing info .<CODESPLIT>def timed ( log = sys . stderr , limit = 2.0 ) : return lambda func : timeit ( func , log , limit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JsonResponse . Make sure you have django installed first .<CODESPLIT>def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the given path relative to this file .<CODESPLIT>def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a grayscale image to BGR image .<CODESPLIT>def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split text into list of sentences .<CODESPLIT>def split_into_sentences ( s ) : s = re . sub ( r"\s+" , " " , s ) s = re . sub ( r"[\\.\\?\\!]" , "\n" , s ) return s . split ( "\n" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill all null values with NaN values in a column . Null values are None or en empty string<CODESPLIT>def fill_nulls ( self , col : str ) : n = [ None , "" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create the file with the given content<CODESPLIT>def write_file ( filename , content ) : print 'Generating {0}' . format ( filename ) with open ( filename , 'wb' ) as out_f : out_f . write ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if there is enough permissions for access<CODESPLIT>def access_ok ( self , access ) : for c in access : if c not in self . perms : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return ignored regions like strings and comments in source<CODESPLIT>def ignored_regions ( source ) : return [ ( match . start ( ) , match . end ( ) ) for match in _str . finditer ( source ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit this application<CODESPLIT>def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .<CODESPLIT>def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try converting the README to an RST document . Return it as is on failure .<CODESPLIT>def readme ( ) : try : import pypandoc readme_content = pypandoc . convert ( 'README.md' , 'rst' ) except ( IOError , ImportError ) : print ( "Warning: no pypandoc module found." ) try : readme_content = open ( 'README.md' ) . read ( ) except IOError : readme_content = '' return readme_content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Index all available documents using streaming_bulk for speed Args :<CODESPLIT>def index_all ( self , index_name ) : oks = 0 notoks = 0 for ok , item in streaming_bulk ( self . es_client , self . _iter_documents ( index_name ) ) : if ok : oks += 1 else : notoks += 1 logging . info ( "Import results: %d ok, %d not ok" , oks , notoks )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the correlation matrix given the covariance matrix .<CODESPLIT>def cov_to_correlation ( cov ) : err = np . sqrt ( np . diag ( cov ) ) errinv = np . ones_like ( err ) * np . nan m = np . isfinite ( err ) & ( err != 0 ) errinv [ m ] = 1. / err [ m ] corr = np . array ( cov ) return corr * np . outer ( errinv , errinv )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds execute permission to file . : param filename : : return :<CODESPLIT>def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until all task are executed .<CODESPLIT>async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether a certain column exists<CODESPLIT>def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Evaluates a piece of Javascript in the context of the current page and returns its value .<CODESPLIT>def eval_script ( self , expr ) : ret = self . conn . issue_command ( "Evaluate" , expr ) return json . loads ( "[%s]" % ret ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .<CODESPLIT>def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Portable cast function .<CODESPLIT>def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Paginate queryset .<CODESPLIT>def paginate ( self , request , offset = 0 , limit = None ) : return self . collection . offset ( offset ) . limit ( limit ) , self . collection . count ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend the list by appending all the items in the given list .<CODESPLIT>def extend ( self , iterable ) : return super ( Collection , self ) . extend ( self . _ensure_iterable_is_valid ( iterable ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert record array to a dictionaries<CODESPLIT>def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create random string of selected size<CODESPLIT>def random_str ( size = 10 ) : return '' . join ( random . choice ( string . ascii_lowercase ) for _ in range ( size ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .<CODESPLIT>def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return group content .<CODESPLIT>def _read_group_h5 ( filename , groupname ) : with h5py . File ( filename , 'r' ) as h5f : data = h5f [ groupname ] [ ( ) ] return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cast uint32 RGB image to 4 uint8 channels .<CODESPLIT>def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a copy of dct without keys keys<CODESPLIT>def _delete_keys ( dct , keys ) : c = deepcopy ( dct ) assert isinstance ( keys , list ) for k in keys : c . pop ( k ) return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this an integer .<CODESPLIT>def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the request payload size<CODESPLIT>def calculate_size ( name , data_list ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += INT_SIZE_IN_BYTES for data_list_item in data_list : data_size += calculate_size_data ( data_list_item ) return data_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit this application<CODESPLIT>def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A basic document feature extractor that returns a dict of words that the document contains .<CODESPLIT>def contains_extractor ( document ) : tokens = _get_document_tokens ( document ) features = dict ( ( u'contains({0})' . format ( w ) , True ) for w in tokens ) return features
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses box coordinates to crop an image without resizing it first .<CODESPLIT>def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when a new DropDownItem gets selected .<CODESPLIT>def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save a Keras model definition to JSON with given path<CODESPLIT>def save_keras_definition ( keras_model , path ) : model_json = keras_model . to_json ( ) with open ( path , "w" ) as json_file : json_file . write ( model_json )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a datetime from GnuCash 2 . 6 date string<CODESPLIT>def get_from_gnucash26_date ( date_str : str ) -> date : date_format = "%Y%m%d" result = datetime . strptime ( date_str , date_format ) . date ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select a subset of features from the example dict .<CODESPLIT>def _select_features ( example , feature_list = None ) : feature_list = feature_list or [ "inputs" , "targets" ] return { f : example [ f ] for f in feature_list }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Aggregation function to get the first non - zero value .<CODESPLIT>def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move cursor to this line in the current buffer .<CODESPLIT>def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes stopwords contained in a list of words .<CODESPLIT>def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a target name matches with an input regular expression .<CODESPLIT>def _namematcher ( regex ) : matcher = re_compile ( regex ) def match ( target ) : target_name = getattr ( target , '__name__' , '' ) result = matcher . match ( target_name ) return result return match
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set colouring on if STDOUT is a terminal device off otherwise<CODESPLIT>def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the index of elem in the reversed iterator .<CODESPLIT>def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first line of a file .<CODESPLIT>def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\n' ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw header with underline<CODESPLIT>def draw_header ( self , stream , header ) : stream . writeln ( '=' * ( len ( header ) + 4 ) ) stream . writeln ( '| ' + header + ' |' ) stream . writeln ( '=' * ( len ( header ) + 4 ) ) stream . writeln ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager that suppresses stdout .<CODESPLIT>def suppress_stdout ( ) : save_stdout = sys . stdout sys . stdout = DevNull ( ) yield sys . stdout = save_stdout
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pop - up menu and wx . EVT_CLOSE closing event<CODESPLIT>def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dictionary of words and word counts in a string .<CODESPLIT>def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A basic document feature extractor that returns a dict of words that the document contains .<CODESPLIT>def contains_extractor ( document ) : tokens = _get_document_tokens ( document ) features = dict ( ( u'contains({0})' . format ( w ) , True ) for w in tokens ) return features
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a C array using the given string .<CODESPLIT>def bytes_to_c_array ( data ) : chars = [ "'{}'" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a boolean from a string imput of true or false<CODESPLIT>def bool_str ( string ) : if string not in BOOL_STRS : raise ValueError ( 'Invalid boolean string: "{}"' . format ( string ) ) return True if string == 'true' else False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load the search_freq from JSON file<CODESPLIT>def load_search_freq ( fp = SEARCH_FREQ_JSON ) : try : with open ( fp ) as f : return Counter ( json . load ( f ) ) except FileNotFoundError : return Counter ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a str and transform it into a byte array .<CODESPLIT>def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a UUID .<CODESPLIT>def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the scroll region on the canvas<CODESPLIT>def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns background color rgb tuple of right line<CODESPLIT>def _get_background_color ( self ) : color = self . cell_attributes [ self . key ] [ "bgcolor" ] return tuple ( c / 255.0 for c in color_pack2rgb ( color ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generic plotting method overplotting any existing plot<CODESPLIT>def oplot ( self , x , y , * * kw ) : self . panel . oplot ( x , y , * * kw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the pythonic string type .<CODESPLIT>def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the previous quarter for dt<CODESPLIT>def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a new random state .<CODESPLIT>def new_random_state ( seed = None , fully_random = False ) : if seed is None : if not fully_random : # sample manually a seed instead of just RandomState(), # because the latter one # is way slower. seed = CURRENT_RANDOM_STATE . randint ( SEED_MIN_VALUE , SEED_MAX_VALUE , 1 ) [ 0 ] return np . random . RandomState ( seed )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set an object s field to default if it doesn t have a value<CODESPLIT>def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If pair is in search_list return the index . Otherwise return - 1<CODESPLIT>def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Slicing op .<CODESPLIT>def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads image specified by path into numpy . ndarray<CODESPLIT>def read_img ( path ) : img = cv2 . resize ( cv2 . imread ( path , 0 ) , ( 80 , 30 ) ) . astype ( np . float32 ) / 255 img = np . expand_dims ( img . transpose ( 1 , 0 ) , 0 ) return img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns min ( val1 val2 ) returning None only if both values are None<CODESPLIT>def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the Jaccard similarity between two sets of nodes . Called by mroc .<CODESPLIT>def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a O ( 1 ) memory hash of an iterable of arbitrary length .<CODESPLIT>def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .<CODESPLIT>def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes flags returns indexes of True values<CODESPLIT>def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A background thread to kill the process if it takes too long .<CODESPLIT>def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( "Killing program due to %f second timeout" % timeout ) os . _exit ( 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .<CODESPLIT>def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = "{}[{}]" . format ( pdf_path , page_num ) ) with pdf_img . convert ( "png" ) as converted : # Set white background. converted . background_color = Color ( "white" ) converted . alpha_channel = "remove" converted . save ( filename = img_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the location of the static data directory .<CODESPLIT>def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , "static" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn dict keys and values into native strings .<CODESPLIT>def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that gets relative path to the filename<CODESPLIT>def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Install Postgres on remote<CODESPLIT>def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closest values<CODESPLIT>def closest_values ( L ) : assert len ( L ) >= 2 L . sort ( ) valmin , argmin = min ( ( L [ i ] - L [ i - 1 ] , i ) for i in range ( 1 , len ( L ) ) ) return L [ argmin - 1 ] , L [ argmin ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a string is a bytes instance<CODESPLIT>def is_bytes ( string ) : if six . PY3 and isinstance ( string , ( bytes , memoryview , bytearray ) ) : # noqa return True elif six . PY2 and isinstance ( string , ( buffer , bytearray ) ) : # noqa return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize s into ASCII and replace non - word characters with delimiter .<CODESPLIT>def slugify ( s , delimiter = '-' ) : s = unicodedata . normalize ( 'NFKD' , to_unicode ( s ) ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' ) return RE_SLUG . sub ( delimiter , s ) . strip ( delimiter ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert jamo characters in a string into hcj as much as possible .<CODESPLIT>def synth_hangul ( string ) : raise NotImplementedError return '' . join ( [ '' . join ( '' . join ( jamo_to_hcj ( _ ) ) for _ in string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the crossproduct of the two vectors as a Vec2 . Cross product doesn t really make sense in 2D but return the Z component of the 3d result .<CODESPLIT>def cross_v2 ( vec1 , vec2 ) : return vec1 . y * vec2 . x - vec1 . x * vec2 . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a is a subdirectory of b<CODESPLIT>def is_subdir ( a , b ) : a , b = map ( os . path . abspath , [ a , b ] ) return os . path . commonpath ( [ a , b ] ) == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type an integer type?<CODESPLIT>def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a number to a precision<CODESPLIT>def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>given a DataFrame where records are stored row - wise rearrange it such that records are stored column - wise .<CODESPLIT>def _preprocess ( df ) : df = df . stack ( ) df . index . rename ( [ "id" , "time" ] , inplace = True ) # .reset_index() df . name = "value" df = df . reset_index ( ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type .<CODESPLIT>def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize every item of the list .<CODESPLIT>def serialize ( self , value , * * kwargs ) : return [ self . item_type . serialize ( val , * * kwargs ) for val in value ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap text to terminal width with default indentation<CODESPLIT>def wrap ( text , indent = '    ' ) : wrapper = textwrap . TextWrapper ( width = int ( os . environ . get ( 'COLUMNS' , 80 ) ) , initial_indent = indent , subsequent_indent = indent ) return '\n' . join ( wrapper . wrap ( text ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets main window icon to given wx . Bitmap<CODESPLIT>def set_icon ( self , bmp ) : _icon = wx . EmptyIcon ( ) _icon . CopyFromBitmap ( bmp ) self . SetIcon ( _icon )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>load an nparray object from a json filename<CODESPLIT>def from_file ( filename ) : f = open ( filename , 'r' ) j = json . load ( f ) f . close ( ) return from_dict ( j )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a section a subsection and some text to the document .<CODESPLIT>def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds points and converts to topojson string .<CODESPLIT>def to_topojson ( self ) : topojson = self . topojson topojson [ "objects" ] [ "points" ] = { "type" : "GeometryCollection" , "geometries" : [ point . to_topojson ( ) for point in self . points . all ( ) ] , } return json . dumps ( topojson )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns names of object columns in the DataFrame .<CODESPLIT>def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>All branches in a list<CODESPLIT>def branches ( self ) : result = self . git ( self . default + [ 'branch' , '-a' , '--no-color' ] ) return [ l . strip ( ' *\n' ) for l in result . split ( '\n' ) if l . strip ( ' *\n' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update dict with fields from obj . attributes .<CODESPLIT>def update_dict ( obj , dict , attributes ) : for attribute in attributes : if hasattr ( obj , attribute ) and getattr ( obj , attribute ) is not None : dict [ attribute ] = getattr ( obj , attribute )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the item is a placeholder or contains a placeholder .<CODESPLIT>def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Just the last entry .<CODESPLIT>def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM "%s" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>press to continue<CODESPLIT>def pause ( msg = "Press Enter to Continue..." ) : print ( '\n' + Fore . YELLOW + msg + Fore . RESET , end = '' ) input ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the high median of data .<CODESPLIT>def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( "no median for empty data" ) return data [ n // 2 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rounds float to closest int : rtype : int : param n : float<CODESPLIT>def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms a DataFrame in place . Computes all outputs of the DataFrame .<CODESPLIT>def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Aggregation function to get the first non - zero value .<CODESPLIT>def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpickle a pstats . Stats object<CODESPLIT>def unpickle_stats ( stats ) : stats = cPickle . loads ( stats ) stats . stream = True return stats
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .<CODESPLIT>def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform underscore separated string to pascal case<CODESPLIT>def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get single system variable from CCU / Homegear<CODESPLIT>def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that the Executor must be close () d elsewhere or join () will never return .<CODESPLIT>def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a string is quoted : param arg : the string being checked for quotes : return : True if a string is quoted<CODESPLIT>def is_quoted ( arg : str ) -> bool : return len ( arg ) > 1 and arg [ 0 ] == arg [ - 1 ] and arg [ 0 ] in constants . QUOTES
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a byte array into an integer array . The number of bytes forming an integer is defined by num<CODESPLIT>def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects<CODESPLIT>def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a gid given a group name .<CODESPLIT>def _get_gid ( name ) : if getgrnam is None or name is None : return None try : result = getgrnam ( name ) except KeyError : result = None if result is not None : return result [ 2 ] return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return opened file with a specific encoding .<CODESPLIT>def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dict mapping item - > indices .<CODESPLIT>def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a 3x3 cross - product matrix from a 3 - element vector .<CODESPLIT>def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs the contents of the given script in hive and returns stdout .<CODESPLIT>def run_hive_script ( script ) : if not os . path . isfile ( script ) : raise RuntimeError ( "Hive script: {0} does not exist." . format ( script ) ) return run_hive ( [ '-f' , script ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy text to clipboard without prompts<CODESPLIT>def copy_without_prompts ( self ) : text = self . get_selected_text ( ) lines = text . split ( os . linesep ) for index , line in enumerate ( lines ) : if line . startswith ( '>>> ' ) or line . startswith ( '... ' ) : lines [ index ] = line [ 4 : ] text = os . linesep . join ( lines ) QApplication . clipboard ( ) . setText ( text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a dict of 1d array to a numpy recarray<CODESPLIT>def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverse the normalization done to a batch of images .<CODESPLIT>def denorm ( self , arr ) : if type ( arr ) is not np . ndarray : arr = to_np ( arr ) if len ( arr . shape ) == 3 : arr = arr [ None ] return self . transform . denorm ( np . rollaxis ( arr , 1 , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the CSRF token out of the Set - Cookie header of a response .<CODESPLIT>def get_csrf_token ( response ) : cookie_headers = [ h . decode ( 'ascii' ) for h in response . headers . getlist ( "Set-Cookie" ) ] if not cookie_headers : return None csrf_headers = [ h for h in cookie_headers if h . startswith ( "csrftoken=" ) ] if not csrf_headers : return None match = re . match ( "csrftoken=([^ ;]+);" , csrf_headers [ - 1 ] ) return match . group ( 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return if the token is in the list or not .<CODESPLIT>def contains ( self , token : str ) -> bool : self . _validate_token ( token ) return token in self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a dictionary and a key list remove any data in the dictionary with the given keys .<CODESPLIT>def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> list = [ 0 0 7 ] >>> list_to_str ( list ) 0 0 7<CODESPLIT>def list_to_str ( list , separator = ',' ) : list = [ str ( x ) for x in list ] return separator . join ( list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>find a path from start to end node on grid using the A * algorithm : param start : start node : param end : end node : param grid : grid that stores all possible steps / tiles as 2D - list : return :<CODESPLIT>def find_path ( self , start , end , grid ) : start . g = 0 start . f = 0 return super ( AStarFinder , self ) . find_path ( start , end , grid )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize the length of a vector to one<CODESPLIT>def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find longest ORF from the given list of ORFs .<CODESPLIT>def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return opened file with a specific encoding .<CODESPLIT>def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert Matrix attributes which are array - like or buffer to array .<CODESPLIT>def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the first value in each row .<CODESPLIT>def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the local variables in the caller s frame .<CODESPLIT>def caller_locals ( ) : import inspect frame = inspect . currentframe ( ) try : return frame . f_back . f_back . f_locals finally : del frame
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return pinyin of string the string must be unicode<CODESPLIT>def get ( s , delimiter = '' , format = "diacritical" ) : return delimiter . join ( _pinyin_generator ( u ( s ) , format = format ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to get return code of a url<CODESPLIT>def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Filter a set of entities based on method return . Use keyword arguments . Example : filtmeth ( entities id = 123 ) filtmeth ( entities name = bart )<CODESPLIT>def filtany ( entities , * * kw ) : ret = set ( ) for k , v in kw . items ( ) : for entity in entities : if getattr ( entity , k ) ( ) == v : ret . add ( entity ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download a Single File from S3 into a local path<CODESPLIT>def download_file ( bucket_name , path , target , sagemaker_session ) : path = path . lstrip ( '/' ) boto_session = sagemaker_session . boto_session s3 = boto_session . resource ( 's3' ) bucket = s3 . Bucket ( bucket_name ) bucket . download_file ( path , target )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the memory byte size of a Numpy array as an integer .<CODESPLIT>def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins the coordinator thread and all worker threads .<CODESPLIT>def join ( self ) : for thread in self . worker_threads : thread . join ( ) WorkerThread . join ( self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether a path names an existing executable file .<CODESPLIT>def is_executable ( path ) : return os . path . isfile ( path ) and os . access ( path , os . X_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a list of the public data attributes .<CODESPLIT>def __len__ ( self ) : return len ( [ i for i in ( set ( dir ( self ) ) - self . _STANDARD_ATTRS ) if i [ 0 ] != '_' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure the cursor is within horizontal screen bounds .<CODESPLIT>def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return flattened dictionary from MultiDict .<CODESPLIT>def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decode base64 string to byte array .<CODESPLIT>def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : x : iterable of strings<CODESPLIT>def gen_lower ( x : Iterable [ str ] ) -> Generator [ str , None , None ] : for string in x : yield string . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a numpy array of integers<CODESPLIT>def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates the returned positional object<CODESPLIT>def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ "seqname" , "position" , "strand" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( "int64" ) assert df . strand . dtype == np . dtype ( "O" ) assert df . seqname . dtype == np . dtype ( "O" ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts the input single value into the expected Python data type raising django . core . exceptions . ValidationError if the data can t be converted . Returns the converted value . Subclasses should override this .<CODESPLIT>def value_to_python ( self , value ) : if not isinstance ( value , bytes ) : raise tldap . exceptions . ValidationError ( "should be a bytes" ) value = value . decode ( "utf_8" ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a pretty - printed string for this object .<CODESPLIT>def __str__ ( self ) : return 'Output name: "%s" watts: %d type: "%s" id: %d' % ( self . _name , self . _watts , self . _output_type , self . _integration_id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shot noise corruption to images .<CODESPLIT>def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string from a form into an Enum value .<CODESPLIT>def to_python ( self , value ) : if value is None : return value if isinstance ( value , self . enum ) : return value return self . enum [ value ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A small helper function to convert a string to a numeric value if appropriate<CODESPLIT>def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Let the DBMS perform a sum on a queryset<CODESPLIT>def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Init a noise variable .<CODESPLIT>def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the percentile of a list of values .<CODESPLIT>def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Drops the trailing zeros in a float that is printed .<CODESPLIT>def drop_trailing_zeros ( num ) : txt = '%f' % ( num ) txt = txt . rstrip ( '0' ) if txt . endswith ( '.' ) : txt = txt [ : - 1 ] return txt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets multiple headers on the request and returns the request itself .<CODESPLIT>def with_headers ( self , headers ) : for key , value in headers . items ( ) : self . with_header ( key , value ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join the given iterable with<CODESPLIT>def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the last stack element and delete it from the list<CODESPLIT>def pop ( self ) : if not self . empty ( ) : val = self . stack [ - 1 ] del self . stack [ - 1 ] return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of active CPUs on a Darwin system .<CODESPLIT>def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render a jinja template<CODESPLIT>def render_template ( env , filename , values = None ) : if not values : values = { } tmpl = env . get_template ( filename ) return tmpl . render ( values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from strings to integers<CODESPLIT>def str2int ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . str2int ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert datetime to epoch seconds .<CODESPLIT>def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A handy wrapper to get a remote file content<CODESPLIT>def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield all non - sytem collections in db .<CODESPLIT>def all_collections ( db ) : include_pattern = r'(?!system\.)' return ( db [ name ] for name in db . list_collection_names ( ) if re . match ( include_pattern , name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def unpack_out ( self , name ) : return self . parse ( """             $enum = $enum_class($value.value)             """ , enum_class = self . _import_type ( ) , value = name ) [ "enum" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return sanitized Eidos text field for human readability .<CODESPLIT>def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented .<CODESPLIT>def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take any values coming in as a datetime and deserialize them<CODESPLIT>def _deserialize_datetime ( self , data ) : for key in data : if isinstance ( data [ key ] , dict ) : if data [ key ] . get ( 'type' ) == 'datetime' : data [ key ] = datetime . datetime . fromtimestamp ( data [ key ] [ 'value' ] ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invoked when determining whether a specific key is in the dictionary using key in d .<CODESPLIT>def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Push item onto heap maintaining the heap invariant .<CODESPLIT>def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values<CODESPLIT>def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( "Error getting image size {}" . format ( url ) , exc_info = True ) return w_h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of ( key value ) pairs and turns it into a dict .<CODESPLIT>def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the val is in the list of values for this Enum .<CODESPLIT>def validate ( self , val ) : if val in self . values : return True , None else : return False , "'%s' is not in enum: %s" % ( val , str ( self . values ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from integers to strings<CODESPLIT>def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Go to parent directory<CODESPLIT>def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether or not a given path is a ( sub ) package or not .<CODESPLIT>def isPackage ( file_path ) : return ( os . path . isdir ( file_path ) and os . path . isfile ( os . path . join ( file_path , '__init__.py' ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register all globally visible functions .<CODESPLIT>def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates an mxn sparse d matrix with round ( a * m * n ) nonzeros .<CODESPLIT>def sp_rand ( m , n , a ) : if m == 0 or n == 0 : return spmatrix ( [ ] , [ ] , [ ] , ( m , n ) ) nnz = min ( max ( 0 , int ( round ( a * m * n ) ) ) , m * n ) nz = matrix ( random . sample ( range ( m * n ) , nnz ) , tc = 'i' ) return spmatrix ( normal ( nnz , 1 ) , nz % m , matrix ( [ int ( ii ) for ii in nz / m ] ) , ( m , n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets up the python include paths to include src<CODESPLIT>def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , "src" ) ] + sys . path pass return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An argparse type representing an email address .<CODESPLIT>def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( "{0} is not a valid email address" . format ( repr ( arg ) ) ) return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close connection with the database<CODESPLIT>def close_database_session ( session ) : try : session . close ( ) except OperationalError as e : raise DatabaseError ( error = e . orig . args [ 1 ] , code = e . orig . args [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the chars in the given string .<CODESPLIT>def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to infer an object s dtype for use in arithmetic ops<CODESPLIT>def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a zeep object to a dictionary .<CODESPLIT>def _zeep_to_dict ( cls , obj ) : res = serialize_object ( obj ) res = cls . _get_non_empty_dict ( res ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simplest required implementation of collections . Counter . Required as 2 . 6 does not have Counter in collections .<CODESPLIT>def counter ( items ) : results = { } for item in items : results [ item ] = results . get ( item , 0 ) + 1 return results
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the index of the closest in xarr to value val<CODESPLIT>def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures well - formedness of a key .<CODESPLIT>def _check_key ( self , key ) : if not len ( key ) == 2 : raise TypeError ( 'invalid key: %r' % key ) elif key [ 1 ] not in TYPES : raise TypeError ( 'invalid datatype: %s' % key [ 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to unpickle data from picklefile .<CODESPLIT>def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a file exists and is non - empty .<CODESPLIT>def file_exists ( fname ) : try : return fname and os . path . exists ( fname ) and os . path . getsize ( fname ) > 0 except OSError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write file with current process ID .<CODESPLIT>def _write_pidfile ( pidfile ) : pid = str ( os . getpid ( ) ) handle = open ( pidfile , 'w' ) try : handle . write ( "%s\n" % pid ) finally : handle . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does openat read - only then does fdopen to get a file object<CODESPLIT>def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns given method name .<CODESPLIT>def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( "__" ) and not name . endswith ( "__" ) : name = "_{0}{1}" . format ( get_object_name ( method . im_class ) , name ) return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string from camel case to snake case .<CODESPLIT>def camel_to_snake ( s : str ) -> str : return CAMEL_CASE_RE . sub ( r'_\1' , s ) . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Under UNIX : is a keystroke available?<CODESPLIT>def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return opened file with a specific encoding .<CODESPLIT>def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yaml either have automatically converted it to a datetime object or it is a string that will be validated later .<CODESPLIT>def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch the data field if it does not exist .<CODESPLIT>def get_data ( self ) : try : return DocumentDataDict ( self . __dict__ [ 'data' ] ) except KeyError : self . _lazy_load ( ) return DocumentDataDict ( self . __dict__ [ 'data' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return current free memory on the machine for windows .<CODESPLIT>def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator to wrap an async function in an event loop . Use for main sync interface methods .<CODESPLIT>def run_task ( func ) : def _wrapped ( * a , * * k ) : loop = asyncio . get_event_loop ( ) return loop . run_until_complete ( func ( * a , * * k ) ) return _wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether a certain column exists<CODESPLIT>def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the moving average of an array .<CODESPLIT>def moving_average ( array , n = 3 ) : ret = _np . cumsum ( array , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to calculate the Fourier transform of data . Parameters ---------- data : numpy . ndarray 1D or 2D array containing time series . tbin : float Bin size of time series ( in ms ) . Returns ------- freqs : numpy . ndarray Frequency axis of signal in Fourier space . fft : numpy . ndarray Signal in Fourier space .<CODESPLIT>def calculate_fft ( data , tbin ) : if len ( np . shape ( data ) ) > 1 : n = len ( data [ 0 ] ) return np . fft . fftfreq ( n , tbin * 1e-3 ) , np . fft . fft ( data , axis = 1 ) else : n = len ( data ) return np . fft . fftfreq ( n , tbin * 1e-3 ) , np . fft . fft ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Instanciate a singleton per scope .<CODESPLIT>def singleton_per_scope ( _cls , _scope = None , _renew = False , * args , * * kwargs ) : result = None singletons = SINGLETONS_PER_SCOPES . setdefault ( _scope , { } ) if _renew or _cls not in singletons : singletons [ _cls ] = _cls ( * args , * * kwargs ) result = singletons [ _cls ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Expand $vars in a string .<CODESPLIT>def _expand ( self , str , local_vars = { } ) : return ninja_syntax . expand ( str , self . vars , local_vars )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes object obj from the index .<CODESPLIT>def _remove_from_index ( index , obj ) : try : index . value_map [ indexed_value ( index , obj ) ] . remove ( obj . id ) except KeyError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - negative integer .<CODESPLIT>def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Code due to Thomas Heller - published in Python Cookbook ( O Reilley )<CODESPLIT>def debug_on_error ( type , value , tb ) : traceback . print_exc ( type , value , tb ) print ( ) pdb . pm ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursivly delete a directory<CODESPLIT>def rrmdir ( directory ) : for root , dirs , files in os . walk ( directory , topdown = False ) : for name in files : os . remove ( os . path . join ( root , name ) ) for name in dirs : os . rmdir ( os . path . join ( root , name ) ) os . rmdir ( directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the pixel at ( x y ) to the integers in sequence color .<CODESPLIT>def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the text .<CODESPLIT>def check ( text ) : err = "misc.currency" msg = u"Incorrect use of symbols in {}." symbols = [ "\$[\d]* ?(?:dollars|usd|us dollars)" ] return existence_check ( text , symbols , err , msg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split input / output value into two values .<CODESPLIT>def _split ( value ) : if isinstance ( value , str ) : # iterable, but not meant for splitting return value , value try : invalue , outvalue = value except TypeError : invalue = outvalue = value except ValueError : raise ValueError ( "Only single values and pairs are allowed" ) return invalue , outvalue
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The bounding box ( ymin xmin ymax xmax ) of the minimal rectangular region containing the source segment .<CODESPLIT>def bbox ( self ) : # (stop - 1) to return the max pixel location, not the slice index return ( self . _slice [ 0 ] . start , self . _slice [ 1 ] . start , self . _slice [ 0 ] . stop - 1 , self . _slice [ 1 ] . stop - 1 ) * u . pix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: returns the minimum of the column<CODESPLIT>def min ( self ) : res = self . _qexec ( "min(%s)" % self . _name ) if len ( res ) > 0 : self . _min = res [ 0 ] [ 0 ] return self . _min
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether the given value is a byte or unicode string .<CODESPLIT>def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalizes the given vector . The vector given may have any number of dimensions .<CODESPLIT>def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .<CODESPLIT>def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>setuptools blah : it still can t run a module as a script entry_point<CODESPLIT>def stub_main ( ) : from google . apputils import run_script_module import butcher . main run_script_module . RunScriptModule ( butcher . main )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the maximum value of the domain .<CODESPLIT>def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print an error in red text . Parameters error ( HTTPError ) Error object to print .<CODESPLIT>def fail_print ( error ) : print ( COLORS . fail , error . message , COLORS . end ) print ( COLORS . fail , error . errors , COLORS . end )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output a networkx graph to a DOT file .<CODESPLIT>def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse path string .<CODESPLIT>def parse_path ( path ) : version , project = path [ 1 : ] . split ( '/' ) return dict ( version = int ( version ) , project = project )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call Imagemagick to generate a scheme .<CODESPLIT>def imagemagick ( color_count , img , magick_command ) : flags = [ "-resize" , "25%" , "-colors" , str ( color_count ) , "-unique-colors" , "txt:-" ] img += "[0]" return subprocess . check_output ( [ * magick_command , img , * flags ] ) . splitlines ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log - normal function from scipy<CODESPLIT>def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Last modified timestamp as a UTC datetime<CODESPLIT>def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test program for telnetlib .<CODESPLIT>def test ( ) : debuglevel = 0 while sys . argv [ 1 : ] and sys . argv [ 1 ] == '-d' : debuglevel = debuglevel + 1 del sys . argv [ 1 ] host = 'localhost' if sys . argv [ 1 : ] : host = sys . argv [ 1 ] port = 0 if sys . argv [ 2 : ] : portstr = sys . argv [ 2 ] try : port = int ( portstr ) except ValueError : port = socket . getservbyname ( portstr , 'tcp' ) tn = Telnet ( ) tn . set_debuglevel ( debuglevel ) tn . open ( host , port ) tn . interact ( ) tn . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given the python representation of a JSONschema as defined in the swagger spec validate that the schema complies to spec . If target is provided that target will be validated against the provided schema .<CODESPLIT>def validate ( raw_schema , target = None , * * kwargs ) : schema = schema_validator ( raw_schema , * * kwargs ) if target is not None : validate_object ( target , schema = schema , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Starts the web server .<CODESPLIT>def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Categorical accuracy<CODESPLIT>def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get elements in this document which matches condition .<CODESPLIT>def getElementsBy ( self , cond : Callable [ [ Element ] , bool ] ) -> NodeList : return getElementsBy ( self , cond )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True when alias already in shell config .<CODESPLIT>def _is_already_configured ( configuration_details ) : path = Path ( configuration_details . path ) . expanduser ( ) with path . open ( 'r' ) as shell_config : return configuration_details . content in shell_config . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the provided name is a valid variable name in Python<CODESPLIT>def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialise sets used for uniqueness checking .<CODESPLIT>def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the opposite of input condition .<CODESPLIT>def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterator that allow for piecemeal processing of a file .<CODESPLIT>def filechunk ( f , chunksize ) : while True : chunk = tuple ( itertools . islice ( f , chunksize ) ) if not chunk : return yield np . loadtxt ( iter ( chunk ) , dtype = np . float64 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate angle between two vectors<CODESPLIT>def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to get bins for histplot .<CODESPLIT>def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be a float<CODESPLIT>def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a hash of the contents of a dictionary<CODESPLIT>def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a PID into a pidfile<CODESPLIT>def put_pidfile ( pidfile_path , pid ) : with open ( pidfile_path , "w" ) as f : f . write ( "%s" % pid ) os . fsync ( f . fileno ( ) ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this a string .<CODESPLIT>def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return password from pipe if not on TTY else False .<CODESPLIT>def pass_from_pipe ( cls ) : is_pipe = not sys . stdin . isatty ( ) return is_pipe and cls . strip_last_newline ( sys . stdin . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a list of the top topn features in this : class : . Feature \ .<CODESPLIT>def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to render a list of dictionaries as an HTML display object .<CODESPLIT>def _render_table ( data , fields = None ) : return IPython . core . display . HTML ( datalab . utils . commands . HtmlBuilder . render_table ( data , fields ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove problem characters from string<CODESPLIT>def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\'' ] for c in remove : string = string . replace ( c , '_' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mocked decorator needed in the case we need to mock a decorator<CODESPLIT>def mock_decorator ( * args , * * kwargs ) : def _called_decorator ( dec_func ) : @ wraps ( dec_func ) def _decorator ( * args , * * kwargs ) : return dec_func ( ) return _decorator return _called_decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if two objects are equal .<CODESPLIT>def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a username / password combination is valid .<CODESPLIT>def check_auth ( email , password ) : try : user = User . get ( User . email == email ) except User . DoesNotExist : return False return password == user . password
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the magnitude of a vector .<CODESPLIT>def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a tuple of numbers . e . g . vertices normals or teture coords .<CODESPLIT>def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the html for a Bokeh chart<CODESPLIT>def _get_bokeh_html ( self , chart_obj ) : global bokeh_renderer try : renderer = bokeh_renderer p = renderer . get_plot ( chart_obj ) . state script , div = components ( p ) return script + "\n" + div except Exception as e : self . err ( e , self . _get_bokeh_html , "Can not get html from the Bokeh rendering engine" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if var is a list or a tuple ( but not a string! )<CODESPLIT>def is_a_sequence ( var , allow_none = False ) : return isinstance ( var , ( list , tuple ) ) or ( var is None and allow_none )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rearrange the heap after the item at position i got updated .<CODESPLIT>def fix ( h , i ) : down ( h , i , h . size ( ) ) up ( h , i )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encode one categorical column into labels .<CODESPLIT>def _transform_col ( self , x , i ) : return x . fillna ( NAN_INT ) . map ( self . label_encoders [ i ] ) . fillna ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a microsecond timestamp to a UTC datetime instance .<CODESPLIT>def from_timestamp ( microsecond_timestamp ) : # Create datetime without losing precision from floating point (yes, this # is actually needed): return datetime . datetime . fromtimestamp ( microsecond_timestamp // 1000000 , datetime . timezone . utc ) . replace ( microsecond = ( microsecond_timestamp % 1000000 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>will plot a stack of traces one above the other assuming marray . shape = numRows numSamples<CODESPLIT>def stackplot ( marray , seconds = None , start_time = None , ylabels = None ) : tarray = np . transpose ( marray ) stackplot_t ( tarray , seconds = seconds , start_time = start_time , ylabels = ylabels ) plt . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount .<CODESPLIT>def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a dict to a querystring suitable to be appended to a URL .<CODESPLIT>def dict_to_querystring ( dictionary ) : s = u"" for d in dictionary . keys ( ) : s = unicode . format ( u"{0}{1}={2}&" , s , d , dictionary [ d ] ) return s [ : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a vector with the elements rounded to the given number of digits .<CODESPLIT>def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Evaluates the binomial pmf .<CODESPLIT>def EvalBinomialPmf ( k , n , p ) : return scipy . stats . binom . pmf ( k , n , p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check whether the item is list ( tuple ) and consist of list ( tuple ) elements<CODESPLIT>def is_list_of_list ( item ) : if ( type ( item ) in ( list , tuple ) and len ( item ) and isinstance ( item [ 0 ] , ( list , tuple ) ) ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempts to convert given object to a string object<CODESPLIT>def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Call f n times with args and kwargs . Useful e . g . for simplistic timing .<CODESPLIT>def nTimes ( n , f , * args , * * kwargs ) : for i in xrange ( n ) : f ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the file - like object is readable .<CODESPLIT>def is_readable ( fp , size = 1 ) : read_size = len ( fp . read ( size ) ) fp . seek ( - read_size , 1 ) return read_size == size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dot product of two vectors<CODESPLIT>def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join the list of images into the out file<CODESPLIT>def join_images ( img_files , out_file ) : images = [ PIL . Image . open ( f ) for f in img_files ] joined = PIL . Image . new ( 'RGB' , ( sum ( i . size [ 0 ] for i in images ) , max ( i . size [ 1 ] for i in images ) ) ) left = 0 for img in images : joined . paste ( im = img , box = ( left , 0 ) ) left = left + img . size [ 0 ] joined . save ( out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read entire contents of file into a string .<CODESPLIT>def read_string_from_file ( path , encoding = "utf8" ) : with codecs . open ( path , "rb" , encoding = encoding ) as f : value = f . read ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Continuous constant pulse .<CODESPLIT>def constant ( times : np . ndarray , amp : complex ) -> np . ndarray : return np . full ( len ( times ) , amp , dtype = np . complex_ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a dictionary of strings from a file<CODESPLIT>def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the given multiquery .<CODESPLIT>async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the window that owns selection ( an atom ) or X . NONE if there is no owner for the selection . Can raise BadAtom .<CODESPLIT>def get_selection_owner ( self , selection ) : r = request . GetSelectionOwner ( display = self . display , selection = selection ) return r . owner
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform an underscore_case string to a mixedCase string<CODESPLIT>def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove password from printed connection URLs .<CODESPLIT>def safe_url ( url ) : parsed = urlparse ( url ) if parsed . password is not None : pwd = ':%s@' % parsed . password url = url . replace ( pwd , ':*****@' ) return url
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect and login to an FTP server and return ftplib . FTP object .<CODESPLIT>def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list find the last occurance of a sublist within it .<CODESPLIT>def find_last_sublist ( list_ , sublist ) : for i in reversed ( range ( len ( list_ ) - len ( sublist ) + 1 ) ) : if list_ [ i ] == sublist [ 0 ] and list_ [ i : i + len ( sublist ) ] == sublist : return i return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reimplement Qt method to send focus change notification<CODESPLIT>def focusInEvent ( self , event ) : self . focus_changed . emit ( ) return super ( ShellWidget , self ) . focusInEvent ( event )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get string from file .<CODESPLIT>def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a bool from a string .<CODESPLIT>def FromString ( self , string ) : if string . lower ( ) in ( "false" , "no" , "n" ) : return False if string . lower ( ) in ( "true" , "yes" , "y" ) : return True raise TypeValueError ( "%s is not recognized as a boolean value." % string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get input from the user given an input function and an input string<CODESPLIT>def get_input ( input_func , input_str ) : val = input_func ( "Please enter your {0}: " . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( "You didn't enter a valid {0}, please try again: " . format ( input_str ) ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>printdict<CODESPLIT>def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates a LaTeX table from parameter summaries .<CODESPLIT>def get_latex_table ( self , parameters = None , transpose = False , caption = None , label = "tab:model_params" , hlines = True , blank_fill = "--" ) : # pragma: no cover if parameters is None : parameters = self . parent . _all_parameters for p in parameters : assert isinstance ( p , str ) , "Generating a LaTeX table requires all parameters have labels" num_parameters = len ( parameters ) num_chains = len ( self . parent . chains ) fit_values = self . get_summary ( squeeze = False ) if label is None : label = "" if caption is None : caption = "" end_text = " \\\\ \n" if transpose : column_text = "c" * ( num_chains + 1 ) else : column_text = "c" * ( num_parameters + 1 ) center_text = "" hline_text = "\\hline\n" if hlines : center_text += hline_text + "\t\t" if transpose : center_text += " & " . join ( [ "Parameter" ] + [ c . name for c in self . parent . chains ] ) + end_text if hlines : center_text += "\t\t" + hline_text for p in parameters : arr = [ "\t\t" + p ] for chain_res in fit_values : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += " & " . join ( arr ) + end_text else : center_text += " & " . join ( [ "Model" ] + parameters ) + end_text if hlines : center_text += "\t\t" + hline_text for name , chain_res in zip ( [ c . name for c in self . parent . chains ] , fit_values ) : arr = [ "\t\t" + name ] for p in parameters : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += " & " . join ( arr ) + end_text if hlines : center_text += "\t\t" + hline_text final_text = get_latex_table_frame ( caption , label ) % ( column_text , center_text ) return final_text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Under UNIX : is a keystroke available?<CODESPLIT>def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpickle a pstats . Stats object<CODESPLIT>def unpickle_stats ( stats ) : stats = cPickle . loads ( stats ) stats . stream = True return stats
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If the database is empty generate a random vector .<CODESPLIT>def _random_x ( self ) : return ( tuple ( random . random ( ) for _ in range ( self . fmodel . dim_x ) ) , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the topmost parent of the current category .<CODESPLIT>def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}<CODESPLIT>def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type one that inherits from : class : Numeric such as : class : Float : class : Decimal ?<CODESPLIT>def is_sqlatype_numeric ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Numeric )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return file contents as string .<CODESPLIT>def str_from_file ( path ) : with open ( path ) as f : s = f . read ( ) . strip ( ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a path to its canonical case - normalized absolute version .<CODESPLIT>def normalize_path ( path ) : return os . path . normcase ( os . path . realpath ( os . path . expanduser ( path ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call callable ( * args ** kw ) fixing any type errors that come out .<CODESPLIT>def fix_call ( callable , * args , * * kw ) : try : val = callable ( * args , * * kw ) except TypeError : exc_info = fix_type_error ( None , callable , args , kw ) reraise ( * exc_info ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to get the location of a Python file .<CODESPLIT>def getScriptLocation ( ) : location = os . path . abspath ( "./" ) if __file__ . rfind ( "/" ) != - 1 : location = __file__ [ : __file__ . rfind ( "/" ) ] return location
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap text with markdown specific flavour .<CODESPLIT>def build_code ( self , lang , body ) : self . out . append ( "```" + lang ) self . build_markdown ( lang , body ) self . out . append ( "```" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x is a 2D sparse matrix with it s first shape equal to 1 .<CODESPLIT>def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Roll a die .<CODESPLIT>def roll_dice ( ) : sums = 0 # will return the sum of the roll calls. while True : roll = random . randint ( 1 , 6 ) sums += roll if ( input ( "Enter y or n to continue: " ) . upper ( ) ) == 'N' : print ( sums ) # prints the sum of the roll calls break
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can add this object<CODESPLIT>def has_add_permission ( self , request ) : return request . user . is_authenticated and request . user . is_active and request . user . is_staff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Insert None as value for missing fields .<CODESPLIT>def inject_nulls ( data : Mapping , field_names ) -> dict : record = dict ( ) for field in field_names : record [ field ] = data . get ( field , None ) return record
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a grayscale image to BGR image .<CODESPLIT>def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ajout d un message de log de type INFO<CODESPLIT>def info ( self , text ) : self . logger . info ( "{}{}" . format ( self . message_prefix , text ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wraps jsonschema . validate returning the same object passed in .<CODESPLIT>def validate ( request : Union [ Dict , List ] , schema : dict ) -> Union [ Dict , List ] : jsonschema_validate ( request , schema ) return request
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reseed factory . fuzzy s random generator .<CODESPLIT>def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls the specified Trigger of another Area with the optionally given parameters .<CODESPLIT>def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function that reads a local file and generates a SHA256 hash digest for it<CODESPLIT>def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts text that may be camelcased into an underscored format<CODESPLIT>def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\1_\2' , UNDERSCORE [ 0 ] . sub ( r'\1_\2' , text ) ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip the whitespace from all column names in the given DataFrame and return the result .<CODESPLIT>def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to restore index information after collection . Doesn t use self so we can serialize this .<CODESPLIT>def _update_index_on_df ( df , index_names ) : if index_names : df = df . set_index ( index_names ) # Remove names from unnamed indexes index_names = _denormalize_index_names ( index_names ) df . index . names = index_names return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rotates an image by deg degrees<CODESPLIT>def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return indices of inputs to the node with the given index .<CODESPLIT>def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a DataFrame with rows where column values match match are removed .<CODESPLIT>def remove_rows_matching ( df , column , match ) : df = df . copy ( ) mask = df [ column ] . values != match return df . iloc [ mask , : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This parallel fetcher uses gevent one uses gevent<CODESPLIT>def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the x - axis tick labels for a subplot .<CODESPLIT>def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete this message<CODESPLIT>async def delete ( self ) : return await self . bot . delete_message ( self . chat . id , self . message_id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for pulling a keyed value off various types of objects<CODESPLIT>def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all database table names found in an SQLAlchemy : class : MetaData object .<CODESPLIT>def get_table_names_from_metadata ( metadata : MetaData ) -> List [ str ] : return [ table . name for table in metadata . tables . values ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indent given text using custom spacing default is set to 4 .<CODESPLIT>def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing whitespace on each line .<CODESPLIT>def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\n' ) ] return '\n' . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform list into a maxheap in - place in O ( len ( x )) time .<CODESPLIT>def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns day number of the last day of the month : param t : datetime : return : int<CODESPLIT>def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Imputes data set containing Nan values<CODESPLIT>def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the input is a comma separated list of names .<CODESPLIT>def isCommaList ( inputFilelist ) : if isinstance ( inputFilelist , int ) or isinstance ( inputFilelist , np . int32 ) : ilist = str ( inputFilelist ) else : ilist = inputFilelist if "," in ilist : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform column - stacking on a list of 2d data blocks .<CODESPLIT>def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops the status update thread .<CODESPLIT>def _StopStatusUpdateThread ( self ) : self . _status_update_active = False if self . _status_update_thread . isAlive ( ) : self . _status_update_thread . join ( ) self . _status_update_thread = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializes a numpy array to a compressed base64 string<CODESPLIT>def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the extension from a filename<CODESPLIT>def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Registers entity to put to datastore .<CODESPLIT>def put ( self , entity ) : actual_entity = _normalize_entity ( entity ) if actual_entity is None : return self . ndb_put ( entity ) self . puts . append ( actual_entity )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a blank row with only an index value to self . df . This is done inplace .<CODESPLIT>def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function to make a dict from a coordinate for logging<CODESPLIT>def make_coord_dict ( coord ) : return dict ( z = int_if_exact ( coord . zoom ) , x = int_if_exact ( coord . column ) , y = int_if_exact ( coord . row ) , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the chars in the given string .<CODESPLIT>def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns day number of the last day of the month : param t : datetime : return : int<CODESPLIT>def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap i and j rows<CODESPLIT>def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function for conversion of various data types into numeric representation .<CODESPLIT>def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set __doc__ of * method * to __doc__ of * method * in its parent class .<CODESPLIT>def inheritdoc ( method ) : method . __doc__ = getattr ( str , method . __name__ ) . __doc__ return method
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all non - printable characters from a text string<CODESPLIT>def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>map for a directory<CODESPLIT>def dmap ( fn , record ) : values = ( fn ( v ) for k , v in record . items ( ) ) return dict ( itertools . izip ( record , values ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the conda executable robustly across conda versions .<CODESPLIT>def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Truncates a value to a number of decimals places<CODESPLIT>def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP PUT operation to API endpoint .<CODESPLIT>def put ( self , endpoint : str , * * kwargs ) -> dict : return self . _request ( 'PUT' , endpoint , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function : to be called with each stream element as its only argument<CODESPLIT>def __init__ ( self , function ) : super ( takewhile , self ) . __init__ ( ) self . function = function
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the high median of data .<CODESPLIT>def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( "no median for empty data" ) return data [ n // 2 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to timestamp .<CODESPLIT>async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates RFC2822 format<CODESPLIT>def is_rfc2822 ( instance : str ) : if not isinstance ( instance , str ) : return True return email . utils . parsedate ( instance ) is not None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>u Returns a list of children and available helper methods .<CODESPLIT>def __dir__ ( self ) : return sorted ( self . keys ( ) | { m for m in dir ( self . __class__ ) if m . startswith ( 'to_' ) } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to make map () behave the same on Py2 and Py3 .<CODESPLIT>def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>0 . Empty row returns False .<CODESPLIT>def non_zero_row ( arr ) : if len ( arr ) == 0 : return False for item in arr : if item == 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete task ( in any state ) permanently .<CODESPLIT>async def delete ( self ) : the_tuple = await self . queue . delete ( self . tube , self . task_id ) self . update_from_tuple ( the_tuple ) return bool ( self . state == DONE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats a list of elements using the given line style<CODESPLIT>def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .<CODESPLIT>def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap i and j rows<CODESPLIT>def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform column - stacking on a list of 2d data blocks .<CODESPLIT>def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convolve 2d gaussian .<CODESPLIT>def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the usage string for available options<CODESPLIT>def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calcuate median datetime from datetime list<CODESPLIT>def median_date ( dt_list ) : #dt_list_sort = sorted(dt_list) idx = len ( dt_list ) / 2 if len ( dt_list ) % 2 == 0 : md = mean_date ( [ dt_list [ idx - 1 ] , dt_list [ idx ] ] ) else : md = dt_list [ idx ] return md
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the terminal to the passed color . : param color : one of the availabe colors .<CODESPLIT>def set ( cls , color ) : sys . stdout . write ( cls . colors . get ( color , cls . colors [ 'RESET' ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract text from a given lxml node .<CODESPLIT>def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( ".//text()" ) ) ) ) return " " . join ( text for text in texts if text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a random API key for a user : param username : : return : Hex encoded SHA512 random string<CODESPLIT>def gen_api_key ( username ) : salt = str ( os . urandom ( 64 ) ) . encode ( 'utf-8' ) return hash_password ( username , salt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple helper hash function<CODESPLIT>def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .<CODESPLIT>def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop the instance .<CODESPLIT>def _stop_instance ( self ) : instance = self . _get_instance ( ) instance . stop ( ) self . _wait_on_instance ( 'stopped' , self . timeout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert from arange to linspace<CODESPLIT>def to_linspace ( self ) : num = int ( ( self . stop - self . start ) / ( self . step ) ) return Linspace ( self . start , self . stop - self . step , num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator for JSON - per - line in a file pattern<CODESPLIT>def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an argument parser<CODESPLIT>def createArgumentParser ( description ) : parser = argparse . ArgumentParser ( description = description , formatter_class = SortedHelpFormatter ) return parser
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns current utcoffset for a timezone . Uses DEFAULT_LOCAL_TZ by default . That value can be changed at runtime using the func below .<CODESPLIT>def current_offset ( local_tz = None ) : if local_tz is None : local_tz = DEFAULT_LOCAL_TZ dt = local_tz . localize ( datetime . now ( ) ) return dt . utcoffset ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>move to util_iter<CODESPLIT>def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>test if object is a list or tuple<CODESPLIT>def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DOES NOT WORK WELL WITH MOPIDY Hack from https : // www . daniweb . com / software - development / python / code / 260268 / restart - your - python - program to support updating the settings since mopidy is not able to do that yet Restarts the current program Note : this function does not return . Any cleanup action ( like saving data ) must be done before calling this function<CODESPLIT>def restart_program ( ) : python = sys . executable os . execl ( python , python , * sys . argv )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file is a regular file and is readable .<CODESPLIT>def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the received object as precise as possible .<CODESPLIT>def _repr ( obj ) : vals = ", " . join ( "{}={!r}" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = "{}(name={}, {})" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = "{}(name={})" . format ( obj . __class__ . __name__ , obj . name ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap vertical table in a function for TabularOutputFormatter .<CODESPLIT>def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the column width .<CODESPLIT>def _column_resized ( self , col , old_width , new_width ) : self . dataTable . setColumnWidth ( col , new_width ) self . _update_layout ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the largest real value h such that all elements in x are integer multiples of h .<CODESPLIT>def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .<CODESPLIT>def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the date is at the end of the month<CODESPLIT>def is_end_of_month ( self ) -> bool : end_of_month = Datum ( ) # get_end_of_month(value) end_of_month . end_of_month ( ) return self . value == end_of_month . value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the passed variable is a tuple with two floats or integers<CODESPLIT>def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple from parsing a b c d - > ( a b c d )<CODESPLIT>def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Outputs a string to the console ( stdout ) .<CODESPLIT>def out ( self , output , newline = True ) : click . echo ( output , nl = newline )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats Python code to conform to the PEP 8 style guide .<CODESPLIT>def rpc_fix_code_with_black ( self , source , directory ) : source = get_source ( source ) return fix_code_with_black ( source , directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a substring delimited by start and end position .<CODESPLIT>def _mid ( string , start , end = None ) : if end is None : end = len ( string ) return string [ start : start + end ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse an ISO format date ( YYYY - mm - dd ) .<CODESPLIT>def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount .<CODESPLIT>def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip the whitespace from all column names in the given DataFrame and return the result .<CODESPLIT>def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to a redis instance .<CODESPLIT>def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whitespace normalization :<CODESPLIT>def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return "\n" . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a python string to C string .<CODESPLIT>def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manipulate json data on the fly<CODESPLIT>def set_json_item ( key , value ) : data = get_json ( ) data [ key ] = value request = get_request ( ) request [ "BODY" ] = json . dumps ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If item is not in lst add item to list at its sorted position<CODESPLIT>def insort_no_dup ( lst , item ) : import bisect ix = bisect . bisect_left ( lst , item ) if lst [ ix ] != item : lst [ ix : ix ] = [ item ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this attribute present?<CODESPLIT>def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats Python code to conform to the PEP 8 style guide .<CODESPLIT>def rpc_fix_code ( self , source , directory ) : source = get_source ( source ) return fix_code ( source , directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a confusion matrix returns the accuracy . Accuracy Definition : http : // research . ics . aalto . fi / events / eyechallenge2005 / evaluation . shtml<CODESPLIT>def accuracy ( conf_matrix ) : total , correct = 0.0 , 0.0 for true_response , guess_dict in conf_matrix . items ( ) : for guess , count in guess_dict . items ( ) : if true_response == guess : correct += count total += count return correct / total
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if the step table exists<CODESPLIT>def step_table_made ( self ) : try : empty = self . step_table . empty except AttributeError : empty = True return not empty
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove key from dict and return value .<CODESPLIT>def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns uptime in seconds or None on Syllable .<CODESPLIT>def _uptime_syllable ( ) : global __boottime try : __boottime = os . stat ( '/dev/pty/mst/pty0' ) . st_mtime return time . time ( ) - __boottime except ( NameError , OSError ) : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>* Get the root path for this python package - used in unit testing code *<CODESPLIT>def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + "/../" return packagePath
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log - normal function from scipy<CODESPLIT>def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a single document from the collection this class is bound to . Additional arguments are processed according to _prepare_find prior to passing to PyMongo where positional parameters are interpreted as query fragments parametric keyword arguments combined and other keyword arguments passed along with minor transformation . Automatically calls to_mongo with the retrieved data . https : // api . mongodb . com / python / current / api / pymongo / collection . html#pymongo . collection . Collection . find_one<CODESPLIT>def find_one ( cls , * args , * * kw ) : if len ( args ) == 1 and not isinstance ( args [ 0 ] , Filter ) : args = ( getattr ( cls , cls . __pk__ ) == args [ 0 ] , ) Doc , collection , query , options = cls . _prepare_find ( * args , * * kw ) result = Doc . from_mongo ( collection . find_one ( query , * * options ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a Path or string is a file on the file system .<CODESPLIT>def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if dtype is a numeric type .<CODESPLIT>def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the module name associated with a frame num_frames_back in the call stack . This function adds 1 to account for itself so num_frames_back should be given relative to the caller .<CODESPLIT>def _module_name_from_previous_frame ( num_frames_back ) : frm = inspect . stack ( ) [ num_frames_back + 1 ] return inspect . getmodule ( frm [ 0 ] ) . __name__
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like print but a function . I . e . prints out all arguments as print would do . Specify output stream like this ::<CODESPLIT>def prin ( * args , * * kwargs ) : print >> kwargs . get ( 'out' , None ) , " " . join ( [ str ( arg ) for arg in args ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Digits needed to comforatbly display values in [ minval maxval ]<CODESPLIT>def _digits ( minval , maxval ) : if minval == maxval : return 3 else : return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add dots .<CODESPLIT>def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for generating tagNameConverter Makes dict that maps from key to value and back<CODESPLIT>def makeBiDirectional ( d ) : dTmp = d . copy ( ) for k in d : dTmp [ d [ k ] ] = k return dTmp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string column into datetime column<CODESPLIT>def convert_str_to_datetime ( df , * , column : str , format : str ) : df [ column ] = pd . to_datetime ( df [ column ] , format = format ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix inversion op .<CODESPLIT>def MatrixInverse ( a , adj ) : return np . linalg . inv ( a if not adj else _adjoint ( a ) ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forward mouse cursor position events to the example<CODESPLIT>def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert input argument to bytes<CODESPLIT>def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matthews correlation coefficient<CODESPLIT>def mcc ( y , z ) : tp , tn , fp , fn = contingency_table ( y , z ) return ( tp * tn - fp * fn ) / K . sqrt ( ( tp + fp ) * ( tp + fn ) * ( tn + fp ) * ( tn + fn ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a form value from the request .<CODESPLIT>def parse_form ( self , req , name , field ) : return get_value ( req . body_arguments , name , field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get rid of all axis ticks lines etc .<CODESPLIT>def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the sentence or fragment begins with one of the parts of speech in the list else False<CODESPLIT>def _begins_with_one_of ( sentence , parts_of_speech ) : doc = nlp ( sentence ) if doc [ 0 ] . tag_ in parts_of_speech : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverse op .<CODESPLIT>def ReverseV2 ( a , axes ) : idxs = tuple ( slice ( None , None , 2 * int ( i not in axes ) - 1 ) for i in range ( len ( a . shape ) ) ) return np . copy ( a [ idxs ] ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rollback MySQL Transaction to database . MySQLDB : If the database and tables support transactions this rolls back ( cancels ) the current transaction ; otherwise a NotSupportedError is raised .<CODESPLIT>def rollback ( self ) : try : if self . connection is not None : self . connection . rollback ( ) self . _updateCheckTime ( ) self . release ( ) except Exception , e : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hides the main window of the terminal and sets the visible flag to False .<CODESPLIT>def hide ( self ) : if not HidePrevention ( self . window ) . may_hide ( ) : return self . hidden = True self . get_widget ( 'window-root' ) . unstick ( ) self . window . hide ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the dev_info data from a dictionary .<CODESPLIT>def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove null items from a dictionary<CODESPLIT>def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output data as a nicely - formatted python data structure<CODESPLIT>def py ( self , output ) : import pprint pprint . pprint ( output , stream = self . outfile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rewrite a file adding a line to its beginning .<CODESPLIT>def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JsonResponse . Make sure you have django installed first .<CODESPLIT>def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rewrite a file adding a line to its beginning .<CODESPLIT>def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>There s probably a way to do this with string functions but I was lazy . Replace all instances of \ r or \ n in a string with something else .<CODESPLIT>def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = "" for segment in segments : string += segment return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output<CODESPLIT>def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a horizontal line up to a given length .<CODESPLIT>def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rounds a float value off to the desired precision<CODESPLIT>def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The how well do the features plus a constant base rate sum up to the model output .<CODESPLIT>def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cast uint32 RGB image to 4 uint8 channels .<CODESPLIT>def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a stdout and print it s lines to output if lines are present .<CODESPLIT>def report_stdout ( host , stdout ) : lines = stdout . readlines ( ) if lines : print ( "STDOUT from {host}:" . format ( host = host ) ) for line in lines : print ( line . rstrip ( ) , file = sys . stdout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load a FASTA file and return the sequences as a list of SeqRecords<CODESPLIT>def load_fasta_file ( filename ) : with open ( filename , "r" ) as handle : records = list ( SeqIO . parse ( handle , "fasta" ) ) return records
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use top_k to sort a Tensor along the last dimension .<CODESPLIT>def _sort_tensor ( tensor ) : sorted_ , _ = tf . nn . top_k ( tensor , k = tf . shape ( input = tensor ) [ - 1 ] ) sorted_ . set_shape ( tensor . shape ) return sorted_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For a range indicated from start to end replace with replacement .<CODESPLIT>def _replace_token_range ( tokens , start , end , replacement ) : tokens = tokens [ : start ] + replacement + tokens [ end : ] return tokens
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ANSI Escape sequences http : // ascii - table . com / ansi - escape - sequences . php<CODESPLIT>def position ( self , x , y , text ) : sys . stdout . write ( "\x1b7\x1b[%d;%df%s\x1b8" % ( x , y , text ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to render a list of dictionaries as an HTML display object .<CODESPLIT>def _render_table ( data , fields = None ) : return IPython . core . display . HTML ( datalab . utils . commands . HtmlBuilder . render_table ( data , fields ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if end - of - file is reached for file fd .<CODESPLIT>def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>searchs a value in a dicionary and returns the key of the first occurrence<CODESPLIT>def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the unnormalized PDF of the normal distribution .<CODESPLIT>def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all rows from a cursor as a list of : class : OrderedDict objects .<CODESPLIT>def dictfetchall ( cursor : Cursor ) -> List [ Dict [ str , Any ] ] : columns = get_fieldnames_from_cursor ( cursor ) return [ OrderedDict ( zip ( columns , row ) ) for row in cursor . fetchall ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse an ISO format date ( YYYY - mm - dd ) .<CODESPLIT>def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert special characters using %xx escape .<CODESPLIT>def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function used to fit the exponential decay .<CODESPLIT>def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if there is an invalid digit in the input number . Args : number : An number in the following form : ( int int int ... . int int int ) ( iterable container ) containing positive integers of the input base input_base ( int ) : The base of the input number . Returns : bool True if all digits valid else False . Examples : >>> check_valid (( 1 9 6 . 5 1 6 ) 12 ) True >>> check_valid (( 8 1 15 9 ) 15 ) False<CODESPLIT>def check_valid ( number , input_base = 10 ) : for n in number : if n in ( "." , "[" , "]" ) : continue elif n >= input_base : if n == 1 and input_base == 1 : continue else : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform column - stacking on a list of 2d data blocks .<CODESPLIT>def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function<CODESPLIT>def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit without garbage collection this speeds up exit by about 10ms for things like bash completion .<CODESPLIT>def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises an AssertionError if expected is actual .<CODESPLIT>def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , "is" , extra )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does a string replace with a list of search and replacements<CODESPLIT>def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>extract features in a sentence<CODESPLIT>def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge modified objects into parent transaction .<CODESPLIT>def commit ( self , session = None ) : if self . __cleared : return if self . _parent : # nested transaction self . _commit_parent ( ) else : self . _commit_repository ( ) self . _clear ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets all defaults for the given dictionary to those contained in a second defaults dictionary . This convenience method calls :<CODESPLIT>def setDictDefaults ( d , defaults ) : for key , val in defaults . items ( ) : d . setdefault ( key , val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shape a list of lists into the appropriate shape and data type<CODESPLIT>def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the index rank according to Bertran s notation .<CODESPLIT>def rank ( idx , dim ) : idxm = multi_index ( idx , dim ) out = 0 while idxm [ - 1 : ] == ( 0 , ) : out += 1 idxm = idxm [ : - 1 ] return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function for loading yaml - encoded data from disk .<CODESPLIT>def load_yaml ( filepath ) : with open ( filepath ) as f : txt = f . read ( ) return yaml . load ( txt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return True if the current distribution is running on debian like OS .<CODESPLIT>def is_archlinux ( ) : if platform . system ( ) . lower ( ) == 'linux' : if platform . linux_distribution ( ) == ( '' , '' , '' ) : # undefined distribution. Fixed in python 3. if os . path . exists ( '/etc/arch-release' ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an iterator over the values of a dictionary .<CODESPLIT>def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if the guessed mimetyped isnt t in text group .<CODESPLIT>def IsBinary ( self , filename ) : mimetype = mimetypes . guess_type ( filename ) [ 0 ] if not mimetype : return False # e.g. README, "real" binaries usually have an extension # special case for text files which don't start with text/ if mimetype in TEXT_MIMETYPES : return False return not mimetype . startswith ( "text/" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Erases n lines from the screen and moves the cursor up to follow<CODESPLIT>def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ "up" ] , end = "" ) print ( codes . cursor [ "eol" ] , end = "" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply transforms to the data and predict with the final estimator<CODESPLIT>def predict ( self , X ) : Xt , _ , _ = self . _transform ( X ) return self . _final_estimator . predict ( Xt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim the trailing silence of the pianoroll .<CODESPLIT>def trim_trailing_silence ( self ) : length = self . get_active_length ( ) self . pianoroll = self . pianoroll [ : length ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts query strings into native Python objects<CODESPLIT>def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a float to a precision<CODESPLIT>def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Re - raises the error that was processed by prepare_for_reraise earlier .<CODESPLIT>def reraise ( error ) : if hasattr ( error , "_type_" ) : six . reraise ( type ( error ) , error , error . _traceback ) raise error
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Order - preserving sorting function .<CODESPLIT>def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dump single enum type . Keyword arguments : top -- top namespace<CODESPLIT>def _dump_enum ( self , e , top = '' ) : self . _print ( ) self . _print ( 'enum {} {{' . format ( e . name ) ) self . defines . append ( '{}.{}' . format ( top , e . name ) ) self . tabs += 1 for v in e . value : self . _print ( '{} = {};' . format ( v . name , v . number ) ) self . tabs -= 1 self . _print ( '}' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets all defaults for the given dictionary to those contained in a second defaults dictionary . This convenience method calls :<CODESPLIT>def setDictDefaults ( d , defaults ) : for key , val in defaults . items ( ) : d . setdefault ( key , val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if USB is on and device is ready by verifying adb devices .<CODESPLIT>def is_adb_detectable ( self ) : serials = list_adb_devices ( ) if self . serial in serials : self . log . debug ( 'Is now adb detectable.' ) return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return :<CODESPLIT>def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Parses a string into a list of pairs .<CODESPLIT>def _parse_string_to_list_of_pairs ( s , seconds_to_int = False ) : ret = [ ] for p in [ s . split ( ":" ) for s in re . sub ( "[,.;]" , " " , s ) . split ( ) ] : if len ( p ) != 2 : raise ValueError ( "bad input to _parse_string_to_list_of_pairs %s" % s ) if seconds_to_int : ret . append ( ( p [ 0 ] , int ( p [ 1 ] ) ) ) else : ret . append ( tuple ( p ) ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the eigvals of mat and then find the center eigval difference .<CODESPLIT>def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print just one that returns what you give it instead of None<CODESPLIT>def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ideally we shouldn t lose the first second of events<CODESPLIT>def main ( ) : time . sleep ( 1 ) with Input ( ) as input_generator : for e in input_generator : print ( repr ( e ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find leftmost item greater than or equal to x .<CODESPLIT>def find_ge ( a , x ) : i = bs . bisect_left ( a , x ) if i != len ( a ) : return i raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build the header<CODESPLIT>def format_op_hdr ( ) : txt = 'Base Filename' . ljust ( 36 ) + ' ' txt += 'Lines' . rjust ( 7 ) + ' ' txt += 'Words' . rjust ( 7 ) + '  ' txt += 'Unique' . ljust ( 8 ) + '' return txt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>save something to a pickle file<CODESPLIT>def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , "wb" ) , pickle . HIGHEST_PROTOCOL ) return thing
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bootstrapped mean with confidence limits<CODESPLIT>def mean_cl_boot ( series , n_samples = 1000 , confidence_interval = 0.95 , random_state = None ) : return bootstrap_statistics ( series , np . mean , n_samples = n_samples , confidence_interval = confidence_interval , random_state = random_state )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .<CODESPLIT>def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1 - farthest apart ( same number of words all diff ) . 0 - same<CODESPLIT>def levenshtein_distance_metric ( a , b ) : return ( levenshtein_distance ( a , b ) / ( 2.0 * max ( len ( a ) , len ( b ) , 1 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create directory with template for topic of the current environment<CODESPLIT>def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Truncates a value to a number of decimals places<CODESPLIT>def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decodes a given base64 string into bytes .<CODESPLIT>def decode_bytes ( string ) : if is_string_type ( type ( string ) ) : string = bytes ( string , "utf-8" ) return base64 . decodebytes ( string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds execute permission to file . : param filename : : return :<CODESPLIT>def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Replace all ( frm to ) tuples in args in string s .<CODESPLIT>def replaceStrs ( s , * args ) : if args == ( ) : return s mapping = dict ( ( frm , to ) for frm , to in args ) return re . sub ( "|" . join ( map ( re . escape , mapping . keys ( ) ) ) , lambda match : mapping [ match . group ( 0 ) ] , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a comma separated option into a list .<CODESPLIT>def split_comma_argument ( comma_sep_str ) : terms = [ ] for term in comma_sep_str . split ( ',' ) : if term : terms . append ( term ) return terms
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requests - mock requests . post wrapper .<CODESPLIT>def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whitespace normalization :<CODESPLIT>def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return "\n" . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - negative integer .<CODESPLIT>def is_natural ( x ) : try : is_integer = int ( x ) == x except ( TypeError , ValueError ) : return False return is_integer and x >= 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a histogram for the data to the axes .<CODESPLIT>def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = "left" , density = True , * * kwargs ) return ax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create database tables from sqlalchemy models<CODESPLIT>def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip excess spaces from a string<CODESPLIT>def strip_spaces ( s ) : return u" " . join ( [ c for c in s . split ( u' ' ) if c ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does openat read - only then does fdopen to get a file object<CODESPLIT>def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can edit this object<CODESPLIT>def has_edit_permission ( self , request ) : return request . user . is_authenticated and request . user . is_active and request . user . is_staff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prepare test for singleton property .<CODESPLIT>def step_impl06 ( context ) : store = context . SingleStore context . st_1 = store ( ) context . st_2 = store ( ) context . st_3 = store ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rounds a float value off to the desired precision<CODESPLIT>def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function for conversion of various data types into numeric representation .<CODESPLIT>def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for inserting int64 features into Example proto .<CODESPLIT>def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resets the scale on this image . Correctly aligns time scale undoes manual scaling<CODESPLIT>def resetScale ( self ) : self . img . scale ( 1. / self . imgScale [ 0 ] , 1. / self . imgScale [ 1 ] ) self . imgScale = ( 1. , 1. )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the pattern matches anywhere in the string s .<CODESPLIT>def matches ( self , s ) : regex_matches = self . compiled_regex . search ( s ) is not None return not regex_matches if self . inverted else regex_matches
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a python string to C string .<CODESPLIT>def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function used for joins builds left and right join list for join function<CODESPLIT>def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempt to guess the title from the filename<CODESPLIT>def guess_title ( basename ) : base , _ = os . path . splitext ( basename ) return re . sub ( r'[ _-]+' , r' ' , base ) . title ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if value value is empty . Keyword arguments : value str -- the value of the associated field to compare<CODESPLIT>def run ( self , value ) : if self . pass_ and not value . strip ( ) : return True if not value : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a stringified representation of this object .<CODESPLIT>def __repr__ ( self ) : return str ( { 'name' : self . _name , 'watts' : self . _watts , 'type' : self . _output_type , 'id' : self . _integration_id } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse ISO8601 timestamps given by github API .<CODESPLIT>def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to run commands synchronously for testing .<CODESPLIT>def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( "Event loop is already running." ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log memory usage before and after a method .<CODESPLIT>def memory_usage ( method ) : def wrapper ( * args , * * kwargs ) : logging . info ( 'Memory before method %s is %s.' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) result = method ( * args , * * kwargs ) logging . info ( 'Memory after method %s is %s' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) return result return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the value of the other type instance to use in an operator method namely when the method s instance is on the left side of the expression .<CODESPLIT>def value_left ( self , other ) : return other . value if isinstance ( other , self . __class__ ) else other
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>determines whether the card number is valid .<CODESPLIT>def is_valid ( number ) : n = str ( number ) if not n . isdigit ( ) : return False return int ( n [ - 1 ] ) == get_check_digit ( n [ : - 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>HTTP request method of interface implementation .<CODESPLIT>def _request ( self , method : str , endpoint : str , params : dict = None , data : dict = None , headers : dict = None ) -> dict :
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Purely a debugging aid : Ascii - art picture of a tree descended from node<CODESPLIT>def debugTreePrint ( node , pfx = "->" ) : print pfx , node . item for c in node . children : debugTreePrint ( c , "  " + pfx )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert dict of ascii str / unicode to dict of str if necessary<CODESPLIT>def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialise sets used for uniqueness checking .<CODESPLIT>def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find longest ORF from the given list of ORFs .<CODESPLIT>def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Directly send utf8 bytes to stdout<CODESPLIT>def imp_print ( self , text , end ) : sys . stdout . write ( ( text + end ) . encode ( "utf-8" ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JsonResponse . Make sure you have django installed first .<CODESPLIT>def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method for just changing font size .<CODESPLIT>def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decorator to convert a method taking a iterable to a * args one<CODESPLIT>def _iterable_to_varargs_method ( func ) : def wrapped ( self , * args , * * kwargs ) : return func ( self , args , * * kwargs ) return wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper to clean up an input string<CODESPLIT>def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace masked - out elements in an array using an iterative image inpainting algorithm .<CODESPLIT>def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a millisecond accuracy timestamp to a datetime<CODESPLIT>def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pops multiple keys off a dict like object<CODESPLIT>def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert to datetime to UTC offset .<CODESPLIT>def convert_2_utc ( self , datetime_ , timezone ) : datetime_ = self . tz_mapper [ timezone ] . localize ( datetime_ ) return datetime_ . astimezone ( pytz . UTC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if the specified file / folder exists even if it is on a remote server .<CODESPLIT>def exists ( self , filepath ) : if self . is_ssh ( filepath ) : self . _check_ftp ( ) remotepath = self . _get_remote ( filepath ) try : self . ftp . stat ( remotepath ) except IOError as e : if e . errno == errno . ENOENT : return False else : return True else : return os . path . exists ( filepath )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : size of the entire schema in bytes<CODESPLIT>def size_on_disk ( self ) : return int ( self . connection . query ( """             SELECT SUM(data_length + index_length)             FROM information_schema.tables WHERE table_schema='{db}'             """ . format ( db = self . database ) ) . fetchone ( ) [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Combine PDFs and return a byte - string with the result .<CODESPLIT>def combine_pdf_as_bytes ( pdfs : List [ BytesIO ] ) -> bytes : writer = PdfWriter ( ) for pdf in pdfs : writer . addpages ( PdfReader ( pdf ) . pages ) bio = BytesIO ( ) writer . write ( bio ) bio . seek ( 0 ) output = bio . read ( ) bio . close ( ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plot the empirical histogram versus best - fit distribution s PDF .<CODESPLIT>def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the content of the zip - file at zip_path into target_folder .<CODESPLIT>def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an OrderedDict containing C values to a 1D array .<CODESPLIT>def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Advances to next line .<CODESPLIT>def advance_one_line ( self ) : current_line = self . _current_token . line_number while current_line == self . _current_token . line_number : self . _current_token = ConfigParser . Token ( * next ( self . _token_generator ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the greatest common divisor for a sequence of numbers . Uses a numerical tolerance so can be used on floats<CODESPLIT>def gcd_float ( numbers , tol = 1e-8 ) : def pair_gcd_tol ( a , b ) : """Calculate the Greatest Common Divisor of a and b.          Unless b==0, the result will have the same sign as b (so that when         b is divided by it, the result comes out positive).         """ while b > tol : a , b = b , a % b return a n = numbers [ 0 ] for i in numbers : n = pair_gcd_tol ( n , i ) return n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts an ARRAY string stored in the database back into a Numpy array .<CODESPLIT>def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manually shutdown the async API .<CODESPLIT>def shutdown ( ) : global handler , transport , protocol if handler is not None : handler . close ( ) transport . close ( ) handler = None transport = None protocol = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>history Display a list of commands that have been entered .<CODESPLIT>def do_history ( self , line ) : self . _split_args ( line , 0 , 0 ) for idx , item in enumerate ( self . _history ) : d1_cli . impl . util . print_info ( "{0: 3d} {1}" . format ( idx , item ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extracts all integers from a string an return them in a list<CODESPLIT>def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def generate_random_string ( chars = 7 ) : return u"" . join ( random . sample ( string . ascii_letters * 2 + string . digits , chars ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the given time into HH : MM : SS<CODESPLIT>def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return "%02d:%02d:%02d" % ( h , m , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn dict keys and values into native strings .<CODESPLIT>def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The current position of the cursor .<CODESPLIT>def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the index of an element in the list .<CODESPLIT>def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose k random elements of array .<CODESPLIT>def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates sql datetime2 object from Python datetime object ignoring timezone<CODESPLIT>def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Localize a datetime object to local time .<CODESPLIT>def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a 2D numpy array of bools<CODESPLIT>def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove instance from model<CODESPLIT>def remove_instance ( self , item ) : self . instances . remove ( item ) self . remove_item ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cast uint32 RGB image to 4 uint8 channels .<CODESPLIT>def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for plotting .<CODESPLIT>def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A datetime - version that takes datetime object list as x_axis<CODESPLIT>def spline_interpolate_by_datetime ( datetime_axis , y_axis , datetime_new_axis ) : numeric_datetime_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_axis ] numeric_datetime_new_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_new_axis ] return spline_interpolate ( numeric_datetime_axis , y_axis , numeric_datetime_new_axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the sum of a and b .<CODESPLIT>def pair_strings_sum_formatter ( a , b ) : if b [ : 1 ] == "-" : return "{0} - {1}" . format ( a , b [ 1 : ] ) return "{0} + {1}" . format ( a , b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Locate the command s man page .<CODESPLIT>def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace month strings occurrences with month number .<CODESPLIT>def replace_month_abbr_with_num ( date_str , lang = DEFAULT_DATE_LANG ) : num , abbr = get_month_from_date_str ( date_str , lang ) return re . sub ( abbr , str ( num ) , date_str , flags = re . IGNORECASE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove html code contained into the given string .<CODESPLIT>def strip_html ( string , keep_tag_content = False ) : r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE return r . sub ( '' , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get actual tree selection object and all respective models of selected rows<CODESPLIT>def get_view_selection ( self ) : if not self . MODEL_STORAGE_ID : return None , None # avoid selection requests on empty tree views -> case warnings in gtk3 if len ( self . store ) == 0 : paths = [ ] else : model , paths = self . _tree_selection . get_selected_rows ( ) # get all related models for selection from respective tree store field selected_model_list = [ ] for path in paths : model = self . store [ path ] [ self . MODEL_STORAGE_ID ] selected_model_list . append ( model ) return self . _tree_selection , selected_model_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the value of a local variable somewhere in the call stack .<CODESPLIT>def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the value of a property or the default one<CODESPLIT>def get_prop_value ( name , props , default = None ) : # type: (str, Dict[str, Any], Any) -> Any if not props : return default try : return props [ name ] except KeyError : return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a function that will call a named method on the target object with optional positional and keyword arguments .<CODESPLIT>def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the lowercase chars in the given string .<CODESPLIT>def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start web application<CODESPLIT>def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Square of the euclidean distance<CODESPLIT>def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort data rows and order columns<CODESPLIT>def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An enum is encoded by a int representing the zero - based position of the symbol in the schema .<CODESPLIT>def write_enum ( fo , datum , schema ) : index = schema [ 'symbols' ] . index ( datum ) write_int ( fo , index )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a block of data and parse using the given protobuf object .<CODESPLIT>def read_proto_object ( fobj , klass ) : log . debug ( '%s chunk' , klass . __name__ ) obj = klass ( ) obj . ParseFromString ( read_block ( fobj ) ) log . debug ( 'Header: %s' , str ( obj ) ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a section a subsection and some text to the document .<CODESPLIT>def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute summary statistics of a unique ( S_TYPE_UNIQUE ) variable ( a Series ) .<CODESPLIT>def describe_unique_1d ( series ) : return pd . Series ( [ base . S_TYPE_UNIQUE ] , index = [ 'type' ] , name = series . name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Install or upgrade setuptools and EasyInstall<CODESPLIT>def main ( argv , version = DEFAULT_VERSION ) : tarball = download_setuptools ( ) _install ( tarball , _build_install_args ( argv ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Re - index every document in a named index .<CODESPLIT>def update_index ( index ) : logger . info ( "Updating search index: '%s'" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( "Updating search index model: '%s'" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = "index" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( "chunk_size" ) ) responses . append ( response ) return responses
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns Gaussian smoothed image .<CODESPLIT>def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = "nearest" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a ctypes void pointer to the memory mapped region .<CODESPLIT>def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Confusion matrix plot<CODESPLIT>def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test whether a path exists and is readable . Returns None for broken symbolic links or a failing stat () and False if the file exists but does not have read permission . True is returned if the file is readable .<CODESPLIT>def readable ( path ) : try : st = os . stat ( path ) return 0 != st . st_mode & READABLE_MASK except os . error : return None return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pure - Python implementation of itertools . combinations ( l 2 ) .<CODESPLIT>def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a remote api method but don t raise if an error occurred .<CODESPLIT>def safe_call ( cls , method , * args ) : return cls . call ( method , * args , safe = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if value is an instance of int .<CODESPLIT>def test_value ( self , value ) : if not isinstance ( value , int ) : raise ValueError ( 'expected int value: ' + str ( type ( value ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new : class : DataFrame containing rows only in both this frame and another frame .<CODESPLIT>def intersect ( self , other ) : return DataFrame ( self . _jdf . intersect ( other . _jdf ) , self . sql_ctx )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Represent string / bytes s as base64 omitting newlines<CODESPLIT>def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( "utf-8" ) return binascii . b2a_base64 ( s ) [ : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If called after an update the sprite can move back<CODESPLIT>def move_back ( self , dt ) : self . _position = self . _old_position self . rect . topleft = self . _position self . feet . midbottom = self . rect . midbottom
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Drops the trailinz zeros from decimal value . Returns a string<CODESPLIT>def drop_trailing_zeros_decimal ( num ) : out = str ( num ) return out . rstrip ( '0' ) . rstrip ( '.' ) if '.' in out else out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get list of datetime objects extracted from a filename<CODESPLIT>def get_dt_list ( fn_list ) : dt_list = np . array ( [ fn_getdatetime ( fn ) for fn in fn_list ] ) return dt_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .<CODESPLIT>def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Under UNIX : is a keystroke available?<CODESPLIT>def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse datetime .<CODESPLIT>def parse_datetime ( dt_str ) : date_format = "%Y-%m-%dT%H:%M:%S %z" dt_str = dt_str . replace ( "Z" , " +0000" ) return datetime . datetime . strptime ( dt_str , date_format )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that verify if the header parameter is a essential header<CODESPLIT>def required_header ( header ) : if header in IGNORE_HEADERS : return False if header . startswith ( 'HTTP_' ) or header == 'CONTENT_TYPE' : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like dict ( ** kwargs ) but where the source key is special .<CODESPLIT>def _sourced_dict ( self , source = None , * * kwargs ) : if source : kwargs [ 'source' ] = source elif self . source : kwargs [ 'source' ] = self . source return kwargs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a UUID object to a 22 - char BUID string<CODESPLIT>def uuid2buid ( value ) : if six . PY3 : # pragma: no cover return urlsafe_b64encode ( value . bytes ) . decode ( 'utf-8' ) . rstrip ( '=' ) else : return six . text_type ( urlsafe_b64encode ( value . bytes ) . rstrip ( '=' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if list contains either values of type vtype or None .<CODESPLIT>def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use Python % format strings as template format specifiers .<CODESPLIT>def PythonPercentFormat ( format_str ) : if format_str . startswith ( 'printf ' ) : fmt = format_str [ len ( 'printf ' ) : ] return lambda value : fmt % value else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print a CSV file .<CODESPLIT>def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the data where the expression is normalized so that the total count per cell is equal .<CODESPLIT>def cell_normalize ( data ) : if sparse . issparse ( data ) : data = sparse . csc_matrix ( data . astype ( float ) ) # normalize in-place sparse_cell_normalize ( data . data , data . indices , data . indptr , data . shape [ 1 ] , data . shape [ 0 ] ) return data data_norm = data . astype ( float ) total_umis = [ ] for i in range ( data . shape [ 1 ] ) : di = data_norm [ : , i ] total_umis . append ( di . sum ( ) ) di /= total_umis [ i ] med = np . median ( total_umis ) data_norm *= med return data_norm
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the given value is a function or method object .<CODESPLIT>def isfunc ( x ) : return any ( [ inspect . isfunction ( x ) and not asyncio . iscoroutinefunction ( x ) , inspect . ismethod ( x ) and not asyncio . iscoroutinefunction ( x ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a string and dictionary . replaces all occurrences of i with j<CODESPLIT>def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .<CODESPLIT>def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>parse_query_string : very simplistic . won t do the right thing with list values<CODESPLIT>def parse_query_string ( query ) : result = { } qparts = query . split ( '&' ) for item in qparts : key , value = item . split ( '=' ) key = key . strip ( ) value = value . strip ( ) result [ key ] = unquote_plus ( value ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>imshow without interpolation like as matshow : param args : : param kwargs : : return :<CODESPLIT>def matshow ( * args , * * kwargs ) : kwargs [ 'interpolation' ] = kwargs . pop ( 'interpolation' , 'none' ) return plt . imshow ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a hash of a NumPy array .<CODESPLIT>def np_hash ( a ) : if a is None : return hash ( None ) # Ensure that hashes are equal whatever the ordering in memory (C or # Fortran) a = np . ascontiguousarray ( a ) # Compute the digest and return a decimal int return int ( hashlib . sha1 ( a . view ( a . dtype ) ) . hexdigest ( ) , 16 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a hash of the contents of a dictionary<CODESPLIT>def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert this confusion matrix into a 2x2 plain list of values .<CODESPLIT>def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a list of the top topn features in this : class : . Feature \ .<CODESPLIT>def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a string for screen printing .<CODESPLIT>def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Advance the iterator without returning the old head .<CODESPLIT>def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional<CODESPLIT>def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a datetime object of a given timestamp ( in local tz ) .<CODESPLIT>def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print a binary tree<CODESPLIT>def print_bintree ( tree , indent = '  ' ) : for n in sorted ( tree . keys ( ) ) : print "%s%s" % ( indent * depth ( n , tree ) , n )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flat nested list of lists into a single list .<CODESPLIT>def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fast median operation for masked array using 50th - percentile<CODESPLIT>def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the value in arr that value is closest to<CODESPLIT>def _findNearest ( arr , value ) : arr = np . array ( arr ) # find nearest value in array idx = ( abs ( arr - value ) ) . argmin ( ) return arr [ idx ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the x - axis tick labels for a subplot .<CODESPLIT>def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove text nodes containing only whitespace<CODESPLIT>def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses a byte array containing a JSON document and returns a Python object . : param data : The byte array containing a JSON document . : param MimeType mimetype : The mimetype chose to parse the data . : return : A Python object .<CODESPLIT>def parse ( self , data , mimetype ) : encoding = mimetype . params . get ( 'charset' ) or 'utf-8' return json . loads ( data . decode ( encoding ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( Point Point ) - > Point Return the point that lies in between the two input points .<CODESPLIT>def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Renders a template from the given template source string with the given context .<CODESPLIT>def render_template_string ( source , * * context ) : ctx = _app_ctx_stack . top ctx . app . update_template_context ( context ) return _render ( ctx . app . jinja_env . from_string ( source ) , context , ctx . app )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a column of the given matrix .<CODESPLIT>def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disconnect from target .<CODESPLIT>async def disconnect ( self ) : if not self . connected : return self . writer . close ( ) self . reader = None self . writer = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return default argument value as given by argparse s add_argument () .<CODESPLIT>def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return file type icon<CODESPLIT>def get_filetype_icon ( fname ) : ext = osp . splitext ( fname ) [ 1 ] if ext . startswith ( '.' ) : ext = ext [ 1 : ] return get_icon ( "%s.png" % ext , ima . icon ( 'FileIcon' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read currency from windows registry<CODESPLIT>def __get_registry_key ( self , key ) : import winreg root = winreg . OpenKey ( winreg . HKEY_CURRENT_USER , r'SOFTWARE\GSettings\org\gnucash\general' , 0 , winreg . KEY_READ ) [ pathname , regtype ] = ( winreg . QueryValueEx ( root , key ) ) winreg . CloseKey ( root ) return pathname
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms a DataFrame in place . Computes all outputs of the DataFrame .<CODESPLIT>def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ajout d un message de log de type DEBUG<CODESPLIT>def debug ( self , text ) : self . logger . debug ( "{}{}" . format ( self . message_prefix , text ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .<CODESPLIT>def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string for various input types<CODESPLIT>def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same order unique list using only a list compression .<CODESPLIT>def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch an image from url and convert it into a Pillow Image object<CODESPLIT>def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses a date string formatted like YYYY - MM - DD .<CODESPLIT>def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Monkey - patch urllib3 with SecureTransport - backed SSL - support .<CODESPLIT>def inject_into_urllib3 ( ) : util . ssl_ . SSLContext = SecureTransportContext util . HAS_SNI = HAS_SNI util . ssl_ . HAS_SNI = HAS_SNI util . IS_SECURETRANSPORT = True util . ssl_ . IS_SECURETRANSPORT = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A non - optimal implementation of a regex filter<CODESPLIT>def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a section a subsection and some text to the document .<CODESPLIT>def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets tail<CODESPLIT>def get_tail ( self ) : node = self . head last_node = self . head while node is not None : last_node = node node = node . next_node return last_node
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the user a system administrator<CODESPLIT>def is_admin ( self ) : return self . role == self . roles . administrator . value and self . state == State . approved
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits<CODESPLIT>def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send signal to process .<CODESPLIT>def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>adds information to the sequence for better debugging currently only an index property on each point in the sequence .<CODESPLIT>def debug ( sequence ) : points = [ ] for i , p in enumerate ( sequence ) : copy = Point ( p ) copy [ 'index' ] = i points . append ( copy ) return sequence . __class__ ( points )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a Path or string is a file on the file system .<CODESPLIT>def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response .<CODESPLIT>def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == "POST" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == "OPTIONS" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: API : public<CODESPLIT>def assert_list ( self , putative_list , expected_type = string_types , key_arg = None ) : return assert_list ( putative_list , expected_type , key_arg = key_arg , raise_type = lambda msg : TargetDefinitionException ( self , msg ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emulate what a Python set () does but keeping the element s order .<CODESPLIT>def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert to datetime to UTC offset .<CODESPLIT>def convert_2_utc ( self , datetime_ , timezone ) : datetime_ = self . tz_mapper [ timezone ] . localize ( datetime_ ) return datetime_ . astimezone ( pytz . UTC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get width and height of a PDF<CODESPLIT>def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in string astr replace all occurences of thefind with thereplace<CODESPLIT>def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes a ( shell ) command in the background<CODESPLIT>def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check that all arrays have consistent first dimensions .<CODESPLIT>def check_consistent_length ( * arrays ) : uniques = np . unique ( [ _num_samples ( X ) for X in arrays if X is not None ] ) if len ( uniques ) > 1 : raise ValueError ( "Found arrays with inconsistent numbers of samples: %s" % str ( uniques ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The current active : class : . Window .<CODESPLIT>def get_active_window ( self ) : app = get_app ( ) try : return self . _active_window_for_cli [ app ] except KeyError : self . _active_window_for_cli [ app ] = self . _last_active_window or self . windows [ 0 ] return self . windows [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts query strings into native Python objects<CODESPLIT>def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a name in camelCase return in snake_case<CODESPLIT>def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\1_\2' , name ) return ALL_CAP_REGEX . sub ( r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) .<CODESPLIT>def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first location of the maximum value of x . The position is calculated relatively to the length of x .<CODESPLIT>def first_location_of_maximum ( x ) : if not isinstance ( x , ( np . ndarray , pd . Series ) ) : x = np . asarray ( x ) return np . argmax ( x ) / len ( x ) if len ( x ) > 0 else np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the size of a specific dimension .<CODESPLIT>def dimension_size ( x , axis ) : # Since tf.gather isn't "constant-in, constant-out", we must first check the # static shape or fallback to dynamic shape. s = tf . compat . dimension_value ( tensorshape_util . with_rank_at_least ( x . shape , np . abs ( axis ) ) [ axis ] ) if s is not None : return s return tf . shape ( input = x ) [ axis ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a boolean indicating if the code is executed inside softimage .<CODESPLIT>def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string into list of strings by specified number .<CODESPLIT>def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>We have a full length slice .<CODESPLIT>def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the list have unique items only and maintains the order<CODESPLIT>def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate<CODESPLIT>def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return list of Logger classes .<CODESPLIT>def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if outfile exists and is no older than base datetime .<CODESPLIT>def is_up_to_date ( outfile , basedatetime ) : # type: (AnyStr, datetime) -> bool if os . path . exists ( outfile ) : if os . path . getmtime ( outfile ) >= basedatetime : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Array of bytes<CODESPLIT>def barray ( iterlines ) : lst = [ line . encode ( 'utf-8' ) for line in iterlines ] arr = numpy . array ( lst ) return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return extension identifying format of given filename<CODESPLIT>def infer_format ( filename : str ) -> str : _ , ext = os . path . splitext ( filename ) return ext
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return current free memory on the machine for windows .<CODESPLIT>def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list possibly nested to any level return it flattened .<CODESPLIT>def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1<CODESPLIT>def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the string name of an enum value .<CODESPLIT>def EnumValueName ( self , enum , value ) : return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the id of the last written row in table<CODESPLIT>def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( "SELECT seq FROM sqlite_sequence WHERE name='{0}'" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Close all opened windows .<CODESPLIT>def close_all ( ) : # Windows can be closed by releasing all references to them so they can be # garbage collected. May not be necessary to call close(). global _qtg_windows for window in _qtg_windows : window . close ( ) _qtg_windows = [ ] global _qtg_widgets for widget in _qtg_widgets : widget . close ( ) _qtg_widgets = [ ] global _plt_figures for fig in _plt_figures : _ , plt , _ = _import_plt ( ) plt . close ( fig ) _plt_figures = [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an JavaRDD of Object by unpickling<CODESPLIT>def _to_java_object_rdd ( rdd ) : rdd = rdd . _reserialize ( AutoBatchedSerializer ( PickleSerializer ( ) ) ) return rdd . ctx . _jvm . org . apache . spark . ml . python . MLSerDe . pythonToJava ( rdd . _jrdd , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the ( name value ) pairs of the enum .<CODESPLIT>def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a dataframe and string - i - fy a column of values . Turn nan / None into and all other values into strings .<CODESPLIT>def stringify_col ( df , col_name ) : df = df . copy ( ) df [ col_name ] = df [ col_name ] . fillna ( "" ) df [ col_name ] = df [ col_name ] . astype ( str ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resursively create a named directory .<CODESPLIT>def makedirs ( directory ) : parent = os . path . dirname ( os . path . abspath ( directory ) ) if not os . path . exists ( parent ) : makedirs ( parent ) os . mkdir ( directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>shotcut to pull out useful info for interactive use<CODESPLIT>def stats ( self ) : printDebug ( "Classes.....: %d" % len ( self . all_classes ) ) printDebug ( "Properties..: %d" % len ( self . all_properties ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the list of all indexes of the given array .<CODESPLIT>def _indexes ( arr ) : myarr = np . array ( arr ) if myarr . ndim == 1 : return list ( range ( len ( myarr ) ) ) elif myarr . ndim == 2 : return tuple ( itertools . product ( list ( range ( arr . shape [ 0 ] ) ) , list ( range ( arr . shape [ 1 ] ) ) ) ) else : raise NotImplementedError ( 'Only supporting arrays of dimension 1 and 2 as yet.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A standard compound hash .<CODESPLIT>def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Search into instance attributes properties and return values of no - args methods .<CODESPLIT>def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exchange a code ( and state token ) for a bearer token<CODESPLIT>def fetch_token ( self , * * kwargs ) : return super ( AsanaOAuth2Session , self ) . fetch_token ( self . token_url , client_secret = self . client_secret , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets names of all methods implemented in specified object .<CODESPLIT>def get_method_names ( obj ) : method_names = [ ] for method_name in dir ( obj ) : method = getattr ( obj , method_name ) if MethodReflector . _is_method ( method , method_name ) : method_names . append ( method_name ) return method_names
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to camel case .<CODESPLIT>def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + "" . join ( x . title ( ) for x in split [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Similar to #itertools . chain . from_iterable () .<CODESPLIT>def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts query strings into native Python objects<CODESPLIT>def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the request headers .<CODESPLIT>def __call__ ( self , r ) : r . headers [ 'Authorization' ] = 'JWT {jwt}' . format ( jwt = self . token ) return r
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .<CODESPLIT>def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix solve op .<CODESPLIT>def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert datetime to epoch seconds .<CODESPLIT>def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the width ( in terms of space characters ) for tab characters .<CODESPLIT>def _set_tab_width ( self , tab_width ) : font_metrics = QtGui . QFontMetrics ( self . font ) self . _control . setTabStopWidth ( tab_width * font_metrics . width ( ' ' ) ) self . _tab_width = tab_width
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list copy in which each item occurs only once ( in - order ) .<CODESPLIT>def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read the sphinx environment . pickle file at path pth .<CODESPLIT>def read_sphinx_environment ( pth ) : with open ( pth , 'rb' ) as fo : env = pickle . load ( fo ) return env
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a digraph string fragment based on the passed - in module<CODESPLIT>def make_dep_graph ( depender ) : shutit_global . shutit_global_object . yield_to_draw ( ) digraph = '' for dependee_id in depender . depends_on : digraph = ( digraph + '"' + depender . module_id + '"->"' + dependee_id + '";\n' ) return digraph
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split text into list of sentences .<CODESPLIT>def split_into_sentences ( s ) : s = re . sub ( r"\s+" , " " , s ) s = re . sub ( r"[\\.\\?\\!]" , "\n" , s ) return s . split ( "\n" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns full ISO string for the given date<CODESPLIT>def to_iso_string ( self ) -> str : assert isinstance ( self . value , datetime ) return datetime . isoformat ( self . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new dict from an existing dict that only has the given keys<CODESPLIT>def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split message to list by commas and trim whitespace .<CODESPLIT>def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = "" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( "," ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get object from string reference .<CODESPLIT>def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if value is a valid UUID .<CODESPLIT>def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the RMS of the audio<CODESPLIT>def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flush all items from cache .<CODESPLIT>def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all child objects in nested lists of strings .<CODESPLIT>def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of the earliest occurence of an item from a list in a string<CODESPLIT>def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A very thin wrapper around textwrap . fill to consistently wrap documentation text for display in a command line environment . The text is wrapped to 99 characters with an indentation depth of 4 spaces . Each line is wrapped independently in order to preserve manually added line breaks .<CODESPLIT>def format_doc_text ( text ) : return '\n' . join ( textwrap . fill ( line , width = 99 , initial_indent = '    ' , subsequent_indent = '    ' ) for line in inspect . cleandoc ( text ) . splitlines ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like print_exc () but return a string . Backport for Python 2 . 3 .<CODESPLIT>def format_exc ( limit = None ) : try : etype , value , tb = sys . exc_info ( ) return '' . join ( traceback . format_exception ( etype , value , tb , limit ) ) finally : etype = value = tb = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trace every executed line .<CODESPLIT>def _trace_full ( frame , event , arg ) : if event == "line" : _trace_line ( frame , event , arg ) else : _trace ( frame , event , arg ) return _trace_full
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add an object to Javascript .<CODESPLIT>def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For a given value the function finds the nearest value in the array and returns its index .<CODESPLIT>def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Efficient conversion from scipy sparse matrix to cvxopt sparse matrix<CODESPLIT>def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate column - wise Pearson correlations using numpy . ma . corrcoef<CODESPLIT>def correlation ( df , rowvar = False ) : # Create a correlation matrix for all correlations # of the columns (filled with na for all values) df = df . copy ( ) maskv = np . ma . masked_where ( np . isnan ( df . values ) , df . values ) cdf = np . ma . corrcoef ( maskv , rowvar = False ) cdf = pd . DataFrame ( np . array ( cdf ) ) cdf . columns = df . columns cdf . index = df . columns cdf = cdf . sort_index ( level = 0 , axis = 1 ) cdf = cdf . sort_index ( level = 0 ) return cdf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a number to a precision<CODESPLIT>def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets<CODESPLIT>def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until the user accepted or rejected the request<CODESPLIT>def _wait_for_response ( self ) : while not self . server . response_code : time . sleep ( 2 ) time . sleep ( 5 ) self . server . shutdown ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if dtype is a numeric type .<CODESPLIT>def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform column - stacking on a list of 2d data blocks .<CODESPLIT>def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle linear / log scale for Y - axis .<CODESPLIT>def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to a list with sanitization .<CODESPLIT>def _str_to_list ( value , separator ) : value_list = [ item . strip ( ) for item in value . split ( separator ) ] value_list_sanitized = builtins . list ( filter ( None , value_list ) ) if len ( value_list_sanitized ) > 0 : return value_list_sanitized else : raise ValueError ( 'Invalid list variable.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>variance of the values must have 2 or more entries .<CODESPLIT>def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the progressbar .<CODESPLIT>def __call__ ( self , _ ) : if self . iter % self . step == 0 : self . pbar . update ( self . step ) self . iter += 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tuple describing range to read from the ndarray - closed : open<CODESPLIT>def _index_range ( self , version , symbol , from_version = None , * * kwargs ) : from_index = None if from_version : from_index = from_version [ 'up_to' ] return from_index , None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a dictionary of strings from a file<CODESPLIT>def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from a list preserving the order .<CODESPLIT>def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return matrix as csv data .<CODESPLIT>def csv_matrix_print ( classes , table ) : result = "" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + "," result = result [ : - 1 ] + "\n" return result [ : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a skew - symmetric cross - product matrix to its corresponding vector . Only works for 3x3 matrices .<CODESPLIT>def deskew ( S ) : x = np . zeros ( 3 ) x [ 0 ] = S [ 2 , 1 ] x [ 1 ] = S [ 0 , 2 ] x [ 2 ] = S [ 1 , 0 ] return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1<CODESPLIT>def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Google AppEngine Helper to convert a data type into a string .<CODESPLIT>def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Launches the django server at 127 . 0 . 0 . 1 : 8000<CODESPLIT>def launch_server ( ) : print ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) cur_dir = os . getcwd ( ) path = os . path . dirname ( os . path . abspath ( __file__ ) ) run = True os . chdir ( path ) os . system ( 'python manage.py runserver --nostatic' ) os . chdir ( cur_dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap standard function to easily pass into map processing .<CODESPLIT>def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a date into a datetime<CODESPLIT>def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the year .<CODESPLIT>def year ( date ) : try : fmt = '%m/%d/%Y' return datetime . strptime ( date , fmt ) . timetuple ( ) . tm_year except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets RAM memory usage<CODESPLIT>def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert list of key value lists to dict<CODESPLIT>def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compose all given tuples together .<CODESPLIT>def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A background thread to kill the process if it takes too long .<CODESPLIT>def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( "Killing program due to %f second timeout" % timeout ) os . _exit ( 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert JSON string to an ordered defaultdict .<CODESPLIT>def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If we re not on the first line ( of a multiline input ) go a line up otherwise go back in history . ( If nothing is selected . )<CODESPLIT>def auto_up ( self , count = 1 , go_to_start_of_line_if_history_changes = False ) : if self . complete_state : self . complete_previous ( count = count ) elif self . document . cursor_position_row > 0 : self . cursor_up ( count = count ) elif not self . selection_state : self . history_backward ( count = count ) # Go to the start of the line? if go_to_start_of_line_if_history_changes : self . cursor_position += self . document . get_start_of_line_position ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts Timestamp to datetime .<CODESPLIT>def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates and returns a month number basing on PESEL standard .<CODESPLIT>def calculate_month ( birth_date ) : year = int ( birth_date . strftime ( '%Y' ) ) month = int ( birth_date . strftime ( '%m' ) ) + ( ( int ( year / 100 ) - 14 ) % 5 ) * 20 return month
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>At least one of the items in value should match<CODESPLIT>def any_of ( value , * args ) : if len ( args ) : value = ( value , ) + args return ExpectationAny ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip out namespace data from an ElementTree .<CODESPLIT>def strip_xml_namespace ( root ) : try : root . tag = root . tag . split ( '}' ) [ 1 ] except IndexError : pass for element in root . getchildren ( ) : strip_xml_namespace ( element )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The default urlparse . urljoin behavior look strange Standard urlparse . urljoin ( http : // a . com / foo / bar ) Expect : http : // a . com / foo / bar Actually : http : // a . com / bar This function fix that .<CODESPLIT>def urljoin ( * urls ) : return reduce ( urlparse . urljoin , [ u . strip ( '/' ) + '/' for u in urls if u . strip ( '/' ) ] , '' ) . rstrip ( '/' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the longest path in a dag between two nodes<CODESPLIT>def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python 3 input () / Python 2 raw_input ()<CODESPLIT>def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wraps os . environ to filter out non - encodable values .<CODESPLIT>def _environment_variables ( ) -> Dict [ str , str ] : return { key : value for key , value in os . environ . items ( ) if _is_encodable ( value ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets<CODESPLIT>def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse an ISO format date ( YYYY - mm - dd ) .<CODESPLIT>def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type s : str : rtype : int<CODESPLIT>def first_unique_char ( s ) : if ( len ( s ) == 1 ) : return 0 ban = [ ] for i in range ( len ( s ) ) : if all ( s [ i ] != s [ k ] for k in range ( i + 1 , len ( s ) ) ) == True and s [ i ] not in ban : return i else : ban . append ( s [ i ] ) return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indicate whether the specified image file is valid or not .<CODESPLIT>def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a millisecond accuracy timestamp to a datetime<CODESPLIT>def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get adjacency matrix .<CODESPLIT>def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shut down a specific process .<CODESPLIT>def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output a networkx graph to a DOT file .<CODESPLIT>def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if an http server runs on a given port .<CODESPLIT>def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implementation of circle border with PyCairo .<CODESPLIT>def circles_pycairo ( width , height , color ) : cairo_color = color / rgb ( 255 , 255 , 255 ) surface = cairo . ImageSurface ( cairo . FORMAT_ARGB32 , width , height ) ctx = cairo . Context ( surface ) # draw a circle in the center ctx . new_path ( ) ctx . set_source_rgb ( cairo_color . red , cairo_color . green , cairo_color . blue ) ctx . arc ( width / 2 , height / 2 , width / 2 , 0 , 2 * pi ) ctx . fill ( ) surface . write_to_png ( 'circles.png' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to restore index information after collection . Doesn t use self so we can serialize this .<CODESPLIT>def _update_index_on_df ( df , index_names ) : if index_names : df = df . set_index ( index_names ) # Remove names from unnamed indexes index_names = _denormalize_index_names ( index_names ) df . index . names = index_names return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>save something to a pickle file<CODESPLIT>def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , "wb" ) , pickle . HIGHEST_PROTOCOL ) return thing
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the distance of a given image to the original image .<CODESPLIT>def normalized_distance ( self , image ) : return self . __distance ( self . __original_image_for_distance , image , bounds = self . bounds ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap text in an ansi escape sequence<CODESPLIT>def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts name to lower camel case . Words are identified by capitalization dashes and underscores .<CODESPLIT>def fmt_camel ( name ) : words = split_words ( name ) assert len ( words ) > 0 first = words . pop ( 0 ) . lower ( ) return first + '' . join ( [ word . capitalize ( ) for word in words ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields<CODESPLIT>def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a value or list of values and returns a single result joined by if necessary .<CODESPLIT>def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the day name<CODESPLIT>def get_day_name ( self ) -> str : weekday = self . value . isoweekday ( ) - 1 return calendar . day_name [ weekday ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run Python test cases against Java runtime classes .<CODESPLIT>def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip SGML / XML tags and replace adjacent whitespace by one space .<CODESPLIT>def do_striptags ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return Markup ( unicode ( value ) ) . striptags ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implements the context manager protocol . Specially useful for asserting exceptions<CODESPLIT>def __enter__ ( self ) : clone = self . clone ( ) self . _contexts . append ( clone ) self . reset ( ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents )<CODESPLIT>def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves and removes the first task from the heap .<CODESPLIT>def PopTask ( self ) : try : _ , task = heapq . heappop ( self . _heap ) except IndexError : return None self . _task_identifiers . remove ( task . identifier ) return task
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Segmented min op .<CODESPLIT>def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Union any overlapping intervals in the given set .<CODESPLIT>def union_overlapping ( intervals ) : disjoint_intervals = [ ] for interval in intervals : if disjoint_intervals and disjoint_intervals [ - 1 ] . overlaps ( interval ) : disjoint_intervals [ - 1 ] = disjoint_intervals [ - 1 ] . union ( interval ) else : disjoint_intervals . append ( interval ) return disjoint_intervals
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the configuration dictionary to an output file .<CODESPLIT>def write_config ( self , outfile ) : utils . write_yaml ( self . config , outfile , default_flow_style = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove files specified multiple times in a list .<CODESPLIT>def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ "path" ] not in seen : out . append ( x ) seen . add ( x [ "path" ] ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>validate that we can store the multi - index ; reset and return the new object<CODESPLIT>def validate_multiindex ( self , obj ) : levels = [ l if l is not None else "level_{0}" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( "duplicate names/columns in the multi-index when " "storing as a table" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for inserting int64 features into Example proto .<CODESPLIT>def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Downloads and returns the full text of a particular page in the document .<CODESPLIT>def get_page_text ( self , page ) : url = self . get_page_text_url ( page ) return self . _get_url ( url )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace all the ocurrences ( in a file ) of a string with another value .<CODESPLIT>def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>non - recursively break spaces and remove newlines in the tag<CODESPLIT>def _breakRemNewlines ( tag ) : for i , c in enumerate ( tag . contents ) : if type ( c ) != bs4 . element . NavigableString : continue c . replace_with ( re . sub ( r' {2,}' , ' ' , c ) . replace ( '\n' , '' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines the number of bytes required to store a NumPy array with the specified shape and datatype .<CODESPLIT>def _requiredSize ( shape , dtype ) : return math . floor ( np . prod ( np . asarray ( shape , dtype = np . uint64 ) ) * np . dtype ( dtype ) . itemsize )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure val is Nx ( n_col ) usually Nx3<CODESPLIT>def _check_color_dim ( val ) : val = np . atleast_2d ( val ) if val . shape [ 1 ] not in ( 3 , 4 ) : raise RuntimeError ( 'Value must have second dimension of size 3 or 4' ) return val , val . shape [ 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes eigenvalues and eigenvectors of covariance matrix of A . The rows of a correspond to observations the columns to variables .<CODESPLIT>def perform_pca ( A ) : # First subtract the mean M = ( A - numpy . mean ( A . T , axis = 1 ) ) . T # Get eigenvectors and values of covariance matrix return numpy . linalg . eig ( numpy . cov ( M ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render our pages as a jinja template for fancy templating goodness .<CODESPLIT>def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a copy of the given string ( or list of strings ) in which all occurrences of the given source are replaced by the given dest .<CODESPLIT>def replace ( scope , strings , source , dest ) : return [ s . replace ( source [ 0 ] , dest [ 0 ] ) for s in strings ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill missing data in a column of df with the median and add a { name } _na column which specifies if the data was missing . Parameters : ----------- df : The data frame that will be changed . col : The column of data to fix by filling in missing data . name : The name of the new filled column in df . na_dict : A dictionary of values to create na s of and the value to insert . If name is not a key of na_dict the median will fill any missing data . Also if name is not a key of na_dict and there is no missing data in col then no { name } _na column is not created . Examples : --------- >>> df = pd . DataFrame ( { col1 : [ 1 np . NaN 3 ] col2 : [ 5 2 2 ] } ) >>> df col1 col2 0 1 5 1 nan 2 2 3 2 >>> fix_missing ( df df [ col1 ] col1 {} ) >>> df col1 col2 col1_na 0 1 5 False 1 2 2 True 2 3 2 False >>> df = pd . DataFrame ( { col1 : [ 1 np . NaN 3 ] col2 : [ 5 2 2 ] } ) >>> df col1 col2 0 1 5 1 nan 2 2 3 2 >>> fix_missing ( df df [ col2 ] col2 {} ) >>> df col1 col2 0 1 5 1 nan 2 2 3 2 >>> df = pd . DataFrame ( { col1 : [ 1 np . NaN 3 ] col2 : [ 5 2 2 ] } ) >>> df col1 col2 0 1 5 1 nan 2 2 3 2 >>> fix_missing ( df df [ col1 ] col1 { col1 : 500 } ) >>> df col1 col2 col1_na 0 1 5 False 1 500 2 True 2 3 2 False<CODESPLIT>def fix_missing ( df , col , name , na_dict ) : if is_numeric_dtype ( col ) : if pd . isnull ( col ) . sum ( ) or ( name in na_dict ) : df [ name + '_na' ] = pd . isnull ( col ) filler = na_dict [ name ] if name in na_dict else col . median ( ) df [ name ] = col . fillna ( filler ) na_dict [ name ] = filler return na_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip agents from a string .<CODESPLIT>def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Evaluate smooth term in Vf .<CODESPLIT>def eval_Rf ( self , Vf ) : return sl . inner ( self . Df , Vf , axis = self . cri . axisM ) - self . Sf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read only access to the read preference of this instance or session .<CODESPLIT>def _read_preference_for ( self , session ) : # Override this operation's read preference with the transaction's. if session : return session . _txn_read_preference ( ) or self . __read_preference return self . __read_preference
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises the supplied figure number or figure window .<CODESPLIT>def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a a random string that represent a binary representation<CODESPLIT>def binary ( length ) : num = randint ( 1 , 999999 ) mask = '0' * length return ( mask + '' . join ( [ str ( num >> i & 1 ) for i in range ( 7 , - 1 , - 1 ) ] ) ) [ - length : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the minimum of an array ignoring any NaNs .<CODESPLIT>def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a dictionary of strings from a file<CODESPLIT>def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find longest ORF from the given list of ORFs .<CODESPLIT>def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return block of normal random numbers<CODESPLIT>def block ( seed ) : num = SAMPLE_RATE * BLOCK_SIZE rng = RandomState ( seed % 2 ** 32 ) variance = SAMPLE_RATE / 2 return rng . normal ( size = num , scale = variance ** 0.5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create ctypes pointer to object .<CODESPLIT>def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns public attributes of the inspected object .<CODESPLIT>def public ( self ) -> 'PrettyDir' : return PrettyDir ( self . obj , [ pattr for pattr in self . pattrs if not pattr . name . startswith ( '_' ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Push a new value into heap .<CODESPLIT>def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds execute permission to file . : param filename : : return :<CODESPLIT>def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .<CODESPLIT>def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return median<CODESPLIT>def get_median ( temp_list ) : num = len ( temp_list ) temp_list . sort ( ) print ( temp_list ) if num % 2 == 0 : median = ( temp_list [ int ( num / 2 ) ] + temp_list [ int ( num / 2 ) - 1 ] ) / 2 else : median = temp_list [ int ( num / 2 ) ] return median
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this a string .<CODESPLIT>def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates sql datetime2 object from Python datetime object ignoring timezone<CODESPLIT>def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def make_prefixed_stack_name ( prefix , template_path ) : parts = os . path . basename ( template_path ) . split ( '-' ) parts = parts if len ( parts ) == 1 else parts [ : - 1 ] return ( '%s-%s' % ( prefix , '-' . join ( parts ) ) ) . split ( '.' ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>string dict / object / value to JSON<CODESPLIT>def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fibonacci example function<CODESPLIT>def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple measure of similarity : Number of letters in common / max length<CODESPLIT>def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to get the location of a Python file .<CODESPLIT>def getScriptLocation ( ) : location = os . path . abspath ( "./" ) if __file__ . rfind ( "/" ) != - 1 : location = __file__ [ : __file__ . rfind ( "/" ) ] return location
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if URL is safe to redirect to .<CODESPLIT>def is_local_url ( target ) : ref_url = urlparse ( request . host_url ) test_url = urlparse ( urljoin ( request . host_url , target ) ) return test_url . scheme in ( 'http' , 'https' ) and ref_url . netloc == test_url . netloc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>React to a docstring event and append contracts to it .<CODESPLIT>def process_docstring ( app , what , name , obj , options , lines ) : # pylint: disable=unused-argument # pylint: disable=too-many-arguments lines . extend ( _format_contracts ( what = what , obj = obj ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close tensorflow session . Exposes for memory management .<CODESPLIT>def close_session ( self ) : with self . _graph . as_default ( ) : self . _sess . close ( ) self . _sess = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return start and end date of this month .<CODESPLIT>def last_month ( ) : since = TODAY + delta ( day = 1 , months = - 1 ) until = since + delta ( months = 1 ) return Date ( since ) , Date ( until )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return first occurrence matching f otherwise None<CODESPLIT>def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Traverse parent refs to top .<CODESPLIT>def find_root ( self ) : cmd = self while cmd . parent : cmd = cmd . parent return cmd
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a structured NumPy array into a Table .<CODESPLIT>def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> l = [ 1 1 1 ] >>> obj_in_list_always ( l 1 ) True >>> l . append ( 2 ) >>> obj_in_list_always ( l 1 ) False<CODESPLIT>def obj_in_list_always ( target_list , obj ) : for item in set ( target_list ) : if item is not obj : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is an enum type .<CODESPLIT>def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given an index for the text return the corresponding ( row col ) tuple . ( 0 - based . Returns ( 0 0 ) for index = 0 . )<CODESPLIT>def translate_index_to_position ( self , index ) : # Find start of this line. row , row_index = self . _find_line_start_index ( index ) col = index - row_index return row , col
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Chunk one big list into few small lists .<CODESPLIT>def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Locate the command s man page .<CODESPLIT>def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callable function for the multiprocessing pool .<CODESPLIT>def compute_capture ( args ) : x , y , w , h , params = args return x , y , mandelbrot_capture ( x , y , w , h , params )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helpful in situations where browser / app may recognize Unicode encoding in the \ u0b8e type syntax but not actual unicode glyph / code - point<CODESPLIT>def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u"u'" + u"" . join ( [ u"\\u%04x" % ord ( l ) for l in _letter ] ) + u"'"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract tag s attributes into a dict .<CODESPLIT>def tag_to_dict ( html ) : element = document_fromstring ( html ) . xpath ( "//html/body/child::*" ) [ 0 ] attributes = dict ( element . attrib ) attributes [ "text" ] = element . text_content ( ) return attributes
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Confirms that the uploaded image is of supported format .<CODESPLIT>def image_format ( value ) : if value . image . format . upper ( ) not in constants . ALLOWED_IMAGE_FORMATS : raise ValidationError ( MESSAGE_INVALID_IMAGE_FORMAT )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs str . strip () a column of a DataFrame Parameters : df - DataFrame DataFrame to operate on col_list - list of strings names of columns to strip dest - bool default False Whether to apply the result to the DataFrame or return it . True is apply False is return .<CODESPLIT>def cols_strip ( df , col_list , dest = False ) : if not dest : return _pd . DataFrame ( { col_name : col_strip ( df , col_name ) for col_name in col_list } ) for col_name in col_list : col_strip ( df , col_name , dest )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates symbolic link for either operating system . http : // stackoverflow . com / questions / 6260149 / os - symlink - support - in - windows<CODESPLIT>def create_symlink ( source , link_name ) : os_symlink = getattr ( os , "symlink" , None ) if isinstance ( os_symlink , collections . Callable ) : os_symlink ( source , link_name ) else : import ctypes csl = ctypes . windll . kernel32 . CreateSymbolicLinkW csl . argtypes = ( ctypes . c_wchar_p , ctypes . c_wchar_p , ctypes . c_uint32 ) csl . restype = ctypes . c_ubyte flags = 1 if os . path . isdir ( source ) else 0 if csl ( link_name , source , flags ) == 0 : raise ctypes . WinError ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>initializes 3D plot<CODESPLIT>def plot3d_init ( fignum ) : from mpl_toolkits . mplot3d import Axes3D fig = plt . figure ( fignum ) ax = fig . add_subplot ( 111 , projection = '3d' ) return ax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the channels of a colorbar .<CODESPLIT>def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>move to util_iter<CODESPLIT>def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate equality between two ( Comparable ) objects .<CODESPLIT>def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .<CODESPLIT>def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find longest ORF from the given list of ORFs .<CODESPLIT>def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the slice after at sub in string astr<CODESPLIT>def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if the json_element passed is present for the task specified .<CODESPLIT>def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorts a list of strings case insensitively as well as numerically .<CODESPLIT>def natural_sort ( list_to_sort : Iterable [ str ] ) -> List [ str ] : return sorted ( list_to_sort , key = natural_keys )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional<CODESPLIT>def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Truncates a value to a number of decimals places<CODESPLIT>def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Index of the last occurrence of x in the sequence .<CODESPLIT>def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list consisting of the cumulative sum of the items in the passed list .<CODESPLIT>def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value in the pandas DataFrame<CODESPLIT>def SetValue ( self , row , col , value ) : self . dataframe . iloc [ row , col ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the absolute uri for a file<CODESPLIT>def __absolute__ ( self , uri ) : return op . abspath ( op . join ( self . __path__ , uri ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the output shape from an array .<CODESPLIT>def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last object in file .<CODESPLIT>def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shuffle lists consistently .<CODESPLIT>def consistent_shuffle ( * lists ) : perm = list ( range ( len ( lists [ 0 ] ) ) ) random . shuffle ( perm ) lists = tuple ( [ sublist [ index ] for index in perm ] for sublist in lists ) return lists
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpacks sqlite rows as returned by fetchall into an array of simple dicts .<CODESPLIT>def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the mean value across a list of dictionaries<CODESPLIT>def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The title of this window<CODESPLIT>def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorting logic for Quantity objects .<CODESPLIT>def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def attr_cache_clear ( self ) : node = extract_node ( """def cache_clear(self): pass""" ) return BoundMethod ( proxy = node , bound = self . _instance . parent . scope ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forcefully delete objects from memory<CODESPLIT>def cleanup ( self ) : for instance in self . context : del ( instance ) for plugin in self . plugins : del ( plugin )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the closest object of a given type .<CODESPLIT>def find_object ( self , object_type ) : node = self while node is not None : if isinstance ( node . obj , object_type ) : return node . obj node = node . parent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns indices of the maximum values along an axis<CODESPLIT>def argmax ( attrs , inputs , proto_obj ) : axis = attrs . get ( 'axis' , 0 ) keepdims = attrs . get ( 'keepdims' , 1 ) argmax_op = symbol . argmax ( inputs [ 0 ] , axis = axis , keepdims = keepdims ) # onnx argmax operator always expects int64 as output type cast_attrs = { 'dtype' : 'int64' } return 'cast' , cast_attrs , argmax_op
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates a ruler line for separating rows from each other<CODESPLIT>def ruler_line ( self , widths , linetype = '-' ) : cells = [ ] for w in widths : cells . append ( linetype * ( w + 2 ) ) return '+' + '+' . join ( cells ) + '+'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a float to a precision<CODESPLIT>def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Currently pretends to talk to an instrument and get back the magnitud and phase of the measurement .<CODESPLIT>def get_data ( ) : # pretend we're measuring a noisy resonance at zero y = 1.0 / ( 1.0 + 1j * ( n_x . get_value ( ) - 0.002 ) * 1000 ) + _n . random . rand ( ) * 0.1 # and that it takes time to do so _t . sleep ( 0.1 ) # return mag phase return abs ( y ) , _n . angle ( y , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string from snake case to camel case .<CODESPLIT>def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Outputs json with formatting edits + object handling .<CODESPLIT>def dumps ( obj ) : return json . dumps ( obj , indent = 4 , sort_keys = True , cls = CustomEncoder )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>extract features in a sentence<CODESPLIT>def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Open a file .<CODESPLIT>def open_file ( file , mode ) : if hasattr ( file , "read" ) : return file if hasattr ( file , "open" ) : return file . open ( mode ) return open ( file , mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .<CODESPLIT>def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utilize wordnet ( installed with nltk ) to get synonyms for words word is the input word returns a list of unique synonyms<CODESPLIT>def get_wordnet_syns ( word ) : synonyms = [ ] regex = r"_" pat = re . compile ( regex ) synset = nltk . wordnet . wordnet . synsets ( word ) for ss in synset : for swords in ss . lemma_names : synonyms . append ( pat . sub ( " " , swords . lower ( ) ) ) synonyms = f7 ( synonyms ) return synonyms
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert this confusion matrix into a 2x2 plain list of values .<CODESPLIT>def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Root Mean Square<CODESPLIT>def rms ( x ) : try : return ( np . array ( x ) ** 2 ) . mean ( ) ** 0.5 except : x = np . array ( dropna ( x ) ) invN = 1.0 / len ( x ) return ( sum ( invN * ( x_i ** 2 ) for x_i in x ) ) ** .5
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse datetime .<CODESPLIT>def parse_datetime ( dt_str ) : date_format = "%Y-%m-%dT%H:%M:%S %z" dt_str = dt_str . replace ( "Z" , " +0000" ) return datetime . datetime . strptime ( dt_str , date_format )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the * cmd * and exit with the proper exit code .<CODESPLIT>def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Directly reads text data from url<CODESPLIT>def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for fast reading from sensor files .<CODESPLIT>def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds execute permission to file . : param filename : : return :<CODESPLIT>def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns given method name .<CODESPLIT>def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( "__" ) and not name . endswith ( "__" ) : name = "_{0}{1}" . format ( get_object_name ( method . im_class ) , name ) return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230<CODESPLIT>def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads the flow from a JSON file .<CODESPLIT>def load ( cls , fname ) : with open ( fname ) as f : content = f . readlines ( ) return Flow . from_json ( '' . join ( content ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if an array is a square matrix .<CODESPLIT>def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the extension from a filename<CODESPLIT>def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves dictionary as CSV file .<CODESPLIT>def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts array to a json string<CODESPLIT>def _convert_dict_to_json ( array ) : return json . dumps ( array , skipkeys = False , allow_nan = False , indent = None , separators = ( "," , ":" ) , sort_keys = True , default = lambda o : o . __dict__ , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>average of the values must have more than 0 entries .<CODESPLIT>def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( "ERROR: no content in array to take average\n" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rewind the file to the start of the body ( if seekable ) .<CODESPLIT>def rewindbody ( self ) : if not self . seekable : raise IOError , "unseekable file" self . fp . seek ( self . startofbody )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that the Executor must be close () d elsewhere or join () will never return .<CODESPLIT>def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return default argument value as given by argparse s add_argument () .<CODESPLIT>def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if end - of - file is reached for file fd .<CODESPLIT>def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>image resize function used by quite a few image problems .<CODESPLIT>def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a value from a dict which contains just one item .<CODESPLIT>def get_single_value ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . itervalues ( d ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends control values directly to the engines overriding control loops .<CODESPLIT>def pwm ( host , seq , m1 , m2 , m3 , m4 ) : at ( host , 'PWM' , seq , [ m1 , m2 , m3 , m4 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets value of key key to value in both session and cookies .<CODESPLIT>def save_config_value ( request , response , key , value ) : request . session [ key ] = value response . set_cookie ( key , value , expires = one_year_from_now ( ) ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a Seaborn linear regression plot<CODESPLIT>def _linear_seaborn_ ( self , label = None , style = None , opts = None ) : xticks , yticks = self . _get_ticks ( opts ) try : fig = sns . lmplot ( self . x , self . y , data = self . df ) fig = self . _set_with_height ( fig , opts ) return fig except Exception as e : self . err ( e , self . linear_ , "Can not draw linear regression chart" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a help string for names_list grouped by prefix .<CODESPLIT>def display_list_by_prefix ( names_list , starting_spaces = 0 ) : cur_prefix , result_lines = None , [ ] space = " " * starting_spaces for name in sorted ( names_list ) : split = name . split ( "_" , 1 ) prefix = split [ 0 ] if cur_prefix != prefix : result_lines . append ( space + prefix + ":" ) cur_prefix = prefix result_lines . append ( space + "  * " + name ) return "\n" . join ( result_lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the received object as precise as possible .<CODESPLIT>def _repr ( obj ) : vals = ", " . join ( "{}={!r}" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = "{}(name={}, {})" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = "{}(name={})" . format ( obj . __class__ . __name__ , obj . name ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .<CODESPLIT>def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins two dictionaries .<CODESPLIT>def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends Modify_DNS_Record request<CODESPLIT>def _request_modify_dns_record ( self , record ) : return self . _request_internal ( "Modify_DNS_Record" , domain = self . domain , record = record )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a directory and it contents . Ignore any failures .<CODESPLIT>def _clear_dir ( dirName ) : # If we got here, clear dir   for fname in os . listdir ( dirName ) : try : os . remove ( os . path . join ( dirName , fname ) ) except Exception : pass try : os . rmdir ( dirName ) except Exception : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates converts to a masked array<CODESPLIT>def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a file - like object loads it up into a PIL . Image object and returns it .<CODESPLIT>def get_image ( self , source ) : buf = StringIO ( source . read ( ) ) return Image . open ( buf )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether this is a complex floating point type .<CODESPLIT>def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return unique rows<CODESPLIT>def _unique_rows_numpy ( a ) : a = np . ascontiguousarray ( a ) unique_a = np . unique ( a . view ( [ ( '' , a . dtype ) ] * a . shape [ 1 ] ) ) return unique_a . view ( a . dtype ) . reshape ( ( unique_a . shape [ 0 ] , a . shape [ 1 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Evaluates the binomial pmf .<CODESPLIT>def EvalBinomialPmf ( k , n , p ) : return scipy . stats . binom . pmf ( k , n , p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Private method for setting axis limits .<CODESPLIT>def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lookup country for IP address .<CODESPLIT>def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>format mpv s title<CODESPLIT>def _format_title_string ( self , title_string ) : return self . _title_string_format_text_tag ( title_string . replace ( self . icy_tokkens [ 0 ] , self . icy_title_prefix ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first location of the maximum value of x . The position is calculated relatively to the length of x .<CODESPLIT>def first_location_of_maximum ( x ) : if not isinstance ( x , ( np . ndarray , pd . Series ) ) : x = np . asarray ( x ) return np . argmax ( x ) / len ( x ) if len ( x ) > 0 else np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decode ( bytearray raw = False ) - > value<CODESPLIT>def decode ( self , bytes , raw = False ) : return struct . unpack ( self . format , buffer ( bytes ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts datetimeoffset object into Python s datetime . datetime object<CODESPLIT>def to_pydatetime ( self ) : dt = datetime . datetime . combine ( self . _date . to_pydate ( ) , self . _time . to_pytime ( ) ) from . tz import FixedOffsetTimezone return dt . replace ( tzinfo = _utc ) . astimezone ( FixedOffsetTimezone ( self . _offset ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Underlying synchronized wrapper .<CODESPLIT>def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a matplotlib colormap .<CODESPLIT>def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>!<CODESPLIT>def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a wav contains data<CODESPLIT>def empty_wav ( wav_path : Union [ Path , str ] ) -> bool : with wave . open ( str ( wav_path ) , 'rb' ) as wav_f : return wav_f . getnframes ( ) == 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns January 1 of the given year .<CODESPLIT>def get_year_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( month = 1 ) . replace ( day = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>string dict / object / value to JSON<CODESPLIT>def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix multiplication using binary<CODESPLIT>def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds index of nearest value in array . Args : array : numpy array value : Returns : int http : // stackoverflow . com / questions / 2566412 / find - nearest - value - in - numpy - array<CODESPLIT>def index_nearest ( array , value ) : idx = ( np . abs ( array - value ) ) . argmin ( ) return idx
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for running binary search on a sorted list .<CODESPLIT>def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse an int robustly ignoring commas and other cruft .<CODESPLIT>def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a name in camelCase return in snake_case<CODESPLIT>def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\1_\2' , name ) return ALL_CAP_REGEX . sub ( r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a DataTable instance built from either the filename or STDIN if filename is None .<CODESPLIT>def get_data_table ( filename ) : with get_file_object ( filename , "r" ) as rf : return DataTable ( list ( csv . reader ( rf ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply re . sub to bunch of ( pattern repl )<CODESPLIT>def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a log record into a list of strings<CODESPLIT>def log_to_json ( log ) : return [ log . timestamp . isoformat ( ) [ : 22 ] , log . level , log . process , log . message ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download the page into a string<CODESPLIT>def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns data as : class : numpy . recarray .<CODESPLIT>def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list possibly nested to any level return it flattened .<CODESPLIT>def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Composes the passed filters into an and - joined filter .<CODESPLIT>def BROADCAST_FILTER_NOT ( func ) : return lambda u , command , * args , * * kwargs : not func ( u , command , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the queue is full False otherwise ( not reliable! ) .<CODESPLIT>def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string of data after gzip decoding<CODESPLIT>def ungzip_data ( input_data ) : buf = StringIO ( input_data ) f = gzip . GzipFile ( fileobj = buf ) return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the text for the given root node ( xml . dom . minidom ) .<CODESPLIT>def __get_xml_text ( root ) : txt = "" for e in root . childNodes : if ( e . nodeType == e . TEXT_NODE ) : txt += e . data return txt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple of this array s dimensions . This is done by querying the Dim children . Note that once it has been created it is also possible to examine an Array object s . array attribute directly and doing that is much faster .<CODESPLIT>def get_shape ( self ) : return tuple ( int ( c . pcdata ) for c in self . getElementsByTagName ( ligolw . Dim . tagName ) ) [ : : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Imputes data set containing Nan values<CODESPLIT>def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get dimension of an array getting the number of rows and the max num of columns .<CODESPLIT>def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like map but also chains the results .<CODESPLIT>def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the size of the label .<CODESPLIT>def ylabelsize ( self , size , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'titlefont' ] [ 'size' ] = size return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The cell lengths .<CODESPLIT>def lengths ( self ) : return ( np . array ( [ math . sqrt ( sum ( row ** 2 ) ) for row in self . matrix ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for pulling a keyed value off various types of objects<CODESPLIT>def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generator for reading from standard input in nonblocking mode .<CODESPLIT>def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect and login to an FTP server and return ftplib . FTP object .<CODESPLIT>def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to a redis instance .<CODESPLIT>def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse string into Identity dictionary .<CODESPLIT>def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads and returns foreign library .<CODESPLIT>def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the date that a file was created .<CODESPLIT>def get_creation_datetime ( filepath ) : if platform . system ( ) == 'Windows' : return datetime . fromtimestamp ( os . path . getctime ( filepath ) ) else : stat = os . stat ( filepath ) try : return datetime . fromtimestamp ( stat . st_birthtime ) except AttributeError : # We're probably on Linux. No easy way to get creation dates here, # so we'll settle for when its content was last modified. return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures that the external tool is available . Asserts upon failure .<CODESPLIT>def require ( executable : str , explanation : str = "" ) -> None : assert shutil . which ( executable ) , "Need {!r} on the PATH.{}" . format ( executable , "\n" + explanation if explanation else "" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return file name ( s ) from Tkinter s file open dialog .<CODESPLIT>def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Search into instance attributes properties and return values of no - args methods .<CODESPLIT>def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim left - right given string<CODESPLIT>def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( "" , somestr ) tmp = RE_TSPACES . sub ( "" , tmp ) return str ( tmp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Images must be either 2D or 3D .<CODESPLIT>def _validate_image_rank ( self , img_array ) : if img_array . ndim == 1 or img_array . ndim > 3 : msg = "{0}D imagery is not allowed." . format ( img_array . ndim ) raise IOError ( msg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the default bucket from a list of buckets i . e . the largest bucket .<CODESPLIT>def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function for loading yaml - encoded data from disk .<CODESPLIT>def load_yaml ( filepath ) : with open ( filepath ) as f : txt = f . read ( ) return yaml . load ( txt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format list .<CODESPLIT>def list_formatter ( handler , item , value ) : return u', ' . join ( str ( v ) for v in value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dotproduct of two vectors .<CODESPLIT>def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the list of field names of the model .<CODESPLIT>def fields ( self ) : return ( self . attributes . values ( ) + self . lists . values ( ) + self . references . values ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate an endless sequence of random integers from permutations of the set [ 0 ... N ) .<CODESPLIT>def endless_permutations ( N , random_state = None ) : generator = check_random_state ( random_state ) while True : batch_inds = generator . permutation ( N ) for b in batch_inds : yield b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of names of columns that are string type .<CODESPLIT>def _get_str_columns ( sf ) : return [ name for name in sf . column_names ( ) if sf [ name ] . dtype == str ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join all lines from input string and wrap it at specified width<CODESPLIT>def rewrap ( s , width = COLS ) : s = ' ' . join ( [ l . strip ( ) for l in s . strip ( ) . split ( '\n' ) ] ) return '\n' . join ( textwrap . wrap ( s , width ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform actions before parent main window is closed<CODESPLIT>def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called by the instance manager when a component property is modified<CODESPLIT>def on_property_change ( self , name , old_value , new_value ) : if self . _registration is not None : # use the registration to trigger the service event self . _registration . set_properties ( { name : new_value } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a multiline string into a list excluding blank lines .<CODESPLIT>def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\n' ) ) if element ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the chars in the given string .<CODESPLIT>def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to turn a string representation of true into boolean True .<CODESPLIT>def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .<CODESPLIT>def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Communicate with the child process without closing stdin .<CODESPLIT>def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the specified element selector is present on the page .<CODESPLIT>def is_element_present ( driver , selector , by = By . CSS_SELECTOR ) : try : driver . find_element ( by = by , value = selector ) return True except Exception : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get authentication .<CODESPLIT>def get_auth ( ) : import getpass user = input ( "User Name: " ) # noqa pswd = getpass . getpass ( 'Password: ' ) return Github ( user , pswd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function prints the given String immediately and flushes the output .<CODESPLIT>def printOut ( value , end = '\n' ) : sys . stdout . write ( value ) sys . stdout . write ( end ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Force commit changes to the file and stdout<CODESPLIT>def flush ( self ) : if not self . nostdout : self . stdout . flush ( ) if self . file is not None : self . file . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implements the === operator .<CODESPLIT>def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a lisst of Text instances as JSON corpus on disk . A JSON corpus contains one document per line encoded in JSON .<CODESPLIT>def write_json_corpus ( documents , fnm ) : with codecs . open ( fnm , 'wb' , 'ascii' ) as f : for document in documents : f . write ( json . dumps ( document ) + '\n' ) return documents
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV SampleSheet to YAML run_info format .<CODESPLIT>def csv2yaml ( in_file , out_file = None ) : if out_file is None : out_file = "%s.yaml" % os . path . splitext ( in_file ) [ 0 ] barcode_ids = _generate_barcode_ids ( _read_input_csv ( in_file ) ) lanes = _organize_lanes ( _read_input_csv ( in_file ) , barcode_ids ) with open ( out_file , "w" ) as out_handle : out_handle . write ( yaml . safe_dump ( lanes , default_flow_style = False ) ) return out_file
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the unit tests on an installed copy of unyt .<CODESPLIT>def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plot the elements of the Pauli transfer matrix .<CODESPLIT>def plot_pauli_transfer_matrix ( self , ax ) : title = "Estimated process" ut . plot_pauli_transfer_matrix ( self . r_est , ax , self . pauli_basis . labels , title )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a string return true if it matches the supplied list of patterns .<CODESPLIT>def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register callbacks for button press events and selection changed<CODESPLIT>def register_view ( self , view ) : super ( ListViewController , self ) . register_view ( view ) self . tree_view . connect ( 'button_press_event' , self . mouse_click )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is an enum type .<CODESPLIT>def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generator that loops through all absolute paths of the files within folder<CODESPLIT>def get_all_files ( folder ) : for path , dirlist , filelist in os . walk ( folder ) : for fn in filelist : yield op . join ( path , fn )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type root : TreeNode : rtype : int<CODESPLIT>def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert bytes and non - string into Python 3 str<CODESPLIT>def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts and image to matrix ( one pixel per line )<CODESPLIT>def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause for this many seconds<CODESPLIT>def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple helper hash function<CODESPLIT>def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until the user accepted or rejected the request<CODESPLIT>def _wait_for_response ( self ) : while not self . server . response_code : time . sleep ( 2 ) time . sleep ( 5 ) self . server . shutdown ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpacks sqlite rows as returned by fetchall into an array of simple dicts .<CODESPLIT>def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>As a convenience turn Python lists and tuples into NumPy arrays .<CODESPLIT>def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield num_chars - character chunks from string .<CODESPLIT>def generate_chunks ( string , num_chars ) : for start in range ( 0 , len ( string ) , num_chars ) : yield string [ start : start + num_chars ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Empty the range from start to stop .<CODESPLIT>def empty ( self , start = None , stop = None ) : self . set ( NOT_SET , start = start , stop = stop )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the total timedelta duration in seconds .<CODESPLIT>def timedelta_seconds ( timedelta ) : return ( timedelta . total_seconds ( ) if hasattr ( timedelta , "total_seconds" ) else timedelta . days * 24 * 3600 + timedelta . seconds + timedelta . microseconds / 1000000. )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a property of the experiment by name .<CODESPLIT>def experiment_property ( prop ) : exp = experiment ( session ) p = getattr ( exp , prop ) return success_response ( field = prop , data = p , request_type = prop )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the file size of a given file<CODESPLIT>def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function which returns an array with the Intervals boundaries .<CODESPLIT>def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sum the total number of cycles over a list of tokens .<CODESPLIT>def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculcate checksum for a file .<CODESPLIT>def checksum ( path ) : hasher = hashlib . sha1 ( ) with open ( path , 'rb' ) as stream : buf = stream . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = stream . read ( BLOCKSIZE ) return hasher . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove element from the RangeSet if it is a member .<CODESPLIT>def discard ( self , element ) : try : i = int ( element ) set . discard ( self , i ) except ValueError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method that escapes parameters to a SQL query .<CODESPLIT>def _escape ( s ) : e = s e = e . replace ( '\\' , '\\\\' ) e = e . replace ( '\n' , '\\n' ) e = e . replace ( '\r' , '\\r' ) e = e . replace ( "'" , "\\'" ) e = e . replace ( '"' , '\\"' ) return e
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Makes sure that x is type of float<CODESPLIT>def ensure_dtype_float ( x , default = np . float64 ) : if isinstance ( x , np . ndarray ) : if x . dtype . kind == 'f' : return x elif x . dtype . kind == 'i' : return x . astype ( default ) else : raise TypeError ( 'x is of type ' + str ( x . dtype ) + ' that cannot be converted to float' ) else : raise TypeError ( 'x is not an array' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that the Executor must be close () d elsewhere or join () will never return .<CODESPLIT>def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets up the python include paths to include src<CODESPLIT>def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , "src" ) ] + sys . path pass return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate combined size of tiles .<CODESPLIT>def get_combined_size ( tiles ) : # TODO: Refactor calculating layout to avoid repetition. columns , rows = calc_columns_rows ( len ( tiles ) ) tile_size = tiles [ 0 ] . image . size return ( tile_size [ 0 ] * columns , tile_size [ 1 ] * rows )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalized Gaussian<CODESPLIT>def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1<CODESPLIT>def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Banana banana<CODESPLIT>def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s="%s"' % ( k , v ) for k , v in dict_ . items ( ) ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Random uniform variates .<CODESPLIT>def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show help on all commands .<CODESPLIT>def do_help ( self , arg ) : print ( self . response_prompt , file = self . stdout ) return cmd . Cmd . do_help ( self , arg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a number to a precision<CODESPLIT>def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read<CODESPLIT>def read ( self , count = 0 ) : return self . f . read ( count ) if count > 0 else self . f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>printdict<CODESPLIT>def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip all color codes from a string . Returns empty string for falsey inputs .<CODESPLIT>def strip_codes ( s : Any ) -> str : return codepat . sub ( '' , str ( s ) if ( s or ( s == 0 ) ) else '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Custom type for managing dates in the command - line .<CODESPLIT>def Date ( value ) : from datetime import datetime try : return datetime ( * reversed ( [ int ( val ) for val in value . split ( '/' ) ] ) ) except Exception as err : raise argparse . ArgumentTypeError ( "invalid date '%s'" % value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a 2D numpy array of bools<CODESPLIT>def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Index of the last occurrence of x in the sequence .<CODESPLIT>def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether one of the items in the list has multiple lines .<CODESPLIT>def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closest distance between a line segment and a point<CODESPLIT>def distance_to_line ( a , b , p ) : return distance ( closest_point ( a , b , p ) , p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Builds a comment .<CODESPLIT>def to_comment ( value ) : if value is None : return if len ( value . split ( '\n' ) ) == 1 : return "* " + value else : return '\n' . join ( [ ' * ' + l for l in value . split ( '\n' ) [ : - 1 ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the width of the table that would be printed . : rtype : int<CODESPLIT>def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns file name of file at given url .<CODESPLIT>def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill missing values in pandas objects and numpy arrays .<CODESPLIT>def fillna ( series_or_arr , missing_value = 0.0 ) : if pandas . notnull ( missing_value ) : if isinstance ( series_or_arr , ( numpy . ndarray ) ) : series_or_arr [ numpy . isnan ( series_or_arr ) ] = missing_value else : series_or_arr . fillna ( missing_value , inplace = True ) return series_or_arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show a basic reference about the GUI Console .<CODESPLIT>def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return unix SECOND timestamp of num mondays ago<CODESPLIT>def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fix common typos in given URL like forgotten colon .<CODESPLIT>def url_fix_common_typos ( url ) : if url . startswith ( "http//" ) : url = "http://" + url [ 6 : ] elif url . startswith ( "https//" ) : url = "https://" + url [ 7 : ] return url
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reformat a date string to standard format .<CODESPLIT>def std_datestr ( self , datestr ) : return date . strftime ( self . str2date ( datestr ) , self . std_dateformat )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a a random string that represent a binary representation<CODESPLIT>def binary ( length ) : num = randint ( 1 , 999999 ) mask = '0' * length return ( mask + '' . join ( [ str ( num >> i & 1 ) for i in range ( 7 , - 1 , - 1 ) ] ) ) [ - length : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a Python object stored in a specified YAML file .<CODESPLIT>def ReadManyFromPath ( filepath ) : with io . open ( filepath , mode = "r" , encoding = "utf-8" ) as filedesc : return ReadManyFromFile ( filedesc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if this database is in a transactional context .<CODESPLIT>def in_transaction ( self ) : if not hasattr ( self . local , 'tx' ) : return False return len ( self . local . tx ) > 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Override Qt method<CODESPLIT>def contextMenuEvent ( self , event ) : self . update_menu ( ) self . menu . popup ( event . globalPos ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserialize s ( a str ) to a Python object .<CODESPLIT>def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes object obj from the index .<CODESPLIT>def _remove_from_index ( index , obj ) : try : index . value_map [ indexed_value ( index , obj ) ] . remove ( obj . id ) except KeyError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns : a triple of integers from a version tag<CODESPLIT>def version_triple ( tag ) : groups = re . match ( r'v?(\d+)\.(\d+)\.(\d+)' , tag ) . groups ( ) return tuple ( int ( n ) for n in groups )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute entropy on the string<CODESPLIT>def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rate limit a function .<CODESPLIT>def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether a path names an existing directory we can list and read files from .<CODESPLIT>def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds an if expression as a statement<CODESPLIT>def find_if_expression_as_statement ( node ) : return ( isinstance ( node , ast . Expr ) and isinstance ( node . value , ast . IfExp ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>given a bytes object should return a base python data structure that represents the object .<CODESPLIT>def load ( raw_bytes ) : try : if not isinstance ( raw_bytes , string_type ) : raw_bytes = raw_bytes . decode ( ) return json . loads ( raw_bytes ) except ValueError as e : raise SerializationException ( str ( e ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mark a given source line as executed count times .<CODESPLIT>def mark ( self , lineno , count = 1 ) : self . sourcelines [ lineno ] = self . sourcelines . get ( lineno , 0 ) + count
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: deprecated : use self . statement to execute properly - formatted sql statements<CODESPLIT>def sql ( self , sql : str , * qmark_params , * * named_params ) : statement = SingleSqlStatement ( sql ) return self . statement ( statement ) . execute ( * qmark_params , * * named_params )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the lowercase chars in the given string .<CODESPLIT>def lowercase_chars ( string : any ) -> str : return '' . join ( [ c if c . islower ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Combine the outer and inner keys of nested dictionaries into a single ordering .<CODESPLIT>def flattened_nested_key_indices ( nested_dict ) : outer_keys , inner_keys = collect_nested_keys ( nested_dict ) combined_keys = list ( sorted ( set ( outer_keys + inner_keys ) ) ) return { k : i for ( i , k ) in enumerate ( combined_keys ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .<CODESPLIT>def generate_unique_host_id ( ) : host = "." . join ( reversed ( socket . gethostname ( ) . split ( "." ) ) ) pid = os . getpid ( ) return "%s.%d" % ( host , pid )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lookup country for IP address .<CODESPLIT>def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional<CODESPLIT>def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the memory is too full for further caching .<CODESPLIT>def memory_full ( ) : current_process = psutil . Process ( os . getpid ( ) ) return ( current_process . memory_percent ( ) > config . MAXIMUM_CACHE_MEMORY_PERCENTAGE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prints the top n lines of a file<CODESPLIT>def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty printing for numpy matrix X<CODESPLIT>def print_matrix ( X , decimals = 1 ) : for row in np . round ( X , decimals = decimals ) : print ( row )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>string dict / object / value to JSON<CODESPLIT>def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the scalar product of this vector with the given other vector .<CODESPLIT>def get_scalar_product ( self , other ) : return self . x * other . x + self . y * other . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a name which includes the module name and function name .<CODESPLIT>def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will test whether the ACS service is up and alive .<CODESPLIT>def is_alive ( self ) : response = self . get_monitoring_heartbeat ( ) if response . status_code == 200 and response . content == 'alive' : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : list (( option value ) ... ) pairs of all items in the given section<CODESPLIT>def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a Python object from a XML file<CODESPLIT>def from_file ( cls , file_path , validate = True ) : return xmlmap . load_xmlobject_from_file ( file_path , xmlclass = cls , validate = validate )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>help to direct to the correct interface interacting with DB by class name only<CODESPLIT>def interface_direct_class ( data_class ) : if data_class in ASSET : interface = AssetsInterface ( ) elif data_class in PARTY : interface = PartiesInterface ( ) elif data_class in BOOK : interface = BooksInterface ( ) elif data_class in CORPORATE_ACTION : interface = CorporateActionsInterface ( ) elif data_class in MARKET_DATA : interface = MarketDataInterface ( ) elif data_class in TRANSACTION : interface = TransactionsInterface ( ) else : interface = AssetManagersInterface ( ) return interface
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the default matplotlib ticks .<CODESPLIT>def clear_matplotlib_ticks ( self , axis = "both" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load and pre - process the images specified with absolute paths .<CODESPLIT>def load_preprocess_images ( image_paths : List [ str ] , image_size : tuple ) -> List [ np . ndarray ] : image_size = image_size [ 1 : ] # we do not need the number of channels images = [ ] for image_path in image_paths : images . append ( load_preprocess_image ( image_path , image_size ) ) return images
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns method or function arguments .<CODESPLIT>def get_args ( method_or_func ) : try : # Python 3.0+ args = list ( inspect . signature ( method_or_func ) . parameters . keys ( ) ) except AttributeError : # Python 2.7 args = inspect . getargspec ( method_or_func ) . args return args
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the estimated standard error of the mean ( sx - bar ) of the values in the passed list . sem = stdev / sqrt ( n )<CODESPLIT>def sem ( inlist ) : sd = stdev ( inlist ) n = len ( inlist ) return sd / math . sqrt ( n )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends a command and an ( optional ) sequence of arguments through to the delegated serial interface . Note that the arguments are passed through as data .<CODESPLIT>def command ( self , cmd , * args ) : self . _serial_interface . command ( cmd ) if len ( args ) > 0 : self . _serial_interface . data ( list ( args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register all globally visible functions .<CODESPLIT>def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the margin in pixels above the plot area setting border_top .<CODESPLIT>def calculate_top_margin ( self ) : self . border_top = 5 if self . show_graph_title : self . border_top += self . title_font_size self . border_top += 5 if self . show_graph_subtitle : self . border_top += self . subtitle_font_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a float to a precision<CODESPLIT>def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves all relevant data to . h5 file ; so state can be restored .<CODESPLIT>def save_hdf ( self , filename , path = '' ) : self . dataframe . to_hdf ( filename , '{}/df' . format ( path ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks to see if list is equal everywhere<CODESPLIT>def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Synthesize white noise<CODESPLIT>def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets limits for this config value<CODESPLIT>def set_limits ( self , min_ = None , max_ = None ) : self . _min , self . _max = min_ , max_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns TRUE if any argument is TRUE<CODESPLIT>def _or ( ctx , * logical ) : for arg in logical : if conversions . to_boolean ( arg , ctx ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type s : str : rtype : int<CODESPLIT>def first_unique_char ( s ) : if ( len ( s ) == 1 ) : return 0 ban = [ ] for i in range ( len ( s ) ) : if all ( s [ i ] != s [ k ] for k in range ( i + 1 , len ( s ) ) ) == True and s [ i ] not in ban : return i else : ban . append ( s [ i ] ) return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>how high in sorted list each key is . inverse permutation of sorter such that sorted [ rank ] == keys<CODESPLIT>def rank ( self ) : r = np . empty ( self . size , np . int ) r [ self . sorter ] = np . arange ( self . size ) return r
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decide if the Ipython command line is running code .<CODESPLIT>def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , "function" , None ) == pkg_resources . load_entry_point ( "ipython" , "console_scripts" , "ipython" ) . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Integer to two bytes<CODESPLIT>def intToBin ( i ) : # devide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return chr ( i1 ) + chr ( i2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a float returns a rounded int . Should give the same result on both Py2 / 3<CODESPLIT>def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closest values<CODESPLIT>def closest_values ( L ) : assert len ( L ) >= 2 L . sort ( ) valmin , argmin = min ( ( L [ i ] - L [ i - 1 ] , i ) for i in range ( 1 , len ( L ) ) ) return L [ argmin - 1 ] , L [ argmin ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a python string to c array .<CODESPLIT>def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shortcut to create md5 hash : param s : : return :<CODESPLIT>def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process command line arguments and walk inputs .<CODESPLIT>def run ( args ) : raw_arguments = get_arguments ( args [ 1 : ] ) process_arguments ( raw_arguments ) walk . run ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to validate if the value is valid for exact match type evaluation .<CODESPLIT>def is_value_type_valid_for_exact_conditions ( self , value ) : # No need to check for bool since bool is a subclass of int if isinstance ( value , string_types ) or isinstance ( value , ( numbers . Integral , float ) ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a duration in seconds .<CODESPLIT>def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list of 2 - tuples ( find repl ) this function performs all replacements on the input and returns the result .<CODESPLIT>def _replace ( self , data , replacements ) : for find , repl in replacements : data = data . replace ( find , repl ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dictionary of conversion<CODESPLIT>def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the rows columns of terminal<CODESPLIT>def _size_36 ( ) : from shutil import get_terminal_size dim = get_terminal_size ( ) if isinstance ( dim , list ) : return dim [ 0 ] , dim [ 1 ] return dim . lines , dim . columns
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether this is a complex floating point type .<CODESPLIT>def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adjust image balance and contrast<CODESPLIT>def lighting ( im , b , c ) : if b == 0 and c == 1 : return im mu = np . average ( im ) return np . clip ( ( im - mu ) * c + mu + b , 0. , 1. ) . astype ( np . float32 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ask a yes / no question interactively .<CODESPLIT>def confirm ( question , default = True ) : valid = { "" : default , "yes" : True , "y" : True , "no" : False , "n" : False } while 1 : choice = input ( question + ( " [Y/n] " if default else " [y/N] " ) ) . lower ( ) if choice in valid : return valid [ choice ] print ( "Please respond with 'y' or 'n' " )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flip an image horizontally or vertically .<CODESPLIT>def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .<CODESPLIT>def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a one - hot encoded array back to string<CODESPLIT>def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return standard deviation .<CODESPLIT>def standard_deviation ( numbers ) : numbers = list ( numbers ) if not numbers : return 0 mean = sum ( numbers ) / len ( numbers ) return ( sum ( ( n - mean ) ** 2 for n in numbers ) / len ( numbers ) ) ** .5
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Small transformer model with small batch size for fast step times .<CODESPLIT>def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a field or enum value node get deprecation reason as string .<CODESPLIT>def get_deprecation_reason ( node : Union [ EnumValueDefinitionNode , FieldDefinitionNode ] ) -> Optional [ str ] : from . . execution import get_directive_values deprecated = get_directive_values ( GraphQLDeprecatedDirective , node ) return deprecated [ "reason" ] if deprecated else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does a simple validation of an email by matching it to a regexps<CODESPLIT>def _validate_simple ( email ) : name , address = parseaddr ( email ) if not re . match ( '[^@]+@[^@]+\.[^@]+' , address ) : raise ValueError ( 'Invalid email :{email}' . format ( email = email ) ) return address
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a numpy array of floats ( any dimension<CODESPLIT>def is_float_array ( l ) : if isinstance ( l , np . ndarray ) : if l . dtype . kind == 'f' : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace placeholders in text by using the data mapping . Other placeholders that is not represented by data is left untouched .<CODESPLIT>def template_substitute ( text , * * kwargs ) : for name , value in kwargs . items ( ) : placeholder_pattern = "{%s}" % name if placeholder_pattern in text : text = text . replace ( placeholder_pattern , value ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ANSI Escape sequences http : // ascii - table . com / ansi - escape - sequences . php<CODESPLIT>def position ( self , x , y , text ) : sys . stdout . write ( "\x1b7\x1b[%d;%df%s\x1b8" % ( x , y , text ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a matplotlib colormap .<CODESPLIT>def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate if non empty string<CODESPLIT>def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a task waits for it until it finishes : param task : Task : return :<CODESPLIT>def wait_and_join ( self , task ) : while not task . has_started : time . sleep ( self . _polling_time ) task . thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a representation of the case in the Graphviz DOT language .<CODESPLIT>def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For Python3 compatibility of generator .<CODESPLIT>def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .<CODESPLIT>def energy_string_to_float ( string ) : energy_re = re . compile ( "(-?\d+\.\d+)" ) return float ( energy_re . match ( string ) . group ( 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert JSON string to an ordered defaultdict .<CODESPLIT>def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list copy in which each item occurs only once ( in - order ) .<CODESPLIT>def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if dtype is a numeric type .<CODESPLIT>def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if contents of the files are the same<CODESPLIT>def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if exception was raised because of too many executed requests . ( This is a temporal solution and will be changed in later package versions . )<CODESPLIT>def _request_limit_reached ( exception ) : return isinstance ( exception , requests . HTTPError ) and exception . response . status_code == requests . status_codes . codes . TOO_MANY_REQUESTS
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>underscore to mixed case notation<CODESPLIT>def case_us2mc ( x ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of names of columns that are string type .<CODESPLIT>def _get_str_columns ( sf ) : return [ name for name in sf . column_names ( ) if sf [ name ] . dtype == str ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the item is a placeholder or contains a placeholder .<CODESPLIT>def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Command line interface for PyBEL .<CODESPLIT>def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>writes the line and count newlines after the line<CODESPLIT>def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns file name of file at given url .<CODESPLIT>def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait for a proc to shut down then terminate or kill it after timeout .<CODESPLIT>def _shutdown_proc ( p , timeout ) : freq = 10 # how often to check per second for _ in range ( 1 + timeout * freq ) : ret = p . poll ( ) if ret is not None : logging . info ( "Shutdown gracefully." ) return ret time . sleep ( 1 / freq ) logging . warning ( "Killing the process." ) p . kill ( ) return p . wait ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a percentile range from an array of values .<CODESPLIT>def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform auth request for token .<CODESPLIT>def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y<CODESPLIT>def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write to given samples to a wav file . The samples are expected to be floating point numbers in the range of - 1 . 0 to 1 . 0 .<CODESPLIT>def write_wav ( path , samples , sr = 16000 ) : max_value = np . abs ( np . iinfo ( np . int16 ) . min ) data = ( samples * max_value ) . astype ( np . int16 ) scipy . io . wavfile . write ( path , sr , data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method that escapes parameters to a SQL query .<CODESPLIT>def _escape ( s ) : e = s e = e . replace ( '\\' , '\\\\' ) e = e . replace ( '\n' , '\\n' ) e = e . replace ( '\r' , '\\r' ) e = e . replace ( "'" , "\\'" ) e = e . replace ( '"' , '\\"' ) return e
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Idempotent and None - safe version of strict_bool .<CODESPLIT>def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read an image from file - PIL doesnt close nicely<CODESPLIT>def load_image ( fname ) : with open ( fname , "rb" ) as f : i = Image . open ( fname ) #i.load() return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check for filelikeness of an object .<CODESPLIT>def is_filelike ( ob ) : if hasattr ( ob , 'read' ) and callable ( ob . read ) : return True if hasattr ( ob , 'write' ) and callable ( ob . write ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if filename has changed since the last check . If this is the first check assume the file is changed .<CODESPLIT>def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batches a list into a list of lists with sub - lists sized by a specified batch size .<CODESPLIT>def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether stdin has any data to read .<CODESPLIT>def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set x - axis limits of a subplot .<CODESPLIT>def set_xlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_xlimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns is seq is sequence and not string .<CODESPLIT>def _is_proper_sequence ( seq ) : return ( isinstance ( seq , collections . abc . Sequence ) and not isinstance ( seq , str ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all nodes and edges from the graph .<CODESPLIT>def clear ( self ) : self . adj . clear ( ) self . node . clear ( ) self . graph . clear ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>given a DataFrame where records are stored row - wise rearrange it such that records are stored column - wise .<CODESPLIT>def _preprocess ( df ) : df = df . stack ( ) df . index . rename ( [ "id" , "time" ] , inplace = True ) # .reset_index() df . name = "value" df = df . reset_index ( ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a sentence into list of words .<CODESPLIT>def split_into_words ( s ) : s = re . sub ( r"\W+" , " " , s ) s = re . sub ( r"[_0-9]+" , " " , s ) return s . split ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adapts a Numpy array into an ARRAY string to put into the database .<CODESPLIT>def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a dict to a querystring suitable to be appended to a URL .<CODESPLIT>def dict_to_querystring ( dictionary ) : s = u"" for d in dictionary . keys ( ) : s = unicode . format ( u"{0}{1}={2}&" , s , d , dictionary [ d ] ) return s [ : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True positive rate tp / ( tp + fn )<CODESPLIT>def tpr ( y , z ) : tp , tn , fp , fn = contingency_table ( y , z ) return tp / ( tp + fn )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the minimum of an array ignoring any NaNs .<CODESPLIT>def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>splits iterables a in equal parts of size sz<CODESPLIT>def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort data rows and order columns<CODESPLIT>def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the smallest index of the row ( s ) with this column equal to value .<CODESPLIT>def index ( self , value ) : for i in xrange ( len ( self . parentNode ) ) : if getattr ( self . parentNode [ i ] , self . Name ) == value : return i raise ValueError ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object<CODESPLIT>def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( "." ) dt = datetime . strptime ( dt , "%Y-%m-%dT%H:%M:%S" ) return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function which converts lists to tuples .<CODESPLIT>def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns files matched by all extensions in the extensions list<CODESPLIT>def glob_by_extensions ( directory , extensions ) : directorycheck ( directory ) files = [ ] xt = files . extend for ex in extensions : xt ( glob . glob ( '{0}/*.{1}' . format ( directory , ex ) ) ) return files
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Euclidean distance between two vectors .<CODESPLIT>def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>zfill ( x width ) - > string<CODESPLIT>def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a horizontal line up to a given length .<CODESPLIT>def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first line of a file .<CODESPLIT>def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\n' ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the week start date and end date<CODESPLIT>def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the adjacency matrix of a bipartite graph whose biadjacency matrix is A .<CODESPLIT>def to_bipartite_matrix ( A ) : m , n = A . shape return four_blocks ( zeros ( m , m ) , A , A . T , zeros ( n , n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves a tuple with the x y coordinates of the upper right point of the ellipse . Requires the radius and the coordinates to be numbers<CODESPLIT>def getTopRight ( self ) : return ( float ( self . get_cx ( ) ) + float ( self . get_rx ( ) ) , float ( self . get_cy ( ) ) + float ( self . get_ry ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if key exists in datastore . True if yes False if no .<CODESPLIT>def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert input 3 - vector in axis - angle representation to unit quaternion<CODESPLIT>def from_rotation_vector ( rot ) : rot = np . array ( rot , copy = False ) quats = np . zeros ( rot . shape [ : - 1 ] + ( 4 , ) ) quats [ ... , 1 : ] = rot [ ... ] / 2 quats = as_quat_array ( quats ) return np . exp ( quats )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Translates window screen coordinates to client coordinates .<CODESPLIT>def screen_to_client ( self , x , y ) : return tuple ( win32 . ScreenToClient ( self . get_handle ( ) , ( x , y ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the key ( aka database value ) of a human key ( aka Python identifier ) .<CODESPLIT>def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge this range object with another ( ranges need not overlap or abut ) .<CODESPLIT>def merge ( self , other ) : newstart = min ( self . _start , other . start ) newend = max ( self . _end , other . end ) return Range ( newstart , newend )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrun True if x is a valid YYYYMMDD date ; otherwise return False .<CODESPLIT>def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The distance between two skip - connections .<CODESPLIT>def skip_connection_distance ( a , b ) : if a [ 2 ] != b [ 2 ] : return 1.0 len_a = abs ( a [ 1 ] - a [ 0 ] ) len_b = abs ( b [ 1 ] - b [ 0 ] ) return ( abs ( a [ 0 ] - b [ 0 ] ) + abs ( len_a - len_b ) ) / ( max ( a [ 0 ] , b [ 0 ] ) + max ( len_a , len_b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str<CODESPLIT>def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverse the normalization done to a batch of images .<CODESPLIT>def denorm ( self , arr ) : if type ( arr ) is not np . ndarray : arr = to_np ( arr ) if len ( arr . shape ) == 3 : arr = arr [ None ] return self . transform . denorm ( np . rollaxis ( arr , 1 , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conver a path string to a list of path elements .<CODESPLIT>def path_to_list ( pathstr ) : return [ elem for elem in pathstr . split ( os . path . pathsep ) if elem ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a millisecond accuracy timestamp to a datetime<CODESPLIT>def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the class is a date type .<CODESPLIT>def is_date_type ( cls ) : if not isinstance ( cls , type ) : return False return issubclass ( cls , date ) and not issubclass ( cls , datetime )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform log transform log ( x + 1 ) . Parameters ---------- data : array_like<CODESPLIT>def log_normalize ( data ) : if sp . issparse ( data ) : data = data . copy ( ) data . data = np . log2 ( data . data + 1 ) return data return np . log2 ( data . astype ( np . float64 ) + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of literal values .<CODESPLIT>def INIT_LIST_EXPR ( self , cursor ) : values = [ self . parse_cursor ( child ) for child in list ( cursor . get_children ( ) ) ] return values
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For list values returns the index location of element x . If x does not exist will raise an error .<CODESPLIT>def sorted_index ( values , x ) : i = bisect_left ( values , x ) j = bisect_right ( values , x ) return values [ i : j ] . index ( x ) + i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>MIME type of the asset .<CODESPLIT>def mimetype ( self ) : return ( self . environment . mimetypes . get ( self . format_extension ) or self . compiler_mimetype or 'application/octet-stream' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Optimized function for calculating the distance between each pair of points in positions1 and positions2 .<CODESPLIT>def _jit_pairwise_distances ( pos1 , pos2 ) : n1 = pos1 . shape [ 0 ] n2 = pos2 . shape [ 0 ] D = np . empty ( ( n1 , n2 ) ) for i in range ( n1 ) : for j in range ( n2 ) : D [ i , j ] = np . sqrt ( ( ( pos1 [ i ] - pos2 [ j ] ) ** 2 ) . sum ( ) ) return D
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns a werkzeug . MultiDict or django . MultiValueDict into a dict with list values : param d : a MultiDict or MultiValueDict instance : return : a dict instance<CODESPLIT>def multidict_to_dict ( d ) : return dict ( ( k , v [ 0 ] if len ( v ) == 1 else v ) for k , v in iterlists ( d ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of indexes of substr . If substr not found list is empty .<CODESPLIT>def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return only the part of the row which should be printed .<CODESPLIT>def _get_printable_columns ( columns , row ) : if not columns : return row # Extract the column values, in the order specified. return tuple ( row [ c ] for c in columns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes the websocket connection .<CODESPLIT>def _close_websocket ( self ) : close_method = getattr ( self . _websocket , "close" , None ) if callable ( close_method ) : asyncio . ensure_future ( close_method ( ) , loop = self . _event_loop ) self . _websocket = None self . _dispatch_event ( event = "close" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the number of leaves in a tree<CODESPLIT>def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove any duplicate entries .<CODESPLIT>def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print emphasized good the given txt message<CODESPLIT>def good ( txt ) : print ( "%s# %s%s%s" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize a sequence of Python objects into a YAML stream . Produce only basic YAML tags . If stream is None return the produced string instead .<CODESPLIT>def safe_dump_all ( documents , stream = None , * * kwds ) : return dump_all ( documents , stream , Dumper = SafeDumper , * * kwds )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return a normalized version of abmn<CODESPLIT>def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace boolean variables by the characters F / T<CODESPLIT>def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given extension is one of the watched extensions<CODESPLIT>def watched_extension ( extension ) : for ext in hamlpy . VALID_EXTENSIONS : if extension . endswith ( '.' + ext ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a DataFrame with the required format for a surface ( sine wave ) plot<CODESPLIT>def sinwave ( n = 4 , inc = .25 ) : x = np . arange ( - n , n , inc ) y = np . arange ( - n , n , inc ) X , Y = np . meshgrid ( x , y ) R = np . sqrt ( X ** 2 + Y ** 2 ) Z = np . sin ( R ) / ( .5 * R ) return pd . DataFrame ( Z , index = x , columns = y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Description : Returns the first index of the array ( vector ) x containing the value i . Parameters : x : one - dimensional array i : search value<CODESPLIT>def get_index_nested ( x , i ) : for ind in range ( len ( x ) ) : if i == x [ ind ] : return ind return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>execute jobs in processes using N threads<CODESPLIT>def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places a legend box outside a matplotlib Axes instance .<CODESPLIT>def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper to create a proxy method in a class .<CODESPLIT>def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shape of histogram s data .<CODESPLIT>def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>There s probably a way to do this with string functions but I was lazy . Replace all instances of \ r or \ n in a string with something else .<CODESPLIT>def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = "" for segment in segments : string += segment return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function that removes a dicts keys that have falsy values<CODESPLIT>def _clean_dict ( target_dict , whitelist = None ) : assert isinstance ( target_dict , dict ) return { ustr ( k ) . strip ( ) : ustr ( v ) . strip ( ) for k , v in target_dict . items ( ) if v not in ( None , Ellipsis , [ ] , ( ) , "" ) and ( not whitelist or k in whitelist ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Guess extraction method given file name ( or path ) .<CODESPLIT>def _guess_extract_method ( fname ) : for method , extensions in _EXTRACTION_METHOD_TO_EXTS : for ext in extensions : if fname . endswith ( ext ) : return method return ExtractMethod . NO_EXTRACT
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join helper<CODESPLIT>def _join ( verb ) : data = pd . merge ( verb . x , verb . y , * * verb . kwargs ) # Preserve x groups if isinstance ( verb . x , GroupedDataFrame ) : data . plydata_groups = list ( verb . x . plydata_groups ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a node from this network .<CODESPLIT>def remove_node ( self , node ) : if _debug : Network . _debug ( "remove_node %r" , node ) self . nodes . remove ( node ) node . lan = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield code with useless pass lines removed .<CODESPLIT>def filter_useless_pass ( source ) : try : marked_lines = frozenset ( useless_pass_line_numbers ( source ) ) except ( SyntaxError , tokenize . TokenError ) : marked_lines = frozenset ( ) sio = io . StringIO ( source ) for line_number , line in enumerate ( sio . readlines ( ) , start = 1 ) : if line_number not in marked_lines : yield line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calcuate mean datetime from datetime list<CODESPLIT>def mean_date ( dt_list ) : dt_list_sort = sorted ( dt_list ) dt_list_sort_rel = [ dt - dt_list_sort [ 0 ] for dt in dt_list_sort ] avg_timedelta = sum ( dt_list_sort_rel , timedelta ( ) ) / len ( dt_list_sort_rel ) return dt_list_sort [ 0 ] + avg_timedelta
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip a section<CODESPLIT>def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Communicate with the child process without closing stdin .<CODESPLIT>def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints the top row of a table<CODESPLIT>def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>More important level : default for print and save<CODESPLIT>def info ( self , message , * args , * * kwargs ) : self . _log ( logging . INFO , message , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to get return code of a url<CODESPLIT>def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts backslashes in path patterns to forward slashes .<CODESPLIT>def normalize_pattern ( pattern ) : if not ( pattern . startswith ( 'RE:' ) or pattern . startswith ( '!RE:' ) ) : pattern = _slashes . sub ( '/' , pattern ) if len ( pattern ) > 1 : pattern = pattern . rstrip ( '/' ) return pattern
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads and iterates through each image file in the given directory<CODESPLIT>def each_img ( img_dir ) : for fname in utils . each_img ( img_dir ) : fname = os . path . join ( img_dir , fname ) yield cv . imread ( fname ) , fname
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stream stdout and stderr from the task container to this process s stdout and stderr respectively .<CODESPLIT>def _stream_docker_logs ( self ) : thread = threading . Thread ( target = self . _stderr_stream_worker ) thread . start ( ) for line in self . docker_client . logs ( self . container , stdout = True , stderr = False , stream = True ) : sys . stdout . write ( line ) thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str<CODESPLIT>def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>New record with renamed keys including keys only found in key_map .<CODESPLIT>def replace_keys ( record : Mapping , key_map : Mapping ) -> dict : return { key_map [ k ] : v for k , v in record . items ( ) if k in key_map }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hides the main window of the terminal and sets the visible flag to False .<CODESPLIT>def hide ( self ) : if not HidePrevention ( self . window ) . may_hide ( ) : return self . hidden = True self . get_widget ( 'window-root' ) . unstick ( ) self . window . hide ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns background color rgb tuple of right line<CODESPLIT>def _get_background_color ( self ) : color = self . cell_attributes [ self . key ] [ "bgcolor" ] return tuple ( c / 255.0 for c in color_pack2rgb ( color ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sum the total number of cycles over a list of tokens .<CODESPLIT>def _sum_cycles_from_tokens ( self , tokens : List [ str ] ) -> int : return sum ( ( int ( self . _nonnumber_pattern . sub ( '' , t ) ) for t in tokens ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // stackoverflow . com / questions / 5098580 / implementing - argmax - in - python<CODESPLIT>def argmax ( l , f = None ) : if f : l = [ f ( i ) for i in l ] return max ( enumerate ( l ) , key = lambda x : x [ 1 ] ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : x : iterable of strings<CODESPLIT>def gen_lower ( x : Iterable [ str ] ) -> Generator [ str , None , None ] : for string in x : yield string . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of processors on this machine .<CODESPLIT>def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( "SC_NPROCESSORS_CONF" ) except ( AttributeError , ValueError ) : pass gen_log . error ( "Could not detect number of processors; assuming 1" ) return 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a conda environment inside the current sandbox for the given list of dependencies and options .<CODESPLIT>def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ "conda" , "create" , "--yes" , "--copy" , "--quiet" , "-p" , env_dir ] + list ( options ) + dependencies log . info ( "Creating conda environment: " ) log . info ( "  command line: %s" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( "Environment created" ) return env_dir , env_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if all of the elements in the list are equal .<CODESPLIT>def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , "Input value must be a list." return not lst or lst . count ( lst [ 0 ] ) == len ( lst )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .<CODESPLIT>def input_int_default ( question = "" , default = 0 ) : answer = input_string ( question ) if answer == "" or answer == "yes" : return default else : return int ( answer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates the returned positional object<CODESPLIT>def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ "seqname" , "position" , "strand" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( "int64" ) assert df . strand . dtype == np . dtype ( "O" ) assert df . seqname . dtype == np . dtype ( "O" ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the encoding type .<CODESPLIT>def get_encoding ( binary ) : try : from chardet import detect except ImportError : LOGGER . error ( "Please install the 'chardet' module" ) sys . exit ( 1 ) encoding = detect ( binary ) . get ( 'encoding' ) return 'iso-8859-1' if encoding == 'CP949' else encoding
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .<CODESPLIT>def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute boxplot for given pandas Series .<CODESPLIT>def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = "|" . join ( map ( str , stats [ 'fliers' ] ) ) return stats
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns HTML from MediaWiki markup<CODESPLIT>def parse ( text , showToc = True ) : p = Parser ( show_toc = showToc ) return p . parse ( text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Directory where to store output<CODESPLIT>def output_dir ( self , * args ) -> str : return os . path . join ( self . project_dir , 'output' , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a WAV file and returns the data and sample rate<CODESPLIT>def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enforce HTML escaping . This will probably double escape variables .<CODESPLIT>def do_forceescape ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return escape ( text_type ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find a reasonable editor to use by default for the system that the cmd2 application is running on .<CODESPLIT>def find_editor ( ) -> str : editor = os . environ . get ( 'EDITOR' ) if not editor : if sys . platform [ : 3 ] == 'win' : editor = 'notepad' else : # Favor command-line editors first so we don't leave the terminal to edit for editor in [ 'vim' , 'vi' , 'emacs' , 'nano' , 'pico' , 'gedit' , 'kate' , 'subl' , 'geany' , 'atom' ] : if which ( editor ) : break return editor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the specified element selector is present on the page .<CODESPLIT>def is_element_present ( driver , selector , by = By . CSS_SELECTOR ) : try : driver . find_element ( by = by , value = selector ) return True except Exception : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list consisting of the cumulative sum of the items in the passed list .<CODESPLIT>def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to identify whether this is an ActivityPub request .<CODESPLIT>def identify_request ( request : RequestType ) -> bool : # noinspection PyBroadException try : data = json . loads ( decode_if_bytes ( request . body ) ) if "@context" in data : return True except Exception : pass return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a list of words given text removing punctuation .<CODESPLIT>def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete an object from the redis table<CODESPLIT>def delete_entry ( self , key ) : pipe = self . client . pipeline ( ) pipe . srem ( self . keys_container , key ) pipe . delete ( key ) pipe . execute ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper parse action to convert tokens to lower case .<CODESPLIT>def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dump string .<CODESPLIT>def dumps ( obj , indent = None , default = None , sort_keys = False , * * kw ) : return YAMLEncoder ( indent = indent , default = default , sort_keys = sort_keys , * * kw ) . encode ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the attributes of an object using dir .<CODESPLIT>def get_object_attrs ( obj ) : attrs = [ k for k in dir ( obj ) if not k . startswith ( '__' ) ] if not attrs : attrs = dir ( obj ) return attrs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert None values to 0 so the data works with Matplotlib : param ts : : return : a list with 0s where Nones existed<CODESPLIT>def __convert_none_to_zero ( self , ts ) : if not ts : return ts ts_clean = [ val if val else 0 for val in ts ] return ts_clean
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorting logic for Quantity objects .<CODESPLIT>def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Acquire a lock file on linux or osx .<CODESPLIT>def acquire_nix ( lock_file ) : # pragma: no cover fd = os . open ( lock_file , OPEN_MODE ) try : fcntl . flock ( fd , fcntl . LOCK_EX | fcntl . LOCK_NB ) except ( IOError , OSError ) : os . close ( fd ) else : return fd
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure the cursor is within horizontal screen bounds .<CODESPLIT>def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager to temporarily disable certificate validation in the standard SSL library .<CODESPLIT>def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>simple method to determine if a url is relative or absolute<CODESPLIT>def is_relative_url ( url ) : if url . startswith ( "#" ) : return None if url . find ( "://" ) > 0 or url . startswith ( "//" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the short - time Fourier transform magnitude .<CODESPLIT>def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all the files and subdirectories in a directory .<CODESPLIT>def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert a ctypes structure to a dictionary<CODESPLIT>def struct2dict ( struct ) : return { x : getattr ( struct , x ) for x in dict ( struct . _fields_ ) . keys ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull comma separated string values out of a text file and converts them to float list<CODESPLIT>def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a numpy array of integers<CODESPLIT>def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I strip extra whitespace off multi - line strings if they are ready to be stripped!<CODESPLIT>def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a line of text into an MLlib LabeledPoint object .<CODESPLIT>def parsePoint ( line ) : values = [ float ( s ) for s in line . split ( ' ' ) ] if values [ 0 ] == - 1 : # Convert -1 labels to 0 for MLlib values [ 0 ] = 0 return LabeledPoint ( values [ 0 ] , values [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .<CODESPLIT>def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform log transform log ( x + 1 ) . Parameters ---------- data : array_like<CODESPLIT>def log_normalize ( data ) : if sp . issparse ( data ) : data = data . copy ( ) data . data = np . log2 ( data . data + 1 ) return data return np . log2 ( data . astype ( np . float64 ) + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get device state via HTTP GET .<CODESPLIT>def device_state ( device_id ) : if device_id not in devices : return jsonify ( success = False ) return jsonify ( state = devices [ device_id ] . state )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A basic check of if the program is running in interactive mode<CODESPLIT>def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\r' try : import threading except ImportError : return False else : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a pie chart that depicts the distribution of the allocated memory for a given snapshot . The chart is saved to filename .<CODESPLIT>def create_pie_chart ( self , snapshot , filename = '' ) : try : from pylab import figure , title , pie , axes , savefig from pylab import sum as pylab_sum except ImportError : return self . nopylab_msg % ( "pie_chart" ) # Don't bother illustrating a pie without pieces. if not snapshot . tracked_total : return '' classlist = [ ] sizelist = [ ] for k , v in list ( snapshot . classes . items ( ) ) : if v [ 'pct' ] > 3.0 : classlist . append ( k ) sizelist . append ( v [ 'sum' ] ) sizelist . insert ( 0 , snapshot . asizeof_total - pylab_sum ( sizelist ) ) classlist . insert ( 0 , 'Other' ) #sizelist = [x*0.01 for x in sizelist] title ( "Snapshot (%s) Memory Distribution" % ( snapshot . desc ) ) figure ( figsize = ( 8 , 8 ) ) axes ( [ 0.1 , 0.1 , 0.8 , 0.8 ] ) pie ( sizelist , labels = classlist ) savefig ( filename , dpi = 50 ) return self . chart_tag % ( self . relative_path ( filename ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make dictionary version of enumerated class .<CODESPLIT>def to_dict ( cls ) : return dict ( ( item . name , item . number ) for item in iter ( cls ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field is a member of the given value .<CODESPLIT>def selectin ( table , field , value , complement = False ) : return select ( table , field , lambda v : v in value , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read the configuration file and return a section .<CODESPLIT>def _config_section ( config , section ) : path = os . path . join ( config . get ( 'config_path' ) , config . get ( 'config_file' ) ) conf = _config_ini ( path ) return conf . get ( section )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resizes an image preserving the aspect ratio .<CODESPLIT>def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ctypes int pointer array to a numpy array .<CODESPLIT>def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load an object from disk at explicit path<CODESPLIT>def load_object_at_path ( path ) : with open ( path , 'r' ) as f : data = _deserialize ( f . read ( ) ) return aadict ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>str to bytes ( py3k )<CODESPLIT>def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the folder exisits . If not create the folder<CODESPLIT>def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate the configuration file .<CODESPLIT>def validate ( self ) : validator = Draft4Validator ( self . SCHEMA ) if not validator . is_valid ( self . config ) : for err in validator . iter_errors ( self . config ) : LOGGER . error ( str ( err . message ) ) validator . validate ( self . config )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds parent folder of file<CODESPLIT>def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add params to doc string<CODESPLIT>def _add_params_docstring ( params ) : p_string = "\nAccepts the following paramters: \n" for param in params : p_string += "name: %s, required: %s, description: %s \n" % ( param [ 'name' ] , param [ 'required' ] , param [ 'description' ] ) return p_string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of branches in the current repo .<CODESPLIT>def branches ( ) : # type: () -> List[str] out = shell . run ( 'git branch' , capture = True , never_pretend = True ) . stdout . strip ( ) return [ x . strip ( '* \t\n' ) for x in out . splitlines ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterable - first replacement of Python s built - in map () function .<CODESPLIT>def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def mouse_get_pos ( ) : p = POINT ( ) AUTO_IT . AU3_MouseGetPos ( ctypes . byref ( p ) ) return p . x , p . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .<CODESPLIT>def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run Python test cases against Java runtime classes .<CODESPLIT>def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>replace nan in a by val and returns the replaced array and the nan position<CODESPLIT>def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a random element from seq n times . If n is None it continues indefinitly<CODESPLIT>def rand_elem ( seq , n = None ) : return map ( random . choice , repeat ( seq , n ) if n is not None else repeat ( seq ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field evaluates True .<CODESPLIT>def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get a value from a tag ( if it exists )<CODESPLIT>def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to infer an object s dtype for use in arithmetic ops<CODESPLIT>def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to draw lines connecting a set of nodes that are scaled for the Screen .<CODESPLIT>def _draw_lines_internal ( self , coords , colour , bg ) : for i , ( x , y ) in enumerate ( coords ) : if i == 0 : self . _screen . move ( x , y ) else : self . _screen . draw ( x , y , colour = colour , bg = bg , thin = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes tags from objects<CODESPLIT>def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a lowercased string with non alphabetic chars removed .<CODESPLIT>def _to_lower_alpha_only ( s ) : s = re . sub ( r'\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\s]' , '' , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the remote file exists .<CODESPLIT>def remote_file_exists ( self , url ) : status = requests . head ( url ) . status_code if status != 200 : raise RemoteFileDoesntExist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I strip extra whitespace off multi - line strings if they are ready to be stripped!<CODESPLIT>def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert numpy s datetime64 to datetime<CODESPLIT>def datetime64_to_datetime ( dt ) : dt64 = np . datetime64 ( dt ) ts = ( dt64 - np . datetime64 ( '1970-01-01T00:00:00' ) ) / np . timedelta64 ( 1 , 's' ) return datetime . datetime . utcfromtimestamp ( ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Temporary helper function to link to the API routes<CODESPLIT>def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a slice from a table column holding arrays . ( see : func : table . getcolslice )<CODESPLIT>def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a reversed iterable over the items in the dictionary . Items are iterated over in their reverse sort order .<CODESPLIT>def __reversed__ ( self ) : _dict = self . _dict return iter ( ( key , _dict [ key ] ) for key in reversed ( self . _list ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy given string into system clipboard .<CODESPLIT>def copy ( string , * * kwargs ) : window = Tk ( ) window . withdraw ( ) window . clipboard_clear ( ) window . clipboard_append ( string ) window . destroy ( ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate a CamelCase string from an underscore_string .<CODESPLIT>def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Time execution of function . Returns ( res seconds ) .<CODESPLIT>def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Registers default factories for logging standard package .<CODESPLIT>def register_logging_factories ( loader ) : loader . register_factory ( logging . Logger , LoggerFactory ) loader . register_factory ( logging . Handler , LoggingHandlerFactory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert things on the way from Python to the database .<CODESPLIT>def process_literal_param ( self , value : Optional [ List [ int ] ] , dialect : Dialect ) -> str : retval = self . _intlist_to_dbstr ( value ) return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute boxplot for given pandas Series .<CODESPLIT>def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = "|" . join ( map ( str , stats [ 'fliers' ] ) ) return stats
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert the given list of parameters to a JSON object .<CODESPLIT>def save_list ( key , * values ) : return json . dumps ( { key : [ _get_json ( value ) for value in values ] } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract text from a given lxml node .<CODESPLIT>def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( ".//text()" ) ) ) ) return " " . join ( text for text in texts if text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location .<CODESPLIT>def get_mnist ( data_type = "train" , location = "/tmp/mnist" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if you are on a 64 bit platform<CODESPLIT>def check64bit ( current_system = "python" ) : if current_system == "python" : return sys . maxsize > 2147483647 elif current_system == "os" : import platform pm = platform . machine ( ) if pm != ".." and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert from canvas to screen coordinates<CODESPLIT>def c2s ( self , p = [ 0 , 0 ] ) : return ( ( p [ 0 ] - self . canvasx ( self . cx1 ) , p [ 1 ] - self . canvasy ( self . cy1 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If the requirement is frozen to a github url check for new commits .<CODESPLIT>def check_github ( self ) : for name , req in list ( self . reqs . items ( ) ) : req_url = req [ "url" ] if not req_url : continue req_url = str ( req_url ) if req_url . startswith ( "git" ) and "github.com/" not in req_url : continue if req_url . endswith ( ( ".tar.gz" , ".tar.bz2" , ".zip" ) ) : continue headers = { "content-type" : "application/json" , } if self . github_api_token : headers [ "Authorization" ] = "token {0}" . format ( self . github_api_token ) try : path_parts = urlparse ( req_url ) . path . split ( "#" , 1 ) [ 0 ] . strip ( "/" ) . rstrip ( "/" ) . split ( "/" ) if len ( path_parts ) == 2 : user , repo = path_parts elif 'archive' in path_parts : # Supports URL of format: # https://github.com/django/django/archive/master.tar.gz#egg=Django # https://github.com/django/django/archive/master.zip#egg=Django user , repo = path_parts [ : 2 ] repo += '@' + path_parts [ - 1 ] . replace ( '.tar.gz' , '' ) . replace ( '.zip' , '' ) else : self . style . ERROR ( "\nFailed to parse %r\n" % ( req_url , ) ) continue except ( ValueError , IndexError ) as e : self . stdout . write ( self . style . ERROR ( "\nFailed to parse %r: %s\n" % ( req_url , e ) ) ) continue try : test_auth = requests . get ( "https://api.github.com/django/" , headers = headers ) . json ( ) except HTTPError as e : self . stdout . write ( "\n%s\n" % str ( e ) ) return if "message" in test_auth and test_auth [ "message" ] == "Bad credentials" : self . stdout . write ( self . style . ERROR ( "\nGithub API: Bad credentials. Aborting!\n" ) ) return elif "message" in test_auth and test_auth [ "message" ] . startswith ( "API Rate Limit Exceeded" ) : self . stdout . write ( self . style . ERROR ( "\nGithub API: Rate Limit Exceeded. Aborting!\n" ) ) return frozen_commit_sha = None if ".git" in repo : repo_name , frozen_commit_full = repo . split ( ".git" ) if frozen_commit_full . startswith ( "@" ) : frozen_commit_sha = frozen_commit_full [ 1 : ] elif "@" in repo : repo_name , frozen_commit_sha = repo . split ( "@" ) if frozen_commit_sha is None : msg = self . style . ERROR ( "repo is not frozen" ) if frozen_commit_sha : branch_url = "https://api.github.com/repos/{0}/{1}/branches" . format ( user , repo_name ) branch_data = requests . get ( branch_url , headers = headers ) . json ( ) frozen_commit_url = "https://api.github.com/repos/{0}/{1}/commits/{2}" . format ( user , repo_name , frozen_commit_sha ) frozen_commit_data = requests . get ( frozen_commit_url , headers = headers ) . json ( ) if "message" in frozen_commit_data and frozen_commit_data [ "message" ] == "Not Found" : msg = self . style . ERROR ( "{0} not found in {1}. Repo may be private." . format ( frozen_commit_sha [ : 10 ] , name ) ) elif frozen_commit_data [ "sha" ] in [ branch [ "commit" ] [ "sha" ] for branch in branch_data ] : msg = self . style . BOLD ( "up to date" ) else : msg = self . style . INFO ( "{0} is not the head of any branch" . format ( frozen_commit_data [ "sha" ] [ : 10 ] ) ) if "dist" in req : pkg_info = "{dist.project_name} {dist.version}" . format ( dist = req [ "dist" ] ) elif frozen_commit_sha is None : pkg_info = name else : pkg_info = "{0} {1}" . format ( name , frozen_commit_sha [ : 10 ] ) self . stdout . write ( "{pkg_info:40} {msg}" . format ( pkg_info = pkg_info , msg = msg ) ) del self . reqs [ name ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print the values of all this object s Parameters .<CODESPLIT>def print_param_values ( self_ ) : self = self_ . self for name , val in self . param . get_param_values ( ) : print ( '%s.%s = %s' % ( self . name , name , val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accepts a NumberGenerator operand an operator and optional arguments to be provided to the operator when calling it on the operand .<CODESPLIT>def __init__ ( self , operand , operator , * * args ) : # Note that it's currently not possible to set # parameters in the superclass when creating an instance, # because **args is used by this class itself. super ( UnaryOperator , self ) . __init__ ( ) self . operand = operand self . operator = operator self . args = args
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list produced by applying : func : multiple_replace to every string in stringlist .<CODESPLIT>def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like rotate but modifies l in - place .<CODESPLIT>def iprotate ( l , steps = 1 ) : if len ( l ) : steps %= len ( l ) if steps : firstPart = l [ : steps ] del l [ : steps ] l . extend ( firstPart ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create NumPy array from a pointer to some memory .<CODESPLIT>def _frombuffer ( ptr , frames , channels , dtype ) : framesize = channels * dtype . itemsize data = np . frombuffer ( ffi . buffer ( ptr , frames * framesize ) , dtype = dtype ) data . shape = - 1 , channels return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate standard deviation weighted by errors<CODESPLIT>def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the sql query<CODESPLIT>def get_sql ( query ) : sql = str ( query . statement . compile ( dialect = sqlite . dialect ( ) , compile_kwargs = { "literal_binds" : True } ) ) return sql
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shut down a specific process .<CODESPLIT>def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get terminal width<CODESPLIT>def get_width ( ) : # Get terminal size ws = struct . pack ( "HHHH" , 0 , 0 , 0 , 0 ) ws = fcntl . ioctl ( sys . stdout . fileno ( ) , termios . TIOCGWINSZ , ws ) lines , columns , x , y = struct . unpack ( "HHHH" , ws ) width = min ( columns * 39 // 40 , columns - 2 ) return width
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return grandparent s path string<CODESPLIT>def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>replace nan in a by val and returns the replaced array and the nan position<CODESPLIT>def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new dict from an existing dict that only has the given keys<CODESPLIT>def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises an AssertionError if expected is actual .<CODESPLIT>def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , "is" , extra )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the high median of data .<CODESPLIT>def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( "no median for empty data" ) return data [ n // 2 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call it on your own endpoint s to update the back history navigation . If you bypass it the next submit or back will go over it .<CODESPLIT>def update_redirect ( self ) : page_history = Stack ( session . get ( "page_history" , [ ] ) ) page_history . push ( request . url ) session [ "page_history" ] = page_history . to_json ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .<CODESPLIT>def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( "lib2to3.fixes" , args = args . sources ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>writes a string to file<CODESPLIT>def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create 2D rotation matrix<CODESPLIT>def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the RMS of the audio<CODESPLIT>def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = "{}[{}]" . format ( pdf_path , page_num ) ) with pdf_img . convert ( "png" ) as converted : # Set white background. converted . background_color = Color ( "white" ) converted . alpha_channel = "remove" converted . save ( filename = img_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a property by name<CODESPLIT>def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts from a Minigo coordinate to a GTP coordinate .<CODESPLIT>def to_gtp ( coord ) : if coord is None : return 'pass' y , x = coord return '{}{}' . format ( _GTP_COLUMNS [ x ] , go . N - y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>stupid windows . converts the backslash to forwardslash for consistency<CODESPLIT>def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , "/" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a vector orthogonal to the given triangle<CODESPLIT>def triangle_normal ( a , b , c ) : normal = np . cross ( a - c , b - c ) norm = np . linalg . norm ( normal ) return normal / norm
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extend the list by appending all the items in the given list .<CODESPLIT>def extend ( self , iterable ) : return super ( Collection , self ) . extend ( self . _ensure_iterable_is_valid ( iterable ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the opposite of input condition .<CODESPLIT>def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set yaxis limits .<CODESPLIT>def ylim ( self , low , high , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'range' ] = [ low , high ] return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the queue is full<CODESPLIT>def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a datetime from GnuCash 2 . 6 date string<CODESPLIT>def get_from_gnucash26_date ( date_str : str ) -> date : date_format = "%Y%m%d" result = datetime . strptime ( date_str , date_format ) . date ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>There s probably a way to do this with string functions but I was lazy . Replace all instances of \ r or \ n in a string with something else .<CODESPLIT>def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = "" for segment in segments : string += segment return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field is not None .<CODESPLIT>def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log - normal function from scipy<CODESPLIT>def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pre - order depth - first<CODESPLIT>def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets a user s password in the keyring storage<CODESPLIT>def set_user_password ( environment , parameter , password ) : username = '%s:%s' % ( environment , parameter ) return password_set ( username , password )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yields tokens from input string .<CODESPLIT>def get_tokens ( line : str ) -> Iterator [ str ] : for token in line . rstrip ( ) . split ( ) : if len ( token ) > 0 : yield token
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the log of the magnitude spectrum of frames<CODESPLIT>def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to restore button state .<CODESPLIT>def restore_button_state ( self ) : self . parent . pbnNext . setEnabled ( self . next_button_state ) self . parent . pbnBack . setEnabled ( self . back_button_state )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quit signal handler .<CODESPLIT>def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( "\nSIGINT in frame signal received. Quitting..." ) sys . stdout . flush ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle an IOError exception .<CODESPLIT>def on_IOError ( self , e ) : sys . stderr . write ( "Error: %s: \"%s\"\n" % ( e . strerror , e . filename ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stream stdout and stderr from the task container to this process s stdout and stderr respectively .<CODESPLIT>def _stream_docker_logs ( self ) : thread = threading . Thread ( target = self . _stderr_stream_worker ) thread . start ( ) for line in self . docker_client . logs ( self . container , stdout = True , stderr = False , stream = True ) : sys . stdout . write ( line ) thread . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Squash self . out into string .<CODESPLIT>def build_output ( self , fout ) : fout . write ( '\n' . join ( [ s for s in self . out ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return ( first channel data sample frequency sample width ) from a . wav file .<CODESPLIT>def data_from_file ( file ) : fp = wave . open ( file , 'r' ) data = fp . readframes ( fp . getnframes ( ) ) channels = fp . getnchannels ( ) freq = fp . getframerate ( ) bits = fp . getsampwidth ( ) # Unpack bytes -- warning currently only tested with 16 bit wavefiles. 32 # bit not supported. data = struct . unpack ( ( '%sh' % fp . getnframes ( ) ) * channels , data ) # Only use first channel channel1 = [ ] n = 0 for d in data : if n % channels == 0 : channel1 . append ( d ) n += 1 fp . close ( ) return ( channel1 , freq , bits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert dict of ascii str / unicode to dict of str if necessary<CODESPLIT>def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends a PDF to a pyPDF writer . Legacy interface .<CODESPLIT>def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs a join using the union join function .<CODESPLIT>def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column<CODESPLIT>def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread<CODESPLIT>async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator which adds correct MIME type for python source to the decorated bottle API function .<CODESPLIT>def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = "text/x-python" return fn ( * args , * * kwargs ) return python_mime_decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a set of unique n - grams from a string .<CODESPLIT>def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print at most limit elements of list .<CODESPLIT>def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ "'%s'" % str ( i ) for i in lst ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the request payload size<CODESPLIT>def calculate_size ( name , data_list ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += INT_SIZE_IN_BYTES for data_list_item in data_list : data_size += calculate_size_data ( data_list_item ) return data_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the local ip of this device<CODESPLIT>def _get_local_ip ( ) : return set ( [ x [ 4 ] [ 0 ] for x in socket . getaddrinfo ( socket . gethostname ( ) , 80 , socket . AF_INET ) ] ) . pop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a file from an AWS S3 bucket .<CODESPLIT>def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .<CODESPLIT>def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap a function as a method .<CODESPLIT>def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the channels of a colorbar .<CODESPLIT>def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the offset of the current cursor position in rl_line_buffer<CODESPLIT>def rl_get_point ( ) -> int : # pragma: no cover if rl_type == RlType . GNU : return ctypes . c_int . in_dll ( readline_lib , "rl_point" ) . value elif rl_type == RlType . PYREADLINE : return readline . rl . mode . l_buffer . point else : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple helper hash function<CODESPLIT>def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns ( width height ) for the given variable<CODESPLIT>def get_grid_spatial_dimensions ( self , variable ) : data = self . open_dataset ( self . service ) . variables [ variable . variable ] dimensions = list ( data . dimensions ) return data . shape [ dimensions . index ( variable . x_dimension ) ] , data . shape [ dimensions . index ( variable . y_dimension ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets up the python include paths to include src<CODESPLIT>def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , "src" ) ] + sys . path pass return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns nr of first entry parseable to float in ll None otherwise<CODESPLIT>def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a dict to a querystring suitable to be appended to a URL .<CODESPLIT>def dict_to_querystring ( dictionary ) : s = u"" for d in dictionary . keys ( ) : s = unicode . format ( u"{0}{1}={2}&" , s , d , dictionary [ d ] ) return s [ : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to read JSON file as OrderedDict<CODESPLIT>def _read_json_file ( self , json_file ) : self . log . debug ( "Reading '%s' JSON file..." % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format numpy array as a string .<CODESPLIT>def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( "," ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + "%s[%s]" % ( arr . dtype , shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function that reads a local file and generates a SHA256 hash digest for it<CODESPLIT>def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return line ending .<CODESPLIT>def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert datetime to epoch seconds .<CODESPLIT>def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the unit tests on an installed copy of unyt .<CODESPLIT>def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves a list of member - like objects ( members or properties ) that are publically exposed .<CODESPLIT>def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( "_" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>htmlify string<CODESPLIT>def safe_quotes ( text , escape_single_quotes = False ) : if isinstance ( text , str ) : safe_text = text . replace ( '"' , "&quot;" ) if escape_single_quotes : safe_text = safe_text . replace ( "'" , "&#92;'" ) return safe_text . replace ( 'True' , 'true' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns HTML from MediaWiki markup<CODESPLIT>def parse ( text , showToc = True ) : p = Parser ( show_toc = showToc ) return p . parse ( text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Allocate device memory .<CODESPLIT>def cudaMalloc ( count , ctype = None ) : ptr = ctypes . c_void_p ( ) status = _libcudart . cudaMalloc ( ctypes . byref ( ptr ) , count ) cudaCheckStatus ( status ) if ctype != None : ptr = ctypes . cast ( ptr , ctypes . POINTER ( ctype ) ) return ptr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of synsets of a word after lemmatization .<CODESPLIT>def has_synset ( word : str ) -> list : return wn . synsets ( lemmatize ( word , neverstem = True ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An enum is encoded by a int representing the zero - based position of the symbol in the schema .<CODESPLIT>def write_enum ( fo , datum , schema ) : index = schema [ 'symbols' ] . index ( datum ) write_int ( fo , index )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Upload a directory on the remote host .<CODESPLIT>def send_dir ( self , local_path , remote_path , user = 'root' ) : self . enable_user ( user ) return self . ssh_pool . send_dir ( user , local_path , remote_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Google AppEngine Helper to convert a data type into a string .<CODESPLIT>def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>apply a function to all non - dict values in a dictionary<CODESPLIT>def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add value to a set in a dictionary by key<CODESPLIT>def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last n rows in the table<CODESPLIT>def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format numpy array as a string .<CODESPLIT>def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( "," ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + "%s[%s]" % ( arr . dtype , shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Guess the input type of the parameter based off the default value if unknown use text<CODESPLIT>def _guess_type ( val ) : if isinstance ( val , bool ) : return "choice" elif isinstance ( val , int ) : return "number" elif isinstance ( val , float ) : return "number" elif isinstance ( val , str ) : return "text" elif hasattr ( val , 'read' ) : return "file" else : return "text"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Root Mean Square<CODESPLIT>def rms ( x ) : try : return ( np . array ( x ) ** 2 ) . mean ( ) ** 0.5 except : x = np . array ( dropna ( x ) ) invN = 1.0 / len ( x ) return ( sum ( invN * ( x_i ** 2 ) for x_i in x ) ) ** .5
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a name in camelCase return in snake_case<CODESPLIT>def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\1_\2' , name ) return ALL_CAP_REGEX . sub ( r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print emphasized good the given txt message<CODESPLIT>def good ( txt ) : print ( "%s# %s%s%s" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return start and end date of the current week .<CODESPLIT>def this_week ( ) : since = TODAY + delta ( weekday = MONDAY ( - 1 ) ) until = since + delta ( weeks = 1 ) return Date ( since ) , Date ( until )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Linear oldstyle interpolation of the transform matrix .<CODESPLIT>def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>abstract method<CODESPLIT>def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the keys that maps to the top n max values in the given dict .<CODESPLIT>def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if filename has changed since the last check . If this is the first check assume the file is changed .<CODESPLIT>def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to make map () behave the same on Py2 and Py3 .<CODESPLIT>def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates shannon entropy in bits .<CODESPLIT>def shannon_entropy ( p ) : return - np . sum ( np . where ( p != 0 , p * np . log2 ( p ) , 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tiny hparams suitable for CIFAR / etc .<CODESPLIT>def revnet_164_cifar ( ) : hparams = revnet_cifar_base ( ) hparams . bottleneck = True hparams . num_channels = [ 16 , 32 , 64 ] hparams . num_layers_per_block = [ 8 , 8 , 8 ] return hparams
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit without garbage collection this speeds up exit by about 10ms for things like bash completion .<CODESPLIT>def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List APIs in account .<CODESPLIT>def list_apis ( awsclient ) : client_api = awsclient . get_client ( 'apigateway' ) apis = client_api . get_rest_apis ( ) [ 'items' ] for api in apis : print ( json2table ( api ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A method used to round a number in the way that UsefulUtils rounds .<CODESPLIT>def specialRound ( number , rounding ) : temp = 0 if rounding == 0 : temp = number else : temp = round ( number , rounding ) if temp % 1 == 0 : return int ( temp ) else : return float ( temp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks to see if a 2D list is a valid 2D matrix<CODESPLIT>def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use the S3 SWAG backend .<CODESPLIT>def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends the prefix to the topic before sendingf<CODESPLIT>def send ( self , topic , * args , * * kwargs ) : prefix_topic = self . heroku_kafka . prefix_topic ( topic ) return super ( HerokuKafkaProducer , self ) . send ( prefix_topic , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare two strings while protecting against timing attacks<CODESPLIT>def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the device id<CODESPLIT>def _get_device_id ( self , bus ) : _dbus = bus . get ( SERVICE_BUS , PATH ) devices = _dbus . devices ( ) if self . device is None and self . device_id is None and len ( devices ) == 1 : return devices [ 0 ] for id in devices : self . _dev = bus . get ( SERVICE_BUS , DEVICE_PATH + "/%s" % id ) if self . device == self . _dev . name : return id return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pick an unused port . There is a slight chance that this wont work .<CODESPLIT>def pick_unused_port ( self ) : s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . bind ( ( '127.0.0.1' , 0 ) ) _ , port = s . getsockname ( ) s . close ( ) return port
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return opened file with a specific encoding .<CODESPLIT>def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Integer to two bytes<CODESPLIT>def intToBin ( i ) : # divide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return i . to_bytes ( 2 , byteorder = 'little' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim a PIL image and remove white space .<CODESPLIT>def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .<CODESPLIT>def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Value of property .<CODESPLIT>def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a number of second into a time<CODESPLIT>def seconds_to_time ( x ) : t = int ( x * 10 ** 6 ) ms = t % 10 ** 6 t = t // 10 ** 6 s = t % 60 t = t // 60 m = t % 60 t = t // 60 h = t return time ( h , m , s , ms )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Idempotent and None - safe version of strict_bool .<CODESPLIT>def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fast median operation for masked array using 50th - percentile<CODESPLIT>def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .<CODESPLIT>def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears globals and reloads modules<CODESPLIT>def clear_globals_reload_modules ( self ) : self . code_array . clear_globals ( ) self . code_array . reload_modules ( ) # Clear result cache self . code_array . result_cache . clear ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list of coords for 3 points Compute the area of this triangle .<CODESPLIT>def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Intersect dictionaries d1 and d2 by key * and * value .<CODESPLIT>def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get hue value of HSL color .<CODESPLIT>def _hue ( color , * * kwargs ) : h = colorsys . rgb_to_hls ( * [ x / 255.0 for x in color . value [ : 3 ] ] ) [ 0 ] return NumberValue ( h * 360.0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether * obj * is iterable lazily such as generators range objects etc .<CODESPLIT>def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Se asegura de que un directorio exista .<CODESPLIT>def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given object conforms to the Serializable protocol .<CODESPLIT>def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits string into n sized chunks .<CODESPLIT>def schunk ( string , size ) : return [ string [ i : i + size ] for i in range ( 0 , len ( string ) , size ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A tensorflow variable tranfomed to be constrained in a L2 unit ball .<CODESPLIT>def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>print the message to the predefined log file without newline<CODESPLIT>def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of processors on this machine .<CODESPLIT>def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( "SC_NPROCESSORS_CONF" ) except ( AttributeError , ValueError ) : pass gen_log . error ( "Could not detect number of processors; assuming 1" ) return 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the index of elem in the reversed iterator .<CODESPLIT>def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check for app updates and print / log them .<CODESPLIT>def check_update ( ) : logging . info ( 'Check for app updates.' ) try : update = updater . check_for_app_updates ( ) except Exception : logging . exception ( 'Check for updates failed.' ) return if update : print ( "!!! UPDATE AVAILABLE !!!\n" "" + static_data . PROJECT_URL + "\n\n" ) logging . info ( "Update available: " + static_data . PROJECT_URL ) else : logging . info ( "No update available." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets up the python include paths to include src<CODESPLIT>def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , "src" ) ] + sys . path pass return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns true if all of the elements in the list are equal .<CODESPLIT>def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , "Input value must be a list." return not lst or lst . count ( lst [ 0 ] ) == len ( lst )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove key from dict and return value .<CODESPLIT>def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set nan and inf rows from x to zero<CODESPLIT>def clean_with_zeros ( self , x ) : x [ ~ np . any ( np . isnan ( x ) | np . isinf ( x ) , axis = 1 ) ] = 0 return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>linear regression calculation<CODESPLIT>def linregress ( x , y , return_stats = False ) : a1 , a0 , r_value , p_value , stderr = scipy . stats . linregress ( x , y ) retval = a1 , a0 if return_stats : retval += r_value , p_value , stderr return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mark a given source line as executed count times .<CODESPLIT>def mark ( self , lineno , count = 1 ) : self . sourcelines [ lineno ] = self . sourcelines . get ( lineno , 0 ) + count
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the language parameter from the current request .<CODESPLIT>def get_language ( self ) : return get_language_parameter ( self . request , self . query_language_key , default = self . get_default_language ( object = object ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a single list from an asynchronous sequence .<CODESPLIT>async def list ( source ) : result = [ ] async with streamcontext ( source ) as streamer : async for item in streamer : result . append ( item ) yield result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if variable is a set<CODESPLIT>def is_set ( self , key ) : data = self . model . get_data ( ) return isinstance ( data [ key ] , set )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to snake_case .<CODESPLIT>def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill missing values in pandas objects and numpy arrays .<CODESPLIT>def fillna ( series_or_arr , missing_value = 0.0 ) : if pandas . notnull ( missing_value ) : if isinstance ( series_or_arr , ( numpy . ndarray ) ) : series_or_arr [ numpy . isnan ( series_or_arr ) ] = missing_value else : series_or_arr . fillna ( missing_value , inplace = True ) return series_or_arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the list of properties specified for a model in an index .<CODESPLIT>def get_model_index_properties ( instance , index ) : mapping = get_index_mapping ( index ) doc_type = instance . _meta . model_name . lower ( ) return list ( mapping [ "mappings" ] [ doc_type ] [ "properties" ] . keys ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the percentile of a sorted list of values .<CODESPLIT>def percentile ( sorted_list , percent , key = lambda x : x ) : if not sorted_list : return None if percent == 1 : return float ( sorted_list [ - 1 ] ) if percent == 0 : return float ( sorted_list [ 0 ] ) n = len ( sorted_list ) i = percent * n if ceil ( i ) == i : i = int ( i ) return ( sorted_list [ i - 1 ] + sorted_list [ i ] ) / 2 return float ( sorted_list [ ceil ( i ) - 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the base directory<CODESPLIT>def get_base_dir ( ) : return os . path . split ( os . path . abspath ( os . path . dirname ( __file__ ) ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the configuration dictionary to an output file .<CODESPLIT>def write_config ( self , outfile ) : utils . write_yaml ( self . config , outfile , default_flow_style = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if two pathes represent the same file .<CODESPLIT>def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if value is a valid UUID .<CODESPLIT>def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of characters in two strings that don t exactly match<CODESPLIT>def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves a list of member - like objects ( members or properties ) that are publically exposed .<CODESPLIT>def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( "_" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>execute jobs in processes using N threads<CODESPLIT>def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the width of the table that would be printed . : rtype : int<CODESPLIT>def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get user input from the command line via raw_input / input .<CODESPLIT>def get_raw_input ( description , default = False ) : additional = ' (default: %s)' % default if default else '' prompt = '    %s%s: ' % ( description , additional ) user_input = input_ ( prompt ) return user_input
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Advance the iterator without returning the old head .<CODESPLIT>def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unified rounding in all python versions .<CODESPLIT>def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts an RGB image to grayscale using matlab s algorithm .<CODESPLIT>def rgb2gray ( img ) : T = np . linalg . inv ( np . array ( [ [ 1.0 , 0.956 , 0.621 ] , [ 1.0 , - 0.272 , - 0.647 ] , [ 1.0 , - 1.106 , 1.703 ] , ] ) ) r_c , g_c , b_c = T [ 0 ] r , g , b = np . rollaxis ( as_float_image ( img ) , axis = - 1 ) return r_c * r + g_c * g + b_c * b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Proximal operator to project onto zero<CODESPLIT>def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage .<CODESPLIT>def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param list_of_points : : return : list_of_points with None s removed<CODESPLIT>def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether a variable is a numpy float array .<CODESPLIT>def is_float_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . floating )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrun True if x is a valid YYYYMMDD date ; otherwise return False .<CODESPLIT>def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get image as a buffer in ( format ) . Format should be jpeg png etc .<CODESPLIT>def get_buffer ( self , data_np , header , format , output = None ) : if not have_pil : raise Exception ( "Install PIL to use this method" ) image = PILimage . fromarray ( data_np ) buf = output if buf is None : buf = BytesIO ( ) image . save ( buf , format ) return buf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a vector with the elements rounded to the given number of digits .<CODESPLIT>def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple wrapper to kubectl .<CODESPLIT>def kubectl ( * args , input = None , * * flags ) : # Build command line call. line = [ 'kubectl' ] + list ( args ) line = line + get_flag_args ( * * flags ) if input is not None : line = line + [ '-f' , '-' ] # Run subprocess output = subprocess . run ( line , input = input , capture_output = True , text = True ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log the exc_info tuple in the server log .<CODESPLIT>def log_exception ( exc_info = None , stream = None ) : exc_info = exc_info or sys . exc_info ( ) stream = stream or sys . stderr try : from traceback import print_exception print_exception ( exc_info [ 0 ] , exc_info [ 1 ] , exc_info [ 2 ] , None , stream ) stream . flush ( ) finally : exc_info = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>merge two Mapping objects keeping the type of the first mapping<CODESPLIT>def _merge_maps ( m1 , m2 ) : return type ( m1 ) ( chain ( m1 . items ( ) , m2 . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find a model reference by its table name<CODESPLIT>def find_model_by_table_name ( name ) : for model in ModelBase . _decl_class_registry . values ( ) : if hasattr ( model , '__table__' ) and model . __table__ . fullname == name : return model return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert audio data into a frequency - amplitude table using fast fourier transformation .<CODESPLIT>def find_frequencies ( data , freq = 44100 , bits = 16 ) : # Fast fourier transform n = len ( data ) p = _fft ( data ) uniquePts = numpy . ceil ( ( n + 1 ) / 2.0 ) # Scale by the length (n) and square the value to get the amplitude p = [ ( abs ( x ) / float ( n ) ) ** 2 * 2 for x in p [ 0 : uniquePts ] ] p [ 0 ] = p [ 0 ] / 2 if n % 2 == 0 : p [ - 1 ] = p [ - 1 ] / 2 # Generate the frequencies and zip with the amplitudes s = freq / float ( n ) freqArray = numpy . arange ( 0 , uniquePts * s , s ) return zip ( freqArray , p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether the item is a placeholder or contains a placeholder .<CODESPLIT>def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return ( first column model index last column model index ) tuple for a configTreeItem<CODESPLIT>def indexTupleFromItem ( self , treeItem ) : # TODO: move to BaseTreeItem? if not treeItem : return ( QtCore . QModelIndex ( ) , QtCore . QModelIndex ( ) ) if not treeItem . parentItem : # TODO: only necessary because of childNumber? return ( QtCore . QModelIndex ( ) , QtCore . QModelIndex ( ) ) # Is there a bug in Qt in QStandardItemModel::indexFromItem? # It passes the parent in createIndex. TODO: investigate row = treeItem . childNumber ( ) return ( self . createIndex ( row , 0 , treeItem ) , self . createIndex ( row , self . columnCount ( ) - 1 , treeItem ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar<CODESPLIT>def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output data in excel - compatible tab - delimited format<CODESPLIT>def tab ( self , output ) : import csv csvwriter = csv . writer ( self . outfile , dialect = csv . excel_tab ) csvwriter . writerows ( output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check to see if the specified object is colliding with any of the objects currently in the Collision Manager Returns the first object we are colliding with if there was a collision and None if no collisions was found<CODESPLIT>def query_collision ( collision_object ) : global collidable_objects # Note that we use a Brute Force approach for the time being. # It performs horribly under heavy loads, but it meets # our needs for the time being. for obj in collidable_objects : # Make sure we don't check ourself against ourself. if obj . obj_id is not collision_object . obj_id : if collision_object . is_colliding ( obj ) : # A collision has been detected. Return the object that we are colliding with. return obj # No collision was noticed. Return None. return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like print but a function . I . e . prints out all arguments as print would do . Specify output stream like this ::<CODESPLIT>def prin ( * args , * * kwargs ) : print >> kwargs . get ( 'out' , None ) , " " . join ( [ str ( arg ) for arg in args ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function to replace all occurrences of a with b under the given field . See also : func : convert .<CODESPLIT>def replace ( table , field , a , b , * * kwargs ) : return convert ( table , field , { a : b } , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Equivalent Noise Bandwidth in bins ( Processing Gain reciprocal ) .<CODESPLIT>def enbw ( wnd ) : return sum ( el ** 2 for el in wnd ) / sum ( wnd ) ** 2 * len ( wnd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts an ARRAY string stored in the database back into a Numpy array .<CODESPLIT>def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last weekday in a given month . e . g :<CODESPLIT>def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>splits iterables a in equal parts of size sz<CODESPLIT>def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch an image from url and convert it into a Pillow Image object<CODESPLIT>def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks to see if list is equal everywhere<CODESPLIT>def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a str and transform it into a byte array .<CODESPLIT>def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes self . function to convert LazyString instance to a real str .<CODESPLIT>def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove instance from model<CODESPLIT>def remove_instance ( self , item ) : self . instances . remove ( item ) self . remove_item ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hide the window .<CODESPLIT>def hide ( self ) : self . tk . withdraw ( ) self . _visible = False if self . _modal : self . tk . grab_release ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse file specified by constructor .<CODESPLIT>def parse ( self ) : f = open ( self . parse_log_path , "r" ) self . parse2 ( f ) f . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Configure session for particular device<CODESPLIT>def _config_session ( ) : config = tf . ConfigProto ( ) config . gpu_options . allow_growth = True config . gpu_options . visible_device_list = '0' return tf . Session ( config = config )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a random element from seq n times . If n is None it continues indefinitly<CODESPLIT>def rand_elem ( seq , n = None ) : return map ( random . choice , repeat ( seq , n ) if n is not None else repeat ( seq ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper to create a proxy method in a class .<CODESPLIT>def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Construction from a string raise a TypeError if not possible<CODESPLIT>def construct_from_string ( cls , string ) : if string == cls . name : return cls ( ) raise TypeError ( "Cannot construct a '{}' from " "'{}'" . format ( cls , string ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to turn a string representation of true into boolean True .<CODESPLIT>def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a user exists<CODESPLIT>def user_exists ( username ) : try : pwd . getpwnam ( username ) user_exists = True except KeyError : user_exists = False return user_exists
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether we re in an interactive shell . Sets interactivity off if appropriate . cf http : // stackoverflow . com / questions / 24861351 / how - to - detect - if - python - script - is - being - run - as - a - background - process<CODESPLIT>def determine_interactive ( self ) : try : if not sys . stdout . isatty ( ) or os . getpgrp ( ) != os . tcgetpgrp ( sys . stdout . fileno ( ) ) : self . interactive = 0 return False except Exception : self . interactive = 0 return False if self . interactive == 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes tags from objects<CODESPLIT>def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a consistent ( key value ) iterable on dict - like objects including lists of tuple pairs .<CODESPLIT>def iterate_items ( dictish ) : if hasattr ( dictish , 'iteritems' ) : return dictish . iteritems ( ) if hasattr ( dictish , 'items' ) : return dictish . items ( ) return dictish
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type<CODESPLIT>def QA_util_datetime_to_strdate ( dt ) : strdate = "%04d-%02d-%02d" % ( dt . year , dt . month , dt . day ) return strdate
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provides the color corresponding to value x in the form of a tuple ( R G B A ) with int values between 0 and 255 .<CODESPLIT>def rgba_bytes_tuple ( self , x ) : return tuple ( int ( u * 255.9999 ) for u in self . rgba_floats_tuple ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output all sections of the page .<CODESPLIT>def Output ( self ) : self . Open ( ) self . Header ( ) self . Body ( ) self . Footer ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a sha1 of the given string<CODESPLIT>def sha1 ( s ) : h = hashlib . new ( 'sha1' ) h . update ( s ) return h . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads complete file contents .<CODESPLIT>def read ( * args ) : return io . open ( os . path . join ( HERE , * args ) , encoding = "utf-8" ) . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Message printer .<CODESPLIT>def _show ( self , message , indent = 0 , enable_verbose = True ) : # pragma: no cover if enable_verbose : print ( "    " * indent + message )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>linear regression calculation<CODESPLIT>def linregress ( x , y , return_stats = False ) : a1 , a0 , r_value , p_value , stderr = scipy . stats . linregress ( x , y ) retval = a1 , a0 if return_stats : retval += r_value , p_value , stderr return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run a function in Matlab and return the result .<CODESPLIT>def run_func ( self , func_path , * func_args , * * kwargs ) : if not self . started : raise ValueError ( 'Session not started, use start()' ) nargout = kwargs . pop ( 'nargout' , 1 ) func_args += tuple ( item for pair in zip ( kwargs . keys ( ) , kwargs . values ( ) ) for item in pair ) dname = os . path . dirname ( func_path ) fname = os . path . basename ( func_path ) func_name , ext = os . path . splitext ( fname ) if ext and not ext == '.m' : raise TypeError ( 'Need to give path to .m file' ) return self . _json_response ( cmd = 'eval' , func_name = func_name , func_args = func_args or '' , dname = dname , nargout = nargout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>searchs a value in a dicionary and returns the key of the first occurrence<CODESPLIT>def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit execution with return code and message : param msg : Message displayed prior to exit : param code : code returned upon exiting<CODESPLIT>def Exit ( msg , code = 1 ) : print >> sys . stderr , msg sys . exit ( code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function<CODESPLIT>def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string containing the type and text of the exception .<CODESPLIT>def format_exception ( e ) : from . utils . printing import fill return '\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dot product of the given vectors .<CODESPLIT>def dot_product ( self , other ) : return self . x * other . x + self . y * other . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get pull request info by number<CODESPLIT>def get_pull_request ( project , num , auth = False ) : url = "https://api.github.com/repos/{project}/pulls/{num}" . format ( project = project , num = num ) if auth : header = make_auth_header ( ) else : header = None response = requests . get ( url , headers = header ) response . raise_for_status ( ) return json . loads ( response . text , object_hook = Obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserializes string to date .<CODESPLIT>def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a dict to a JSON file .<CODESPLIT>def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the size of the label .<CODESPLIT>def ylabelsize ( self , size , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'titlefont' ] [ 'size' ] = size return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Region formed by taking border elements .<CODESPLIT>def border ( self ) : border_array = self . bitmap - self . inner . bitmap return Region ( border_array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a colored string to the target handle .<CODESPLIT>def cprint ( string , fg = None , bg = None , end = '\n' , target = sys . stdout ) : _color_manager . set_color ( fg , bg ) target . write ( string + end ) target . flush ( ) # Needed for Python 3.x _color_manager . set_defaults ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the longest string size for a string entry across data .<CODESPLIT>def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Banana banana<CODESPLIT>def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s="%s"' % ( k , v ) for k , v in dict_ . items ( ) ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send a terminate request and then disconnect from the serial device .<CODESPLIT>def close ( self ) : if self . _initialized : self . stop ( ) self . logged_in = False return self . serial_h . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>\ Asserts that two iterables contain the same values .<CODESPLIT>def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a modified list containing only the indices indicated .<CODESPLIT>def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads an array from bytestring with big - endian data .<CODESPLIT>def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .<CODESPLIT>def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write to given samples to a wav file . The samples are expected to be floating point numbers in the range of - 1 . 0 to 1 . 0 .<CODESPLIT>def write_wav ( path , samples , sr = 16000 ) : max_value = np . abs ( np . iinfo ( np . int16 ) . min ) data = ( samples * max_value ) . astype ( np . int16 ) scipy . io . wavfile . write ( path , sr , data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return matrix as csv data .<CODESPLIT>def csv_matrix_print ( classes , table ) : result = "" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + "," result = result [ : - 1 ] + "\n" return result [ : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split the given comma separated value to multiple integer values .<CODESPLIT>def lengths_offsets ( value ) : values = [ ] for item in value . split ( ',' ) : item = int ( item ) values . append ( item ) return values
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the modified time of a file<CODESPLIT>def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)  mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a bool determining if the process is in a running state or not<CODESPLIT>def is_running ( self ) : return self . state in [ self . STATE_IDLE , self . STATE_ACTIVE , self . STATE_SLEEPING ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes all the integer factors of the number n<CODESPLIT>def factors ( n ) : return set ( reduce ( list . __add__ , ( [ i , n // i ] for i in range ( 1 , int ( n ** 0.5 ) + 1 ) if n % i == 0 ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a key prefix return whether this prefix is the prefix of an existing key in the trie .<CODESPLIT>def check_if_branch_exist ( db , root_hash , key_prefix ) : validate_is_bytes ( key_prefix ) return _check_if_branch_exist ( db , root_hash , encode_to_bin ( key_prefix ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>compose a list of functions<CODESPLIT>def compose ( * funcs ) : return lambda x : reduce ( lambda v , f : f ( v ) , reversed ( funcs ) , x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sympy symbols q0 q1 ... Args : n ( int ) m ( int optional ) : If specified both n and m returns [ qn q ( n + 1 ) ... qm ] Only n is specified returns [ q0 q1 ... qn ] .<CODESPLIT>def make_qs ( n , m = None ) : try : import sympy except ImportError : raise ImportError ( "This function requires sympy. Please install it." ) if m is None : syms = sympy . symbols ( " " . join ( f"q{i}" for i in range ( n ) ) ) if isinstance ( syms , tuple ) : return syms else : return ( syms , ) syms = sympy . symbols ( " " . join ( f"q{i}" for i in range ( n , m ) ) ) if isinstance ( syms , tuple ) : return syms else : return ( syms , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provide the root module of a TF - 2 . 0 API for use within TensorBoard .<CODESPLIT>def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if element is present by css<CODESPLIT>def elXpath ( self , xpath , dom = None ) : if dom is None : dom = self . browser return expect ( dom . is_element_present_by_xpath , args = [ xpath ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>arr_out = round_array ( array_in )<CODESPLIT>def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test whether the current python environment is the correct lore env .<CODESPLIT>def launched ( ) : if not PREFIX : return False return os . path . realpath ( sys . prefix ) == os . path . realpath ( PREFIX )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a hash of the contents of a dictionary<CODESPLIT>def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Counts the word frequences in a list of sentences .<CODESPLIT>def count_words ( file ) : c = Counter ( ) with open ( file , 'r' ) as f : for l in f : words = l . strip ( ) . split ( ) c . update ( words ) return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform list into a maxheap in - place in O ( len ( x )) time .<CODESPLIT>def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a n + 1 dim one - hot array from n dim int - categorical array .<CODESPLIT>def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for matplotlib imshow<CODESPLIT>def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>attempt to draw str on screen and ignore errors if they occur<CODESPLIT>def add_str ( window , line_num , str ) : try : window . addstr ( line_num , 0 , str ) except curses . error : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates a count of the number of times each unique item appears in a list<CODESPLIT>def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from a list while keeping order .<CODESPLIT>def dedup ( seq ) : seen = set ( ) for item in seq : if item not in seen : seen . add ( item ) yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>see doc in Term class<CODESPLIT>def get_size ( self ) : self . curses . setupterm ( ) return self . curses . tigetnum ( 'cols' ) , self . curses . tigetnum ( 'lines' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decrease zoom factor and redraw TimeLine<CODESPLIT>def zoom_out ( self ) : index = self . _zoom_factors . index ( self . _zoom_factor ) if index == 0 : # Already zoomed out all the way return self . _zoom_factor = self . _zoom_factors [ index - 1 ] if self . _zoom_factors . index ( self . _zoom_factor ) == 0 : self . _button_zoom_out . config ( state = tk . DISABLED ) self . _button_zoom_in . config ( state = tk . NORMAL ) self . draw_timeline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether stdin has any data to read .<CODESPLIT>def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether stdin has any data to read .<CODESPLIT>def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return first row and also iterable with same items as original<CODESPLIT>def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : """Generator that returns first and proxy other items from source""" yield one while True : yield next ( it ) return ( one , gen ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether this path is a symbolic link .<CODESPLIT>def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a native Python dictionary to a raw DynamoDB item .<CODESPLIT>def dict_to_ddb ( item ) : # type: (Dict[str, Any]) -> Dict[str, Any] # TODO: narrow these types down serializer = TypeSerializer ( ) return { key : serializer . serialize ( value ) for key , value in item . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether this letter contains Jongsung<CODESPLIT>def has_jongsung ( letter ) : if len ( letter ) != 1 : raise Exception ( 'The target string must be one letter.' ) if not is_hangul ( letter ) : raise NotHangulException ( 'The target string must be Hangul' ) code = lt . hangul_index ( letter ) return code % NUM_JONG > 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the tanimoto set similarity .<CODESPLIT>def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last object in file .<CODESPLIT>def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like netCDF4 . chartostring but faster and more flexible .<CODESPLIT>def _numpy_char_to_bytes ( arr ) : # based on: http://stackoverflow.com/a/10984878/809705 arr = np . array ( arr , copy = False , order = 'C' ) dtype = 'S' + str ( arr . shape [ - 1 ] ) return arr . view ( dtype ) . reshape ( arr . shape [ : - 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the default local index file from the download cache<CODESPLIT>def search_index_file ( ) : from metapack import Downloader from os import environ return environ . get ( 'METAPACK_SEARCH_INDEX' , Downloader . get_instance ( ) . cache . getsyspath ( 'index.json' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialise sets used for uniqueness checking .<CODESPLIT>def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a JSON - encoded message build an object .<CODESPLIT>def from_json ( s ) : d = json . loads ( s ) sbp = SBP . from_json_dict ( d ) return sbp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the MD5 hash for a file .<CODESPLIT>def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set an object s field to default if it doesn t have a value<CODESPLIT>def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def _check_methods ( self , methods ) : for method in methods : if method not in self . ALLOWED_METHODS : raise Exception ( 'Invalid \'%s\' method' % method )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits<CODESPLIT>def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write DOT comment .<CODESPLIT>def comment ( self , s , * * args ) : self . write ( u"// " ) self . writeln ( s = s , * * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the group associated to the file : param filename : : return : str<CODESPLIT>def get_file_extension_type ( filename ) : ext = get_file_extension ( filename ) if ext : for name , group in EXTENSIONS . items ( ) : if ext in group : return name return "OTHER"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read the full contents of the given stream into memory .<CODESPLIT>def read_full ( stream ) : assert stream , "stream is required" chunks = [ ] chunk = yield stream . read ( ) while chunk : chunks . append ( chunk ) chunk = yield stream . read ( ) raise tornado . gen . Return ( b'' . join ( chunks ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lookup a transitive parent object that is an instance of a given class .<CODESPLIT>def _lookup_parent ( self , cls ) : codeobj = self . parent while codeobj is not None and not isinstance ( codeobj , cls ) : codeobj = codeobj . parent return codeobj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a copy of seq without duplicates .<CODESPLIT>def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of tuples specifying the column name and type<CODESPLIT>def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( "PRAGMA table_info('%s');" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string from snake case to camel case .<CODESPLIT>def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a random date between two dates<CODESPLIT>def date ( start , end ) : stime = date_to_timestamp ( start ) etime = date_to_timestamp ( end ) ptime = stime + random . random ( ) * ( etime - stime ) return datetime . date . fromtimestamp ( ptime )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean up processes after SIGTERM or SIGINT is received .<CODESPLIT>def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a name which includes the module name and function name .<CODESPLIT>def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scattering form - factor amplitude of a sphere normalized to F ( q = 0 ) = V<CODESPLIT>def Fsphere ( q , R ) : return 4 * np . pi / q ** 3 * ( np . sin ( q * R ) - q * R * np . cos ( q * R ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose k random elements of array .<CODESPLIT>def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list into a space - separated string and puts it in a dictionary<CODESPLIT>def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : " " . join ( str ( i ) for i in list_ ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert an image by applying a contour<CODESPLIT>def filter_contour ( imageFile , opFile ) : im = Image . open ( imageFile ) im1 = im . filter ( ImageFilter . CONTOUR ) im1 . save ( opFile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes the specified file from the local filesystem .<CODESPLIT>def _delete_local ( self , filename ) : if os . path . exists ( filename ) : os . remove ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parameters ---------- sub : str sup : str<CODESPLIT>def _is_subsequence_of ( self , sub , sup ) : return bool ( re . search ( ".*" . join ( sub ) , sup ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerces JSON string to boolean<CODESPLIT>def from_json ( value , * * kwargs ) : if isinstance ( value , string_types ) : value = value . upper ( ) if value in ( 'TRUE' , 'Y' , 'YES' , 'ON' ) : return True if value in ( 'FALSE' , 'N' , 'NO' , 'OFF' ) : return False if isinstance ( value , int ) : return value raise ValueError ( 'Could not load boolean from JSON: {}' . format ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type s : str : rtype : int<CODESPLIT>def first_unique_char ( s ) : if ( len ( s ) == 1 ) : return 0 ban = [ ] for i in range ( len ( s ) ) : if all ( s [ i ] != s [ k ] for k in range ( i + 1 , len ( s ) ) ) == True and s [ i ] not in ban : return i else : ban . append ( s [ i ] ) return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a multiline string into a list excluding blank lines .<CODESPLIT>def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\n' ) ) if element ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove sequence duplicates ( based on sequence ) from FASTA .<CODESPLIT>def dedupFasta ( reads ) : seen = set ( ) add = seen . add for read in reads : hash_ = md5 ( read . sequence . encode ( 'UTF-8' ) ) . digest ( ) if hash_ not in seen : add ( hash_ ) yield read
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a queue log handler to the global logger .<CODESPLIT>def add_queue_handler ( queue ) : handler = QueueLogHandler ( queue ) handler . setFormatter ( QueueFormatter ( ) ) handler . setLevel ( DEBUG ) GLOBAL_LOGGER . addHandler ( handler )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( Point Point ) - > Point Return the point that lies in between the two input points .<CODESPLIT>def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to camel_case<CODESPLIT>def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a PNG file and decode it into flat row flat pixel format .<CODESPLIT>def read_flat ( self ) : x , y , pixel , meta = self . read ( ) arraycode = 'BH' [ meta [ 'bitdepth' ] > 8 ] pixel = array ( arraycode , itertools . chain ( * pixel ) ) return x , y , pixel , meta
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a str if a bytes object is given .<CODESPLIT>def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batches a list into a list of lists with sub - lists sized by a specified batch size .<CODESPLIT>def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resolve all html entities to their corresponding unicode character<CODESPLIT>def unescape_all ( string ) : def escape_single ( matchobj ) : return _unicode_for_entity_with_name ( matchobj . group ( 1 ) ) return entities . sub ( escape_single , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple of axis dimensions<CODESPLIT>def shape ( self ) : return tuple ( len ( self . _get_axis ( a ) ) for a in self . _AXIS_ORDERS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute Pearson correlation coefficient .<CODESPLIT>def cor ( y_true , y_pred ) : y_true , y_pred = _mask_nan ( y_true , y_pred ) return np . corrcoef ( y_true , y_pred ) [ 0 , 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prompts the user for yes or no .<CODESPLIT>def yn_prompt ( msg , default = True ) : ret = custom_prompt ( msg , [ "y" , "n" ] , "y" if default else "n" ) if ret == "y" : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of dimensions of a tensor<CODESPLIT>def rank ( tensor : BKTensor ) -> int : if isinstance ( tensor , np . ndarray ) : return len ( tensor . shape ) return len ( tensor [ 0 ] . size ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Linspace op .<CODESPLIT>def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the venv by name<CODESPLIT>def rm ( venv_name ) : inenv = InenvManager ( ) venv = inenv . get_venv ( venv_name ) click . confirm ( "Delete dir {}" . format ( venv . path ) ) shutil . rmtree ( venv . path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def matrixTimesVector ( MM , aa ) : bb = np . zeros ( 3 , np . float ) for ii in range ( 3 ) : bb [ ii ] = np . sum ( MM [ ii , : ] * aa ) return bb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether any of the strings contains any of the candidates .<CODESPLIT>def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate equality between two ( Comparable ) objects .<CODESPLIT>def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display the first and last n elements of a DataFrame .<CODESPLIT>def head_and_tail_print ( self , n = 5 ) : from IPython import display display . display ( display . HTML ( self . _head_and_tail_table ( n ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clips a prefix from the beginning of a string if it exists .<CODESPLIT>def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ajoute la target au plot<CODESPLIT>def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = "red" , s = 80 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an SArray that contains the last n elements in the SArray .<CODESPLIT>def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the given time into HH : MM : SS<CODESPLIT>def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return "%02d:%02d:%02d" % ( h , m , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new dict from an existing dict that only has the given keys<CODESPLIT>def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pyqt specific key press callback function . Translates and forwards events to : py : func : keyboard_event .<CODESPLIT>def keyPressEvent ( self , event ) : self . keyboard_event ( event . key ( ) , self . keys . ACTION_PRESS , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generator that yields lines from standard input .<CODESPLIT>def standard_input ( ) : with click . get_text_stream ( "stdin" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( "utf-8" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Instantiate the object from a protocol buffer .<CODESPLIT>def from_pb ( cls , pb ) : obj = cls . _from_pb ( pb ) obj . _pb = pb return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the first value in each row .<CODESPLIT>def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Marker for a token<CODESPLIT>def token ( name ) : def wrap ( f ) : tokenizers . append ( ( name , f ) ) return f return wrap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Visible width of a potentially multiline content .<CODESPLIT>def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( "[\r\n]" , multiline_s ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Project x and y<CODESPLIT>def __call__ ( self , xy ) : x , y = xy return ( self . x ( x ) , self . y ( y ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return ( and memoize ) a database session<CODESPLIT>def _get_session ( ) : session = getattr ( g , '_session' , None ) if session is None : session = g . _session = db . session ( ) return session
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort the updatable objects according to ascending order<CODESPLIT>def __sort_up ( self ) : if self . __do_need_sort_up : self . __up_objects . sort ( key = cmp_to_key ( self . __up_cmp ) ) self . __do_need_sort_up = False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a 1D list to a single long string for file output using the string . join function .<CODESPLIT>def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize obj as a JSON formatted stream to fp<CODESPLIT>def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Outputs a string to the console ( stdout ) .<CODESPLIT>def out ( self , output , newline = True ) : click . echo ( output , nl = newline )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the lines for a file from the cache . Update the cache if it doesn t contain an entry for this file already .<CODESPLIT>def getlines ( filename , module_globals = None ) : if filename in cache : return cache [ filename ] [ 2 ] try : return updatecache ( filename , module_globals ) except MemoryError : clearcache ( ) return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an array of K - Means cluster classes for an array of shapely . geometry . Point objects .<CODESPLIT>def classify_clusters ( points , n = 10 ) : arr = [ [ p . x , p . y ] for p in points . values ] clf = KMeans ( n_clusters = n ) clf . fit ( arr ) classes = clf . predict ( arr ) return classes
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set an object s field to default if it doesn t have a value<CODESPLIT>def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // stackoverflow . com / questions / 5098580 / implementing - argmax - in - python<CODESPLIT>def argmax ( l , f = None ) : if f : l = [ f ( i ) for i in l ] return max ( enumerate ( l ) , key = lambda x : x [ 1 ] ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load a javascript file and minify .<CODESPLIT>def minify ( path ) : if 'http' in path : data = requests . get ( path ) . content . decode ( 'ascii' , errors = 'ignore' ) else : with open ( path , 'rb' ) as f : # some of these assholes use unicode spaces -_- data = f . read ( ) . decode ( 'ascii' , errors = 'ignore' ) # don't re- minify if '.min.' in path : return data try : return jsmin . jsmin ( data ) except BaseException : return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function that reads a local file and generates a SHA256 hash digest for it<CODESPLIT>def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join the list of images into the out file<CODESPLIT>def join_images ( img_files , out_file ) : images = [ PIL . Image . open ( f ) for f in img_files ] joined = PIL . Image . new ( 'RGB' , ( sum ( i . size [ 0 ] for i in images ) , max ( i . size [ 1 ] for i in images ) ) ) left = 0 for img in images : joined . paste ( im = img , box = ( left , 0 ) ) left = left + img . size [ 0 ] joined . save ( out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert arrays of datetime . datetime and datetime . timedelta objects into datetime64 and timedelta64 according to the pandas convention .<CODESPLIT>def _possibly_convert_objects ( values ) : return np . asarray ( pd . Series ( values . ravel ( ) ) ) . reshape ( values . shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all elements of another set from this RangeSet .<CODESPLIT>def __isub__ ( self , other ) : self . _binary_sanity_check ( other ) set . difference_update ( self , other ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a password is valid<CODESPLIT>def is_password_valid ( password ) : pattern = re . compile ( r"^.{4,75}$" ) return bool ( pattern . match ( password ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if tag is an element we should break on .<CODESPLIT>def is_break_tag ( self , el ) : name = el . name return name in self . break_tags or name in self . user_break_tags
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested .<CODESPLIT>def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The title of this window<CODESPLIT>def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a stdout and print it s lines to output if lines are present .<CODESPLIT>def report_stdout ( host , stdout ) : lines = stdout . readlines ( ) if lines : print ( "STDOUT from {host}:" . format ( host = host ) ) for line in lines : print ( line . rstrip ( ) , file = sys . stdout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds self as child of parent then adds parent .<CODESPLIT>def add_parent ( self , parent ) : parent . add_child ( self ) self . parent = parent return parent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get bin edges from a ROOT hist axis .<CODESPLIT>def get_bin_edges_from_axis ( axis ) -> np . ndarray : # Don't include over- or underflow bins bins = range ( 1 , axis . GetNbins ( ) + 1 ) # Bin edges bin_edges = np . empty ( len ( bins ) + 1 ) bin_edges [ : - 1 ] = [ axis . GetBinLowEdge ( i ) for i in bins ] bin_edges [ - 1 ] = axis . GetBinUpEdge ( axis . GetNbins ( ) ) return bin_edges
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a set of unique n - grams from a string .<CODESPLIT>def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string column into datetime column<CODESPLIT>def convert_str_to_datetime ( df , * , column : str , format : str ) : df [ column ] = pd . to_datetime ( df [ column ] , format = format ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get image as a buffer in ( format ) . Format should be jpeg png etc .<CODESPLIT>def get_buffer ( self , data_np , header , format , output = None ) : if not have_pil : raise Exception ( "Install PIL to use this method" ) image = PILimage . fromarray ( data_np ) buf = output if buf is None : buf = BytesIO ( ) image . save ( buf , format ) return buf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display kwargs .<CODESPLIT>def reprkwargs ( kwargs , sep = ', ' , fmt = "{0!s}={1!r}" ) : return sep . join ( fmt . format ( k , v ) for k , v in kwargs . iteritems ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if filename has changed since the last check . If this is the first check assume the file is changed .<CODESPLIT>def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize the state of the object<CODESPLIT>def __init__ ( self ) : self . state = self . STATE_INITIALIZING self . state_start = time . time ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dict mapping item - > indices .<CODESPLIT>def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursive topological sort implementation .<CODESPLIT>def _sort_r ( sorted , processed , key , deps , dependency_tree ) : if key in processed : return processed . add ( key ) for dep_key in deps : dep_deps = dependency_tree . get ( dep_key ) if dep_deps is None : log . debug ( '"%s" not found, skipped' , Repr ( dep_key ) ) continue _sort_r ( sorted , processed , dep_key , dep_deps , dependency_tree ) sorted . append ( ( key , deps ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns path to packaged static files<CODESPLIT>def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert dict of ascii str / unicode to dict of str if necessary<CODESPLIT>def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show the x - axis tick labels for a subplot .<CODESPLIT>def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets a user s password in the keyring storage<CODESPLIT>def set_user_password ( environment , parameter , password ) : username = '%s:%s' % ( environment , parameter ) return password_set ( username , password )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>int : current max id of objects<CODESPLIT>def maxId ( self ) : if len ( self . model . db ) == 0 : return 0 return max ( map ( lambda obj : obj [ "id" ] , self . model . db ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run unit tests .<CODESPLIT>def test ( * args ) : subprocess . call ( [ "py.test-2.7" ] + list ( args ) ) subprocess . call ( [ "py.test-3.4" ] + list ( args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Configure the logging module .<CODESPLIT>def _configure_logger ( ) : if not app . debug : _configure_logger_for_production ( logging . getLogger ( ) ) elif not app . testing : _configure_logger_for_debugging ( logging . getLogger ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a form value from the request .<CODESPLIT>def parse_form ( self , req , name , field ) : return get_value ( req . body_arguments , name , field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function flatten given nested list . Argument : nested list Returns : flat list<CODESPLIT>def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a snake_field_name and returns a camelCaseFieldName<CODESPLIT>def snake_to_camel ( name ) : ret = "" . join ( x . title ( ) for x in name . split ( "_" ) ) ret = ret [ 0 ] . lower ( ) + ret [ 1 : ] return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function is called when a return trap is set here .<CODESPLIT>def user_return ( self , frame , return_value ) : pdb . Pdb . user_return ( self , frame , return_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert numbers to floats whether the decimal point is . or<CODESPLIT>def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create ctypes pointer to object .<CODESPLIT>def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses numpy . load to open the underlying file<CODESPLIT>def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator which adds correct MIME type for python source to the decorated bottle API function .<CODESPLIT>def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = "text/x-python" return fn ( * args , * * kwargs ) return python_mime_decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type s : str : rtype : int<CODESPLIT>def first_unique_char ( s ) : if ( len ( s ) == 1 ) : return 0 ban = [ ] for i in range ( len ( s ) ) : if all ( s [ i ] != s [ k ] for k in range ( i + 1 , len ( s ) ) ) == True and s [ i ] not in ban : return i else : ban . append ( s [ i ] ) return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sophisticated simulation of multiplication<CODESPLIT>def multiply ( traj ) : z = traj . x * traj . y traj . f_add_result ( 'z' , z = z , comment = 'I am the product of two reals!' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read<CODESPLIT>def read ( self , count = 0 ) : return self . f . read ( count ) if count > 0 else self . f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates in a list .<CODESPLIT>def _uniquify ( _list ) : seen = set ( ) result = [ ] for x in _list : if x not in seen : result . append ( x ) seen . add ( x ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforma una string con elementos separados por sep en una lista .<CODESPLIT>def string_to_list ( string , sep = "," , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>There s probably a way to do this with string functions but I was lazy . Replace all instances of \ r or \ n in a string with something else .<CODESPLIT>def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = "" for segment in segments : string += segment return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits iterator in chunks .<CODESPLIT>def chunks ( iterable , size = 1 ) : iterator = iter ( iterable ) for element in iterator : yield chain ( [ element ] , islice ( iterator , size - 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first day of the given month .<CODESPLIT>def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the venv by name<CODESPLIT>def rm ( venv_name ) : inenv = InenvManager ( ) venv = inenv . get_venv ( venv_name ) click . confirm ( "Delete dir {}" . format ( venv . path ) ) shutil . rmtree ( venv . path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pure - Python implementation of itertools . combinations ( l 2 ) .<CODESPLIT>def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return Gaussian that truncates at the given number of std deviations .<CODESPLIT>def gaussian_kernel ( sigma , truncate = 4.0 ) : sigma = float ( sigma ) radius = int ( truncate * sigma + 0.5 ) x , y = np . mgrid [ - radius : radius + 1 , - radius : radius + 1 ] sigma = sigma ** 2 k = 2 * np . exp ( - 0.5 * ( x ** 2 + y ** 2 ) / sigma ) k = k / np . sum ( k ) return k
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save / override the latest model after every epoch .<CODESPLIT>def after_epoch ( self , * * _ ) -> None : SaveEvery . save_model ( model = self . _model , name_suffix = self . _OUTPUT_NAME , on_failure = self . _on_save_failure )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip apostrophe and s from the end of a string .<CODESPLIT>def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return imaginary part of quaternion .<CODESPLIT>def quaternion_imag ( quaternion ) : return numpy . array ( quaternion [ 1 : 4 ] , dtype = numpy . float64 , copy = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>extract features in a sentence<CODESPLIT>def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a Seaborn linear regression plot<CODESPLIT>def _linear_seaborn_ ( self , label = None , style = None , opts = None ) : xticks , yticks = self . _get_ticks ( opts ) try : fig = sns . lmplot ( self . x , self . y , data = self . df ) fig = self . _set_with_height ( fig , opts ) return fig except Exception as e : self . err ( e , self . linear_ , "Can not draw linear regression chart" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Intersect dictionaries d1 and d2 by key * and * value .<CODESPLIT>def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a str of decimal with two digits after a decimal mark .<CODESPLIT>def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return "%1.2f" % ( float ( value ) / 100 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a modbus register .<CODESPLIT>async def write_register ( self , address , value , skip_encode = False ) : await self . _request ( 'write_registers' , address , value , skip_encode = skip_encode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the TextFSMValue object natching the requested name .<CODESPLIT>def _GetValue ( self , name ) : for value in self . values : if value . name == name : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output a networkx graph to a DOT file .<CODESPLIT>def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rounds a float value off to the desired precision<CODESPLIT>def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from integers to strings<CODESPLIT>def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An exception is passed in and this function returns the proper string depending on the result so it is readable enough .<CODESPLIT>def make_exception_message ( exc ) : if str ( exc ) : return '%s: %s\n' % ( exc . __class__ . __name__ , exc ) else : return '%s\n' % ( exc . __class__ . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given thing represents a date<CODESPLIT>def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return widget icon<CODESPLIT>def get_plugin_icon ( self ) : path = osp . join ( self . PLUGIN_PATH , self . IMG_PATH ) return ima . icon ( 'pylint' , icon_path = path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resize and image to fit the passed in width keeping the aspect ratio the same<CODESPLIT>def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads a floating point value from a memory address . If 2nd arg . start with * it is always treated as an indirect value .<CODESPLIT>def _loadf ( ins ) : output = _float_oper ( ins . quad [ 2 ] ) output . extend ( _fpush ( ) ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a millisecond accuracy timestamp to a datetime<CODESPLIT>def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The url of this window<CODESPLIT>def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an array . Keyword arguments as per : func : zarr . creation . zeros .<CODESPLIT>def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the given operation as an asyncio future .<CODESPLIT>def delegate ( self , fn , * args , * * kwargs ) : callback = functools . partial ( fn , * args , * * kwargs ) coro = self . loop . run_in_executor ( self . subexecutor , callback ) return asyncio . ensure_future ( coro )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a DataFrame with rows where column values match match are removed .<CODESPLIT>def remove_rows_matching ( df , column , match ) : df = df . copy ( ) mask = df [ column ] . values != match return df . iloc [ mask , : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sort a list of files by filename only ignoring the directory names<CODESPLIT>def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a function that will call a named method on the target object with optional positional and keyword arguments .<CODESPLIT>def method_caller ( method_name , * args , * * kwargs ) : def call_method ( target ) : func = getattr ( target , method_name ) return func ( * args , * * kwargs ) return call_method
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connects to publisher<CODESPLIT>def connect ( self ) : self . client = redis . Redis ( host = self . host , port = self . port , password = self . password )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>conv2d returns a 2d convolution layer with full stride .<CODESPLIT>def conv2d ( x_input , w_matrix ) : return tf . nn . conv2d ( x_input , w_matrix , strides = [ 1 , 1 , 1 , 1 ] , padding = 'SAME' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>str to bytes ( py3k )<CODESPLIT>def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put a PID into a pidfile<CODESPLIT>def put_pidfile ( pidfile_path , pid ) : with open ( pidfile_path , "w" ) as f : f . write ( "%s" % pid ) os . fsync ( f . fileno ( ) ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if the socket managed by this connection is connected<CODESPLIT>def is_connected ( self ) : try : return self . socket is not None and self . socket . getsockname ( ) [ 1 ] != 0 and BaseTransport . is_connected ( self ) except socket . error : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap text in an ansi escape sequence<CODESPLIT>def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first matching line in a list of lines .<CODESPLIT>def matching_line ( lines , keyword ) : for line in lines : matching = match ( line , keyword ) if matching != None : return matching return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function for creating hash functions .<CODESPLIT>def _hash_the_file ( hasher , filename ) : BUF_SIZE = 65536 with open ( filename , 'rb' ) as f : buf = f . read ( BUF_SIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = f . read ( BUF_SIZE ) return hasher
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quit signal handler .<CODESPLIT>def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( "\nSIGINT in frame signal received. Quitting..." ) sys . stdout . flush ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of bytes that the multipart / form - data encoding of params will be .<CODESPLIT>def get_body_size ( params , boundary ) : size = sum ( p . get_size ( boundary ) for p in MultipartParam . from_params ( params ) ) return size + len ( boundary ) + 6
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return lines of a file with whitespace removed<CODESPLIT>def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( "Could not open file: {!r}" . format ( filename ) ) return [ line . strip ( ) for line in lines ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render our pages as a jinja template for fancy templating goodness .<CODESPLIT>def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the ( name value ) pairs of the enum .<CODESPLIT>def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callable function for the multiprocessing pool .<CODESPLIT>def compute_capture ( args ) : x , y , w , h , params = args return x , y , mandelbrot_capture ( x , y , w , h , params )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a millisecond accuracy timestamp to a datetime<CODESPLIT>def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test the multiprocess<CODESPLIT>def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>copy the dict filter_keywords<CODESPLIT>def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the previous quarter for dt<CODESPLIT>def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find rightmost value less than or equal to x .<CODESPLIT>def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix multiplication using binary<CODESPLIT>def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Linspace op .<CODESPLIT>def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type s str<CODESPLIT>def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert from scientific notation using precision<CODESPLIT>def trim_decimals ( s , precision = - 3 ) : encoded = s . encode ( 'ascii' , 'ignore' ) str_val = "" if six . PY3 : str_val = str ( encoded , encoding = 'ascii' , errors = 'ignore' ) [ : precision ] else : # If precision is 0, this must be handled seperately if precision == 0 : str_val = str ( encoded ) else : str_val = str ( encoded ) [ : precision ] if len ( str_val ) > 0 : return float ( str_val ) else : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values<CODESPLIT>def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert the given list of parameters to a JSON object .<CODESPLIT>def save_list ( key , * values ) : return json . dumps ( { key : [ _get_json ( value ) for value in values ] } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes a rotating logger<CODESPLIT>def init_rotating_logger ( level , logfile , max_files , max_bytes ) : logging . basicConfig ( ) root_logger = logging . getLogger ( ) log_format = "[%(asctime)s] [%(levelname)s] %(filename)s: %(message)s" root_logger . setLevel ( level ) handler = RotatingFileHandler ( logfile , maxBytes = max_bytes , backupCount = max_files ) handler . setFormatter ( logging . Formatter ( fmt = log_format , datefmt = date_format ) ) root_logger . addHandler ( handler ) for handler in root_logger . handlers : root_logger . debug ( "Associated handlers - " + str ( handler ) ) if isinstance ( handler , logging . StreamHandler ) : root_logger . debug ( "Removing StreamHandler: " + str ( handler ) ) root_logger . handlers . remove ( handler )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the average value of a list of numbers Returns a float<CODESPLIT>def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode .<CODESPLIT>def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create ctypes pointer to object .<CODESPLIT>def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads complete file contents .<CODESPLIT>def read ( * args ) : return io . open ( os . path . join ( HERE , * args ) , encoding = "utf-8" ) . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add an additional DATETIME column with standar datetime format .<CODESPLIT>def add_datetime ( dataframe , timestamp_key = 'UNIXTIME' ) : def convert_data ( timestamp ) : return datetime . fromtimestamp ( float ( timestamp ) / 1e3 , UTC_TZ ) try : log . debug ( "Adding DATETIME column to the data" ) converted = dataframe [ timestamp_key ] . apply ( convert_data ) dataframe [ 'DATETIME' ] = converted except KeyError : log . warning ( "Could not add DATETIME column" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of token strings from the given sentence .<CODESPLIT>def tokenize ( self , s ) : return [ s [ start : end ] for start , end in self . span_tokenize ( s ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Match two names .<CODESPLIT>def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverse the broadcasting operation .<CODESPLIT>def unbroadcast_numpy_to ( array , shape ) : axis = create_unbroadcast_axis ( shape , numpy . shape ( array ) ) return numpy . reshape ( numpy . sum ( array , axis = axis ) , shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type an integer type?<CODESPLIT>def is_sqlatype_integer ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . Integer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format text with color or other effects into ANSI escaped string .<CODESPLIT>def sprint ( text , * colors ) : return "\33[{}m{content}\33[{}m" . format ( ";" . join ( [ str ( color ) for color in colors ] ) , RESET , content = text ) if IS_ANSI_TERMINAL and colors else text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace boolean variables by the characters F / T<CODESPLIT>def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the normalized mean square error of a and b<CODESPLIT>def nmse ( a , b ) : return np . square ( a - b ) . mean ( ) / ( a . mean ( ) * b . mean ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes the line content after the cursor<CODESPLIT>def _end_del ( self ) : text = self . edit_text [ : self . edit_pos ] self . set_edit_text ( text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls the shots based on signals<CODESPLIT>def register ( ) : signals . article_generator_finalized . connect ( link_source_files ) signals . page_generator_finalized . connect ( link_source_files ) signals . page_writer_finalized . connect ( write_source_files )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compile and return a Module s code object .<CODESPLIT>def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate a |Subsystem| .<CODESPLIT>def subsystem ( s ) : node_states ( s . state ) cut ( s . cut , s . cut_indices ) if config . VALIDATE_SUBSYSTEM_STATES : state_reachable ( s ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the request headers .<CODESPLIT>def __call__ ( self , r ) : r . headers [ 'Authorization' ] = 'JWT {jwt}' . format ( jwt = self . token ) return r
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove any duplicate entries .<CODESPLIT>def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Idempotent and None - safe version of strict_bool .<CODESPLIT>def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Chain & sort ranges .<CODESPLIT>def sorted_chain ( * ranges : Iterable [ Tuple [ int , int ] ] ) -> List [ Tuple [ int , int ] ] : return sorted ( itertools . chain ( * ranges ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove html code contained into the given string .<CODESPLIT>def strip_html ( string , keep_tag_content = False ) : r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE return r . sub ( '' , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implements string formatting along with color specified in colorama . Fore<CODESPLIT>def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a user exists<CODESPLIT>def user_exists ( username ) : try : pwd . getpwnam ( username ) user_exists = True except KeyError : user_exists = False return user_exists
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an ExpMatrix containing all pairwise sample correlations .<CODESPLIT>def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert list of key value lists to dict<CODESPLIT>def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format numpy array as a string .<CODESPLIT>def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( "," ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + "%s[%s]" % ( arr . dtype , shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if key exists in datastore . True if yes False if no .<CODESPLIT>def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an int of form yyyymmdd to a python date object .<CODESPLIT>def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read an image from file - PIL doesnt close nicely<CODESPLIT>def load_image ( fname ) : with open ( fname , "rb" ) as f : i = Image . open ( fname ) #i.load() return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function which converts lists to tuples .<CODESPLIT>def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all child objects in nested lists of strings .<CODESPLIT>def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents )<CODESPLIT>def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like : meth : items but returns an iterator .<CODESPLIT>def iterlists ( self ) : for key , values in dict . iteritems ( self ) : yield key , list ( values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator which dynamically binds static methods to the model for later use .<CODESPLIT>def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap standard function to easily pass into map processing .<CODESPLIT>def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets the dimensions depending on python version and os<CODESPLIT>def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace my : attr : scopes for the duration of the with block .<CODESPLIT>def scopes_as ( self , new_scopes ) : old_scopes , self . scopes = self . scopes , new_scopes yield self . scopes = old_scopes
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fibonacci example function<CODESPLIT>def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pop - up menu and wx . EVT_CLOSE closing event<CODESPLIT>def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download file from S3 Bucket<CODESPLIT>def download_file_from_bucket ( self , bucket , file_path , key ) : with open ( file_path , 'wb' ) as data : self . __s3 . download_fileobj ( bucket , key , data ) return file_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a absolute path in the file system .<CODESPLIT>def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates converts to a masked array<CODESPLIT>def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Chunk one big list into few small lists .<CODESPLIT>def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses OLS to fit the regression .<CODESPLIT>def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The letter of the Excel worksheet column in which the data for a series appears .<CODESPLIT>def _series_col_letter ( self , series ) : column_number = 1 + series . categories . depth + series . index return self . _column_reference ( column_number )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes a : py : class : . Series from the chart .<CODESPLIT>def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( "Cannot remove last series from %s" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize path slashes .<CODESPLIT>def norm_slash ( name ) : if isinstance ( name , str ) : return name . replace ( '/' , "\\" ) if not is_case_sensitive ( ) else name else : return name . replace ( b'/' , b"\\" ) if not is_case_sensitive ( ) else name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the most common element in iterable .<CODESPLIT>def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to read an XML file<CODESPLIT>def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of the earliest occurence of an item from a list in a string<CODESPLIT>def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use the specified filename for streamed logging .<CODESPLIT>def __init__ ( self , filename , mode , encoding = None ) : FileHandler . __init__ ( self , filename , mode , encoding ) self . mode = mode self . encoding = encoding
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resolve which cross validation strategy is used .<CODESPLIT>def check_cv ( self , y ) : y_arr = None if self . stratified : # Try to convert y to numpy for sklearn's check_cv; if conversion # doesn't work, still try. try : y_arr = to_numpy ( y ) except ( AttributeError , TypeError ) : y_arr = y if self . _is_float ( self . cv ) : return self . _check_cv_float ( ) return self . _check_cv_non_float ( y_arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the week start date and end date<CODESPLIT>def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return lines of a file with whitespace removed<CODESPLIT>def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( "Could not open file: {!r}" . format ( filename ) ) return [ line . strip ( ) for line in lines ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets tail<CODESPLIT>def get_tail ( self ) : node = self . head last_node = self . head while node is not None : last_node = node node = node . next_node return last_node
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause the music<CODESPLIT>def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if obj is number .<CODESPLIT>def is_number ( obj ) : return isinstance ( obj , ( int , float , np . int_ , np . float_ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets RAM memory usage<CODESPLIT>def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeros in the list of integers and returns a new list of integers<CODESPLIT>def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .<CODESPLIT>def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialise sets used for uniqueness checking .<CODESPLIT>def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DFS detect connected component recursive implementation<CODESPLIT>def dfs_recursive ( graph , node , seen ) : seen [ node ] = True for neighbor in graph [ node ] : if not seen [ neighbor ] : dfs_recursive ( graph , neighbor , seen )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Go to the end of the current line and create a new line<CODESPLIT>def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert comma - delimited list / string into a list of strings<CODESPLIT>def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is an integer number .<CODESPLIT>def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pad a matrix with zeros on all sides .<CODESPLIT>def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display Bloch sphere and corresponding data sets .<CODESPLIT>def show ( self , title = '' ) : self . render ( title = title ) if self . fig : plt . show ( self . fig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is the same functionality as int . from_bytes in python 3<CODESPLIT>def _from_bytes ( bytes , byteorder = "big" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forcibly terminates all Celery processes .<CODESPLIT>def force_stop ( self ) : r = self . local_renderer with self . settings ( warn_only = True ) : r . sudo ( 'pkill -9 -f celery' ) r . sudo ( 'rm -f /tmp/celery*.pid' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add suffix to a full file name<CODESPLIT>def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if Glances is running in client mode .<CODESPLIT>def is_client ( self ) : return ( self . args . client or self . args . browser ) and not self . args . server
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether indicated file appears to be a gzipped FASTQ .<CODESPLIT>def is_gzipped_fastq ( file_name ) : _ , ext = os . path . splitext ( file_name ) return file_name . endswith ( ".fastq.gz" ) or file_name . endswith ( ".fq.gz" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .<CODESPLIT>def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Originally used to calculate color based on module name .<CODESPLIT>def name2rgb ( hue ) : r , g , b = colorsys . hsv_to_rgb ( hue / 360.0 , .8 , .7 ) return tuple ( int ( x * 256 ) for x in [ r , g , b ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Own dumb reimplementation of textwrap . wrap () .<CODESPLIT>def _wrap ( text , columns = 80 ) : out = [ ] for cnt , char in enumerate ( text ) : out . append ( char ) if ( cnt + 1 ) % columns == 0 : out . append ( "\n" ) return "" . join ( out )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def compress ( data , * * kwargs ) : """zlib.compress(data, **kwargs)          """ + zopfli . __COMPRESSOR_DOCSTRING__ + """     Returns:       String containing a zlib container     """ kwargs [ 'gzip_mode' ] = 0 return zopfli . zopfli . compress ( data , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies the sofplus activation function element - wise to the input .<CODESPLIT>def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the conda executable robustly across conda versions .<CODESPLIT>def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>log stop<CODESPLIT>def log_stop ( logger ) : handlers = logger . handlers [ : ] for handler in handlers : handler . close ( ) logger . removeHandler ( handler )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert bytes and non - string into Python 3 str<CODESPLIT>def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get distance matrix given a matrix . Used in testing .<CODESPLIT>def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert human readable string to datetime . datetime .<CODESPLIT>def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flatten dict with defined key join symbol .<CODESPLIT>def flatten_dict_join_keys ( dct , join_symbol = " " ) : return dict ( flatten_dict ( dct , join = lambda a , b : a + join_symbol + b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add or update styles<CODESPLIT>def styles ( self , dictobj ) : for k in dictobj : self . chart_style [ k ] = dictobj [ k ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert datetime to epoch seconds .<CODESPLIT>def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap an AST Call node to lambda expression node . call : ast . Call node<CODESPLIT>def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim left - right given string<CODESPLIT>def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( "" , somestr ) tmp = RE_TSPACES . sub ( "" , tmp ) return str ( tmp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to get __name__ first __class__ . __name__ second and finally if we can t get anything acceptable fallback to user a repr () call .<CODESPLIT>def safe_repr ( obj ) : name = getattr ( obj , '__name__' , getattr ( obj . __class__ , '__name__' ) ) if name == 'ndict' : name = 'dict' return name or repr ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801<CODESPLIT>def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string from snake case to camel case .<CODESPLIT>def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the first line of a file .<CODESPLIT>def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\n' ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rebuild list_object removing duplicated and keeping order<CODESPLIT>def deduplicate ( list_object ) : new = [ ] for item in list_object : if item not in new : new . append ( item ) return new
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all the files and subdirectories in a directory .<CODESPLIT>def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return number of empty lines at the end of the document .<CODESPLIT>def empty_line_count_at_the_end ( self ) : count = 0 for line in self . lines [ : : - 1 ] : if not line or line . isspace ( ) : count += 1 else : break return count
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load and parse a feature file .<CODESPLIT>def load_feature ( fname , language ) : fname = os . path . abspath ( fname ) feat = parse_file ( fname , language ) return feat
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether num is a power of two<CODESPLIT>def is_power_of_2 ( num ) : log = math . log2 ( num ) return int ( log ) == float ( log )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .<CODESPLIT>def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is an integer number .<CODESPLIT>def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate equality between two ( Comparable ) objects .<CODESPLIT>def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a ketama compatible list of ( position nodename ) tuples .<CODESPLIT>def get_points ( self ) : return [ ( k , self . runtime . _ring [ k ] ) for k in self . runtime . _keys ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>example matrix for width = 2<CODESPLIT>def get_checkerboard_matrix ( kernel_width ) : return np . vstack ( ( np . hstack ( ( - 1 * np . ones ( ( kernel_width , kernel_width ) ) , np . ones ( ( kernel_width , kernel_width ) ) ) ) , np . hstack ( ( np . ones ( ( kernel_width , kernel_width ) ) , - 1 * np . ones ( ( kernel_width , kernel_width ) ) ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize obj as a JSON formatted stream to fp<CODESPLIT>def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Main window move event<CODESPLIT>def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ "window_position" ] = repr ( position )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a tuple of numbers . e . g . vertices normals or teture coords .<CODESPLIT>def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns day number of the last day of the month : param t : datetime : return : int<CODESPLIT>def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper on iter method callback gets an iterator result<CODESPLIT>def find_all ( self , string , callback ) : for index , output in self . iter ( string ) : callback ( index , output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Time execution of function . Returns ( res seconds ) .<CODESPLIT>def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap an AST Call node to lambda expression node . call : ast . Call node<CODESPLIT>def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pad a matrix with zeros on all sides .<CODESPLIT>def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses box coordinates to crop an image without resizing it first .<CODESPLIT>def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pads an input string to a given block size . : param s : string : returns : The padded string .<CODESPLIT>def old_pad ( s ) : if len ( s ) % OLD_BLOCK_SIZE == 0 : return s return Padding . appendPadding ( s , blocksize = OLD_BLOCK_SIZE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse bytes and return a namedtuple .<CODESPLIT>def unpack ( self , s ) : return self . _create ( super ( NamedStruct , self ) . unpack ( s ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete object from parent object .<CODESPLIT>def del_object_from_parent ( self ) : if self . parent : self . parent . objects . pop ( self . ref )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort input filename list by datetime<CODESPLIT>def sort_fn_list ( fn_list ) : dt_list = get_dt_list ( fn_list ) fn_list_sort = [ fn for ( dt , fn ) in sorted ( zip ( dt_list , fn_list ) ) ] return fn_list_sort
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from list while preserving order .<CODESPLIT>def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to convert variables into datatypes .<CODESPLIT>def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle linear / log scale for Y - axis .<CODESPLIT>def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the text for the given root node ( xml . dom . minidom ) .<CODESPLIT>def __get_xml_text ( root ) : txt = "" for e in root . childNodes : if ( e . nodeType == e . TEXT_NODE ) : txt += e . data return txt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempt to setattr but catch AttributeErrors .<CODESPLIT>def safe_setattr ( obj , name , value ) : try : setattr ( obj , name , value ) return True except AttributeError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether two strings are equivalent .<CODESPLIT>def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs the unit test framework . Can be overridden to run anything . Returns True on passing and False on failure .<CODESPLIT>def run ( self ) : try : import nose arguments = [ sys . argv [ 0 ] ] + list ( self . test_args ) return nose . run ( argv = arguments ) except ImportError : print ( ) print ( "*** Nose library missing. Please install it. ***" ) print ( ) raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs the vector multiplication of the elements of two vectors constructing the 3x3 matrix . : param aa : One vector of size 3 : param bb : Another vector of size 3 : return : A 3x3 matrix M composed of the products of the elements of aa and bb : M_ij = aa_i * bb_j<CODESPLIT>def vectorsToMatrix ( aa , bb ) : MM = np . zeros ( [ 3 , 3 ] , np . float ) for ii in range ( 3 ) : for jj in range ( 3 ) : MM [ ii , jj ] = aa [ ii ] * bb [ jj ] return MM
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace any non - word characters with a dash .<CODESPLIT>def dashrepl ( value ) : patt = re . compile ( r'\W' , re . UNICODE ) return re . sub ( patt , '-' , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the product set of array_a and array_b and sort it .<CODESPLIT>def sorted_product_set ( array_a , array_b ) : return np . sort ( np . concatenate ( [ array_a [ i ] * array_b for i in xrange ( len ( array_a ) ) ] , axis = 0 ) ) [ : : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simplest required implementation of collections . Counter . Required as 2 . 6 does not have Counter in collections .<CODESPLIT>def counter ( items ) : results = { } for item in items : results [ item ] = results . get ( item , 0 ) + 1 return results
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new response header replacing any previously defined headers with the same name .<CODESPLIT>def set_header ( self , name , value ) : self . _headers [ _hkey ( name ) ] = [ _hval ( value ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Populates the ListView with a string list .<CODESPLIT>def new_from_list ( cls , items , * * kwargs ) : obj = cls ( * * kwargs ) for item in items : obj . append ( ListItem ( item ) ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encode the given tensor to given image shape .<CODESPLIT>def encode_to_shape ( inputs , shape , scope ) : with tf . variable_scope ( scope , reuse = tf . AUTO_REUSE ) : w , h = shape [ 1 ] , shape [ 2 ] x = inputs x = tfl . flatten ( x ) x = tfl . dense ( x , w * h , activation = None , name = "enc_dense" ) x = tf . reshape ( x , ( - 1 , w , h , 1 ) ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates a count of the number of times each unique item appears in a list<CODESPLIT>def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : generator of tuples ( isLastFlag item )<CODESPLIT>def iter_with_last ( iterable ) : # Ensure it's an iterator and get the first field iterable = iter ( iterable ) prev = next ( iterable ) for item in iterable : # Lag by one item so I know I'm not at the end yield False , prev prev = item # Last item yield True , prev
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Support change columns .<CODESPLIT>def alter_change_column ( self , table , column , field ) : return self . _update_column ( table , column , lambda a , b : b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create 2D rotation matrix<CODESPLIT>def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : xml_str : str DataONE API XML doc .<CODESPLIT>def str_is_well_formed ( xml_str ) : try : str_to_etree ( xml_str ) except xml . etree . ElementTree . ParseError : return False else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill missing values in pandas objects and numpy arrays .<CODESPLIT>def fillna ( series_or_arr , missing_value = 0.0 ) : if pandas . notnull ( missing_value ) : if isinstance ( series_or_arr , ( numpy . ndarray ) ) : series_or_arr [ numpy . isnan ( series_or_arr ) ] = missing_value else : series_or_arr . fillna ( missing_value , inplace = True ) return series_or_arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if value can be part of binary / bitwise operations .<CODESPLIT>def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply last 2D transforms<CODESPLIT>def post_process ( self ) : self . image . putdata ( self . pixels ) self . image = self . image . transpose ( Image . ROTATE_90 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = "{}[{}]" . format ( pdf_path , page_num ) ) with pdf_img . convert ( "png" ) as converted : # Set white background. converted . background_color = Color ( "white" ) converted . alpha_channel = "remove" converted . save ( filename = img_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Under UNIX : is a keystroke available?<CODESPLIT>def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause for this many seconds<CODESPLIT>def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random integer between two values .<CODESPLIT>def random_int ( self , min = 0 , max = 9999 , step = 1 ) : return self . generator . random . randrange ( min , max + 1 , step )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Kill the browser .<CODESPLIT>def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a map of letter use in a word .<CODESPLIT>def _letter_map ( word ) : lmap = { } for letter in word : try : lmap [ letter ] += 1 except KeyError : lmap [ letter ] = 1 return lmap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For list values returns the index location of element x . If x does not exist will raise an error .<CODESPLIT>def sorted_index ( values , x ) : i = bisect_left ( values , x ) j = bisect_right ( values , x ) return values [ i : j ] . index ( x ) + i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the haversine of an angle<CODESPLIT>def haversine ( x ) : y = .5 * x y = np . sin ( y ) return y * y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>quick and dirty appending of query parameters to a url<CODESPLIT>def append_query_parameter ( url , parameters , ignore_if_exists = True ) : if ignore_if_exists : for key in parameters . keys ( ) : if key + "=" in url : del parameters [ key ] parameters_str = "&" . join ( k + "=" + v for k , v in parameters . items ( ) ) append_token = "&" if "?" in url else "?" return url + append_token + parameters_str
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a flatten version of the nested argument<CODESPLIT>def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Left padding with zero bytes to a given block size<CODESPLIT>def left_zero_pad ( s , blocksize ) : if blocksize > 0 and len ( s ) % blocksize : s = ( blocksize - len ( s ) % blocksize ) * b ( '\000' ) + s return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips a figure into multiple figures with a trace on each of them<CODESPLIT>def strip_figures ( figure ) : fig = [ ] for trace in figure [ 'data' ] : fig . append ( dict ( data = [ trace ] , layout = figure [ 'layout' ] ) ) return fig
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrun True if x is a valid YYYYMMDD date ; otherwise return False .<CODESPLIT>def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: raises docker . exceptions . APIError<CODESPLIT>def running_containers ( name_filter : str ) -> List [ str ] : return [ container . short_id for container in docker_client . containers . list ( filters = { "name" : name_filter } ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialise sets used for uniqueness checking .<CODESPLIT>def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a form value from the request .<CODESPLIT>def parse_form ( self , req , name , field ) : return get_value ( req . body_arguments , name , field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pyqt specific resize callback .<CODESPLIT>def resize ( self , width , height ) : if not self . fbo : return # pyqt reports sizes in actual buffer size self . width = width // self . widget . devicePixelRatio ( ) self . height = height // self . widget . devicePixelRatio ( ) self . buffer_width = width self . buffer_height = height super ( ) . resize ( width , height )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends plain text using _send_text () .<CODESPLIT>async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips comments and filter empty lines .<CODESPLIT>def _ignore_comments ( lines_enum ) : for line_number , line in lines_enum : line = COMMENT_RE . sub ( '' , line ) line = line . strip ( ) if line : yield line_number , line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Max reduction op .<CODESPLIT>def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set the colors for text .<CODESPLIT>def print_log ( value_color = "" , value_noncolor = "" ) : HEADER = '\033[92m' ENDC = '\033[0m' print ( HEADER + value_color + ENDC + str ( value_noncolor ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the path to the javascript bundle<CODESPLIT>def default_static_path ( ) : fdir = os . path . dirname ( __file__ ) return os . path . abspath ( os . path . join ( fdir , '../assets/' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from a list preserving the order .<CODESPLIT>def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the default matplotlib ticks .<CODESPLIT>def clear_matplotlib_ticks ( self , axis = "both" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute average gradient norm of an image<CODESPLIT>def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a sort lambda function for the sortedbykey<CODESPLIT>def _sort_lambda ( sortedby = 'cpu_percent' , sortedby_secondary = 'memory_percent' ) : ret = None if sortedby == 'io_counters' : ret = _sort_io_counters elif sortedby == 'cpu_times' : ret = _sort_cpu_times return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Open and load JSON from file .<CODESPLIT>def read_json ( location ) : location = ensure_path ( location ) with location . open ( 'r' , encoding = 'utf8' ) as f : return ujson . load ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove tags from a file .<CODESPLIT>def delete ( filething ) : f = FLAC ( filething ) filething . fileobj . seek ( 0 ) f . delete ( filething )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type s str<CODESPLIT>def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new copied dictionary without the keys with None values from the given Mapping object .<CODESPLIT>def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Squash self . out into string .<CODESPLIT>def build_output ( self , fout ) : fout . write ( '\n' . join ( [ s for s in self . out ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace masked - out elements in an array using an iterative image inpainting algorithm .<CODESPLIT>def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case<CODESPLIT>def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Max reduction op .<CODESPLIT>def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the string is only composed of hex characters .<CODESPLIT>def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Do all elements of x have a type from types?<CODESPLIT>def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup the flask - cache on a flask app<CODESPLIT>def setup_cache ( app : Flask , cache_config ) -> Optional [ Cache ] : if cache_config and cache_config . get ( 'CACHE_TYPE' ) != 'null' : return Cache ( app , config = cache_config ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorting logic for Quantity objects .<CODESPLIT>def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generator for reading from standard input in nonblocking mode .<CODESPLIT>def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate equality between two ( Comparable ) objects .<CODESPLIT>def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Slicing op .<CODESPLIT>def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Store ipython references in the __builtin__ namespace .<CODESPLIT>def activate ( self ) : add_builtin = self . add_builtin for name , func in self . auto_builtins . iteritems ( ) : add_builtin ( name , func )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load from stored files<CODESPLIT>def load ( cls , filename ) : filename = cls . correct_file_extension ( filename ) with open ( filename , 'rb' ) as f : return pickle . load ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the value of each QuerySet but also add the # property to each return item .<CODESPLIT>def _unordered_iterator ( self ) : for i , qs in zip ( self . _queryset_idxs , self . _querysets ) : for item in qs : setattr ( item , '#' , i ) yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the channels of a palettebar .<CODESPLIT>def palettebar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) + 1 - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . palettize ( cbar )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rounds float to closest int : rtype : int : param n : float<CODESPLIT>def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format list .<CODESPLIT>def list_formatter ( handler , item , value ) : return u', ' . join ( str ( v ) for v in value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a string return true if it matches the supplied list of patterns .<CODESPLIT>def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Partition a list into equally sized pieces including last smaller parts http : // stackoverflow . com / questions / 5129102 / python - equivalent - to - clojures - partition - all<CODESPLIT>def partition_all ( n , iterable ) : it = iter ( iterable ) while True : chunk = list ( itertools . islice ( it , n ) ) if not chunk : break yield chunk
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform auth request for token .<CODESPLIT>def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the median of a list of values Returns a float / int<CODESPLIT>def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a character delimited version of the provided list as a Python string<CODESPLIT>def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a Primary Key constraint on a specific column when the table is already created .<CODESPLIT>def set_primary_key ( self , table , column ) : self . execute ( 'ALTER TABLE {0} ADD PRIMARY KEY ({1})' . format ( wrap ( table ) , column ) ) self . _printer ( '\tAdded primary key to {0} on column {1}' . format ( wrap ( table ) , column ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to run commands synchronously for testing .<CODESPLIT>def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( "Event loop is already running." ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks to see if list is equal everywhere<CODESPLIT>def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close all open / active plotters<CODESPLIT>def close_all ( ) : for key , p in _ALL_PLOTTERS . items ( ) : p . close ( ) _ALL_PLOTTERS . clear ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .<CODESPLIT>def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( "to_dataframe requires the optional dependency Pandas." ) return pd . DataFrame . from_dict ( products , orient = 'index' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap vertical table in a function for TabularOutputFormatter .<CODESPLIT>def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .<CODESPLIT>def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( "to_dataframe requires the optional dependency Pandas." ) return pd . DataFrame . from_dict ( products , orient = 'index' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the modified time of a file<CODESPLIT>def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)  mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dictionary of conversion<CODESPLIT>def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns is seq is sequence and not string .<CODESPLIT>def _is_proper_sequence ( seq ) : return ( isinstance ( seq , collections . abc . Sequence ) and not isinstance ( seq , str ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clips a prefix from the beginning of a string if it exists .<CODESPLIT>def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a copy of seq without duplicates .<CODESPLIT>def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an empty array with appropriate shape .<CODESPLIT>def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits string into n sized chunks .<CODESPLIT>def schunk ( string , size ) : return [ string [ i : i + size ] for i in range ( 0 , len ( string ) , size ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this a string .<CODESPLIT>def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method to generate map from key to entity object for given list of dicts .<CODESPLIT>def _generate_key_map ( entity_list , key , entity_class ) : key_map = { } for obj in entity_list : key_map [ obj [ key ] ] = entity_class ( * * obj ) return key_map
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a prettier version of obj<CODESPLIT>def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted<CODESPLIT>def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '"' + i + '",' cmd = cmd [ : - 1 ] return cmd
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load and pre - process the images specified with absolute paths .<CODESPLIT>def load_preprocess_images ( image_paths : List [ str ] , image_size : tuple ) -> List [ np . ndarray ] : image_size = image_size [ 1 : ] # we do not need the number of channels images = [ ] for image_path in image_paths : images . append ( load_preprocess_image ( image_path , image_size ) ) return images
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a function to convert a string to a datetime . date instance using the formatting string fmt as in time . strftime<CODESPLIT>def stringToDate ( fmt = "%Y-%m-%d" ) : import time import datetime def conv_func ( s ) : return datetime . date ( * time . strptime ( s , fmt ) [ : 3 ] ) return conv_func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Represent string / bytes s as base64 omitting newlines<CODESPLIT>def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( "utf-8" ) return binascii . b2a_base64 ( s ) [ : - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount .<CODESPLIT>def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a class based on class name<CODESPLIT>def str_to_class ( class_name ) : mod_str , cls_str = class_name . rsplit ( '.' , 1 ) mod = __import__ ( mod_str , globals ( ) , locals ( ) , [ '' ] ) cls = getattr ( mod , cls_str ) return cls
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the parent directory of a filename .<CODESPLIT>def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the channels of a colorbar .<CODESPLIT>def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use openpyxl to read an Excel file .<CODESPLIT>def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the prime factor of given integer<CODESPLIT>def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a modified list containing only the indices indicated .<CODESPLIT>def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Align text labels based on the x - and y - axis coordinate values .<CODESPLIT>def text_alignment ( x , y ) : if x == 0 : ha = "center" elif x > 0 : ha = "left" else : ha = "right" if y == 0 : va = "center" elif y > 0 : va = "bottom" else : va = "top" return ha , va
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate area of bounding box .<CODESPLIT>def get_area ( self ) : return ( self . p2 . x - self . p1 . x ) * ( self . p2 . y - self . p1 . y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the channels of a colorbar .<CODESPLIT>def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle many to many relationships<CODESPLIT>def handle_m2m ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . __class__ , instance )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a bool from a string .<CODESPLIT>def FromString ( self , string ) : if string . lower ( ) in ( "false" , "no" , "n" ) : return False if string . lower ( ) in ( "true" , "yes" , "y" ) : return True raise TypeValueError ( "%s is not recognized as a boolean value." % string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def __next__ ( self ) : # Retrieve the row, thereby incrementing the line number: row = super ( UnicodeReaderWithLineNumber , self ) . __next__ ( ) return self . lineno + 1 , row
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print in color .<CODESPLIT>def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>cv2 Image of current window screen<CODESPLIT>def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR   cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if required dependency is installed<CODESPLIT>def check ( modname ) : for dependency in DEPENDENCIES : if dependency . modname == modname : return dependency . check ( ) else : raise RuntimeError ( "Unkwown dependency %s" % modname )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Support change columns .<CODESPLIT>def alter_change_column ( self , table , column , field ) : return self . _update_column ( table , column , lambda a , b : b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a link from A and B of given distance and also add the inverse link if the graph is undirected .<CODESPLIT>def connect ( self , A , B , distance = 1 ) : self . connect1 ( A , B , distance ) if not self . directed : self . connect1 ( B , A , distance )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function should be called instead of direct spio . loadmat as it cures the problem of not properly recovering python dictionaries from mat files . It calls the function check keys to cure all entries which are still mat - objects<CODESPLIT>def loadmat ( filename ) : data = sploadmat ( filename , struct_as_record = False , squeeze_me = True ) return _check_keys ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the progress ratio and percentage .<CODESPLIT>def ratio_and_percentage ( current , total , time_remaining ) : return "{} / {} ({}% completed)" . format ( current , total , int ( current / total * 100 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Schedules this publish action as a Celery task .<CODESPLIT>def schedule_task ( self ) : from . tasks import publish_task publish_task . apply_async ( kwargs = { 'pk' : self . pk } , eta = self . scheduled_time )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I strip extra whitespace off multi - line strings if they are ready to be stripped!<CODESPLIT>def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method to determine actual value based on type of feature variable .<CODESPLIT>def get_typecast_value ( self , value , type ) : if type == entities . Variable . Type . BOOLEAN : return value == 'true' elif type == entities . Variable . Type . INTEGER : return int ( value ) elif type == entities . Variable . Type . DOUBLE : return float ( value ) else : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test program for telnetlib .<CODESPLIT>def test ( ) : debuglevel = 0 while sys . argv [ 1 : ] and sys . argv [ 1 ] == '-d' : debuglevel = debuglevel + 1 del sys . argv [ 1 ] host = 'localhost' if sys . argv [ 1 : ] : host = sys . argv [ 1 ] port = 0 if sys . argv [ 2 : ] : portstr = sys . argv [ 2 ] try : port = int ( portstr ) except ValueError : port = socket . getservbyname ( portstr , 'tcp' ) tn = Telnet ( ) tn . set_debuglevel ( debuglevel ) tn . open ( host , port ) tn . interact ( ) tn . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check that the page title matches the given one .<CODESPLIT>def page_title ( step , title ) : with AssertContextManager ( step ) : assert_equals ( world . browser . title , title )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the median of a list .<CODESPLIT>def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a percentage string representation from the given number . The number is multiplied by 100 before adding a % character .<CODESPLIT>def to_percentage ( number , rounding = 2 ) : number = float ( number ) * 100 number_as_int = int ( number ) rounded = round ( number , rounding ) return '{}%' . format ( number_as_int if number_as_int == rounded else rounded )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run lint checks using flake8 .<CODESPLIT>def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset to the default text color on console window . Return bool True if succeed otherwise False .<CODESPLIT>def ResetConsoleColor ( ) -> bool : if sys . stdout : sys . stdout . flush ( ) bool ( ctypes . windll . kernel32 . SetConsoleTextAttribute ( _ConsoleOutputHandle , _DefaultConsoleColor ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resursively create a named directory .<CODESPLIT>def makedirs ( directory ) : parent = os . path . dirname ( os . path . abspath ( directory ) ) if not os . path . exists ( parent ) : makedirs ( parent ) os . mkdir ( directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1x1 convolution<CODESPLIT>def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove and return the item at index .<CODESPLIT>def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts binary representation label to integer .<CODESPLIT>def label_from_bin ( buf ) : mpls_label = type_desc . Int3 . to_user ( six . binary_type ( buf ) ) return mpls_label >> 4 , mpls_label & 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if we should use Unix style .<CODESPLIT>def is_unix_style ( flags ) : return ( util . platform ( ) != "windows" or ( not bool ( flags & REALPATH ) and get_case ( flags ) ) ) and not flags & _FORCEWIN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the key ( aka database value ) of a human key ( aka Python identifier ) .<CODESPLIT>def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round the number to the specified number of significant figures<CODESPLIT>def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .<CODESPLIT>def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if all the args are functions and / or subroutines<CODESPLIT>def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refresh the screen . You don t need to override this except to update only small portins of the screen .<CODESPLIT>def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output data in excel - compatible tab - delimited format<CODESPLIT>def tab ( self , output ) : import csv csvwriter = csv . writer ( self . outfile , dialect = csv . excel_tab ) csvwriter . writerows ( output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>only resize input image to target size and return scale : param im : BGR image input by opencv : param short : one dimensional size ( the short side ) : param max_size : one dimensional max size ( the long side ) : return : resized image ( NDArray ) and scale ( float )<CODESPLIT>def resize ( im , short , max_size ) : im_shape = im . shape im_size_min = np . min ( im_shape [ 0 : 2 ] ) im_size_max = np . max ( im_shape [ 0 : 2 ] ) im_scale = float ( short ) / float ( im_size_min ) # prevent bigger axis from being more than max_size: if np . round ( im_scale * im_size_max ) > max_size : im_scale = float ( max_size ) / float ( im_size_max ) im = cv2 . resize ( im , None , None , fx = im_scale , fy = im_scale , interpolation = cv2 . INTER_LINEAR ) return im , im_scale
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes the websocket connection .<CODESPLIT>def _close_websocket ( self ) : close_method = getattr ( self . _websocket , "close" , None ) if callable ( close_method ) : asyncio . ensure_future ( close_method ( ) , loop = self . _event_loop ) self . _websocket = None self . _dispatch_event ( event = "close" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prune all but the first ( = best ) n items<CODESPLIT>def prune ( self , n ) : if self . minimize : self . data = self . data [ : n ] else : self . data = self . data [ - 1 * n : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert things on the way from Python to the database .<CODESPLIT>def process_literal_param ( self , value : Optional [ List [ int ] ] , dialect : Dialect ) -> str : retval = self . _intlist_to_dbstr ( value ) return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a dict of 1d array to a numpy recarray<CODESPLIT>def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close the db and release memory<CODESPLIT>def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop the simple WSGI server running the appliation .<CODESPLIT>def exit ( self ) : if self . _server is not None : self . _server . shutdown ( ) self . _server . server_close ( ) self . _server = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Command line interface for PyBEL .<CODESPLIT>def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether a system service is available<CODESPLIT>def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpickles the classifier used<CODESPLIT>def load ( self , filename = 'classifier.dump' ) : ifile = open ( filename , 'r+' ) self . classifier = pickle . load ( ifile ) ifile . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return index of last character in string for which func ( char ) evaluates to True .<CODESPLIT>def findLastCharIndexMatching ( text , func ) : for i in range ( len ( text ) - 1 , - 1 , - 1 ) : if func ( text [ i ] ) : return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a file exists<CODESPLIT>def file_found ( filename , force ) : if os . path . exists ( filename ) and not force : logger . info ( "Found %s; skipping..." % filename ) return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .<CODESPLIT>def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of branches in the current repo .<CODESPLIT>def branches ( ) : # type: () -> List[str] out = shell . run ( 'git branch' , capture = True , never_pretend = True ) . stdout . strip ( ) return [ x . strip ( '* \t\n' ) for x in out . splitlines ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to split every line in a list and retain spaces for a rejoin : param orig_list : Original list : return : A List with split lines<CODESPLIT>def split_strings_in_list_retain_spaces ( orig_list ) : temp_list = list ( ) for line in orig_list : line_split = __re . split ( r'(\s+)' , line ) temp_list . append ( line_split ) return temp_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the height of the given line . ( The height that it would take if this line became visible . )<CODESPLIT>def get_height_for_line ( self , lineno ) : if self . wrap_lines : return self . ui_content . get_height_for_line ( lineno , self . window_width ) else : return 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate unique document id for ElasticSearch .<CODESPLIT>def generate_id ( self , obj ) : object_type = type ( obj ) . __name__ . lower ( ) return '{}_{}' . format ( object_type , self . get_object_id ( obj ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete the key and return true if the key was deleted else false<CODESPLIT>def delete ( self , key_name ) : self . db . remove ( Query ( ) . name == key_name ) return self . get ( key_name ) == { }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate random string of given length<CODESPLIT>def generate_hash ( self , length = 30 ) : import random , string chars = string . ascii_letters + string . digits ran = random . SystemRandom ( ) . choice hash = '' . join ( ran ( chars ) for i in range ( length ) ) return hash
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a soup pick out a title<CODESPLIT>def get_title ( soup ) : if soup . title : return soup . title . string if soup . h1 : return soup . h1 . string return ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends a PDF to a pyPDF writer . Legacy interface .<CODESPLIT>def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the remote file exists .<CODESPLIT>def remote_file_exists ( self , url ) : status = requests . head ( url ) . status_code if status != 200 : raise RemoteFileDoesntExist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace multiple values in a string<CODESPLIT>def replace ( s , replace ) : for r in replace : s = s . replace ( * r ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Custom validation function which inserts a timestamp for when the validation occurred<CODESPLIT>def timestamping_validate ( data , schema ) : jsonschema . validate ( data , schema ) data [ 'timestamp' ] = str ( time . time ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string that matches a named route<CODESPLIT>def get_url ( self , routename , * * kargs ) : return '/' + self . routes . build ( routename , * * kargs ) . split ( ';' , 1 ) [ 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing whitespace on each line .<CODESPLIT>def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\n' ) ] return '\n' . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string from snake case to camel case .<CODESPLIT>def snake_to_camel ( s : str ) -> str : fragments = s . split ( '_' ) return fragments [ 0 ] + '' . join ( x . title ( ) for x in fragments [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the location of the static data directory .<CODESPLIT>def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , "static" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a spent coin based on its index .<CODESPLIT>def DeleteIndex ( self , index ) : to_remove = None for i in self . Items : if i . index == index : to_remove = i if to_remove : self . Items . remove ( to_remove )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a tuple that contains ( screen_width screen_height )<CODESPLIT>def getScreenDims ( self ) : width = ale_lib . getScreenWidth ( self . obj ) height = ale_lib . getScreenHeight ( self . obj ) return ( width , height )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the toplevel widget from a gtk . Builder file .<CODESPLIT>def get_builder_toplevel ( self , builder ) : toplevel = builder . get_object ( self . toplevel_name ) if not gobject . type_is_a ( toplevel , gtk . Window ) : toplevel = None if toplevel is None : toplevel = get_first_builder_window ( builder ) return toplevel
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A background thread to kill the process if it takes too long .<CODESPLIT>def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( "Killing program due to %f second timeout" % timeout ) os . _exit ( 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the topmost parent of the current category .<CODESPLIT>def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Due to the way Angular organizes it model when this Form data is sent using Ajax then for this kind of widget the sent data has to be converted into a format suitable for Django s Form validation .<CODESPLIT>def convert_ajax_data ( self , field_data ) : data = [ key for key , val in field_data . items ( ) if val ] return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove punctuation from string s .<CODESPLIT>def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = "" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return " " . join ( filter ( None , s . split ( " " ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that gets relative path to the filename<CODESPLIT>def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator for JSON - per - line in a file pattern<CODESPLIT>def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert string to int or float .<CODESPLIT>def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a one element byte string to signed int for python 2 support .<CODESPLIT>def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( "b" , string ) [ 0 ] else : return struct . unpack ( "b" , bytes ( [ string ] ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type s str<CODESPLIT>def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for inserting int64 features into Example proto .<CODESPLIT>def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Similar to Python s built - in open () function .<CODESPLIT>def fopen ( name , mode = 'r' , buffering = - 1 ) : f = _fopen ( name , mode , buffering ) return _FileObjectThreadWithContext ( f , mode , buffering )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log out the active user<CODESPLIT>def logout ( ) : flogin . logout_user ( ) next = flask . request . args . get ( 'next' ) return flask . redirect ( next or flask . url_for ( "user" ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reads an RDF file into a graph<CODESPLIT>def load_graph_from_rdf ( fname ) : print ( "reading RDF from " + fname + "...." ) store = Graph ( ) store . parse ( fname , format = "n3" ) print ( "Loaded " + str ( len ( store ) ) + " tuples" ) return store
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if key exists in datastore . True if yes False if no .<CODESPLIT>def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If value is a datetime convert to timestamp<CODESPLIT>def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run application tests<CODESPLIT>def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose k random elements of array .<CODESPLIT>def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all files in a given directory<CODESPLIT>def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether this collection contains all items .<CODESPLIT>def issuperset ( self , items ) : return all ( _compat . map ( self . _seen . __contains__ , items ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be a float<CODESPLIT>def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to return a scalar value representing the most likely outcome given a probability distribution<CODESPLIT>def mostLikely ( self , pred ) : if len ( pred ) == 1 : return pred . keys ( ) [ 0 ] mostLikelyOutcome = None maxProbability = 0 for prediction , probability in pred . items ( ) : if probability > maxProbability : mostLikelyOutcome = prediction maxProbability = probability return mostLikelyOutcome
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch all remaining rows .<CODESPLIT>async def fetchall ( self ) -> Iterable [ sqlite3 . Row ] : return await self . _execute ( self . _cursor . fetchall )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \ t for tab - delimiting .<CODESPLIT>def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register a modele onto the lemmatizer<CODESPLIT>def register_modele ( self , modele : Modele ) : self . lemmatiseur . _modeles [ modele . gr ( ) ] = modele
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Downloads and returns the full text of a particular page in the document .<CODESPLIT>def get_page_text ( self , page ) : url = self . get_page_text_url ( page ) return self . _get_url ( url )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a unique string with length n .<CODESPLIT>def _uniqueid ( n = 30 ) : return '' . join ( random . SystemRandom ( ) . choice ( string . ascii_uppercase + string . ascii_lowercase ) for _ in range ( n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to infer an object s dtype for use in arithmetic ops<CODESPLIT>def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a key from S3<CODESPLIT>def read_key ( self , key , bucket_name = None ) : obj = self . get_key ( key , bucket_name ) return obj . get ( ) [ 'Body' ] . read ( ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn dict keys and values into native strings .<CODESPLIT>def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper parse action to convert tokens to upper case .<CODESPLIT>def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize obj as a JSON formatted stream to fp<CODESPLIT>def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim a PIL image and remove white space .<CODESPLIT>def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A basic check of if the program is running in interactive mode<CODESPLIT>def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\r' try : import threading except ImportError : return False else : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Expand $vars in a string .<CODESPLIT>def _expand ( self , str , local_vars = { } ) : return ninja_syntax . expand ( str , self . vars , local_vars )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a comma separated string to a list<CODESPLIT>def _str_to_list ( s ) : _list = s . split ( "," ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses dynamic programming to infer the location of spaces in a string without spaces .<CODESPLIT>def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>From a list of intervals extract a list of sorted gaps in the form of [ ( g i ) ] where g is the size of the ith gap .<CODESPLIT>def _gaps_from ( intervals ) : sliding_window = zip ( intervals , intervals [ 1 : ] ) gaps = [ b [ 0 ] - a [ 1 ] for a , b in sliding_window ] return gaps
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if two objects are equal .<CODESPLIT>def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield successive n - sized chunks from dictionary .<CODESPLIT>def chunks ( dictionary , chunk_size ) : iterable = iter ( dictionary ) for __ in range ( 0 , len ( dictionary ) , chunk_size ) : yield { key : dictionary [ key ] for key in islice ( iterable , chunk_size ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a target name matches with an input regular expression .<CODESPLIT>def _namematcher ( regex ) : matcher = re_compile ( regex ) def match ( target ) : target_name = getattr ( target , '__name__' , '' ) result = matcher . match ( target_name ) return result return match
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def remove_from_string ( string , values ) : for v in values : string = string . replace ( v , '' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list copy in which each item occurs only once ( in - order ) .<CODESPLIT>def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sort a list of files by filename only ignoring the directory names<CODESPLIT>def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file is a regular file and is readable .<CODESPLIT>def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places all the child widgets in the appropriate positions .<CODESPLIT>def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = "nswe" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = "ns" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove punctuation from string s .<CODESPLIT>def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = "" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return " " . join ( filter ( None , s . split ( " " ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return manhattan distance between two lists of numbers .<CODESPLIT>def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the path to the virtualenv python<CODESPLIT>def get_python ( ) : if sys . platform == 'win32' : python = path . join ( VE_ROOT , 'Scripts' , 'python.exe' ) else : python = path . join ( VE_ROOT , 'bin' , 'python' ) return python
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the moving average ( rolling mean ) of an array of a certain window size .<CODESPLIT>def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a serialised version of the model s fields which exist as local database columns ( i . e . excluding m2m and incoming foreign key relations )<CODESPLIT>def get_serializable_data_for_fields ( model ) : pk_field = model . _meta . pk # If model is a child via multitable inheritance, use parent's pk while pk_field . remote_field and pk_field . remote_field . parent_link : pk_field = pk_field . remote_field . model . _meta . pk obj = { 'pk' : get_field_value ( pk_field , model ) } for field in model . _meta . fields : if field . serialize : obj [ field . name ] = get_field_value ( field , model ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>split string into list of strings by specified number .<CODESPLIT>def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indicates whether or not the given row contains valid data .<CODESPLIT>def is_valid_row ( cls , row ) : for k in row . keys ( ) : if row [ k ] is None : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>R x M x R^ - 1<CODESPLIT>def similarity_transformation ( rot , mat ) : return np . dot ( rot , np . dot ( mat , np . linalg . inv ( rot ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in comparison to argrelmax () more simple and reliable peak finder<CODESPLIT>def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join helper<CODESPLIT>def _join ( verb ) : data = pd . merge ( verb . x , verb . y , * * verb . kwargs ) # Preserve x groups if isinstance ( verb . x , GroupedDataFrame ) : data . plydata_groups = list ( verb . x . plydata_groups ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if val is either a subclass or instance of class_ .<CODESPLIT>def is_instance_or_subclass ( val , class_ ) : try : return issubclass ( val , class_ ) except TypeError : return isinstance ( val , class_ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of rows preceding the data table for * series * in the Excel worksheet .<CODESPLIT>def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the dictionary in json format : param fname : file to save to<CODESPLIT>def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a Dictionary Cursor for executing queries<CODESPLIT>def getCursor ( self ) : if self . connection is None : self . Connect ( ) return self . connection . cursor ( MySQLdb . cursors . DictCursor )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unwrap a Python 2 . 6 SSL socket so we can call shutdown ()<CODESPLIT>def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return memory usage of python process in MB<CODESPLIT>def memory_usage ( ) : try : import psutil import os except ImportError : return _memory_usage_ps ( ) process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) [ 0 ] / float ( 2 ** 20 ) return mem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the self object attributes not inherited as dict .<CODESPLIT>def dict_self ( self ) : return { k : v for k , v in self . __dict__ . items ( ) if k in FSM_ATTRS }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove any duplicate entries .<CODESPLIT>def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dotproduct of two vectors .<CODESPLIT>def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if given string is a punctuation<CODESPLIT>def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a lambda_name and stage_name return a valid API URL .<CODESPLIT>def get_api_url ( self , lambda_name , stage_name ) : api_id = self . get_api_id ( lambda_name ) if api_id : return "https://{}.execute-api.{}.amazonaws.com/{}" . format ( api_id , self . boto_session . region_name , stage_name ) else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :<CODESPLIT>def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( "non-list value found where list is expected" ) return all ( isinstance ( x , str ) for x in arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate all matches found within a string for a regex and yield each match as a string<CODESPLIT>def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sorts a dict by value .<CODESPLIT>def sort_dict ( d , key = None , reverse = False ) : kv_items = [ kv for kv in d . items ( ) ] # Sort kv_items according to key. if key is None : kv_items . sort ( key = lambda t : t [ 1 ] , reverse = reverse ) else : kv_items . sort ( key = key , reverse = reverse ) # Build ordered dict. return collections . OrderedDict ( kv_items )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to render a list of dictionaries as an HTML display object .<CODESPLIT>def _render_table ( data , fields = None ) : return IPython . core . display . HTML ( datalab . utils . commands . HtmlBuilder . render_table ( data , fields ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes a float to the underlying output file as a 4 - byte value .<CODESPLIT>def write_float ( self , number ) : buf = pack ( self . byte_order + "f" , number ) self . write ( buf )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert raw input value of the field .<CODESPLIT>def _converter ( self , value ) : if not isinstance ( value , datetime . date ) : raise TypeError ( '{0} is not valid date' . format ( value ) ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Any normal python logic which runs a loop . Can take arguments .<CODESPLIT>def main ( idle ) : while True : LOG . debug ( "Sleeping for {0} seconds." . format ( idle ) ) time . sleep ( idle )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves the displayed plot to the previous one<CODESPLIT>def prevPlot ( self ) : if self . stacker . currentIndex ( ) > 0 : self . stacker . setCurrentIndex ( self . stacker . currentIndex ( ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get adjacency matrix .<CODESPLIT>def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Max reduction op .<CODESPLIT>def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove and return the item at index .<CODESPLIT>def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adapts a Numpy array into an ARRAY string to put into the database .<CODESPLIT>def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read an image from file - PIL doesnt close nicely<CODESPLIT>def load_image ( fname ) : with open ( fname , "rb" ) as f : i = Image . open ( fname ) #i.load() return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a map of letter use in a word .<CODESPLIT>def _letter_map ( word ) : lmap = { } for letter in word : try : lmap [ letter ] += 1 except KeyError : lmap [ letter ] = 1 return lmap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .<CODESPLIT>def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( "lib2to3.fixes" , args = args . sources ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This follows the validate rules for choices_form_class field used .<CODESPLIT>def validate ( self , value , model_instance , * * kwargs ) : self . get_choices_form_class ( ) . validate ( value , model_instance , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .<CODESPLIT>async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a port is open : param port : : param host : : return bool :<CODESPLIT>def is_port_open ( port , host = "127.0.0.1" ) : s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) try : s . connect ( ( host , int ( port ) ) ) s . shutdown ( 2 ) return True except Exception as e : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Dump Python object as JSON string .<CODESPLIT>def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a queue based on the provided parallel arguments .<CODESPLIT>def create ( parallel ) : queue = { k : v for k , v in parallel . items ( ) if k in [ "queue" , "cores_per_job" , "mem" ] } yield queue
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Annual growth given growth from start date to end date .<CODESPLIT>def growthfromrange ( rangegrowth , startdate , enddate ) : _yrs = ( pd . Timestamp ( enddate ) - pd . Timestamp ( startdate ) ) . total_seconds ( ) / dt . timedelta ( 365.25 ) . total_seconds ( ) return yrlygrowth ( rangegrowth , _yrs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets the dimensions depending on python version and os<CODESPLIT>def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the file size of a given file<CODESPLIT>def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Imputes data set containing Nan values<CODESPLIT>def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given extension is one of the watched extensions<CODESPLIT>def watched_extension ( extension ) : for ext in hamlpy . VALID_EXTENSIONS : if extension . endswith ( '.' + ext ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a graphviz graph from text<CODESPLIT>def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scale the image down by one scale step .<CODESPLIT>def zoom_out ( self ) : if self . _scalefactor >= self . _sfmin : self . _scalefactor -= 1 self . scale_image ( ) self . _adjust_scrollbar ( 1 / self . _scalestep ) self . sig_zoom_changed . emit ( self . get_scaling ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reshape data into ( num_example batch_size )<CODESPLIT>def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort the data .<CODESPLIT>def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hex encode a binary string<CODESPLIT>def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Downsample x by factor using striding .<CODESPLIT>def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implements the === operator .<CODESPLIT>def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select item in the list<CODESPLIT>def _selectItem ( self , index ) : self . _selectedIndex = index self . setCurrentIndex ( self . model ( ) . createIndex ( index , 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an image with the binarised version of the data of img .<CODESPLIT>def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Suppress warning about untrusted SSL certificate .<CODESPLIT>def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the given date with nb_months substracted from it .<CODESPLIT>def months_ago ( date , nb_months = 1 ) : nb_years = nb_months // 12 nb_months = nb_months % 12 month_diff = date . month - nb_months if month_diff > 0 : new_month = month_diff else : new_month = 12 + month_diff nb_years += 1 return date . replace ( day = 1 , month = new_month , year = date . year - nb_years )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds<CODESPLIT>def pprint ( self , seconds ) : return ( "%d:%02d:%02d.%03d" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a directory if it s present . If it s not present no - op .<CODESPLIT>def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invoked when determining whether a specific key is in the dictionary using key in d .<CODESPLIT>def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a set of lines<CODESPLIT>def polyline ( self , arr ) : for i in range ( 0 , len ( arr ) - 1 ) : self . line ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] , arr [ i + 1 ] [ 0 ] , arr [ i + 1 ] [ 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a datetime from GnuCash 2 . 6 date string<CODESPLIT>def get_from_gnucash26_date ( date_str : str ) -> date : date_format = "%Y%m%d" result = datetime . strptime ( date_str , date_format ) . date ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out a neat targets dependency tree based on requested targets .<CODESPLIT>def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mocked decorator needed in the case we need to mock a decorator<CODESPLIT>def mock_decorator ( * args , * * kwargs ) : def _called_decorator ( dec_func ) : @ wraps ( dec_func ) def _decorator ( * args , * * kwargs ) : return dec_func ( ) return _decorator return _called_decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the largest contig for each strain : param contig_lengths_dict : dictionary of strain name : reverse - sorted list of all contig lengths : return : longest_contig_dict : dictionary of strain name : longest contig<CODESPLIT>def find_largest_contig ( contig_lengths_dict ) : # Initialise the dictionary longest_contig_dict = dict ( ) for file_name , contig_lengths in contig_lengths_dict . items ( ) : # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict [ file_name ] = contig_lengths [ 0 ] return longest_contig_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .<CODESPLIT>def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the 2D region of an array corresponding to the rectangle encompassing all unmasked values .<CODESPLIT>def zoomed_scaled_array_around_mask ( self , mask , buffer = 1 ) : return self . new_with_array ( array = array_util . extracted_array_2d_from_array_2d_and_coordinates ( array_2d = self , y0 = mask . zoom_region [ 0 ] - buffer , y1 = mask . zoom_region [ 1 ] + buffer , x0 = mask . zoom_region [ 2 ] - buffer , x1 = mask . zoom_region [ 3 ] + buffer ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reconstruct the image from the tf example .<CODESPLIT>def decode_example ( self , example ) : img = tf . image . decode_image ( example , channels = self . _shape [ - 1 ] , dtype = tf . uint8 ) img . set_shape ( self . _shape ) return img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager to temporarily disable certificate validation in the standard SSL library .<CODESPLIT>def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator to turn tasklet to run eagerly .<CODESPLIT>def _eager_tasklet ( tasklet ) : @ utils . wrapping ( tasklet ) def eager_wrapper ( * args , * * kwds ) : fut = tasklet ( * args , * * kwds ) _run_until_rpc ( ) return fut return eager_wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Euclidean distance between two vectors .<CODESPLIT>def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>parse_query_string : very simplistic . won t do the right thing with list values<CODESPLIT>def parse_query_string ( query ) : result = { } qparts = query . split ( '&' ) for item in qparts : key , value = item . split ( '=' ) key = key . strip ( ) value = value . strip ( ) result [ key ] = unquote_plus ( value ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the absolute path to the directory containing the package data .<CODESPLIT>def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , "data" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places a legend box outside a matplotlib Axes instance .<CODESPLIT>def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply re . sub to bunch of ( pattern repl )<CODESPLIT>def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if value is an integer long integer or float .<CODESPLIT>def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if the json_element passed is present for the task specified .<CODESPLIT>def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert camelcase to lowercase and underscore .<CODESPLIT>def camel_to_underscore ( string ) : string = FIRST_CAP_RE . sub ( r'\1_\2' , string ) return ALL_CAP_RE . sub ( r'\1_\2' , string ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented .<CODESPLIT>def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all non - printable characters from a text string<CODESPLIT>def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an index field from this field<CODESPLIT>def to_index ( self , index_type , index_name , includes = None ) : return IndexField ( self . name , self . data_type , index_type , index_name , includes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Visible width of a potentially multiline content .<CODESPLIT>def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( "[\r\n]" , multiline_s ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a file from an AWS S3 bucket .<CODESPLIT>def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Align the given integer number to the closest page offset which usually is 4096 bytes .<CODESPLIT>def align_to_mmap ( num , round_up ) : res = ( num // ALLOCATIONGRANULARITY ) * ALLOCATIONGRANULARITY if round_up and ( res != num ) : res += ALLOCATIONGRANULARITY # END handle size return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a 3x3 cross - product matrix from a 3 - element vector .<CODESPLIT>def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a dictionary of arg_name : default_values for the input function<CODESPLIT>def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a file safely . If it s not present no - op .<CODESPLIT>def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the provided array or dtype is of the string dtype .<CODESPLIT>def is_string_dtype ( arr_or_dtype ) : # TODO: gh-15585: consider making the checks stricter. def condition ( dtype ) : return dtype . kind in ( 'O' , 'S' , 'U' ) and not is_period_dtype ( dtype ) return _is_dtype ( arr_or_dtype , condition )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the mean value across a list of dictionaries<CODESPLIT>def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap itertools . groupby to make life easier .<CODESPLIT>def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate random string of given length<CODESPLIT>def generate_hash ( self , length = 30 ) : import random , string chars = string . ascii_letters + string . digits ran = random . SystemRandom ( ) . choice hash = '' . join ( ran ( chars ) for i in range ( length ) ) return hash
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a 3 - dimensional rotation matrix .<CODESPLIT>def R_rot_3d ( th ) : sx , sy , sz = np . sin ( th ) . T cx , cy , cz = np . cos ( th ) . T R = np . empty ( ( len ( th ) , 3 , 3 ) , dtype = np . float ) R [ : , 0 , 0 ] = cy * cz R [ : , 0 , 1 ] = - cy * sz R [ : , 0 , 2 ] = sy R [ : , 1 , 0 ] = sx * sy * cz + cx * sz R [ : , 1 , 1 ] = - sx * sy * sz + cx * cz R [ : , 1 , 2 ] = - sx * cy R [ : , 2 , 0 ] = - cx * sy * cz + sx * sz R [ : , 2 , 1 ] = cx * sy * sz + sx * cz R [ : , 2 , 2 ] = cx * cy return R
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print Confirmation Message and Get Y / N response from user .<CODESPLIT>def input_yn ( conf_mess ) : ui_erase_ln ( ) ui_print ( conf_mess ) with term . cbreak ( ) : input_flush ( ) val = input_by_key ( ) return bool ( val . lower ( ) == 'y' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a deep copy of the node<CODESPLIT>def __deepcopy__ ( self , memo ) : # noinspection PyArgumentList return self . __class__ ( * * { key : deepcopy ( getattr ( self , key ) , memo ) for key in self . keys } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add an object to Javascript .<CODESPLIT>def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until all the threads are finished .<CODESPLIT>def wait_until_exit ( self ) : [ t . join ( ) for t in self . threads ] self . threads = list ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Temporarily replace sys . argv with current arguments<CODESPLIT>def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert from whatever is given to a list of scalars for the lookup_field .<CODESPLIT>def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a file or directory path only if it exists .<CODESPLIT>def remover ( file_path ) : if os . path . isfile ( file_path ) : os . remove ( file_path ) return True elif os . path . isdir ( file_path ) : shutil . rmtree ( file_path ) return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if key exists in datastore . True if yes False if no .<CODESPLIT>def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace masked - out elements in an array using an iterative image inpainting algorithm .<CODESPLIT>def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the given dictionary symmetric . Values are assumed to be unique .<CODESPLIT>def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Init connection and consumer with openstack mq .<CODESPLIT>def init_mq ( self ) : mq = self . init_connection ( ) self . init_consumer ( mq ) return mq . connection
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a TreeLib tree<CODESPLIT>def to_tree ( self ) : tree = TreeLibTree ( ) for node in self : tree . create_node ( node , node . node_id , parent = node . parent ) return tree
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param vector_a : A list of numbers . : param vector_b : A list of numbers . : returns : The euclidean distance between the two vectors .<CODESPLIT>def _euclidean_dist ( vector_a , vector_b ) : dist = 0 for ( x , y ) in zip ( vector_a , vector_b ) : dist += ( x - y ) * ( x - y ) return math . sqrt ( dist )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns data as : class : numpy . recarray .<CODESPLIT>def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>utility to set a floating value useful for converting from strings<CODESPLIT>def set_float ( val ) : out = None if not val in ( None , '' ) : try : out = float ( val ) except ValueError : return None if numpy . isnan ( out ) : out = default return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print emphasized neutral the given txt message<CODESPLIT>def info ( txt ) : print ( "%s# %s%s%s" % ( PR_EMPH_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the strict mode active / disable<CODESPLIT>def set_strict ( self , value ) : assert isinstance ( value , bool ) self . __settings . set_strict ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string for various input types<CODESPLIT>def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes 2D spectrum frequencies .<CODESPLIT>def rfft2d_freqs ( h , w ) : fy = np . fft . fftfreq ( h ) [ : , None ] # when we have an odd input dimension we need to keep one additional # frequency and later cut off 1 pixel if w % 2 == 1 : fx = np . fft . fftfreq ( w ) [ : w // 2 + 2 ] else : fx = np . fft . fftfreq ( w ) [ : w // 2 + 1 ] return np . sqrt ( fx * fx + fy * fy )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a file is empty or not .<CODESPLIT>def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>autoscan will check all of the serial ports to see if they have a matching VID : PID for a MicroPython board .<CODESPLIT>def autoscan ( ) : for port in serial . tools . list_ports . comports ( ) : if is_micropython_usb_device ( port ) : connect_serial ( port [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a given file is available in the cache or not<CODESPLIT>def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the billing cycle prior to this one . May return None<CODESPLIT>def get_previous ( self ) : return BillingCycle . objects . filter ( date_range__lt = self . date_range ) . order_by ( 'date_range' ) . last ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reformat a date string to standard format .<CODESPLIT>def std_datestr ( self , datestr ) : return date . strftime ( self . str2date ( datestr ) , self . std_dateformat )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts binary representation label to integer .<CODESPLIT>def label_from_bin ( buf ) : mpls_label = type_desc . Int3 . to_user ( six . binary_type ( buf ) ) return mpls_label >> 4 , mpls_label & 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a vertical line up to a given length .<CODESPLIT>def vline ( self , x , y , height , color ) : self . rect ( x , y , 1 , height , color , fill = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print a CSV file .<CODESPLIT>def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap a function as a method .<CODESPLIT>def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raise the open file handles permitted by the Dusty daemon process and its child processes . The number we choose here needs to be within the OS X default kernel hard limit which is 10240 .<CODESPLIT>def _increase_file_handle_limit ( ) : logging . info ( 'Increasing file handle limit to {}' . format ( constants . FILE_HANDLE_LIMIT ) ) resource . setrlimit ( resource . RLIMIT_NOFILE , ( constants . FILE_HANDLE_LIMIT , resource . RLIM_INFINITY ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logarithmic loss with non - necessarily - binary labels .<CODESPLIT>def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return :<CODESPLIT>def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a string for screen printing .<CODESPLIT>def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops all containers used by this instance of the backend .<CODESPLIT>def stop_containers ( self ) : while len ( self . _containers ) : container = self . _containers . pop ( ) try : container . kill ( signal . SIGKILL ) except docker . errors . APIError : # probably doesn't exist anymore pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in comparison to argrelmax () more simple and reliable peak finder<CODESPLIT>def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Release lock on compilation directory .<CODESPLIT>def release_lock ( ) : get_lock . n_lock -= 1 assert get_lock . n_lock >= 0 # Only really release lock once all lock requests have ended. if get_lock . lock_is_enabled and get_lock . n_lock == 0 : get_lock . start_time = None get_lock . unlocker . unlock ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializes the JSON for the Polling Event Model .<CODESPLIT>def serialize_me ( self , account , bucket_details ) : return self . dumps ( { "account" : account , "detail" : { "request_parameters" : { "bucket_name" : bucket_details [ "Name" ] , "creation_date" : bucket_details [ "CreationDate" ] . replace ( tzinfo = None , microsecond = 0 ) . isoformat ( ) + "Z" } } } ) . data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function to retreive all keys in a shelve Args : file_name : Shelve storage file name file_location : The location of the file derive from the os module<CODESPLIT>def get_keys_from_shelve ( file_name , file_location ) : temp_list = list ( ) file = __os . path . join ( file_location , file_name ) shelve_store = __shelve . open ( file ) for key in shelve_store : temp_list . append ( key ) shelve_store . close ( ) return temp_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flush all unwritten data to disk .<CODESPLIT>def flush ( self ) : if self . _cache_modified_count > 0 : self . storage . write ( self . cache ) self . _cache_modified_count = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decide if the Ipython command line is running code .<CODESPLIT>def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , "function" , None ) == pkg_resources . load_entry_point ( "ipython" , "console_scripts" , "ipython" ) . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a Stripe API timestamp response ( unix epoch ) to a native datetime .<CODESPLIT>def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will make any functions return an iterable objects by wrapping its result in a list .<CODESPLIT>def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If Python 2 replace non - ascii characters and return encoded string .<CODESPLIT>def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\u2019' , "'" ) return uni . encode ( 'utf-8' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .<CODESPLIT>def seq_to_str ( obj , sep = "," ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sophisticated simulation of multiplication<CODESPLIT>def multiply ( traj ) : z = traj . x * traj . y traj . f_add_result ( 'z' , z = z , comment = 'I am the product of two reals!' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>exit without breaking pipes .<CODESPLIT>def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a column of the given matrix .<CODESPLIT>def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date<CODESPLIT>def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if a matrix is approximately orthogonal .<CODESPLIT>def is_orthogonal ( matrix : np . ndarray , * , rtol : float = 1e-5 , atol : float = 1e-8 ) -> bool : return ( matrix . shape [ 0 ] == matrix . shape [ 1 ] and np . all ( np . imag ( matrix ) == 0 ) and np . allclose ( matrix . dot ( matrix . T ) , np . eye ( matrix . shape [ 0 ] ) , rtol = rtol , atol = atol ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns aggregate image load time for all pages .<CODESPLIT>def image_load_time ( self ) : load_times = self . get_load_times ( 'image' ) return round ( mean ( load_times ) , self . decimal_precision )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file is a regular file and is readable .<CODESPLIT>def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the width of the table including padding and borders .<CODESPLIT>def table_width ( self ) : outer_widths = max_dimensions ( self . table_data , self . padding_left , self . padding_right ) [ 2 ] outer_border = 2 if self . outer_border else 0 inner_border = 1 if self . inner_column_border else 0 return table_width ( outer_widths , outer_border , inner_border )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge all the strings . Put space between them .<CODESPLIT>def join ( mapping , bind , values ) : return [ ' ' . join ( [ six . text_type ( v ) for v in values if v is not None ] ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return only the part of the row which should be printed .<CODESPLIT>def _get_printable_columns ( columns , row ) : if not columns : return row # Extract the column values, in the order specified. return tuple ( row [ c ] for c in columns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread<CODESPLIT>async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform get request handling rate limiting .<CODESPLIT>def _ratelimited_get ( self , * args , * * kwargs ) : with self . _ratelimiter : resp = self . session . get ( * args , * * kwargs ) # It's possible that Space-Track will return HTTP status 500 with a # query rate limit violation. This can happen if a script is cancelled # before it has finished sleeping to satisfy the rate limit and it is # started again. # # Let's catch this specific instance and retry once if it happens. if resp . status_code == 500 : # Let's only retry if the error page tells us it's a rate limit # violation. if 'violated your query rate limit' in resp . text : # Mimic the RateLimiter callback behaviour. until = time . time ( ) + self . _ratelimiter . period t = threading . Thread ( target = self . _ratelimit_callback , args = ( until , ) ) t . daemon = True t . start ( ) time . sleep ( self . _ratelimiter . period ) # Now retry with self . _ratelimiter : resp = self . session . get ( * args , * * kwargs ) return resp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places all the child widgets in the appropriate positions .<CODESPLIT>def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = "nswe" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = "ns" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs out the current session by removing it from the cache . This is expected to only occur when a session has<CODESPLIT>def logout ( cache ) : cache . set ( flask . session [ 'auth0_key' ] , None ) flask . session . clear ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an iterator over the values of a dictionary .<CODESPLIT>def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the updated model to the current entity db .<CODESPLIT>def save ( self ) : self . session . add ( self ) self . session . flush ( ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the bounding box around nonzero elements in the given array<CODESPLIT>def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse file specified by constructor .<CODESPLIT>def parse ( self ) : f = open ( self . parse_log_path , "r" ) self . parse2 ( f ) f . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a spectra . Color object in the CMYK color space .<CODESPLIT>def cmyk ( c , m , y , k ) : return Color ( "cmyk" , c , m , y , k )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the local ip of this device<CODESPLIT>def _get_local_ip ( ) : return set ( [ x [ 4 ] [ 0 ] for x in socket . getaddrinfo ( socket . gethostname ( ) , 80 , socket . AF_INET ) ] ) . pop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert to datetime to UTC offset .<CODESPLIT>def convert_2_utc ( self , datetime_ , timezone ) : datetime_ = self . tz_mapper [ timezone ] . localize ( datetime_ ) return datetime_ . astimezone ( pytz . UTC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses http : // www . cplusplus . com / reference / string / to_string / for formatting<CODESPLIT>def format ( x , format ) : # don't change the dtype, otherwise for each block the dtype may be different (string length) sl = vaex . strings . format ( x , format ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the week start date and end date<CODESPLIT>def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if something quacks like a list .<CODESPLIT>def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the nth value of array<CODESPLIT>def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list with no repeated elements .<CODESPLIT>def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>SetCursorPos from Win32 . Set mouse cursor to point x y . x : int . y : int . Return bool True if succeed otherwise False .<CODESPLIT>def SetCursorPos ( x : int , y : int ) -> bool : return bool ( ctypes . windll . user32 . SetCursorPos ( x , y ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Concatenate url and argument dictionary regardless of whether url has existing query parameters .<CODESPLIT>def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies the sofplus activation function element - wise to the input .<CODESPLIT>def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs out the current session by removing it from the cache . This is expected to only occur when a session has<CODESPLIT>def logout ( cache ) : cache . set ( flask . session [ 'auth0_key' ] , None ) flask . session . clear ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove html code contained into the given string .<CODESPLIT>def strip_html ( string , keep_tag_content = False ) : r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE return r . sub ( '' , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if two images have the same height and width ( and optionally channels ) .<CODESPLIT>def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split message to list by commas and trim whitespace .<CODESPLIT>def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = "" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( "," ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace #hashtag and<CODESPLIT>def urlize_twitter ( text ) : html = TwitterText ( text ) . autolink . auto_link ( ) return mark_safe ( html . replace ( 'twitter.com/search?q=' , 'twitter.com/search/realtime/' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert spherical coordinates to cartesian unit vectors .<CODESPLIT>def angle_to_cartesian ( lon , lat ) : theta = np . array ( np . pi / 2. - lat ) return np . vstack ( ( np . sin ( theta ) * np . cos ( lon ) , np . sin ( theta ) * np . sin ( lon ) , np . cos ( theta ) ) ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>RedisCache will set prefix + version as prefix for each key .<CODESPLIT>def make_key ( self , key , version = None ) : return '{}:{}:{}' . format ( self . prefix , version or self . version , key , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If Python 2 replace non - ascii characters and return encoded string .<CODESPLIT>def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\u2019' , "'" ) return uni . encode ( 'utf-8' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>download the dates file from the internet and parse it as a dates file<CODESPLIT>def get_dates_link ( url ) : urllib . request . urlretrieve ( url , "temp.txt" ) dates = get_dates_file ( "temp.txt" ) os . remove ( "temp.txt" ) return dates
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform a range of years ( two ints ) to a DateRange object .<CODESPLIT>def from_years_range ( start_year , end_year ) : start = datetime . date ( start_year , 1 , 1 ) end = datetime . date ( end_year , 12 , 31 ) return DateRange ( start , end )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unpacks sqlite rows as returned by fetchall into an array of simple dicts .<CODESPLIT>def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scipy norm function<CODESPLIT>def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download the given JSON file and pretty - print before we output it .<CODESPLIT>def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>numpy . ndarray dumper .<CODESPLIT>def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { "$" + class_name : self . _json_convert ( obj . tolist ( ) ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempt to cast * value * into a bool returning * default * if it fails .<CODESPLIT>def _parse_boolean ( value , default = False ) : if value is None : return default try : return bool ( value ) except ValueError : return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type<CODESPLIT>def QA_util_datetime_to_strdate ( dt ) : strdate = "%04d-%02d-%02d" % ( dt . year , dt . month , dt . day ) return strdate
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Combine data and a fits header to write a fits file .<CODESPLIT>def write_fits ( data , header , file_name ) : hdu = fits . PrimaryHDU ( data ) hdu . header = header hdulist = fits . HDUList ( [ hdu ] ) hdulist . writeto ( file_name , overwrite = True ) logging . info ( "Wrote {0}" . format ( file_name ) ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse identifier such as a|c|le|d|li|re|or|AT4G00480 . 1 and return tuple of prefix string ( separated at | ) and suffix ( AGI identifier )<CODESPLIT>def parse_prefix ( identifier ) : pf , id = ( ) , identifier if "|" in identifier : pf , id = tuple ( identifier . split ( '|' ) [ : - 1 ] ) , identifier . split ( '|' ) [ - 1 ] return pf , id
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out memory usage at this point in time<CODESPLIT>def m ( name = '' , * * kwargs ) : with Reflect . context ( * * kwargs ) as r : kwargs [ "name" ] = name instance = M_CLASS ( r , stream , * * kwargs ) instance ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the offset of the current cursor position in rl_line_buffer<CODESPLIT>def rl_get_point ( ) -> int : # pragma: no cover if rl_type == RlType . GNU : return ctypes . c_int . in_dll ( readline_lib , "rl_point" ) . value elif rl_type == RlType . PYREADLINE : return readline . rl . mode . l_buffer . point else : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>close socket immediately .<CODESPLIT>def shutdown ( self ) : if self . sock : self . sock . close ( ) self . sock = None self . connected = False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if two rectangles each input as a tuple ( xmin xmax ymin ymax ) intersect .<CODESPLIT>def boxes_intersect ( box1 , box2 ) : xmin1 , xmax1 , ymin1 , ymax1 = box1 xmin2 , xmax2 , ymin2 , ymax2 = box2 if interval_intersection_width ( xmin1 , xmax1 , xmin2 , xmax2 ) and interval_intersection_width ( ymin1 , ymax1 , ymin2 , ymax2 ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike .<CODESPLIT>def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if obj is number .<CODESPLIT>def is_number ( obj ) : return isinstance ( obj , ( int , float , np . int_ , np . float_ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a 1D list to a single long string for file output using the string . join function .<CODESPLIT>def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Concatenates blocks into a block diagonal matrix .<CODESPLIT>def block_diag ( * blocks : np . ndarray ) -> np . ndarray : for b in blocks : if b . shape [ 0 ] != b . shape [ 1 ] : raise ValueError ( 'Blocks must be square.' ) if not blocks : return np . zeros ( ( 0 , 0 ) , dtype = np . complex128 ) n = sum ( b . shape [ 0 ] for b in blocks ) dtype = functools . reduce ( _merge_dtypes , ( b . dtype for b in blocks ) ) result = np . zeros ( shape = ( n , n ) , dtype = dtype ) i = 0 for b in blocks : j = i + b . shape [ 0 ] result [ i : j , i : j ] = b i = j return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from an iterable preserving the order .<CODESPLIT>def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads a model from specified file<CODESPLIT>def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional<CODESPLIT>def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if object is defined<CODESPLIT>def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the index rank according to Bertran s notation .<CODESPLIT>def rank ( idx , dim ) : idxm = multi_index ( idx , dim ) out = 0 while idxm [ - 1 : ] == ( 0 , ) : out += 1 idxm = idxm [ : - 1 ] return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function<CODESPLIT>def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table .<CODESPLIT>def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses a date string formatted like YYYY - MM - DD .<CODESPLIT>def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to render a list of dictionaries as an HTML display object .<CODESPLIT>def _render_table ( data , fields = None ) : return IPython . core . display . HTML ( datalab . utils . commands . HtmlBuilder . render_table ( data , fields ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is a builtin one .<CODESPLIT>def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the average value of a list of numbers Returns a float<CODESPLIT>def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create ctypes pointer to object .<CODESPLIT>def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a conversion function for boolean<CODESPLIT>def str_to_boolean ( input_str ) : if not isinstance ( input_str , six . string_types ) : raise ValueError ( input_str ) input_str = str_quote_stripper ( input_str ) return input_str . lower ( ) in ( "true" , "t" , "1" , "y" , "yes" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempt to guess the title from the filename<CODESPLIT>def guess_title ( basename ) : base , _ = os . path . splitext ( basename ) return re . sub ( r'[ _-]+' , r' ' , base ) . title ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to read bytes until a certain end byte is hit<CODESPLIT>def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the length of s when it is encoded with base64 .<CODESPLIT>def header_length ( bytearray ) : groups_of_3 , leftover = divmod ( len ( bytearray ) , 3 ) # 4 bytes out for each 3 bytes (or nonzero fraction thereof) in. n = groups_of_3 * 4 if leftover : n += 4 return n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rounds float to closest int : rtype : int : param n : float<CODESPLIT>def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the the number of columns required to display a string<CODESPLIT>def _visual_width ( line ) : return len ( re . sub ( colorama . ansitowin32 . AnsiToWin32 . ANSI_CSI_RE , "" , line ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts df to dict and adds a datetime field if df is datetime<CODESPLIT>def as_dict ( df , ix = ':' ) : if isinstance ( df . index , pd . DatetimeIndex ) : df [ 'datetime' ] = df . index return df . to_dict ( orient = 'records' ) [ ix ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The title of this window<CODESPLIT>def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forcefully delete objects from memory<CODESPLIT>def cleanup ( self ) : for instance in self . context : del ( instance ) for plugin in self . plugins : del ( plugin )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print warning about interrupt and empty the job queue .<CODESPLIT>def finish ( ) : out . warn ( "Interrupted!" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( "Waiting for download threads to finish." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check features data are not empty<CODESPLIT>def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return default argument value as given by argparse s add_argument () .<CODESPLIT>def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Asks for a simple string<CODESPLIT>def ask_str ( question : str , default : str = None ) : default_q = " [default: {0}]: " . format ( default ) if default is not None else "" answer = input ( "{0} [{1}]: " . format ( question , default_q ) ) if answer == "" : return default return answer
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when PyYaml encounters !include - raw<CODESPLIT>def include_raw_constructor ( self , loader , node ) : path = convert_path ( node . value ) with open ( path , 'r' ) as f : config = f . read ( ) config = self . inject_include_info ( path , config , include_type = 'include-raw' ) self . add_file ( path , config ) return config
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the tensor shape of the matrix operator<CODESPLIT>def _shape ( self ) : return tuple ( reversed ( self . output_dims ( ) ) ) + tuple ( reversed ( self . input_dims ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns data as : class : numpy . recarray .<CODESPLIT>def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits a string into parts at multiple characters<CODESPLIT>def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ideally we shouldn t lose the first second of events<CODESPLIT>def main ( ) : time . sleep ( 1 ) with Input ( ) as input_generator : for e in input_generator : print ( repr ( e ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get comments only .<CODESPLIT>def comments ( tag , limit = 0 , flags = 0 , * * kwargs ) : return [ comment for comment in cm . CommentsMatch ( tag ) . get_comments ( limit ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the modified time of a file<CODESPLIT>def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)  mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a number to a precision<CODESPLIT>def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the forecasted float from json section .<CODESPLIT>def __get_float ( section , name ) : try : return float ( section [ name ] ) except ( ValueError , TypeError , KeyError ) : return float ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if something quacks like a list .<CODESPLIT>def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the nth value of array<CODESPLIT>def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close our socket .<CODESPLIT>def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Return the area of a triangle .<CODESPLIT>def triangle_area ( pt1 , pt2 , pt3 ) : a = 0.0 a += pt1 [ 0 ] * pt2 [ 1 ] - pt2 [ 0 ] * pt1 [ 1 ] a += pt2 [ 0 ] * pt3 [ 1 ] - pt3 [ 0 ] * pt2 [ 1 ] a += pt3 [ 0 ] * pt1 [ 1 ] - pt1 [ 0 ] * pt3 [ 1 ] return abs ( a ) / 2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}<CODESPLIT>def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round the number to the specified number of significant figures<CODESPLIT>def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is a workaround where Collections are no longer iterable when using JPype .<CODESPLIT>def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in comparison to argrelmax () more simple and reliable peak finder<CODESPLIT>def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes underscores and capitalizes the neighbouring character<CODESPLIT>def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set y - axis limits of a subplot .<CODESPLIT>def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a dictionary of strings from a file<CODESPLIT>def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates or updates a property for the instance for each parameter .<CODESPLIT>def update ( self , * * kwargs ) : for key , value in kwargs . items ( ) : setattr ( self , key , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the cached object list under the appropriate key or None if not set .<CODESPLIT>def get_cached_data ( datatable , * * kwargs ) : cache_key = '%s%s' % ( CACHE_PREFIX , datatable . get_cache_key ( * * kwargs ) ) data = cache . get ( cache_key ) log . debug ( "Reading data from cache at %r: %r" , cache_key , data ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Autoconnect slot activated when tbSourceDir is clicked .<CODESPLIT>def on_source_directory_chooser_clicked ( self ) : title = self . tr ( 'Set the source directory for script and scenario' ) self . choose_directory ( self . source_directory , title )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Gets the string representation of the given type .<CODESPLIT>def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an OrderedDict containing C values to a 1D array .<CODESPLIT>def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all the files and subdirectories in a directory .<CODESPLIT>def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the MD5 hash for a file .<CODESPLIT>def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes the id of the instance .<CODESPLIT>def _initialize_id ( self ) : self . id = str ( self . db . incr ( self . _key [ 'id' ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the modified time for a file as a datetime instance<CODESPLIT>def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints given string to stderr .<CODESPLIT>def puts_err ( s = '' , newline = True , stream = STDERR ) : puts ( s , newline , stream )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Description : Returns the first index of the array ( vector ) x containing the value i . Parameters : x : one - dimensional array i : search value<CODESPLIT>def get_index_nested ( x , i ) : for ind in range ( len ( x ) ) : if i == x [ ind ] : return ind return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate a CamelCase string from an underscore_string .<CODESPLIT>def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>View the quaternion array as an array of floats<CODESPLIT>def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801<CODESPLIT>def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the given multiquery .<CODESPLIT>async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load : class : mongomock . database . Database from a local file .<CODESPLIT>def load_db ( file , db , verbose = True ) : db_data = json . load ( file , verbose = verbose ) return _load ( db_data , db )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set x - axis limits of a subplot .<CODESPLIT>def set_xlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_xlimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to turn a string representation of true into boolean True .<CODESPLIT>def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>kill process Args : process - Popen object for process<CODESPLIT>def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the exectuable bit on the given filename<CODESPLIT>def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns file name of file at given url .<CODESPLIT>def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>move to util_iter<CODESPLIT>def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience method for just changing font size .<CODESPLIT>def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of tuples specifying the column name and type<CODESPLIT>def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( "PRAGMA table_info('%s');" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the given extended file descriptor to out .<CODESPLIT>def WritePythonFile ( file_descriptor , package , version , printer ) : _WriteFile ( file_descriptor , package , version , _ProtoRpcPrinter ( printer ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize name for the Statsd convention<CODESPLIT>def normalize ( name ) : # Name should not contain some specials chars (issue #1068) ret = name . replace ( ':' , '' ) ret = ret . replace ( '%' , '' ) ret = ret . replace ( ' ' , '_' ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The virtual screen is the bounding box containing all monitors .<CODESPLIT>def _getVirtualScreenRect ( self ) : SM_XVIRTUALSCREEN = 76 # Left of virtual screen SM_YVIRTUALSCREEN = 77 # Top of virtual screen SM_CXVIRTUALSCREEN = 78 # Width of virtual screen SM_CYVIRTUALSCREEN = 79 # Height of virtual screen return ( self . _user32 . GetSystemMetrics ( SM_XVIRTUALSCREEN ) , self . _user32 . GetSystemMetrics ( SM_YVIRTUALSCREEN ) , self . _user32 . GetSystemMetrics ( SM_CXVIRTUALSCREEN ) , self . _user32 . GetSystemMetrics ( SM_CYVIRTUALSCREEN ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A standard compound hash .<CODESPLIT>def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For a given value the function finds the nearest value in the array and returns its index .<CODESPLIT>def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns unique elements from a list preserving the original order<CODESPLIT>def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets all defaults for the given dictionary to those contained in a second defaults dictionary . This convenience method calls :<CODESPLIT>def setDictDefaults ( d , defaults ) : for key , val in defaults . items ( ) : d . setdefault ( key , val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same order unique list using only a list compression .<CODESPLIT>def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts the specified datetime object into its appropriate protocol value . This is the number of milliseconds from the epoch .<CODESPLIT>def convertDatetime ( t ) : epoch = datetime . datetime . utcfromtimestamp ( 0 ) delta = t - epoch millis = delta . total_seconds ( ) * 1000 return int ( millis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check for Python 3 . 5 matrix multiplication .<CODESPLIT>def matrix_at_check ( self , original , loc , tokens ) : return self . check_py ( "35" , "matrix multiplication" , original , loc , tokens )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>move to util_iter<CODESPLIT>def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a vertical line up to a given length .<CODESPLIT>def vline ( self , x , y , height , color ) : self . rect ( x , y , 1 , height , color , fill = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve core and memory information for the current machine .<CODESPLIT>def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { "memory" : float ( "%.1f" % ( free_bytes / BYTES_IN_GIG ) ) , "cores" : multiprocessing . cpu_count ( ) , "name" : socket . gethostname ( ) } ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing whitespace on each line .<CODESPLIT>def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\n' ) ] return '\n' . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether stdin has any data to read .<CODESPLIT>def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update dict with fields from obj . attributes .<CODESPLIT>def update_dict ( obj , dict , attributes ) : for attribute in attributes : if hasattr ( obj , attribute ) and getattr ( obj , attribute ) is not None : dict [ attribute ] = getattr ( obj , attribute )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear only any cached global data .<CODESPLIT>def clear_global ( self ) : vname = self . varname logger . debug ( f'global clearning {vname}' ) if vname in globals ( ) : logger . debug ( 'removing global instance var: {}' . format ( vname ) ) del globals ( ) [ vname ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print results straight to stdout<CODESPLIT>def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the value of the other type instance to use in an operator method namely when the method s instance is on the left side of the expression .<CODESPLIT>def value_left ( self , other ) : return other . value if isinstance ( other , self . __class__ ) else other
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a str and transform it into a byte array .<CODESPLIT>def strtobytes ( input , encoding ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _strtobytes_py3 ( input , encoding ) return _strtobytes_py2 ( input , encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = "{}[{}]" . format ( pdf_path , page_num ) ) with pdf_img . convert ( "png" ) as converted : # Set white background. converted . background_color = Color ( "white" ) converted . alpha_channel = "remove" converted . save ( filename = img_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .<CODESPLIT>def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emulate lpush .<CODESPLIT>def lpush ( self , key , * args ) : redis_list = self . _get_list ( key , 'LPUSH' , create = True ) # Creates the list at this key if it doesn't exist, and appends args to its beginning args_reversed = [ self . _encode ( arg ) for arg in args ] args_reversed . reverse ( ) updated_list = args_reversed + redis_list self . redis [ self . _encode ( key ) ] = updated_list # Return the length of the list after the push operation return len ( updated_list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if two objects are equal .<CODESPLIT>def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a list of strings to pass to an SQL statement from the dictionary kw with Python types<CODESPLIT>def _make_sql_params ( self , kw ) : return [ '%s=?' % k for k in kw . keys ( ) ] for k , v in kw . iteritems ( ) : vals . append ( '%s=?' % k ) return vals
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as : meth : random . choice but also supports : class : set type to be passed as sequence .<CODESPLIT>def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits<CODESPLIT>def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function flatten given nested list . Argument : nested list Returns : flat list<CODESPLIT>def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add dots .<CODESPLIT>def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset all parameters to their default values .<CODESPLIT>def reset_params ( self ) : self . __params = dict ( [ p , None ] for p in self . param_names ) self . set_params ( self . param_defaults )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Drops and re - creates the SQL schema<CODESPLIT>def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns ( first ) selected item or None<CODESPLIT>def get_current_item ( self ) : l = self . selectedIndexes ( ) if len ( l ) > 0 : return self . model ( ) . get_item ( l [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the default matplotlib ticks .<CODESPLIT>def clear_matplotlib_ticks ( self , axis = "both" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Grabs image data and converts it to a numpy array<CODESPLIT>def numpy ( self ) : # load GDCM's image reading functionality image_reader = gdcm . ImageReader ( ) image_reader . SetFileName ( self . fname ) if not image_reader . Read ( ) : raise IOError ( "Could not read DICOM image" ) pixel_array = self . _gdcm_to_numpy ( image_reader . GetImage ( ) ) return pixel_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes l2 norm of params by flattening them into a vector .<CODESPLIT>def l2_norm ( params ) : flattened , _ = flatten ( params ) return np . dot ( flattened , flattened )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print emphasized neutral the given txt message<CODESPLIT>def info ( txt ) : print ( "%s# %s%s%s" % ( PR_EMPH_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resize all the colummns to its contents .<CODESPLIT>def _resizeColumnsToContents ( self , header , data , limit_ms ) : max_col = data . model ( ) . columnCount ( ) if limit_ms is None : max_col_ms = None else : max_col_ms = limit_ms / max ( 1 , max_col ) for col in range ( max_col ) : self . _resizeColumnToContents ( header , data , col , max_col_ms )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates an AWS Chalice project for deployment to AWS Lambda .<CODESPLIT>def create_aws_lambda ( ctx , bucket , region_name , aws_access_key_id , aws_secret_access_key ) : from canari . commands . create_aws_lambda import create_aws_lambda create_aws_lambda ( ctx . project , bucket , region_name , aws_access_key_id , aws_secret_access_key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable a default web proxy<CODESPLIT>def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the table names in the database .<CODESPLIT>def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( "SELECT name FROM sqlite_master WHERE type == 'table'" ) return [ name for ( name , ) in cursor ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeros in the list of integers and returns a new list of integers<CODESPLIT>def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>See http : // www . peterbe . com / plog / uniqifiers - benchmark Originally f8 written by Dave Kirby<CODESPLIT>def unique_iter ( seq ) : seen = set ( ) return [ x for x in seq if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Centre and normalize a given array .<CODESPLIT>def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Equivalent of the apply () builtin function . It blocks till the result is ready .<CODESPLIT>def apply ( self , func , args = ( ) , kwds = dict ( ) ) : return self . apply_async ( func , args , kwds ) . get ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print memory .<CODESPLIT>def _print_memory ( self , memory ) : for addr , value in memory . items ( ) : print ( "    0x%08x : 0x%08x (%d)" % ( addr , value , value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts camel - case identifiers to snake - case .<CODESPLIT>def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rescales a numpy array so that min is 0 and max is 255<CODESPLIT>def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rotates an image by deg degrees<CODESPLIT>def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Digits needed to comforatbly display values in [ minval maxval ]<CODESPLIT>def _digits ( minval , maxval ) : if minval == maxval : return 3 else : return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object<CODESPLIT>def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( "." ) dt = datetime . strptime ( dt , "%Y-%m-%dT%H:%M:%S" ) return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if value value is empty . Keyword arguments : value str -- the value of the associated field to compare<CODESPLIT>def run ( self , value ) : if self . pass_ and not value . strip ( ) : return True if not value : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates sql datetime2 object from Python datetime object ignoring timezone<CODESPLIT>def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG<CODESPLIT>def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The distance between two skip - connections .<CODESPLIT>def skip_connection_distance ( a , b ) : if a [ 2 ] != b [ 2 ] : return 1.0 len_a = abs ( a [ 1 ] - a [ 0 ] ) len_b = abs ( b [ 1 ] - b [ 0 ] ) return ( abs ( a [ 0 ] - b [ 0 ] ) + abs ( len_a - len_b ) ) / ( max ( a [ 0 ] , b [ 0 ] ) + max ( len_a , len_b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check that value is in values<CODESPLIT>def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the file is binary<CODESPLIT>def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\0' in data : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill NaNs with the previous value the next value or if all are NaN then 1 . 0<CODESPLIT>def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return manhattan distance between two lists of numbers .<CODESPLIT>def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Opens file attempts to identify content based off magic number and will return the file extension . If mime is True it will return the mime type instead .<CODESPLIT>def from_file ( filename , mime = False ) : head , foot = _file_details ( filename ) return _magic ( head , foot , mime , ext_from_filename ( filename ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new instance from a file .<CODESPLIT>def load ( cls , tree_path ) : with open ( tree_path ) as f : tree_dict = json . load ( f ) return cls . from_dict ( tree_dict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize obj as a JSON formatted stream to the given filename ( pretty printing version )<CODESPLIT>def json_pretty_dump ( obj , filename ) : with open ( filename , "wt" ) as fh : json . dump ( obj , fh , indent = 4 , sort_keys = 4 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Do j / v replacement<CODESPLIT>def replace ( self , text ) : for ( pattern , repl ) in self . patterns : text = re . subn ( pattern , repl , text ) [ 0 ] return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy a file whole from input to output .<CODESPLIT>def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Displays a simple message box with text and a single OK button . Returns the text of the button clicked on .<CODESPLIT>def alert ( text = '' , title = '' , button = OK_TEXT , root = None , timeout = None ) : assert TKINTER_IMPORT_SUCCEEDED , 'Tkinter is required for pymsgbox' return _buttonbox ( msg = text , title = title , choices = [ str ( button ) ] , root = root , timeout = timeout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses S3 URL .<CODESPLIT>def parse_s3_url ( url ) : bucket = '' path = '' if url : result = urlparse ( url ) bucket = result . netloc path = result . path . strip ( '/' ) return bucket , path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts camel - case identifiers to snake - case .<CODESPLIT>def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if the json_element passed is present for the task specified .<CODESPLIT>def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like dict but does not hold any null values .<CODESPLIT>def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs the function asynchronously taking care of exceptions .<CODESPLIT>def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes // - comments and single - line C - style / * * / comments .<CODESPLIT>def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start web application<CODESPLIT>def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the validity of an IPv6 address<CODESPLIT>def is_valid_ipv6 ( ip_str ) : try : socket . inet_pton ( socket . AF_INET6 , ip_str ) except socket . error : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Requests - mock requests . request wrapper .<CODESPLIT>def requests_request ( method , url , * * kwargs ) : session = local_sessions . session response = session . request ( method = method , url = url , * * kwargs ) session . close ( ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the venv by name<CODESPLIT>def rm ( venv_name ) : inenv = InenvManager ( ) venv = inenv . get_venv ( venv_name ) click . confirm ( "Delete dir {}" . format ( venv . path ) ) shutil . rmtree ( venv . path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if a point is within this polygonal region<CODESPLIT>def is_in ( self , point_x , point_y ) : point_array = array ( ( ( point_x , point_y ) , ) ) vertices = array ( self . points ) winding = self . inside_rule == "winding" result = points_in_polygon ( point_array , vertices , winding ) return result [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new : class : ~ulid . ulid . ULID instance from the given : class : ~uuid . UUID value .<CODESPLIT>def from_uuid ( value : uuid . UUID ) -> ulid . ULID : return ulid . ULID ( value . bytes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate all matches found within a string for a regex and yield each match as a string<CODESPLIT>def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Selects n random elements from a list of ( weight item ) tuples . Based on code snippet by Nick Johnson<CODESPLIT>def _weighted_selection ( l , n ) : cuml = [ ] items = [ ] total_weight = 0.0 for weight , item in l : total_weight += weight cuml . append ( total_weight ) items . append ( item ) return [ items [ bisect . bisect ( cuml , random . random ( ) * total_weight ) ] for _ in range ( n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print results straight to stdout<CODESPLIT>def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Collect digits from a string<CODESPLIT>def str2int ( string_with_int ) : return int ( "" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn an SQLAlchemy model into a dict of field names and values .<CODESPLIT>def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the file size of a given file<CODESPLIT>def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use the specified filename for streamed logging .<CODESPLIT>def __init__ ( self , filename , mode , encoding = None ) : FileHandler . __init__ ( self , filename , mode , encoding ) self . mode = mode self . encoding = encoding
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the folder exisits . If not create the folder<CODESPLIT>def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a vector of spherical bessel functions yn : x : The argument . N : values of n will run from 0 to N - 1 .<CODESPLIT>def sbessely ( x , N ) : out = np . zeros ( N , dtype = np . float64 ) out [ 0 ] = - np . cos ( x ) / x out [ 1 ] = - np . cos ( x ) / ( x ** 2 ) - np . sin ( x ) / x for n in xrange ( 2 , N ) : out [ n ] = ( ( 2.0 * n - 1.0 ) / x ) * out [ n - 1 ] - out [ n - 2 ] return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap text in an ansi escape sequence<CODESPLIT>def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a one element byte string to signed int for python 2 support .<CODESPLIT>def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( "b" , string ) [ 0 ] else : return struct . unpack ( "b" , bytes ( [ string ] ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Private method that sets the value currently of the property<CODESPLIT>def _set_property ( self , val , * args ) : val = UserClassAdapter . _set_property ( self , val , * args ) if val : Adapter . _set_property ( self , val , * args ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the input or output mode for a specified pin . Mode should be either OUTPUT or INPUT .<CODESPLIT>def setup ( self , pin , mode , pull_up_down = PUD_OFF ) : self . rpi_gpio . setup ( pin , self . _dir_mapping [ mode ] , pull_up_down = self . _pud_mapping [ pull_up_down ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if dtype is a numeric type .<CODESPLIT>def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set foreground - and background colors and intensity .<CODESPLIT>def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove decoded instruction from instruction cache<CODESPLIT>def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A convenience function for plotting a vertical bar plot from a Counter<CODESPLIT>def barv ( d , plt , title = None , rotation = 'vertical' ) : labels = sorted ( d , key = d . get , reverse = True ) index = range ( len ( labels ) ) plt . xticks ( index , labels , rotation = rotation ) plt . bar ( index , [ d [ v ] for v in labels ] ) if title is not None : plt . title ( title )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get rid of all axis ticks lines etc .<CODESPLIT>def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert cartesian to lon lat .<CODESPLIT>def xyz2lonlat ( x , y , z ) : lon = xu . rad2deg ( xu . arctan2 ( y , x ) ) lat = xu . rad2deg ( xu . arctan2 ( z , xu . sqrt ( x ** 2 + y ** 2 ) ) ) return lon , lat
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does this filename match any of the patterns?<CODESPLIT>def file_matches ( filename , patterns ) : return any ( fnmatch . fnmatch ( filename , pat ) for pat in patterns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a list unique retaining order of initial appearance .<CODESPLIT>def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the type of obj as a string . More descriptive and specific than type ( obj ) and safe for any object unlike __class__ .<CODESPLIT>def typename ( obj ) : if hasattr ( obj , '__class__' ) : return getattr ( obj , '__class__' ) . __name__ else : return type ( obj ) . __name__
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flip an image horizontally or vertically .<CODESPLIT>def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scale the image to uint8<CODESPLIT>def uint8sc ( im ) : im = np . asarray ( im ) immin = im . min ( ) immax = im . max ( ) imrange = immax - immin return cv2 . convertScaleAbs ( im - immin , alpha = 255 / imrange )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if a file is located within the given directory .<CODESPLIT>def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a json string representing the python object obj .<CODESPLIT>def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a filtered image after applying the Fourier - space filters<CODESPLIT>def filtered_image ( self , im ) : q = np . fft . fftn ( im ) for k , v in self . filters : q [ k ] -= v return np . real ( np . fft . ifftn ( q ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A decorator for providing a unittest with a library and have it called only once .<CODESPLIT>def library ( func ) : @ wraps ( func ) def wrapped ( * args , * * kwargs ) : """Transparent wrapper.""" return func ( * args , * * kwargs ) SINGLES . append ( wrapped ) return wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Se asegura de que un directorio exista .<CODESPLIT>def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a system command in the background disown it and hide it s output .<CODESPLIT>def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return time in milliseconds from start_time<CODESPLIT>def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the element with the specified ID .<CODESPLIT>def get_element_with_id ( self , id ) : # Should we maintain a hashmap of ids to make this more efficient? Probably overkill. # TODO: Elements can contain nested elements (captions, footnotes, table cells, etc.) return next ( ( el for el in self . elements if el . id == id ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize path slashes .<CODESPLIT>def norm_slash ( name ) : if isinstance ( name , str ) : return name . replace ( '/' , "\\" ) if not is_case_sensitive ( ) else name else : return name . replace ( b'/' , b"\\" ) if not is_case_sensitive ( ) else name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // stackoverflow . com / a / 31312102 / 190597 ( SoulNibbler )<CODESPLIT>def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) out . seek ( 0 ) return sqlite3 . Binary ( out . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a value to session .<CODESPLIT>def _session_set ( self , key , value ) : self . session [ self . _session_key ( key ) ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Probability density function ( normal distribution )<CODESPLIT>def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace accentuated chars in string by their non accentuated equivalent .<CODESPLIT>def unaccentuate ( s ) : return "" . join ( c for c in unicodedata . normalize ( "NFKD" , s ) if not unicodedata . combining ( c ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find rightmost value less than x .<CODESPLIT>def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Translate an image in fourier - space with plane waves<CODESPLIT>def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the pythonic string type .<CODESPLIT>def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the integer index of * series * in this sequence .<CODESPLIT>def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the indices of the lexicographical sorting order of the supplied arrays .<CODESPLIT>def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>mono - exponential curve .<CODESPLIT>def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns day number of the last day of the month : param t : datetime : return : int<CODESPLIT>def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is to support iterators over a file - like object .<CODESPLIT>def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether the re module can compile the given regular expression .<CODESPLIT>def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a copy of seq without duplicates .<CODESPLIT>def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerce value to an JSON - compatible representation .<CODESPLIT>def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split message to list by commas and trim whitespace .<CODESPLIT>def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = "" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( "," ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all child objects in nested lists of strings .<CODESPLIT>def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return human readable string .<CODESPLIT>def __str__ ( self ) : return ", " . join ( "{:02x}{:02x}={:02x}{:02x}" . format ( c [ 0 ] [ 0 ] , c [ 0 ] [ 1 ] , c [ 1 ] [ 0 ] , c [ 1 ] [ 1 ] ) for c in self . alias_array_ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Filter out any values in target not in image : param image : image containing values to appear in filtered image : param target : the image to filter : rtype : 2d : class : numpy . ndarray containing only value in image and with the same dimensions as target<CODESPLIT>def filter_greys_using_image ( image , target ) : maskbase = numpy . array ( range ( 256 ) , dtype = numpy . uint8 ) mask = numpy . where ( numpy . in1d ( maskbase , numpy . unique ( image ) ) , maskbase , 0 ) return mask [ target ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tries to load an encoded json string back into an object : param json_string : : return :<CODESPLIT>def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve requested URL<CODESPLIT>def _get_url ( url ) : try : data = HTTP_SESSION . get ( url , stream = True ) data . raise_for_status ( ) except requests . exceptions . RequestException as exc : raise FetcherException ( exc ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to get a number out of a string and cast it .<CODESPLIT>def get_number ( s , cast = int ) : import string d = "" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper for pulling a keyed value off various types of objects<CODESPLIT>def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add value to a set in a dictionary by key<CODESPLIT>def dict_of_sets_add ( dictionary , key , value ) : # type: (DictUpperBound, Any, Any) -> None set_objs = dictionary . get ( key , set ( ) ) set_objs . add ( value ) dictionary [ key ] = set_objs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output all sections of the page .<CODESPLIT>def Output ( self ) : self . Open ( ) self . Header ( ) self . Body ( ) self . Footer ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if this is a primary key ; False if this is a subkey<CODESPLIT>def is_primary ( self ) : return isinstance ( self . _key , Primary ) and not isinstance ( self . _key , Sub )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether flyweight object with specified key has already been created .<CODESPLIT>def has_key ( cls , * args ) : key = args if len ( args ) > 1 else args [ 0 ] return key in cls . _instances
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A version of squeeze that works with dynamic axis .<CODESPLIT>def _squeeze ( x , axis ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) if axis is None : return tf . squeeze ( x , axis = None ) axis = tf . convert_to_tensor ( value = axis , name = 'axis' , dtype = tf . int32 ) axis += tf . zeros ( [ 1 ] , dtype = axis . dtype ) # Make axis at least 1d. keep_axis , _ = tf . compat . v1 . setdiff1d ( tf . range ( 0 , tf . rank ( x ) ) , axis ) return tf . reshape ( x , tf . gather ( tf . shape ( input = x ) , keep_axis ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the file size of a given file<CODESPLIT>def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Kill the process group associated with the given process . ( posix )<CODESPLIT>def kill_process ( process ) : logger = logging . getLogger ( 'xenon' ) logger . info ( 'Terminating Xenon-GRPC server.' ) os . kill ( process . pid , signal . SIGINT ) process . wait ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return names as a tuple based on given month . If no month given use current one<CODESPLIT>def get_month_namedays ( self , month = None ) : if month is None : month = datetime . now ( ) . month return self . NAMEDAYS [ month - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform actions before parent main window is closed<CODESPLIT>def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get an item from a dict which contains just one item .<CODESPLIT>def get_single_item ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . iteritems ( d ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redirect standard out to file .<CODESPLIT>def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Searches for the specified method and returns its descriptor .<CODESPLIT>def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the default matplotlib ticks .<CODESPLIT>def clear_matplotlib_ticks ( self , axis = "both" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a vector with the elements rounded to the given number of digits .<CODESPLIT>def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return first row and also iterable with same items as original<CODESPLIT>def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : """Generator that returns first and proxy other items from source""" yield one while True : yield next ( it ) return ( one , gen ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make an MD5 hash of a file ignoring any differences in line ending characters .<CODESPLIT>def filehash ( path ) : with open ( path , "rU" ) as f : return md5 ( py3compat . str_to_bytes ( f . read ( ) ) ) . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dictionary of variables specified at CLI : param : args : Command Line Arguments namespace<CODESPLIT>def get_variables ( args ) : variables_dict = { } if args . variables : for var in args . variables : words = var . split ( '=' ) variables_dict [ words [ 0 ] ] = words [ 1 ] return variables_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a pandas . Series into an xarray . DataArray .<CODESPLIT>def from_series ( cls , series ) : # TODO: add a 'name' parameter name = series . name df = pd . DataFrame ( { name : series } ) ds = Dataset . from_dataframe ( df ) return ds [ name ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Short Time Fourier Transform for real data keeping the full FFT block .<CODESPLIT>def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flip the writability of a file and return the old mode . Returns None if the file is already writable .<CODESPLIT>def flipwritable ( fn , mode = None ) : if os . access ( fn , os . W_OK ) : return None old_mode = os . stat ( fn ) . st_mode os . chmod ( fn , stat . S_IWRITE | old_mode ) return old_mode
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a Path or string is a file on the file system .<CODESPLIT>def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform an underscore_case string to a mixedCase string<CODESPLIT>def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a duration in seconds .<CODESPLIT>def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a new url route .<CODESPLIT>def add_url_rule ( self , route , endpoint , handler ) : self . app . add_url_rule ( route , endpoint , handler )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def table_exists ( cursor , tablename , schema = 'public' ) : query = """     SELECT EXISTS (         SELECT 1         FROM information_schema.tables         WHERE table_schema = %s         AND table_name = %s     )""" cursor . execute ( query , ( schema , tablename ) ) res = cursor . fetchone ( ) [ 0 ] return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Portable cast function .<CODESPLIT>def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build a C ++ binary executable<CODESPLIT>def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends a command and an ( optional ) sequence of arguments through to the delegated serial interface . Note that the arguments are passed through as data .<CODESPLIT>def command ( self , cmd , * args ) : self . _serial_interface . command ( cmd ) if len ( args ) > 0 : self . _serial_interface . data ( list ( args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a stringified representation of this object .<CODESPLIT>def __repr__ ( self ) : return str ( { 'name' : self . _name , 'watts' : self . _watts , 'type' : self . _output_type , 'id' : self . _integration_id } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close our socket .<CODESPLIT>def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a file and close it . Returns the file source .<CODESPLIT>def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether a variable is a numpy integer array .<CODESPLIT>def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the provided name is a valid variable name in Python<CODESPLIT>def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns system clipboard contents .<CODESPLIT>def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list consisting of the cumulative sum of the items in the passed list .<CODESPLIT>def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether path is a directory to which the user has write access .<CODESPLIT>def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format numpy array as a string .<CODESPLIT>def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( "," ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + "%s[%s]" % ( arr . dtype , shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value of the checkbox .<CODESPLIT>def set_value ( self , value ) : if value : self . setChecked ( Qt . Checked ) else : self . setChecked ( Qt . Unchecked )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a float returns a rounded int . Should give the same result on both Py2 / 3<CODESPLIT>def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generates a count of the number of times each unique item appears in a list<CODESPLIT>def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a tif file to a 2D NumPy array<CODESPLIT>def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set x - axis limits of a subplot .<CODESPLIT>def set_xlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_xlimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : size of the entire schema in bytes<CODESPLIT>def size_on_disk ( self ) : return int ( self . connection . query ( """             SELECT SUM(data_length + index_length)             FROM information_schema.tables WHERE table_schema='{db}'             """ . format ( db = self . database ) ) . fetchone ( ) [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: type s str<CODESPLIT>def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pause the music<CODESPLIT>def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>in string astr replace all occurences of thefind with thereplace<CODESPLIT>def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simplified check to see if the text appears to be a URL .<CODESPLIT>def looks_like_url ( url ) : if not isinstance ( url , basestring ) : return False if not isinstance ( url , basestring ) or len ( url ) >= 1024 or not cre_url . match ( url ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a dictionary of strings from a file<CODESPLIT>def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether this RangeSet contains another set .<CODESPLIT>def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip the whitespace from all column names in the given DataFrame and return the result .<CODESPLIT>def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encode from strings to token ids .<CODESPLIT>def encode_dataset ( dataset , vocabulary ) : def encode ( features ) : return { k : vocabulary . encode_tf ( v ) for k , v in features . items ( ) } return dataset . map ( encode , num_parallel_calls = tf . data . experimental . AUTOTUNE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trim left - right given string<CODESPLIT>def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( "" , somestr ) tmp = RE_TSPACES . sub ( "" , tmp ) return str ( tmp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate<CODESPLIT>def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy<CODESPLIT>def getBuffer ( x ) : b = bytes ( x ) return ( c_ubyte * len ( b ) ) . from_buffer_copy ( bytes ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add widget actions to toolbar<CODESPLIT>def add_to_toolbar ( self , toolbar , widget ) : actions = widget . toolbar_actions if actions is not None : add_actions ( toolbar , actions )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list with no repeated elements .<CODESPLIT>def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a set of lines<CODESPLIT>def polyline ( self , arr ) : for i in range ( 0 , len ( arr ) - 1 ) : self . line ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] , arr [ i + 1 ] [ 0 ] , arr [ i + 1 ] [ 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert axis coordinate to bin index .<CODESPLIT>def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get dimension of an array getting the number of rows and the max num of columns .<CODESPLIT>def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds parent folder of file<CODESPLIT>def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a string to a file - like object .<CODESPLIT>def write_string ( value , buff , byteorder = 'big' ) : data = value . encode ( 'utf-8' ) write_numeric ( USHORT , len ( data ) , buff , byteorder ) buff . write ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>detect if a model has a given field has<CODESPLIT>def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data .<CODESPLIT>def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve a simple OAuth Token for use with the local http client .<CODESPLIT>def get_oauth_token ( ) : url = "{0}/token" . format ( DEFAULT_ORIGIN [ "Origin" ] ) r = s . get ( url = url ) return r . json ( ) [ "t" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A small helper function to convert a string to a numeric value if appropriate<CODESPLIT>def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>\ Asserts that two iterables contain the same values .<CODESPLIT>def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if obj is number .<CODESPLIT>def is_number ( obj ) : return isinstance ( obj , ( int , float , np . int_ , np . float_ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if all the args are functions and / or subroutines<CODESPLIT>def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true iff v is a number .<CODESPLIT>def numberp ( v ) : return ( not ( isinstance ( v , bool ) ) and ( isinstance ( v , int ) or isinstance ( v , float ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform auth request for token .<CODESPLIT>def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dictionary of conversion<CODESPLIT>def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a string return true if it matches the supplied list of patterns .<CODESPLIT>def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Softsign op .<CODESPLIT>def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a zero - based column number of the beginning of this range .<CODESPLIT>def column ( self ) : line , column = self . source_buffer . decompose_position ( self . begin_pos ) return column
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>property () but encapsulates it in a list if it s a single - element property .<CODESPLIT>def property_as_list ( self , property_name ) : try : res = self . _a_tags [ property_name ] except KeyError : return [ ] if type ( res ) == list : return res else : return [ res ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a random string from a - zA - Z : param n : length of the string : return : the random string<CODESPLIT>def random_letters ( n ) : return '' . join ( random . SystemRandom ( ) . choice ( string . ascii_letters ) for _ in range ( n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a tuple of numbers . e . g . vertices normals or teture coords .<CODESPLIT>def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns set of the ancestors of a node as DAGNodes .<CODESPLIT>def ancestors ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling ancestors() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] return nx . ancestors ( self . _multi_graph , node )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a sentence into list of words .<CODESPLIT>def split_into_words ( s ) : s = re . sub ( r"\W+" , " " , s ) s = re . sub ( r"[_0-9]+" , " " , s ) return s . split ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructor for try block structures .<CODESPLIT>def __init__ ( self , scope , parent ) : CodeStatement . __init__ ( self , scope , parent ) self . body = CodeBlock ( scope , self , explicit = True ) self . catches = [ ] self . finally_body = CodeBlock ( scope , self , explicit = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crunch a 64 - bit int ( 8 bool bytes ) into a bitfield .<CODESPLIT>def pack_bits ( longbits ) : byte = longbits & ( 0x0101010101010101 ) byte = ( byte | ( byte >> 7 ) ) & ( 0x0003000300030003 ) byte = ( byte | ( byte >> 14 ) ) & ( 0x0000000f0000000f ) byte = ( byte | ( byte >> 28 ) ) & ( 0x00000000000000ff ) return byte
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator which dynamically binds static methods to the model for later use .<CODESPLIT>def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns indices to select the kth nearest neighbour<CODESPLIT>def kindex ( matrix , k ) : ix = ( np . arange ( len ( matrix ) ) , matrix . argsort ( axis = 0 ) [ k ] ) return ix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>append item and print it to stdout<CODESPLIT>def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shape of histogram s data .<CODESPLIT>def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update inplace widgets position when doing vertical scroll<CODESPLIT>def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the a new dict with underscores instead of hyphens in keys .<CODESPLIT>def dict_keys_without_hyphens ( a_dict ) : return dict ( ( key . replace ( '-' , '_' ) , val ) for key , val in a_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A wrapper of os . makedirs () .<CODESPLIT>def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if string could be a valid python identifier<CODESPLIT>def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the path of java executable<CODESPLIT>def get_java_path ( ) : java_home = os . environ . get ( "JAVA_HOME" ) return os . path . join ( java_home , BIN_DIR , "java" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Warn if nans exist in a numpy array .<CODESPLIT>def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime<CODESPLIT>def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Value of property .<CODESPLIT>def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>move to util_iter<CODESPLIT>def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is an integer number .<CODESPLIT>def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits a list into chunks<CODESPLIT>def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert notebook to python script<CODESPLIT>def nb_to_python ( nb_path ) : exporter = python . PythonExporter ( ) output , resources = exporter . from_filename ( nb_path ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if val is of integer type .<CODESPLIT>def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .<CODESPLIT>def generate_unique_host_id ( ) : host = "." . join ( reversed ( socket . gethostname ( ) . split ( "." ) ) ) pid = os . getpid ( ) return "%s.%d" % ( host , pid )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes 2D spectrum frequencies .<CODESPLIT>def rfft2d_freqs ( h , w ) : fy = np . fft . fftfreq ( h ) [ : , None ] # when we have an odd input dimension we need to keep one additional # frequency and later cut off 1 pixel if w % 2 == 1 : fx = np . fft . fftfreq ( w ) [ : w // 2 + 2 ] else : fx = np . fft . fftfreq ( w ) [ : w // 2 + 1 ] return np . sqrt ( fx * fx + fy * fy )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter for dict note f should have signature : f :: key - > value - > bool<CODESPLIT>def _ ( f , x ) : return { k : v for k , v in x . items ( ) if f ( k , v ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method to check if a set of types is the { AnyObject } singleton<CODESPLIT>def is_any_type_set ( sett : Set [ Type ] ) -> bool : return len ( sett ) == 1 and is_any_type ( min ( sett ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a nested list and returns the size of each dimension followed by the element type in the list<CODESPLIT>def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>exactly like s but doesn t return variable names or file positions ( useful for logging )<CODESPLIT>def ss ( * args , * * kwargs ) : if not args : raise ValueError ( "you didn't pass any arguments to print out" ) with Reflect . context ( args , * * kwargs ) as r : instance = V_CLASS ( r , stream , * * kwargs ) return instance . value ( ) . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns a werkzeug . MultiDict or django . MultiValueDict into a dict with list values : param d : a MultiDict or MultiValueDict instance : return : a dict instance<CODESPLIT>def multidict_to_dict ( d ) : return dict ( ( k , v [ 0 ] if len ( v ) == 1 else v ) for k , v in iterlists ( d ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>StringIO constructor shim for the async wrapper .<CODESPLIT>def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For a range indicated from start to end replace with replacement .<CODESPLIT>def _replace_token_range ( tokens , start , end , replacement ) : tokens = tokens [ : start ] + replacement + tokens [ end : ] return tokens
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn a query into a string for printing . Useful for debugging .<CODESPLIT>def atlasdb_format_query ( query , values ) : return "" . join ( [ "%s %s" % ( frag , "'%s'" % val if type ( val ) in [ str , unicode ] else val ) for ( frag , val ) in zip ( query . split ( "?" ) , values + ( "" , ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emulate what a Python set () does but keeping the element s order .<CODESPLIT>def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Covert numpy array to tensorflow tensor<CODESPLIT>def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get list of all uppercase non - private globals ( doesn t start with _ ) .<CODESPLIT>def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( "_" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove any duplicate entries .<CODESPLIT>def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean up processes after SIGTERM or SIGINT is received .<CODESPLIT>def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .<CODESPLIT>def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a comma separated string to a list<CODESPLIT>def _str_to_list ( s ) : _list = s . split ( "," ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Symmetrical logarithmic scale .<CODESPLIT>def filter_symlog ( y , base = 10.0 ) : log_base = np . log ( base ) sign = np . sign ( y ) logs = np . log ( np . abs ( y ) / log_base ) return sign * logs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invoke pytest replacing argv . Return result code .<CODESPLIT>def run_tests ( self ) : with _save_argv ( _sys . argv [ : 1 ] + self . addopts ) : result_code = __import__ ( 'pytest' ) . main ( ) if result_code : raise SystemExit ( result_code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all images from the file .<CODESPLIT>def delete ( self , mutagen_file ) : for cover_tag in self . TAG_NAMES . values ( ) : try : del mutagen_file [ cover_tag ] except KeyError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to divide two numbers<CODESPLIT>def generic_div ( a , b ) : logger . debug ( 'Called generic_div({}, {})' . format ( a , b ) ) return a / b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve the previous quarter for dt<CODESPLIT>def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def correlation_2D ( image ) : # Take the fourier transform of the image. F1 = fftpack . fft2 ( image ) # Now shift the quadrants around so that low spatial frequencies are in # the center of the 2D fourier transformed image. F2 = fftpack . fftshift ( F1 ) # Calculate a 2D power spectrum psd2D = np . abs ( F2 ) # Calculate the azimuthally averaged 1D power spectrum psd1D = analysis_util . azimuthalAverage ( psd2D ) return psd1D , psd2D
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To replace a list of items by a single replacement : param subject_list : list : param replacement : string : param string : string : return : string<CODESPLIT>def list_replace ( subject_list , replacement , string ) : for s in subject_list : string = string . replace ( s , replacement ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of processors on this machine .<CODESPLIT>def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( "SC_NPROCESSORS_CONF" ) except ( AttributeError , ValueError ) : pass gen_log . error ( "Could not detect number of processors; assuming 1" ) return 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use the S3 SWAG backend .<CODESPLIT>def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refresh the screen . You don t need to override this except to update only small portins of the screen .<CODESPLIT>def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a dictionary from a URL params<CODESPLIT>def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate if non empty string<CODESPLIT>def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a hash of the contents of a dictionary<CODESPLIT>def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans the column names on a DataFrame Parameters : df - DataFrame The DataFrame to clean<CODESPLIT>def clean_colnames ( df ) : col_list = [ ] for index in range ( _dutils . cols ( df ) ) : col_list . append ( df . columns [ index ] . strip ( ) . lower ( ) . replace ( ' ' , '_' ) ) df . columns = col_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return standard deviation .<CODESPLIT>def standard_deviation ( numbers ) : numbers = list ( numbers ) if not numbers : return 0 mean = sum ( numbers ) / len ( numbers ) return ( sum ( ( n - mean ) ** 2 for n in numbers ) / len ( numbers ) ) ** .5
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes the extension from a filename<CODESPLIT>def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns this programs current memory usage in bytes<CODESPLIT>def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the shape of the region as ( x y w h )<CODESPLIT>def getTuple ( self ) : return ( self . x , self . y , self . w , self . h )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if variable is a numpy array<CODESPLIT>def is_array ( self , key ) : data = self . model . get_data ( ) return isinstance ( data [ key ] , ( ndarray , MaskedArray ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback to go to the next tab . Called by the accel key .<CODESPLIT>def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts python datetime to epoch microseconds .<CODESPLIT>def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output<CODESPLIT>def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flush the file and close it .<CODESPLIT>def close ( self ) : if not self . _closed : self . __flush ( ) object . __setattr__ ( self , "_closed" , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the given dictionary symmetric . Values are assumed to be unique .<CODESPLIT>def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .<CODESPLIT>def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the default stream encoding if not found .<CODESPLIT>def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Used for debugging .<CODESPLIT>def debug ( ftn , txt ) : if debug_p : sys . stdout . write ( "{0}.{1}:{2}\n" . format ( modname , ftn , txt ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a set of strings .<CODESPLIT>def _split_comma_separated ( string ) : return set ( text . strip ( ) for text in string . split ( ',' ) if text . strip ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Euclidean distance between two vectors .<CODESPLIT>def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize a ResponseException instance .<CODESPLIT>def __init__ ( self , response ) : self . response = response super ( ResponseException , self ) . __init__ ( "received {} HTTP response" . format ( response . status_code ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last weekday in a given month . e . g :<CODESPLIT>def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a tif file to a 2D NumPy array<CODESPLIT>def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents )<CODESPLIT>def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of the earliest occurence of an item from a list in a string<CODESPLIT>def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Directly reads text data from url<CODESPLIT>def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the checkbox matching the CSS selector .<CODESPLIT>def check_by_selector ( self , selector ) : elem = find_element_by_jquery ( world . browser , selector ) if not elem . is_selected ( ) : elem . click ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def http_request_json ( * args , * * kwargs ) : ret , status = http_request ( * args , * * kwargs ) return json . loads ( ret ) , status
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>searchs a value in a dicionary and returns the key of the first occurrence<CODESPLIT>def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Aggregation function to get the first non - zero value .<CODESPLIT>def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the variable set with the given name .<CODESPLIT>def get_var ( self , name ) : for var in self . vars : if var . name == name : return var else : raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Restores the state of the batched queue for writing .<CODESPLIT>def enable_writes ( self ) : self . write_buffer = [ ] self . flush_lock = threading . RLock ( ) self . flush_thread = FlushThread ( self . max_batch_time , self . _flush_writes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read entire contents of file into a string .<CODESPLIT>def read_string_from_file ( path , encoding = "utf8" ) : with codecs . open ( path , "rb" , encoding = encoding ) as f : value = f . read ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>update () extends rather than replaces existing key lists .<CODESPLIT>def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update all visuals in the attached canvas .<CODESPLIT>def update ( self ) : if not self . canvas : return for visual in self . canvas . visuals : self . update_program ( visual . program ) self . canvas . update ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a dict to an encoded URL . Example : given data = { a : 1 b : 2 } it returns a = 1&b = 2<CODESPLIT>def get_dict_to_encoded_url ( data ) : unicode_data = dict ( [ ( k , smart_str ( v ) ) for k , v in data . items ( ) ] ) encoded = urllib . urlencode ( unicode_data ) return encoded
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested .<CODESPLIT>def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the average color from the list of colors where each color is a 3 - tuple of ( r g b ) values .<CODESPLIT>def get_average_color ( colors ) : c = reduce ( color_reducer , colors ) total = len ( colors ) return tuple ( v / total for v in c )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List APIs in account .<CODESPLIT>def list_apis ( awsclient ) : client_api = awsclient . get_client ( 'apigateway' ) apis = client_api . get_rest_apis ( ) [ 'items' ] for api in apis : print ( json2table ( api ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This will insert the value into the array keeping it sorted and returning the index where it was inserted<CODESPLIT>def insert_ordered ( value , array ) : index = 0 # search for the last array item that value is larger than for n in range ( 0 , len ( array ) ) : if value >= array [ n ] : index = n + 1 array . insert ( index , value ) return index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs a bash script in the local directory<CODESPLIT>def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( "bash {}" . format ( filename ) , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from integers to strings<CODESPLIT>def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ajoute la target au plot<CODESPLIT>def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = "red" , s = 80 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits a list into chunks<CODESPLIT>def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets a naive datetime from a datetime .<CODESPLIT>def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , "asdatetime" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the median of a list of values Returns a float / int<CODESPLIT>def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose the most common item from the list or the first item if all items are unique .<CODESPLIT>def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the line number parsed from the comment or 0 .<CODESPLIT>def _get_line_no_from_comments ( py_line ) : matched = LINECOL_COMMENT_RE . match ( py_line ) if matched : return int ( matched . group ( 1 ) ) else : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get width and height of a PDF<CODESPLIT>def dimensions ( path ) : pdf = PdfFileReader ( path ) size = pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .<CODESPLIT>def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load proxy list from configured proxy source<CODESPLIT>def load ( self ) : self . _list = self . _source . load ( ) self . _list_iter = itertools . cycle ( self . _list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>u Delete the character behind the cursor . A numeric argument means to kill the characters instead of deleting them .<CODESPLIT>def backward_delete_word ( self , e ) : # (Control-Rubout)  self . l_buffer . backward_delete_word ( self . argument_reset ) self . finalize ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a page to the page cache .<CODESPLIT>def cache_page ( page_cache , page_hash , cache_size ) : page_cache . append ( page_hash ) if len ( page_cache ) > cache_size : page_cache . pop ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test for ReverseDNS class<CODESPLIT>def test ( ) : dns = ReverseDNS ( ) print ( dns . lookup ( '192.168.0.1' ) ) print ( dns . lookup ( '8.8.8.8' ) ) # Test cache print ( dns . lookup ( '8.8.8.8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear the displayed image .<CODESPLIT>def clear ( self ) : self . _imgobj = None try : # See if there is an image on the canvas self . canvas . delete_object_by_tag ( self . _canvas_img_tag ) self . redraw ( ) except KeyError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add dots .<CODESPLIT>def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values<CODESPLIT>def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to convert list to tsv line with carriage return<CODESPLIT>def write_tsv_line_from_list ( linelist , outfp ) : line = '\t' . join ( linelist ) outfp . write ( line ) outfp . write ( '\n' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refresh the screen . You don t need to override this except to update only small portins of the screen .<CODESPLIT>def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set dictionary array .<CODESPLIT>def setdict ( self , D ) : self . D = np . asarray ( D , dtype = self . dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether a certain column exists<CODESPLIT>def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the default stream encoding if not found .<CODESPLIT>def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if value is an integer long integer or float .<CODESPLIT>def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> l = [ 1 1 1 ] >>> obj_in_list_always ( l 1 ) True >>> l . append ( 2 ) >>> obj_in_list_always ( l 1 ) False<CODESPLIT>def obj_in_list_always ( target_list , obj ) : for item in set ( target_list ) : if item is not obj : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Modifies each item . keys () string based on the func passed in . Often used with inflection s camelize or underscore methods .<CODESPLIT>def _modify ( item , func ) : result = dict ( ) for key in item : result [ func ( key ) ] = item [ key ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to get return code of a url<CODESPLIT>def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get version information for components used by Spyder<CODESPLIT>def get_versions ( reporev = True ) : import sys import platform import qtpy import qtpy . QtCore revision = None if reporev : from spyder . utils import vcs revision , branch = vcs . get_git_revision ( os . path . dirname ( __dir__ ) ) if not sys . platform == 'darwin' : # To avoid a crash with our Mac app system = platform . system ( ) else : system = 'Darwin' return { 'spyder' : __version__ , 'python' : platform . python_version ( ) , # "2.7.3" 'bitness' : 64 if sys . maxsize > 2 ** 32 else 32 , 'qt' : qtpy . QtCore . __version__ , 'qt_api' : qtpy . API_NAME , # PyQt5 'qt_api_ver' : qtpy . PYQT_VERSION , 'system' : system , # Linux, Windows, ... 'release' : platform . release ( ) , # XP, 10.6, 2.2.0, etc. 'revision' : revision , # '9fdf926eccce' }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an updated copy of the dictionary without modifying the original<CODESPLIT>def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a chunked PUT request to url with requests . session This is specifically to upload files .<CODESPLIT>def rest_put_stream ( self , url , stream , headers = None , session = None , verify = True , cert = None ) : res = session . put ( url , headers = headers , data = stream , verify = verify , cert = cert ) return res . text , res . status_code
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes a . wav file .<CODESPLIT>def write_wave ( path , audio , sample_rate ) : with contextlib . closing ( wave . open ( path , 'wb' ) ) as wf : wf . setnchannels ( 1 ) wf . setsampwidth ( 2 ) wf . setframerate ( sample_rate ) wf . writeframes ( audio )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the largest real value h such that all elements in x are integer multiples of h .<CODESPLIT>def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read 4 bytes from bytestream as an unsigned 32 - bit integer .<CODESPLIT>def read32 ( bytestream ) : dt = np . dtype ( np . uint32 ) . newbyteorder ( '>' ) return np . frombuffer ( bytestream . read ( 4 ) , dtype = dt ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to handle what to do when the stop button is pressed<CODESPLIT>def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging  if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cast to float tensor<CODESPLIT>def fcast ( value : float ) -> TensorLike : newvalue = tf . cast ( value , FTYPE ) if DEVICE == 'gpu' : newvalue = newvalue . gpu ( ) # Why is this needed?  # pragma: no cover return newvalue
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a given number of 32 - bits unsigned integers from the given file with the given endianness .<CODESPLIT>def read_data ( file , endian , num = 1 ) : res = struct . unpack ( endian + 'L' * num , file . read ( num * 4 ) ) if len ( res ) == 1 : return res [ 0 ] return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close connection with the database<CODESPLIT>def close_database_session ( session ) : try : session . close ( ) except OperationalError as e : raise DatabaseError ( error = e . orig . args [ 1 ] , code = e . orig . args [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .<CODESPLIT>def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: returns the minimum of the column<CODESPLIT>def min ( self ) : res = self . _qexec ( "min(%s)" % self . _name ) if len ( res ) > 0 : self . _min = res [ 0 ] [ 0 ] return self . _min
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>To know the allocated memory at function termination .<CODESPLIT>def memory_used ( self ) : if self . _end_memory : memory_used = self . _end_memory - self . _start_memory return memory_used else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the eigvals of mat and then find the center eigval difference .<CODESPLIT>def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove ticks tick labels and frame from axis<CODESPLIT>def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>DEBUG FUNC modify argv to look like you ran a command<CODESPLIT>def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple measure of similarity : Number of letters in common / max length<CODESPLIT>def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the argparser namespace with any data from configuration file .<CODESPLIT>def args_update ( self ) : for key , value in self . _config_data . items ( ) : setattr ( self . _default_args , key , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into separate words .<CODESPLIT>def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test that a and b are close and match in shape .<CODESPLIT>def allclose ( a , b ) : from numpy import allclose return ( a . shape == b . shape ) and allclose ( a , b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the features dimension raise if error<CODESPLIT>def parse_dim ( features , check = True ) : # try: dim = features [ 0 ] . shape [ 1 ] # except IndexError: #     dim = 1 if check and not dim > 0 : raise IOError ( 'features dimension must be strictly positive' ) if check and not all ( [ d == dim for d in [ x . shape [ 1 ] for x in features ] ] ) : raise IOError ( 'all files must have the same feature dimension' ) return dim
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the upper bound of a constraint .<CODESPLIT>def set_constraint_bound ( self , name , value ) : index = self . _get_constraint_index ( name ) self . upper_bounds [ index ] = value self . _reset_solution ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if URL is safe to redirect to .<CODESPLIT>def is_local_url ( target ) : ref_url = urlparse ( request . host_url ) test_url = urlparse ( urljoin ( request . host_url , target ) ) return test_url . scheme in ( 'http' , 'https' ) and ref_url . netloc == test_url . netloc
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if current project has any noncommited changes .<CODESPLIT>def is_changed ( ) : executed , changed_lines = execute_git ( 'status --porcelain' , output = False ) merge_not_finished = mod_path . exists ( '.git/MERGE_HEAD' ) return changed_lines . strip ( ) or merge_not_finished
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes tags from objects<CODESPLIT>def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear only any cached global data .<CODESPLIT>def clear_global ( self ) : vname = self . varname logger . debug ( f'global clearning {vname}' ) if vname in globals ( ) : logger . debug ( 'removing global instance var: {}' . format ( vname ) ) del globals ( ) [ vname ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values<CODESPLIT>def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value of the checkbox .<CODESPLIT>def set_value ( self , value ) : if value : self . setChecked ( Qt . Checked ) else : self . setChecked ( Qt . Unchecked )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Re - raises the error that was processed by prepare_for_reraise earlier .<CODESPLIT>def reraise ( error ) : if hasattr ( error , "_type_" ) : six . reraise ( type ( error ) , error , error . _traceback ) raise error
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes the string to stdout<CODESPLIT>def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the thumbnail dimensions depending on the images format .<CODESPLIT>def calculate_dimensions ( image , long_side , short_side ) : if image . width >= image . height : return '{0}x{1}' . format ( long_side , short_side ) return '{0}x{1}' . format ( short_side , long_side )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if dtype is a numeric type .<CODESPLIT>def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a comma separated option into a list .<CODESPLIT>def split_comma_argument ( comma_sep_str ) : terms = [ ] for term in comma_sep_str . split ( ',' ) : if term : terms . append ( term ) return terms
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if the given fasta file contains sequences with duplicate sequence names .<CODESPLIT>def _check_for_duplicate_sequence_names ( self , fasta_file_path ) : found_sequence_names = set ( ) for record in SeqIO . parse ( fasta_file_path , 'fasta' ) : name = record . name if name in found_sequence_names : return name found_sequence_names . add ( name ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return scaled image size in ( width height ) format . The scaling preserves the aspect ratio . If PIL is not found returns None .<CODESPLIT>def getDimensionForImage ( filename , maxsize ) : try : from PIL import Image except ImportError : return None img = Image . open ( filename ) width , height = img . size if width > maxsize [ 0 ] or height > maxsize [ 1 ] : img . thumbnail ( maxsize ) out . info ( "Downscaled display size from %s to %s" % ( ( width , height ) , img . size ) ) return img . size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render a jinja template<CODESPLIT>def render_template ( env , filename , values = None ) : if not values : values = { } tmpl = env . get_template ( filename ) return tmpl . render ( values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply the coefficients from a linear fit to an array of x y positions .<CODESPLIT>def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate<CODESPLIT>def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .<CODESPLIT>def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whitespace normalization :<CODESPLIT>def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return "\n" . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can edit this object<CODESPLIT>def has_edit_permission ( self , request ) : return request . user . is_authenticated and request . user . is_active and request . user . is_staff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add subparser<CODESPLIT>def sub ( name , func , * * kwarg ) : sp = subparsers . add_parser ( name , * * kwarg ) sp . set_defaults ( func = func ) sp . arg = sp . add_argument return sp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be a float<CODESPLIT>def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the absolute uri for a file<CODESPLIT>def __absolute__ ( self , uri ) : return op . abspath ( op . join ( self . __path__ , uri ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JSSObject for the element with ID id_<CODESPLIT>def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterator for JSON - per - line in a file pattern<CODESPLIT>def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove legend for axes or gca .<CODESPLIT>def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap the byte - ordering in a packet with N = 4 bytes per word<CODESPLIT>def byteswap ( data , word_size = 4 ) : return reduce ( lambda x , y : x + '' . join ( reversed ( y ) ) , chunks ( data , word_size ) , '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively computes true depth of the subtree . Should only be needed for debugging . Unless something is wrong the depth field should reflect the correct depth of the subtree .<CODESPLIT>def compute_depth ( self ) : left_depth = self . left_node . compute_depth ( ) if self . left_node else 0 right_depth = self . right_node . compute_depth ( ) if self . right_node else 0 return 1 + max ( left_depth , right_depth )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the directory path for the given package or module .<CODESPLIT>def path_for_import ( name ) : return os . path . dirname ( os . path . abspath ( import_module ( name ) . __file__ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if there s something to read on stdin ( posix version ) .<CODESPLIT>def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I convert strings into integers floats and strings!<CODESPLIT>def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes flags returns indexes of True values<CODESPLIT>def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the latest modification time of all files / subdirectories in a directory<CODESPLIT>def dir_modtime ( dpath ) : return max ( os . path . getmtime ( d ) for d , _ , _ in os . walk ( dpath ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An enum is encoded by a int representing the zero - based position of the symbol in the schema .<CODESPLIT>def write_enum ( fo , datum , schema ) : index = schema [ 'symbols' ] . index ( datum ) write_int ( fo , index )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A socket attached to the stdin / stdout of a container . The object returned contains a get_socket () function to get a socket . socket object and close_socket () to close the connection<CODESPLIT>def attach_to_container ( self , container_id ) : sock = self . _docker . containers . get ( container_id ) . attach_socket ( params = { 'stdin' : 1 , 'stdout' : 1 , 'stderr' : 0 , 'stream' : 1 , } ) # fix a problem with docker-py; we must keep a reference of sock at every time return FixDockerSocket ( sock )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert human readable string to datetime . datetime .<CODESPLIT>def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function to check if input query is not None and set missing arguments to default value<CODESPLIT>def validate_args ( * * args ) : if not args [ 'query' ] : print ( "\nMissing required query argument." ) sys . exit ( ) for key in DEFAULTS : if key not in args : args [ key ] = DEFAULTS [ key ] return args
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return manhattan distance between two lists of numbers .<CODESPLIT>def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the nth value of array<CODESPLIT>def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes the root Dataset .<CODESPLIT>def _closeResources ( self ) : logger . info ( "Closing: {}" . format ( self . _fileName ) ) self . _h5Group . close ( ) self . _h5Group = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put the value of a column keyword . ( see : func : table . putcolkeyword )<CODESPLIT>def putkeyword ( self , keyword , value , makesubrecord = False ) : return self . _table . putcolkeyword ( self . _column , keyword , value , makesubrecord )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of all the image s colors .<CODESPLIT>def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Surveyed length not including excluded shots<CODESPLIT>def included_length ( self ) : return sum ( [ shot . length for shot in self . shots if shot . is_included ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the request payload size<CODESPLIT>def calculate_size ( name , count ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += INT_SIZE_IN_BYTES return data_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a name in camelCase return in snake_case<CODESPLIT>def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\1_\2' , name ) return ALL_CAP_REGEX . sub ( r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extracts all integers from a string an return them in a list<CODESPLIT>def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save a given signal sig to file fname as a 16 - bit one - channel wave with the given rate sample rate .<CODESPLIT>def save_to_16bit_wave_file ( fname , sig , rate ) : with closing ( wave . open ( fname , "wb" ) ) as wave_file : wave_file . setnchannels ( 1 ) wave_file . setsampwidth ( 2 ) wave_file . setframerate ( rate ) for chunk in chunks ( ( clip ( sig ) * 2 ** 15 ) . map ( int ) , dfmt = "h" , padval = 0 ) : wave_file . writeframes ( chunk )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case<CODESPLIT>def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a nested list and returns the size of each dimension followed by the element type in the list<CODESPLIT>def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Counts the word frequences in a list of sentences .<CODESPLIT>def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>validate that we can store the multi - index ; reset and return the new object<CODESPLIT>def validate_multiindex ( self , obj ) : levels = [ l if l is not None else "level_{0}" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( "duplicate names/columns in the multi-index when " "storing as a table" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the conda executable robustly across conda versions .<CODESPLIT>def _find_conda ( ) : if 'CONDA_EXE' in os . environ : conda = os . environ [ 'CONDA_EXE' ] else : conda = util . which ( 'conda' ) return conda
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a string with comma or space - separated elements into a list .<CODESPLIT>def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts C char arrays to bytes and C NULL values to None .<CODESPLIT>def to_bytes_or_none ( value ) : if value == ffi . NULL : return None elif isinstance ( value , ffi . CData ) : return ffi . string ( value ) else : raise ValueError ( 'Value must be char[] or NULL' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes and waits for subprocess to exit .<CODESPLIT>def _finish ( self ) : if self . _process . returncode is None : self . _process . stdin . flush ( ) self . _process . stdin . close ( ) self . _process . wait ( ) self . closed = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set colouring on if STDOUT is a terminal device off otherwise<CODESPLIT>def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a multiline string into a list excluding blank lines .<CODESPLIT>def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\n' ) ) if element ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type a string type?<CODESPLIT>def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increment the key by the given amount .<CODESPLIT>def incr ( self , key , incr_by = 1 ) : return self . database . hincrby ( self . key , key , incr_by )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield successive n - sized chunks from l .<CODESPLIT>def _chunks ( l , n ) : for i in xrange ( 0 , len ( l ) , n ) : yield l [ i : i + n ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks to see if list is equal everywhere<CODESPLIT>def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform a simple check if the value is callable .<CODESPLIT>def callable_validator ( v : Any ) -> AnyCallable : if callable ( v ) : return v raise errors . CallableError ( value = v )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If the option did not exist create a default value .<CODESPLIT>def set_default ( self , section , option , default ) : if not self . parser . has_option ( section , option ) : self . parser . set ( section , option , default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy a file whole from input to output .<CODESPLIT>def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert record array to a dictionaries<CODESPLIT>def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like map but also chains the results .<CODESPLIT>def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str<CODESPLIT>def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the cosine and sin for the given angle in degrees with special - case handling of multiples of 90 for perfect right angles<CODESPLIT>def cos_sin_deg ( deg ) : deg = deg % 360.0 if deg == 90.0 : return 0.0 , 1.0 elif deg == 180.0 : return - 1.0 , 0 elif deg == 270.0 : return 0 , - 1.0 rad = math . radians ( deg ) return math . cos ( rad ) , math . sin ( rad )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file or directory is world writable .<CODESPLIT>def is_writable_by_others ( filename ) : mode = os . stat ( filename ) [ stat . ST_MODE ] return mode & stat . S_IWOTH
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>initializes 3D plot<CODESPLIT>def plot3d_init ( fignum ) : from mpl_toolkits . mplot3d import Axes3D fig = plt . figure ( fignum ) ax = fig . add_subplot ( 111 , projection = '3d' ) return ax
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read and return filename in root dir of project and return string<CODESPLIT>def read ( filename ) : return codecs . open ( os . path . join ( __DIR__ , filename ) , 'r' ) . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a file is empty or not .<CODESPLIT>def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Natural log of scipy norm function truncated at zero<CODESPLIT>def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Escape data for tab - separated value ( TSV ) format .<CODESPLIT>def tsv_escape ( x : Any ) -> str : if x is None : return "" x = str ( x ) return x . replace ( "\t" , "\\t" ) . replace ( "\n" , "\\n" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>inverse hyperbolic sine transformation<CODESPLIT>def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return no more than k indices of smallest values .<CODESPLIT>def argsort_k_smallest ( x , k ) : if k == 0 : return np . array ( [ ] , dtype = np . intp ) if k is None or k >= len ( x ) : return np . argsort ( x ) indices = np . argpartition ( x , k ) [ : k ] values = x [ indices ] return indices [ np . argsort ( values ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like map but also chains the results .<CODESPLIT>def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert documentation to HTML<CODESPLIT>def doc_to_html ( doc , doc_format = "ROBOT" ) : from robot . libdocpkg . htmlwriter import DocToHtml return DocToHtml ( doc_format ) ( doc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute all tests ( normal and slow ) with coverage enabled .<CODESPLIT>def coverage ( ctx , opts = "" ) : return test ( ctx , coverage = True , include_slow = True , opts = opts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compile and return a Module s code object .<CODESPLIT>def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if obj is a sequence but not a string or bytes .<CODESPLIT>def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This function returns a pretty table used to display the port results .<CODESPLIT>def get_table ( ports ) : table = PrettyTable ( [ "Name" , "Port" , "Protocol" , "Description" ] ) table . align [ "Name" ] = "l" table . align [ "Description" ] = "l" table . padding_width = 1 for port in ports : table . add_row ( port ) return table
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>!<CODESPLIT>def bfx ( value , msb , lsb ) : mask = bitmask ( ( msb , lsb ) ) return ( value & mask ) >> lsb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>will plot a stack of traces one above the other assuming marray . shape = numRows numSamples<CODESPLIT>def stackplot ( marray , seconds = None , start_time = None , ylabels = None ) : tarray = np . transpose ( marray ) stackplot_t ( tarray , seconds = seconds , start_time = start_time , ylabels = ylabels ) plt . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert this confusion matrix into a 2x2 plain list of values .<CODESPLIT>def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Randomly select some rows from table .<CODESPLIT>def select_random ( engine , table_or_columns , limit = 5 ) : s = select ( table_or_columns ) . order_by ( func . random ( ) ) . limit ( limit ) return engine . execute ( s ) . fetchall ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set an object s field to default if it doesn t have a value<CODESPLIT>def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert numbers to floats whether the decimal point is . or<CODESPLIT>def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>detect if a model has a given field has<CODESPLIT>def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add executable permissions to the file<CODESPLIT>def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Underlying synchronized wrapper .<CODESPLIT>def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if you are on a 64 bit platform<CODESPLIT>def check64bit ( current_system = "python" ) : if current_system == "python" : return sys . maxsize > 2147483647 elif current_system == "os" : import platform pm = platform . machine ( ) if pm != ".." and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable a default web proxy<CODESPLIT>def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Segmented max op .<CODESPLIT>def SegmentMax ( a , ids ) : func = lambda idxs : np . amax ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cast value to bool .<CODESPLIT>def parse_value ( self , value ) : parsed = super ( BoolField , self ) . parse_value ( value ) return bool ( parsed ) if parsed is not None else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if there s something to read on stdin ( posix version ) .<CODESPLIT>def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the domain : port part of the URL without scheme . Eg : facebook . com 127 . 0 . 0 . 1 : 8080 etc .<CODESPLIT>def get_site_name ( request ) : urlparts = request . urlparts return ':' . join ( [ urlparts . hostname , str ( urlparts . port ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the length longest line in a paragraph<CODESPLIT>def get_longest_line_length ( text ) : lines = text . split ( "\n" ) length = 0 for i in range ( len ( lines ) ) : if len ( lines [ i ] ) > length : length = len ( lines [ i ] ) return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve core and memory information for the current machine .<CODESPLIT>def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { "memory" : float ( "%.1f" % ( free_bytes / BYTES_IN_GIG ) ) , "cores" : multiprocessing . cpu_count ( ) , "name" : socket . gethostname ( ) } ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare differencs from two dicts<CODESPLIT>def compare_dict ( da , db ) : sa = set ( da . items ( ) ) sb = set ( db . items ( ) ) diff = sa & sb return dict ( sa - diff ) , dict ( sb - diff )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a timestamp value and rounds it to a second precision .<CODESPLIT>def RoundToSeconds ( cls , timestamp ) : leftovers = timestamp % definitions . MICROSECONDS_PER_SECOND scrubbed = timestamp - leftovers rounded = round ( float ( leftovers ) / definitions . MICROSECONDS_PER_SECOND ) return int ( scrubbed + rounded * definitions . MICROSECONDS_PER_SECOND )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this a call with exactly 1 argument where that argument is positional?<CODESPLIT>def _is_one_arg_pos_call ( call ) : return isinstance ( call , astroid . Call ) and len ( call . args ) == 1 and not call . keywords
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple from parsing a b c d - > ( a b c d )<CODESPLIT>def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform sed text substitution .<CODESPLIT>def sed ( match , replacement , path , modifiers = "" ) : cmd = "sed -r -i 's/%s/%s/%s' %s" % ( match , replacement , modifiers , path ) process = Subprocess ( cmd , shell = True ) ret , out , err = process . run ( timeout = 60 ) if ret : raise SubprocessError ( "Sed command failed!" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The function compares strings ignoring case<CODESPLIT>def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Empty a table by deleting all of its rows .<CODESPLIT>def truncate ( self , table ) : if isinstance ( table , ( list , set , tuple ) ) : for t in table : self . _truncate ( t ) else : self . _truncate ( table )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the distance between two points on earth .<CODESPLIT>def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate Android device id<CODESPLIT>def generate_device_id ( steamid ) : h = hexlify ( sha1_hash ( str ( steamid ) . encode ( 'ascii' ) ) ) . decode ( 'ascii' ) return "android:%s-%s-%s-%s-%s" % ( h [ : 8 ] , h [ 8 : 12 ] , h [ 12 : 16 ] , h [ 16 : 20 ] , h [ 20 : 32 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set nan and inf rows from x to zero<CODESPLIT>def clean_with_zeros ( self , x ) : x [ ~ np . any ( np . isnan ( x ) | np . isinf ( x ) , axis = 1 ) ] = 0 return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flags that a function is linear wrt all args<CODESPLIT>def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Project points into 3d from 2d points .<CODESPLIT>def transform_to_3d ( points , normal , z = 0 ) : d = np . cross ( normal , ( 0 , 0 , 1 ) ) M = rotation_matrix ( d ) transformed_points = M . dot ( points . T ) . T + z return transformed_points
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r %autoreload = > Reload modules automatically<CODESPLIT>def autoreload ( self , parameter_s = '' ) : if parameter_s == '' : self . _reloader . check ( True ) elif parameter_s == '0' : self . _reloader . enabled = False elif parameter_s == '1' : self . _reloader . check_all = False self . _reloader . enabled = True elif parameter_s == '2' : self . _reloader . check_all = True self . _reloader . enabled = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a random string from 0 - 9 : param n : length of the string : return : the random string<CODESPLIT>def random_numbers ( n ) : return '' . join ( random . SystemRandom ( ) . choice ( string . digits ) for _ in range ( n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the group associated to the file : param filename : : return : str<CODESPLIT>def get_file_extension_type ( filename ) : ext = get_file_extension ( filename ) if ext : for name , group in EXTENSIONS . items ( ) : if ext in group : return name return "OTHER"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if n is a prime number<CODESPLIT>def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>splits iterables a in equal parts of size sz<CODESPLIT>def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return attrs with keys in keys list<CODESPLIT>def _pick_attrs ( attrs , keys ) : return dict ( ( k , v ) for k , v in attrs . items ( ) if k in keys )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to create regexp for matching escaped separators in strings .<CODESPLIT>def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\]|\\.)+)' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the median of a list .<CODESPLIT>def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write DOT comment .<CODESPLIT>def comment ( self , s , * * args ) : self . write ( u"// " ) self . writeln ( s = s , * * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param list_of_points : : return : list_of_points with None s removed<CODESPLIT>def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves all relevant data to . h5 file ; so state can be restored .<CODESPLIT>def save_hdf ( self , filename , path = '' ) : self . dataframe . to_hdf ( filename , '{}/df' . format ( path ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves all IP addresses associated to a given instance .<CODESPLIT>def get_ips ( self , instance_id ) : instance = self . _load_instance ( instance_id ) IPs = sum ( instance . networks . values ( ) , [ ] ) return IPs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Harmonic mean of an array returns the closest int<CODESPLIT>def hmean_int ( a , a_min = 5778 , a_max = 1149851 ) : from scipy . stats import hmean return int ( round ( hmean ( np . clip ( a , a_min , a_max ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>End of the Glances server session .<CODESPLIT>def end ( self ) : if not self . args . disable_autodiscover : self . autodiscover_client . close ( ) self . server . end ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether an object is a path .<CODESPLIT>def _is_path ( s ) : if isinstance ( s , string_types ) : try : return op . exists ( s ) except ( OSError , ValueError ) : return False else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redirect standard out to file .<CODESPLIT>def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether a path names an existing executable file .<CODESPLIT>def is_executable ( path ) : return os . path . isfile ( path ) and os . access ( path , os . X_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses box coordinates to crop an image without resizing it first .<CODESPLIT>def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlinks all of the specified items from the tree .<CODESPLIT>def detach ( self , * items ) : self . _visual_drag . detach ( * items ) ttk . Treeview . detach ( self , * items )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return IPython s guess for the default encoding for bytes as text .<CODESPLIT>def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to FTP server login and return an ftplib . FTP instance .<CODESPLIT>def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return indices of inputs to the node with the given index .<CODESPLIT>def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy<CODESPLIT>def getBuffer ( x ) : b = bytes ( x ) return ( c_ubyte * len ( b ) ) . from_buffer_copy ( bytes ( x ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Advances to next line .<CODESPLIT>def advance_one_line ( self ) : current_line = self . _current_token . line_number while current_line == self . _current_token . line_number : self . _current_token = ConfigParser . Token ( * next ( self . _token_generator ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the indices of the lexicographical sorting order of the supplied arrays .<CODESPLIT>def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to bytes .<CODESPLIT>def to_bytes ( s , encoding = "utf-8" ) : if isinstance ( s , six . binary_type ) : return s if six . PY3 : return bytes ( s , encoding ) return s . encode ( encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets a naive datetime from a datetime .<CODESPLIT>def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , "asdatetime" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform actions before parent main window is closed<CODESPLIT>def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Configure the logging module .<CODESPLIT>def _configure_logger ( ) : if not app . debug : _configure_logger_for_production ( logging . getLogger ( ) ) elif not app . testing : _configure_logger_for_debugging ( logging . getLogger ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect and login to an FTP server and return ftplib . FTP object .<CODESPLIT>def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load a python module from its absolute filesystem path<CODESPLIT>def load_from_file ( module_path ) : from imp import load_module , PY_SOURCE imported = None if module_path : with open ( module_path , 'r' ) as openfile : imported = load_module ( 'mod' , openfile , module_path , ( 'imported' , 'r' , PY_SOURCE ) ) return imported
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to handle what to do when the stop button is pressed<CODESPLIT>def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging  if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Suppress warning about untrusted SSL certificate .<CODESPLIT>def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download file from S3 Bucket<CODESPLIT>def download_file_from_bucket ( self , bucket , file_path , key ) : with open ( file_path , 'wb' ) as data : self . __s3 . download_fileobj ( bucket , key , data ) return file_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper : Creates an array bound<CODESPLIT>def make_bound ( lower , upper , lineno ) : return symbols . BOUND . make_node ( lower , upper , lineno )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print Confirmation Message and Get Y / N response from user .<CODESPLIT>def input_yn ( conf_mess ) : ui_erase_ln ( ) ui_print ( conf_mess ) with term . cbreak ( ) : input_flush ( ) val = input_by_key ( ) return bool ( val . lower ( ) == 'y' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>is_valid_image_extension .<CODESPLIT>def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the signed distance from a mesh to a list of points .<CODESPLIT>def signed_distance ( mesh , points ) : # make sure we have a numpy array points = np . asanyarray ( points , dtype = np . float64 ) # find the closest point on the mesh to the queried points closest , distance , triangle_id = closest_point ( mesh , points ) # we only care about nonzero distances nonzero = distance > tol . merge if not nonzero . any ( ) : return distance inside = mesh . ray . contains_points ( points [ nonzero ] ) sign = ( inside . astype ( int ) * 2 ) - 1 # apply sign to previously computed distance distance [ nonzero ] *= sign return distance
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves the text cursor to given line .<CODESPLIT>def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new image by copying the image on a * color * background .<CODESPLIT>def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( "RGB" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the offset of the current cursor position in rl_line_buffer<CODESPLIT>def rl_get_point ( ) -> int : # pragma: no cover if rl_type == RlType . GNU : return ctypes . c_int . in_dll ( readline_lib , "rl_point" ) . value elif rl_type == RlType . PYREADLINE : return readline . rl . mode . l_buffer . point else : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Paginate queryset .<CODESPLIT>def paginate ( self , request , offset = 0 , limit = None ) : return self . collection . offset ( offset ) . limit ( limit ) , self . collection . count ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>computes factorial of n<CODESPLIT>def computeFactorial ( n ) : sleep_walk ( 10 ) ret = 1 for i in range ( n ) : ret = ret * ( i + 1 ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current time .<CODESPLIT>def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( "%Y-%m-%d %H:%M:%S" ) return datetime . datetime . now ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all versions of req from PyPI .<CODESPLIT>def all_versions ( req ) : import requests url = "https://pypi.python.org/pypi/" + req + "/json" return tuple ( requests . get ( url ) . json ( ) [ "releases" ] . keys ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unified rounding in all python versions .<CODESPLIT>def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a sentence into list of words .<CODESPLIT>def split_into_words ( s ) : s = re . sub ( r"\W+" , " " , s ) s = re . sub ( r"[_0-9]+" , " " , s ) return s . split ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes dict keys which have have self as value .<CODESPLIT>def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether * obj * is iterable lazily such as generators range objects etc .<CODESPLIT>def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Last modified timestamp as a UTC datetime<CODESPLIT>def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .<CODESPLIT>def yaml_to_param ( obj , name ) : return from_pyvalue ( u"yaml:%s" % name , unicode ( yaml . dump ( obj ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encode a python boolean ( True / False ) .<CODESPLIT>def _encode_bool ( name , value , dummy0 , dummy1 ) : return b"\x08" + name + ( value and b"\x01" or b"\x00" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts an RGB image to grayscale using matlab s algorithm .<CODESPLIT>def rgb2gray ( img ) : T = np . linalg . inv ( np . array ( [ [ 1.0 , 0.956 , 0.621 ] , [ 1.0 , - 0.272 , - 0.647 ] , [ 1.0 , - 1.106 , 1.703 ] , ] ) ) r_c , g_c , b_c = T [ 0 ] r , g , b = np . rollaxis ( as_float_image ( img ) , axis = - 1 ) return r_c * r + g_c * g + b_c * b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes average length of words<CODESPLIT>def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Manufacture decorator that filters return value with given function .<CODESPLIT>def apply ( filter ) : def decorator ( callable ) : return lambda * args , * * kwargs : filter ( callable ( * args , * * kwargs ) ) return decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scale a single point<CODESPLIT>def _scaleSinglePoint ( point , scale = 1 , convertToInteger = True ) : x , y = point if convertToInteger : return int ( round ( x * scale ) ) , int ( round ( y * scale ) ) else : return ( x * scale , y * scale )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a user has a given permission .<CODESPLIT>def has_permission ( user , permission_name ) : if user and user . is_superuser : return True return permission_name in available_perm_names ( user )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the value of an attribute .<CODESPLIT>def set_attr ( self , name , value ) : self . exec_script ( "node.setAttribute(%s, %s)" % ( repr ( name ) , repr ( value ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print format some XML so it s readable .<CODESPLIT>def pp_xml ( body ) : pretty = xml . dom . minidom . parseString ( body ) return pretty . toprettyxml ( indent = "  " )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lock connection from being used else where<CODESPLIT>def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>numpy . ndarray dumper .<CODESPLIT>def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { "$" + class_name : self . _json_convert ( obj . tolist ( ) ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>We have a full length slice .<CODESPLIT>def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pops the top frame off the frame stack .<CODESPLIT>def __pop_top_frame ( self ) : popped = self . __stack . pop ( ) if self . __stack : self . __stack [ - 1 ] . process_subframe ( popped )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of unique items ( similar to set functionality ) .<CODESPLIT>def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into a list of tokens .<CODESPLIT>def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \t' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an ARF timestamp to a datetime . datetime object ( naive local time )<CODESPLIT>def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sort a list of files by filename only ignoring the directory names<CODESPLIT>def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like xdo_get_focused_window but return the first ancestor - or - self window * having a property of WM_CLASS . This allows you to get the real or top - level - ish window having focus rather than something you may not expect to be the window having focused .<CODESPLIT>def get_focused_window_sane ( self ) : window_ret = window_t ( 0 ) _libxdo . xdo_get_focused_window_sane ( self . _xdo , ctypes . byref ( window_ret ) ) return window_ret . value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a string and dictionary . replaces all occurrences of i with j<CODESPLIT>def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>date to unix timestamp in milliseconds<CODESPLIT>def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get zero - indexed line from an open file - like .<CODESPLIT>def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the device is on .<CODESPLIT>def get_power ( self ) : power = ( yield from self . handle_int ( self . API . get ( 'power' ) ) ) return bool ( power )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the help text ( signature + docstring ) for a command ( function ) .<CODESPLIT>def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\x08' , '' , help_text ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This will equal 124 for the V1 database .<CODESPLIT>def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of indexes of substr . If substr not found list is empty .<CODESPLIT>def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if value is a valid UUID .<CODESPLIT>def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates data is a timestamp<CODESPLIT>def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list and returns the median .<CODESPLIT>def median ( ls ) : ls = sorted ( ls ) return ls [ int ( floor ( len ( ls ) / 2.0 ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of string names of all available GPUs<CODESPLIT>def get_available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the class is a date type .<CODESPLIT>def is_date_type ( cls ) : if not isinstance ( cls , type ) : return False return issubclass ( cls , date ) and not issubclass ( cls , datetime )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unified rounding in all python versions .<CODESPLIT>def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file or directory is world writable .<CODESPLIT>def is_writable_by_others ( filename ) : mode = os . stat ( filename ) [ stat . ST_MODE ] return mode & stat . S_IWOTH
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display all available logging information .<CODESPLIT>def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reload the cached localzone . You need to call this if the timezone has changed .<CODESPLIT>def reload_localzone ( ) : global _cache_tz _cache_tz = pytz . timezone ( get_localzone_name ( ) ) utils . assert_tz_offset ( _cache_tz ) return _cache_tz
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start web application<CODESPLIT>def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If Python 2 replace non - ascii characters and return encoded string .<CODESPLIT>def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\u2019' , "'" ) return uni . encode ( 'utf-8' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a single boolean for arg1 == arg2 even for numpy arrays using element - wise comparison .<CODESPLIT>def all_equal ( arg1 , arg2 ) : if all ( hasattr ( el , '_infinitely_iterable' ) for el in [ arg1 , arg2 ] ) : return arg1 == arg2 try : return all ( a1 == a2 for a1 , a2 in zip ( arg1 , arg2 ) ) except TypeError : return arg1 == arg2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>str to bytes ( py3k )<CODESPLIT>def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts protobuf message to a JSON dictionary .<CODESPLIT>def MessageToDict ( message , including_default_value_fields = False , preserving_proto_field_name = False ) : printer = _Printer ( including_default_value_fields , preserving_proto_field_name ) # pylint: disable=protected-access return printer . _MessageToJsonObject ( message )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pre - order depth - first<CODESPLIT>def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string containing the type and text of the exception .<CODESPLIT>def format_exception ( e ) : from . utils . printing import fill return '\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file is a regular file and is readable .<CODESPLIT>def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set colouring on if STDOUT is a terminal device off otherwise<CODESPLIT>def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Weeks start are fixes at Monday for now .<CODESPLIT>def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if a matrix is approximately orthogonal .<CODESPLIT>def is_orthogonal ( matrix : np . ndarray , * , rtol : float = 1e-5 , atol : float = 1e-8 ) -> bool : return ( matrix . shape [ 0 ] == matrix . shape [ 1 ] and np . all ( np . imag ( matrix ) == 0 ) and np . allclose ( matrix . dot ( matrix . T ) , np . eye ( matrix . shape [ 0 ] ) , rtol = rtol , atol = atol ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a menu entry .<CODESPLIT>def add ( self , name , desc , func = None , args = None , krgs = None ) : self . entries . append ( MenuEntry ( name , desc , func , args or [ ] , krgs or { } ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a datetime object from an isoformat string .<CODESPLIT>def datetime_from_isoformat ( value : str ) : if sys . version_info >= ( 3 , 7 ) : return datetime . fromisoformat ( value ) return datetime . strptime ( value , '%Y-%m-%dT%H:%M:%S.%f' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retries the passed function 3 times before failing<CODESPLIT>def retry_test ( func ) : success = False ex = Exception ( "Unknown" ) for i in six . moves . range ( 3 ) : try : result = func ( ) except Exception as e : time . sleep ( 1 ) ex = e else : success = True break if not success : raise ex assert success return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set y - axis limits of a subplot .<CODESPLIT>def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update only one property in the dict<CODESPLIT>def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download the page into a string<CODESPLIT>def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms an XML string it to python - zimbra dict format<CODESPLIT>def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last weekday in a given month . e . g :<CODESPLIT>def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if arguments are str type .<CODESPLIT>def str_check ( * args , func = None ) : func = func or inspect . stack ( ) [ 2 ] [ 3 ] for var in args : if not isinstance ( var , ( str , collections . UserString , collections . abc . Sequence ) ) : name = type ( var ) . __name__ raise StringError ( f'Function {func} expected str, {name} got instead.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Returns all local minima from an image . Parameters ---------- img : array_like The image . min_distance : integer The minimal distance between the minimas in voxels . If it is less only the lower minima is returned . Returns ------- indices : sequence List of all minima indices . values : sequence List of all minima values .<CODESPLIT>def local_minima ( img , min_distance = 4 ) : # @TODO: Write a unittest for this. fits = numpy . asarray ( img ) minfits = minimum_filter ( fits , size = min_distance ) # default mode is reflect minima_mask = fits == minfits good_indices = numpy . transpose ( minima_mask . nonzero ( ) ) good_fits = fits [ minima_mask ] order = good_fits . argsort ( ) return good_indices [ order ] , good_fits [ order ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display Bloch sphere and corresponding data sets .<CODESPLIT>def show ( self , title = '' ) : self . render ( title = title ) if self . fig : plt . show ( self . fig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the archive .<CODESPLIT>def extract ( self , destination ) : with zipfile . ZipFile ( self . archive , 'r' ) as zip_ref : zip_ref . extractall ( destination )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a given file is available in the cache or not<CODESPLIT>def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object<CODESPLIT>def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( "." ) dt = datetime . strptime ( dt , "%Y-%m-%dT%H:%M:%S" ) return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unlink the file handler association .<CODESPLIT>def remove_all_handler ( self ) : for handler in self . logger . handlers [ : ] : self . logger . removeHandler ( handler ) self . _handler_cache . append ( handler )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit this application<CODESPLIT>def do_quit ( self , _ : argparse . Namespace ) -> bool : self . _should_quit = True return self . _STOP_AND_EXIT
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shutdown the service with a reason .<CODESPLIT>def stop ( self , reason = None ) : self . logger . info ( 'stopping' ) self . loop . stop ( pyev . EVBREAK_ALL )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get distance between pairs of lat - lon points<CODESPLIT>def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decision Tree<CODESPLIT>def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple method for handling exceptions raised by PyBankID .<CODESPLIT>def handle_exception ( error ) : response = jsonify ( error . to_dict ( ) ) response . status_code = error . status_code return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Qt slot when the window is closed .<CODESPLIT>def closeEvent ( self , e ) : self . emit ( 'close_widget' ) super ( DockWidget , self ) . closeEvent ( e )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Index of the last occurrence of x in the sequence .<CODESPLIT>def _rindex ( mylist : Sequence [ T ] , x : T ) -> int : return len ( mylist ) - mylist [ : : - 1 ] . index ( x ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return lines of a file with whitespace removed<CODESPLIT>def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( "Could not open file: {!r}" . format ( filename ) ) return [ line . strip ( ) for line in lines ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .<CODESPLIT>def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recursively find size of a tree . Slow .<CODESPLIT>def size ( self ) : if self is NULL : return 0 return 1 + self . left . size ( ) + self . right . size ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For Python3 compatibility of generator .<CODESPLIT>def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the table names in the database .<CODESPLIT>def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( "SELECT name FROM sqlite_master WHERE type == 'table'" ) return [ name for ( name , ) in cursor ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: rtype : bool<CODESPLIT>def is_all_field_none ( self ) : if self . _type_ is not None : return False if self . _value is not None : return False if self . _name is not None : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return random lognormal variates .<CODESPLIT>def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check features data are not empty<CODESPLIT>def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a bool from a string .<CODESPLIT>def FromString ( self , string ) : if string . lower ( ) in ( "false" , "no" , "n" ) : return False if string . lower ( ) in ( "true" , "yes" , "y" ) : return True raise TypeValueError ( "%s is not recognized as a boolean value." % string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Overloads iter ( condition ) and also for bit in condition . The values yielded by the iterator are True ( 1 ) False ( 0 ) or None ( # ) .<CODESPLIT>def __iter__ ( self ) : for bit , mask in zip ( self . _bits , self . _mask ) : yield bit if mask else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple of ( start end ) indices of an item from its index .<CODESPLIT>def _get_item_position ( self , idx ) : start = 0 if idx == 0 else self . _index [ idx - 1 ] + 1 end = self . _index [ idx ] return start , end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check to see if we are colliding with the player .<CODESPLIT>def check_player_collision ( self ) : player_tiles = r . TileMapManager . active_map . grab_collisions ( self . char . coords ) enemy_tiles = r . TileMapManager . active_map . grab_collisions ( self . coords ) #Check to see if any of the tiles are the same. If so, there is a collision. for ptile in player_tiles : for etile in enemy_tiles : if r . TileMapManager . active_map . pixels_to_tiles ( ptile . coords ) == r . TileMapManager . active_map . pixels_to_tiles ( etile . coords ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback for comboboxes : notifies us that a combobox for the given item and column has changed<CODESPLIT>def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function returns a truncated repr () of an object .<CODESPLIT>def _short_repr ( obj ) : stringified = pprint . saferepr ( obj ) if len ( stringified ) > 200 : return '%s... (%d bytes)' % ( stringified [ : 200 ] , len ( stringified ) ) return stringified
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates text font color button<CODESPLIT>def _update_fontcolor ( self , fontcolor ) : textcolor = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_WINDOWTEXT ) textcolor . SetRGB ( fontcolor ) self . textcolor_choice . SetColour ( textcolor )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Declares that the double can only be called with the provided arguments .<CODESPLIT>def with_args ( self , * args , * * kwargs ) : self . args = args self . kwargs = kwargs self . verify_arguments ( ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for iterating numpy array<CODESPLIT>def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ "refs_ok" ] ) : c = a . item ( ) if c is not None : yield c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare two strings while protecting against timing attacks<CODESPLIT>def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .<CODESPLIT>def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the keys that maps to the top n max values in the given dict .<CODESPLIT>def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to divide two numbers<CODESPLIT>def generic_div ( a , b ) : logger . debug ( 'Called generic_div({}, {})' . format ( a , b ) ) return a / b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out a neat targets dependency tree based on requested targets .<CODESPLIT>def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert the table to a structured NumPy array .<CODESPLIT>def to_array ( self ) : dt = np . dtype ( list ( zip ( self . labels , ( c . dtype for c in self . columns ) ) ) ) arr = np . empty_like ( self . columns [ 0 ] , dt ) for label in self . labels : arr [ label ] = self [ label ] return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the path to the virtualenv python<CODESPLIT>def get_python ( ) : if sys . platform == 'win32' : python = path . join ( VE_ROOT , 'Scripts' , 'python.exe' ) else : python = path . join ( VE_ROOT , 'bin' , 'python' ) return python
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write file with current process ID .<CODESPLIT>def _write_pidfile ( pidfile ) : pid = str ( os . getpid ( ) ) handle = open ( pidfile , 'w' ) try : handle . write ( "%s\n" % pid ) finally : handle . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For every key value pair return the mapping for the equivalent value key pair<CODESPLIT>def reverse_mapping ( mapping ) : keys , values = zip ( * mapping . items ( ) ) return dict ( zip ( values , keys ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a symbolic link<CODESPLIT>def symlink ( source , destination ) : log ( "Symlinking {} as {}" . format ( source , destination ) ) cmd = [ 'ln' , '-sf' , source , destination , ] subprocess . check_call ( cmd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given type is an enum type .<CODESPLIT>def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is an integer number .<CODESPLIT>def is_integer ( value : Any ) -> bool : return ( isinstance ( value , int ) and not isinstance ( value , bool ) ) or ( isinstance ( value , float ) and isfinite ( value ) and int ( value ) == value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generalised logarithm<CODESPLIT>def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a str if a bytes object is given .<CODESPLIT>def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns A and B in y = Ax^B http : // mathworld . wolfram . com / LeastSquaresFittingPowerLaw . html<CODESPLIT>def plfit_lsq ( x , y ) : n = len ( x ) btop = n * ( log ( x ) * log ( y ) ) . sum ( ) - ( log ( x ) ) . sum ( ) * ( log ( y ) ) . sum ( ) bbottom = n * ( log ( x ) ** 2 ) . sum ( ) - ( log ( x ) . sum ( ) ) ** 2 b = btop / bbottom a = ( log ( y ) . sum ( ) - b * log ( x ) . sum ( ) ) / n A = exp ( a ) return A , b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if arg is a valid file that already exists on the file system .<CODESPLIT>def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( "The file %s does not exist!" % arg ) else : return arg
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create the file with the given content<CODESPLIT>def write_file ( filename , content ) : print 'Generating {0}' . format ( filename ) with open ( filename , 'wb' ) as out_f : out_f . write ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .<CODESPLIT>def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .<CODESPLIT>def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove unsafe unicode characters from a piece of text .<CODESPLIT>def remove_unsafe_chars ( text ) : if isinstance ( text , six . string_types ) : text = UNSAFE_RE . sub ( '' , text ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}<CODESPLIT>def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test whether text contains string or matches regex .<CODESPLIT>def ismatch ( text , pattern ) : if hasattr ( pattern , 'search' ) : return pattern . search ( text ) is not None else : return pattern in text if Config . options . case_sensitive else pattern . lower ( ) in text . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generate a lower - cased camelCase string from an underscore_string . For example : my_variable_name - > myVariableName<CODESPLIT>def lower_camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = components [ 0 ] for component in components [ 1 : ] : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace any non - word characters with a dash .<CODESPLIT>def dashrepl ( value ) : patt = re . compile ( r'\W' , re . UNICODE ) return re . sub ( patt , '-' , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the KL projection on the row constrints<CODESPLIT>def projR ( gamma , p ) : return np . multiply ( gamma . T , p / np . maximum ( np . sum ( gamma , axis = 1 ) , 1e-10 ) ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the type for the requested function<CODESPLIT>def get_function_class ( function_name ) : if function_name in _known_functions : return _known_functions [ function_name ] else : raise UnknownFunction ( "Function %s is not known. Known functions are: %s" % ( function_name , "," . join ( _known_functions . keys ( ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tries to encode images with ffmpeg to check if it works .<CODESPLIT>def ffmpeg_works ( ) : images = np . zeros ( ( 2 , 32 , 32 , 3 ) , dtype = np . uint8 ) try : _encode_gif ( images , 2 ) return True except ( IOError , OSError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A quick and dirty way to get a unique string<CODESPLIT>def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .<CODESPLIT>def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove resource instance from internal cache<CODESPLIT>def __delitem__ ( self , resource ) : self . __caches [ type ( resource ) ] . pop ( resource . get_cache_internal_key ( ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a unique ( within the graph ) identifer internal to graph generation .<CODESPLIT>def _unique_id ( self , prefix ) : _id = self . _id_gen self . _id_gen += 1 return prefix + str ( _id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the nth value of array<CODESPLIT>def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function that reads a local file and generates a SHA256 hash digest for it<CODESPLIT>def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserialize b ( instance of bytes ) to a Python object .<CODESPLIT>def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .<CODESPLIT>def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( "to_dataframe requires the optional dependency Pandas." ) return pd . DataFrame . from_dict ( products , orient = 'index' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>average of the values must have more than 0 entries .<CODESPLIT>def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( "ERROR: no content in array to take average\n" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the filename exists under the path .<CODESPLIT>def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple of strings that match the regular expression pattern .<CODESPLIT>def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Case in - sensitive comparison of two strings . Required arguments : * first - The first string to compare . * second - The second string to compare .<CODESPLIT>def compare ( self , first , second ) : if first . lower ( ) == second . lower ( ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a read_range primitive<CODESPLIT>def add_range ( self , sequence , begin , end ) : sequence . parser_tree = parsing . Range ( self . value ( begin ) . strip ( "'" ) , self . value ( end ) . strip ( "'" ) ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the class is a date type .<CODESPLIT>def is_date_type ( cls ) : if not isinstance ( cls , type ) : return False return issubclass ( cls , date ) and not issubclass ( cls , datetime )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the SSE to the cluster center<CODESPLIT>def _cal_dist2center ( X , center ) : dmemb2cen = scipy . spatial . distance . cdist ( X , center . reshape ( 1 , X . shape [ 1 ] ) , metric = 'seuclidean' ) return ( np . sum ( dmemb2cen ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the index of the parent for a given index of the child . Unfortunately the name of the method has to be parent even though a more verbose name like parentIndex would avoid confusion about what parent actually is - an index or an item .<CODESPLIT>def parent ( self , index ) : childItem = self . item ( index ) parentItem = childItem . parent if parentItem == self . rootItem : parentIndex = QModelIndex ( ) else : parentIndex = self . createIndex ( parentItem . row ( ) , 0 , parentItem ) return parentIndex
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redirect stdout back to the original stdout .<CODESPLIT>def __exit__ ( self , * args ) : sys . stdout = self . _orig self . _devnull . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pyglet specific mouse motion callback . Forwards and traslates the event to the example<CODESPLIT>def on_mouse_motion ( self , x , y , dx , dy ) : # Screen coordinates relative to the lower-left corner  # so we have to flip the y axis to make this consistent with  # other window libraries  self . example . mouse_position_event ( x , self . buffer_height - y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if given string is a punctuation<CODESPLIT>def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the given code line by line with printing as list of lines and return variable ans .<CODESPLIT>def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Re - raises the error that was processed by prepare_for_reraise earlier .<CODESPLIT>def reraise ( error ) : if hasattr ( error , "_type_" ) : six . reraise ( type ( error ) , error , error . _traceback ) raise error
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Setup the RAM buffer from the C ++ code .<CODESPLIT>def _ram_buffer ( self ) : # get the address of the RAM address = _LIB . Memory ( self . _env ) # create a buffer from the contents of the address location buffer_ = ctypes . cast ( address , ctypes . POINTER ( RAM_VECTOR ) ) . contents # create a NumPy array from the buffer return np . frombuffer ( buffer_ , dtype = 'uint8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert a timedelta to seconds .<CODESPLIT>def total_seconds ( td ) : secs = td . seconds + td . days * 24 * 3600 if td . microseconds : secs += 1 return secs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the ROI model to a FITS file .<CODESPLIT>def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string with terminal colors .<CODESPLIT>def stringc ( text , color ) : if has_colors : text = str ( text ) return "\033[" + codeCodes [ color ] + "m" + text + "\033[0m" else : return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to read bytes until a certain end byte is hit<CODESPLIT>def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates a rough guess of runtime based on product of parameters<CODESPLIT>def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .<CODESPLIT>def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops iterating before yielding the specified idx .<CODESPLIT>def stop_at ( iterable , idx ) : for i , item in enumerate ( iterable ) : if i == idx : return yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pops a serialized attribute container from the list .<CODESPLIT>def PopAttributeContainer ( self ) : try : serialized_data = self . _list . pop ( 0 ) self . data_size -= len ( serialized_data ) return serialized_data except IndexError : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a dictionary of arguments including __argv into a list for passing to the function .<CODESPLIT>def _correct_args ( func , kwargs ) : args = inspect . getargspec ( func ) [ 0 ] return [ kwargs [ arg ] for arg in args ] + kwargs [ '__args' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints the top row of a table<CODESPLIT>def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the caption_found and plot_found variables to False .<CODESPLIT>def prepare ( doc ) : doc . caption_found = False doc . plot_found = False doc . listings_counter = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads the images and latent values into Numpy arrays .<CODESPLIT>def _load_data ( filepath ) : with h5py . File ( filepath , "r" ) as h5dataset : image_array = np . array ( h5dataset [ "images" ] ) # The 'label' data set in the hdf5 file actually contains the float values # and not the class labels. values_array = np . array ( h5dataset [ "labels" ] ) return image_array , values_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a string from a file - like object .<CODESPLIT>def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The full remote import path as used in import statements in . go source files .<CODESPLIT>def import_path ( self ) : return os . path . join ( self . remote_root , self . pkg ) if self . pkg else self . remote_root
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove key from dict .<CODESPLIT>def __delitem__ ( self , key ) : self . _keys . remove ( key ) super ( ListDict , self ) . __delitem__ ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def is_alive ( self ) : try : self . wait ( 0 ) except WindowsError : e = sys . exc_info ( ) [ 1 ] return e . winerror == win32 . WAIT_TIMEOUT return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will make any functions return an iterable objects by wrapping its result in a list .<CODESPLIT>def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dict . update but which merges child dicts ( dict2 takes precedence where there s conflict ) .<CODESPLIT>def recursively_update ( d , d2 ) : for k , v in d2 . items ( ) : if k in d : if isinstance ( v , dict ) : recursively_update ( d [ k ] , v ) continue d [ k ] = v
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detokenize a string by removing spaces before punctuation .<CODESPLIT>def detokenize ( s ) : print ( s ) s = re . sub ( "\s+([;:,\.\?!])" , "\\1" , s ) s = re . sub ( "\s+(n't)" , "\\1" , s ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Code due to Thomas Heller - published in Python Cookbook ( O Reilley )<CODESPLIT>def debug_on_error ( type , value , tb ) : traceback . print_exc ( type , value , tb ) print ( ) pdb . pm ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets cursor as beginning of next line .<CODESPLIT>def step_next_line ( self ) : self . _eol . append ( self . position ) self . _lineno += 1 self . _col_offset = 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Any normal python logic which runs a loop . Can take arguments .<CODESPLIT>def main ( idle ) : while True : LOG . debug ( "Sleeping for {0} seconds." . format ( idle ) ) time . sleep ( idle )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts all strings in a column to uppercase .<CODESPLIT>def str_upper ( x ) : sl = _to_string_sequence ( x ) . upper ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return IPython s guess for the default encoding for bytes as text .<CODESPLIT>def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wraps the dispatch method to add session support .<CODESPLIT>def dispatch ( self ) : try : webapp2 . RequestHandler . dispatch ( self ) finally : self . session_store . save_sessions ( self . response )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if we are on a Lyon machine<CODESPLIT>def we_are_in_lyon ( ) : import socket try : hostname = socket . gethostname ( ) ip = socket . gethostbyname ( hostname ) except socket . gaierror : return False return ip . startswith ( "134.158." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the i - th unfolding of a tensor .<CODESPLIT>def unfolding ( tens , i ) : return reshape ( tens . full ( ) , ( np . prod ( tens . n [ 0 : ( i + 1 ) ] ) , - 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips spaces : param x : : return :<CODESPLIT>def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\t' , b'' ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>updates the query context with this clauses values<CODESPLIT>def update_context ( self , ctx ) : assert isinstance ( ctx , dict ) ctx [ str ( self . context_id ) ] = self . value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the X / Y coordinate limits for the full resulting image<CODESPLIT>def _get_xy_scaling_parameters ( self ) : return self . mx , self . bx , self . my , self . by
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle the mouse move event for a drag operation .<CODESPLIT>def mouseMoveEvent ( self , event ) : self . declaration . mouse_move_event ( event ) super ( QtGraphicsView , self ) . mouseMoveEvent ( event )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all non - printable characters from a text string<CODESPLIT>def clean ( ctx , text ) : text = conversions . to_string ( text , ctx ) return '' . join ( [ c for c in text if ord ( c ) >= 32 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List all available backends .<CODESPLIT>def list_backends ( _ ) : backends = [ b . __name__ for b in available_backends ( ) ] print ( '\n' . join ( backends ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the average price between two asset states .<CODESPLIT>def average_price ( quantity_1 , price_1 , quantity_2 , price_2 ) : return ( quantity_1 * price_1 + quantity_2 * price_2 ) / ( quantity_1 + quantity_2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the scroll region on the canvas<CODESPLIT>def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare two strings while protecting against timing attacks<CODESPLIT>def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JSSObject for the element with ID id_<CODESPLIT>def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get domain part of an url .<CODESPLIT>def get_domain ( url ) : parse_result = urlparse ( url ) domain = "{schema}://{netloc}" . format ( schema = parse_result . scheme , netloc = parse_result . netloc ) return domain
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return :<CODESPLIT>def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>filter to keep bolts<CODESPLIT>def filter_bolts ( table , header ) : bolts_info = [ ] for row in table : if row [ 0 ] == 'bolt' : bolts_info . append ( row ) return bolts_info , header
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate an empty texture in OpenGL<CODESPLIT>def _genTex2D ( self ) : for face in range ( 6 ) : gl . glTexImage2D ( self . target0 + face , 0 , self . internal_fmt , self . width , self . height , 0 , self . pixel_fmt , gl . GL_UNSIGNED_BYTE , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all rows from a cursor as a dict .<CODESPLIT>def _dictfetchall ( self , cursor ) : columns = [ col [ 0 ] for col in cursor . description ] return [ dict ( zip ( columns , row ) ) for row in cursor . fetchall ( ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cast DataArrays to np . float64 if they are of type np . float32 .<CODESPLIT>def _maybe_cast_to_float64 ( da ) : if da . dtype == np . float32 : logging . warning ( 'Datapoints were stored using the np.float32 datatype.' 'For accurate reduction operations using bottleneck, ' 'datapoints are being cast to the np.float64 datatype.' ' For more information see: https://github.com/pydata/' 'xarray/issues/1346' ) return da . astype ( np . float64 ) else : return da
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the filename exists under the path .<CODESPLIT>def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns current time as ISO8601 formatted string in the Zulu TZ<CODESPLIT>def current_timestamp ( ) : now = datetime . utcnow ( ) timestamp = now . isoformat ( ) [ 0 : 19 ] + 'Z' debug ( "generated timestamp: {now}" . format ( now = timestamp ) ) return timestamp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of indexes of substr . If substr not found list is empty .<CODESPLIT>def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Drops all of the worker output collections Args : None Returns : Nothing<CODESPLIT>def clear_worker_output ( self ) : self . data_store . clear_worker_output ( ) # Have the plugin manager reload all the plugins self . plugin_manager . load_all_plugins ( ) # Store information about commands and workbench self . _store_information ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove files specified multiple times in a list .<CODESPLIT>def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ "path" ] not in seen : out . append ( x ) seen . add ( x [ "path" ] ) return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check different items in matrix classes .<CODESPLIT>def class_check ( vector ) : for i in vector : if not isinstance ( i , type ( vector [ 0 ] ) ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the result of a number raised to a power<CODESPLIT>def _power ( ctx , number , power ) : return decimal_pow ( conversions . to_decimal ( number , ctx ) , conversions . to_decimal ( power , ctx ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data .<CODESPLIT>def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .<CODESPLIT>def restart ( self , reset = False ) : # Get start path to use in restart script  spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started  # Note: Variables defined in bootstrap.py and spyder/app/start.py  env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder  pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py  if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess  env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS  if os . name == 'nt' : # Hide flashing command prompt  startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '"{0}" "{1}"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and  # the error can be inspected in the internal console  print ( error ) # spyder: test-skip  print ( command )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an int of form yyyymmdd to a python date object .<CODESPLIT>def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute init tasks for all components ( virtualenv pip ) .<CODESPLIT>def init ( ) : print ( yellow ( "# Setting up environment...\n" , True ) ) virtualenv . init ( ) virtualenv . update_requirements ( ) print ( green ( "\n# DONE." , True ) ) print ( green ( "Type " ) + green ( "activate" , True ) + green ( " to enable your virtual environment." ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip SGML / XML tags and replace adjacent whitespace by one space .<CODESPLIT>def do_striptags ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return Markup ( unicode ( value ) ) . striptags ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a modified list containing only the indices indicated .<CODESPLIT>def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize a sequence of Python objects into a YAML stream . Produce only basic YAML tags . If stream is None return the produced string instead .<CODESPLIT>def safe_dump_all ( documents , stream = None , * * kwds ) : return dump_all ( documents , stream , Dumper = SafeDumper , * * kwds )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] .<CODESPLIT>def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Universal indexing for numpy and pandas objects .<CODESPLIT>def idx ( df , index ) : if isinstance ( df , ( pd . DataFrame , pd . Series ) ) : return df . iloc [ index ] else : return df [ index , : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch an image from url and convert it into a Pillow Image object<CODESPLIT>def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add arrow to plot<CODESPLIT>def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts list to string with comma separated values . For string is no - op .<CODESPLIT>def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = "," . join ( value ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sends Modify_DNS_Record request<CODESPLIT>def _request_modify_dns_record ( self , record ) : return self . _request_internal ( "Modify_DNS_Record" , domain = self . domain , record = record )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hacked run function which installs the trace .<CODESPLIT>def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return indices of inputs to the node with the given index .<CODESPLIT>def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return type depend from both operand of the binary operation .<CODESPLIT>def visit_BinOp ( self , node ) : args = [ self . visit ( arg ) for arg in ( node . left , node . right ) ] return list ( { frozenset . union ( * x ) for x in itertools . product ( * args ) } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split text into list of sentences .<CODESPLIT>def split_into_sentences ( s ) : s = re . sub ( r"\s+" , " " , s ) s = re . sub ( r"[\\.\\?\\!]" , "\n" , s ) return s . split ( "\n" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close our socket .<CODESPLIT>def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data .<CODESPLIT>def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Match two names .<CODESPLIT>def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resets the iterator to the start .<CODESPLIT>def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given object conforms to the Serializable protocol .<CODESPLIT>def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Circular standard deviation<CODESPLIT>def circstd ( dts , axis = 2 ) : R = np . abs ( np . exp ( 1.0j * dts ) . mean ( axis = axis ) ) return np . sqrt ( - 2.0 * np . log ( R ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a 2D numpy array of bools<CODESPLIT>def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a Qt application .<CODESPLIT>def create_app ( ) : global QT_APP QT_APP = QApplication . instance ( ) if QT_APP is None : # pragma: no cover QT_APP = QApplication ( sys . argv ) return QT_APP
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the absolute position of table top<CODESPLIT>def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( "pos" ) ) + table_height
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes the session to the database .<CODESPLIT>def unlock ( self ) : if not hasattr ( self , 'session' ) : raise RuntimeError ( 'Error detected! The session that you want to close does not exist any more!' ) logger . debug ( "Closed database session of '%s'" % self . _database ) self . session . close ( ) del self . session
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforma una string con elementos separados por sep en una lista .<CODESPLIT>def string_to_list ( string , sep = "," , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check element for required attributes . Raise NotValidXmlException on error .<CODESPLIT>def required_attributes ( element , * attributes ) : if not reduce ( lambda still_valid , param : still_valid and param in element . attrib , attributes , True ) : raise NotValidXmlException ( msg_err_missing_attributes ( element . tag , * attributes ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize Flask application .<CODESPLIT>def init_app ( self , app ) : app . config . from_pyfile ( '{0}.cfg' . format ( app . name ) , silent = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the index of the earliest occurence of an item from a list in a string<CODESPLIT>def find_first_in_list ( txt : str , str_list : [ str ] ) -> int : # type: ignore start = len ( txt ) + 1 for item in str_list : if start > txt . find ( item ) > - 1 : start = txt . find ( item ) return start if len ( txt ) + 1 > start > - 1 else - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the delay<CODESPLIT>def calculate_delay ( original , delay ) : original = datetime . strptime ( original , '%H:%M' ) delayed = datetime . strptime ( delay , '%H:%M' ) diff = delayed - original return diff . total_seconds ( ) // 60
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display both SQLAlchemy and Python help statements<CODESPLIT>def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reads the zip file determines compression and unzips recursively until source files are extracted<CODESPLIT>def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get width and height of a PDF<CODESPLIT>def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add suffix to a full file name<CODESPLIT>def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a decimal price and rounds to a number of decimal places<CODESPLIT>def price_rounding ( price , decimals = 2 ) : try : exponent = D ( '.' + decimals * '0' ) except InvalidOperation : # Currencies with no decimal places, ex. JPY, HUF exponent = D ( ) return price . quantize ( exponent , rounding = ROUND_UP )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the standard error of a .<CODESPLIT>def stderr ( a ) : return np . nanstd ( a ) / np . sqrt ( sum ( np . isfinite ( a ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes average length of words<CODESPLIT>def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate standard deviation weighted by errors<CODESPLIT>def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the path of java executable<CODESPLIT>def get_java_path ( ) : java_home = os . environ . get ( "JAVA_HOME" ) return os . path . join ( java_home , BIN_DIR , "java" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Official way to get the extension of compiled files ( . pyc or . pyo )<CODESPLIT>def _get_compiled_ext ( ) : for ext , mode , typ in imp . get_suffixes ( ) : if typ == imp . PY_COMPILED : return ext
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed<CODESPLIT>def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convolve 2d gaussian .<CODESPLIT>def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a pdf of the current matplotlib figure .<CODESPLIT>def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether this RangeSet contains another set .<CODESPLIT>def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : args ( list | tuple | None ) : Arguments to represent separator ( str | unicode ) : Separator to use<CODESPLIT>def represented_args ( args , separator = " " ) : result = [ ] if args : for text in args : result . append ( quoted ( short ( text ) ) ) return separator . join ( result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a 2D numpy array of bools<CODESPLIT>def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the hash .<CODESPLIT>def get_hash ( self , handle ) : fpath = self . _fpath_from_handle ( handle ) return DiskStorageBroker . hasher ( fpath )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python<CODESPLIT>def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether this is a function parameter .<CODESPLIT>def is_parameter ( self ) : return ( isinstance ( self . scope , CodeFunction ) and self in self . scope . parameters )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Special case of version () when the executable is a JAR file .<CODESPLIT>def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get attribute from the target object<CODESPLIT>def get_attr ( self , method_name ) : return self . attrs . get ( method_name ) or self . get_callable_attr ( method_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the given dictionary symmetric . Values are assumed to be unique .<CODESPLIT>def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Erases n lines from the screen and moves the cursor up to follow<CODESPLIT>def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ "up" ] , end = "" ) print ( codes . cursor [ "eol" ] , end = "" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats a list of elements using the given line style<CODESPLIT>def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserialize s ( a str ) to a Python object .<CODESPLIT>def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if array is an array of real numbers .<CODESPLIT>def contains_all ( self , array ) : dtype = getattr ( array , 'dtype' , None ) if dtype is None : dtype = np . result_type ( * array ) return is_real_dtype ( dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all files in a given directory<CODESPLIT>def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the media - type of the file at the given filepath<CODESPLIT>def guess_media_type ( filepath ) : o = subprocess . check_output ( [ 'file' , '--mime-type' , '-Lb' , filepath ] ) o = o . strip ( ) return o
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes underscores and capitalizes the neighbouring character<CODESPLIT>def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>variance of the values must have 2 or more entries .<CODESPLIT>def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a hdf5 file into a dictionary<CODESPLIT>def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , "r" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test two dictionary is equal on values . ( ignore order )<CODESPLIT>def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a vector randomly within the given rectangle .<CODESPLIT>def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For Python3 compatibility of generator .<CODESPLIT>def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emit a sine wave at the given frequency .<CODESPLIT>def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Qt slot when the window is closed .<CODESPLIT>def closeEvent ( self , e ) : self . emit ( 'close_widget' ) super ( DockWidget , self ) . closeEvent ( e )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the total size of all elements in objects .<CODESPLIT>def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( "IGNORING: type=%s; o=%s" % ( str ( type ( o ) ) , str ( o ) ) ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Nested lists to single - level list does not split strings<CODESPLIT>def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>sample data from given histogram and min max values within range<CODESPLIT>def inverseHistogram ( hist , bin_range ) : data = hist . astype ( float ) / np . min ( hist [ np . nonzero ( hist ) ] ) new_data = np . empty ( shape = np . sum ( data , dtype = int ) ) i = 0 xvals = np . linspace ( bin_range [ 0 ] , bin_range [ 1 ] , len ( data ) ) for d , x in zip ( data , xvals ) : new_data [ i : i + d ] = x i += int ( d ) return new_data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional<CODESPLIT>def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close our socket .<CODESPLIT>def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses the Unix ps program to see if a process is running .<CODESPLIT>def is_running ( process_id : int ) -> bool : pstr = str ( process_id ) encoding = sys . getdefaultencoding ( ) s = subprocess . Popen ( [ "ps" , "-p" , pstr ] , stdout = subprocess . PIPE ) for line in s . stdout : strline = line . decode ( encoding ) if pstr in strline : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Added because the Dropbox OAuth2 flow doesn t work when scope is passed in which is empty .<CODESPLIT>def _strip_empty_keys ( self , params ) : keys = [ k for k , v in params . items ( ) if v == '' ] for key in keys : del params [ key ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a conda environment inside the current sandbox for the given list of dependencies and options .<CODESPLIT>def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ "conda" , "create" , "--yes" , "--copy" , "--quiet" , "-p" , env_dir ] + list ( options ) + dependencies log . info ( "Creating conda environment: " ) log . info ( "  command line: %s" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( "Environment created" ) return env_dir , env_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ctypes int pointer array to a numpy array .<CODESPLIT>def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if filename has changed since the last check . If this is the first check assume the file is changed .<CODESPLIT>def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the tanimoto set similarity .<CODESPLIT>def tanimoto_set_similarity ( x : Iterable [ X ] , y : Iterable [ X ] ) -> float : a , b = set ( x ) , set ( y ) union = a | b if not union : return 0.0 return len ( a & b ) / len ( union )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implements the === operator .<CODESPLIT>def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates converts to a masked array<CODESPLIT>def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return unit sphere coordinates from window coordinates .<CODESPLIT>def arcball_map_to_sphere ( point , center , radius ) : v0 = ( point [ 0 ] - center [ 0 ] ) / radius v1 = ( center [ 1 ] - point [ 1 ] ) / radius n = v0 * v0 + v1 * v1 if n > 1.0 : # position outside of sphere n = math . sqrt ( n ) return numpy . array ( [ v0 / n , v1 / n , 0.0 ] ) else : return numpy . array ( [ v0 , v1 , math . sqrt ( 1.0 - n ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops the playing thread and close<CODESPLIT>def stop ( self ) : with self . lock : self . halting = True self . go . clear ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs the basic endpoint requested<CODESPLIT>def process_request ( self , request , response ) : self . logger . info ( 'Requested: {0} {1} {2}' . format ( request . method , request . relative_uri , request . content_type ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is builtin in python2 but we have to roll our own on py3 .<CODESPLIT>def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the serial port e . g . : / dev / tty . usbserial - A4001ib8<CODESPLIT>def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse an ISO format date ( YYYY - mm - dd ) .<CODESPLIT>def _parse_date ( string : str ) -> datetime . date : return datetime . datetime . strptime ( string , '%Y-%m-%d' ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .<CODESPLIT>def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses given YAML file .<CODESPLIT>def _ParseYamlFromFile ( filedesc ) : content = filedesc . read ( ) return yaml . Parse ( content ) or collections . OrderedDict ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if obj is number .<CODESPLIT>def is_number ( obj ) : return isinstance ( obj , ( int , float , np . int_ , np . float_ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to MySQL with retries .<CODESPLIT>def connect_mysql ( host , port , user , password , database ) : return pymysql . connect ( host = host , port = port , user = user , passwd = password , db = database )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return type may come from any boolop operand .<CODESPLIT>def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A wrapper of os . makedirs () .<CODESPLIT>def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return maximum nesting depth<CODESPLIT>def maxlevel ( lst ) : maxlev = 0 def f ( lst , level ) : nonlocal maxlev if isinstance ( lst , list ) : level += 1 maxlev = max ( level , maxlev ) for item in lst : f ( item , level ) f ( lst , 0 ) return maxlev
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap an item in optional parentheses only applying them if necessary .<CODESPLIT>def maybeparens ( lparen , item , rparen ) : return item | lparen . suppress ( ) + item + rparen . suppress ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rounds float to closest int : rtype : int : param n : float<CODESPLIT>def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def detach_index ( self , name ) : assert type ( name ) == str if name in self . _indexes : del self . _indexes [ name ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download file from http url link<CODESPLIT>def download_file ( save_path , file_url ) : r = requests . get ( file_url ) # create HTTP response object with open ( save_path , 'wb' ) as f : f . write ( r . content ) return save_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the billing cycle prior to this one . May return None<CODESPLIT>def get_previous ( self ) : return BillingCycle . objects . filter ( date_range__lt = self . date_range ) . order_by ( 'date_range' ) . last ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read the long description .<CODESPLIT>def get_long_description ( ) : here = path . abspath ( path . dirname ( __file__ ) ) with open ( path . join ( here , 'README.rst' ) ) as readme : return readme . read ( ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: API : public<CODESPLIT>def assert_list ( self , putative_list , expected_type = string_types , key_arg = None ) : return assert_list ( putative_list , expected_type , key_arg = key_arg , raise_type = lambda msg : TargetDefinitionException ( self , msg ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap an AST Call node to lambda expression node . call : ast . Call node<CODESPLIT>def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Match two names .<CODESPLIT>def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Insert None as value for missing fields .<CODESPLIT>def inject_nulls ( data : Mapping , field_names ) -> dict : record = dict ( ) for field in field_names : record [ field ] = data . get ( field , None ) return record
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the month start date a nd end date<CODESPLIT>def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique items from iterable * seq * ( in order ) .<CODESPLIT>def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add executable permissions to the file<CODESPLIT>def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a absolute path in the file system .<CODESPLIT>def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>search graph for cycle using DFS continuing from node path contains the list of visited nodes currently on the stack visited_nodes is the set of already visited nodes : param graph : : param node : : param path : : param visited_nodes : : return :<CODESPLIT>def _dfs_cycle_detect ( graph , node , path , visited_nodes ) : visited_nodes . add ( node ) for target in graph [ node ] : if target in path : # cycle found => return current path return path + [ target ] else : return _dfs_cycle_detect ( graph , target , path + [ target ] , visited_nodes ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the absolute value of a number .<CODESPLIT>def fn_abs ( self , value ) : if is_ndarray ( value ) : return numpy . absolute ( value ) else : return abs ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write the given colored string to standard out .<CODESPLIT>def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a hash of a NumPy array .<CODESPLIT>def np_hash ( a ) : if a is None : return hash ( None ) # Ensure that hashes are equal whatever the ordering in memory (C or # Fortran) a = np . ascontiguousarray ( a ) # Compute the digest and return a decimal int return int ( hashlib . sha1 ( a . view ( a . dtype ) ) . hexdigest ( ) , 16 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set foreground - and background colors and intensity .<CODESPLIT>def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resets the iterator to the start .<CODESPLIT>def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check for valid instance name<CODESPLIT>def instance_name ( string ) : invalid = ':/@' if set ( string ) . intersection ( invalid ) : msg = 'Invalid instance name {}' . format ( string ) raise argparse . ArgumentTypeError ( msg ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed<CODESPLIT>def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the latest modification time of all files / subdirectories in a directory<CODESPLIT>def dir_modtime ( dpath ) : return max ( os . path . getmtime ( d ) for d , _ , _ in os . walk ( dpath ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize from iterable<CODESPLIT>def fromiterable ( cls , itr ) : x , y , z = itr return cls ( x , y , z )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the clipboard s text on OS X .<CODESPLIT>def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \r line endings. Change them to \n. text = text . replace ( '\r' , '\n' ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a slice from a table column holding arrays . ( see : func : table . getcolslice )<CODESPLIT>def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to remove the links from the input text<CODESPLIT>def remove_links ( text ) : tco_link_regex = re . compile ( "https?://t.co/[A-z0-9].*" ) generic_link_regex = re . compile ( "(https?://)?(\w*[.]\w+)+([/?=&]+\w+)*" ) remove_tco = re . sub ( tco_link_regex , " " , text ) remove_generic = re . sub ( generic_link_regex , " " , remove_tco ) return remove_generic
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts list to string with comma separated values . For string is no - op .<CODESPLIT>def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = "," . join ( value ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simultaneously replace multiple strigns in a string<CODESPLIT>def multiple_replace ( string , replacements ) : # type: (str, Dict[str,str]) -> str pattern = re . compile ( "|" . join ( [ re . escape ( k ) for k in sorted ( replacements , key = len , reverse = True ) ] ) , flags = re . DOTALL ) return pattern . sub ( lambda x : replacements [ x . group ( 0 ) ] , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts Synergy Timestamp for session to UTC zone seconds since epoch<CODESPLIT>def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove ticks tick labels and frame from axis<CODESPLIT>def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function to make a dict from a coordinate for logging<CODESPLIT>def make_coord_dict ( coord ) : return dict ( z = int_if_exact ( coord . zoom ) , x = int_if_exact ( coord . column ) , y = int_if_exact ( coord . row ) , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a ctypes void pointer to the memory mapped region .<CODESPLIT>def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a file safely . If it s not present no - op .<CODESPLIT>def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>area () - > number<CODESPLIT>def area ( self ) : area = 0.0 for segment in self . segments ( ) : area += ( ( segment . p . x * segment . q . y ) - ( segment . q . x * segment . p . y ) ) / 2 return area
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Construct a single page PDF from the provided page in memory<CODESPLIT>def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return evidence codes in order shown in code2name .<CODESPLIT>def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Idempotent and None - safe version of strict_bool .<CODESPLIT>def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable a default web proxy<CODESPLIT>def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the mean and the standard deviation of the given samples .<CODESPLIT>def fit_gaussian ( samples , ddof = 0 ) : if len ( samples . shape ) == 1 : return np . mean ( samples ) , np . std ( samples , ddof = ddof ) return np . mean ( samples , axis = 1 ) , np . std ( samples , axis = 1 , ddof = ddof )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds passed value to node s globals<CODESPLIT>def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the average value of a list of numbers Returns a float<CODESPLIT>def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>One - hot encode labels from input<CODESPLIT>def one_hot_encoding ( input_tensor , num_labels ) : xview = input_tensor . view ( - 1 , 1 ) . to ( torch . long ) onehot = torch . zeros ( xview . size ( 0 ) , num_labels , device = input_tensor . device , dtype = torch . float ) onehot . scatter_ ( 1 , xview , 1 ) return onehot . view ( list ( input_tensor . shape ) + [ - 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This removes newlines and multiple spaces from a string .<CODESPLIT>def normalize_value ( text ) : result = text . replace ( '\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Drops ( deletes ) a column from an existing table .<CODESPLIT>def drop_column ( self , tablename : str , fieldname : str ) -> int : sql = "ALTER TABLE {} DROP COLUMN {}" . format ( tablename , fieldname ) log . info ( sql ) return self . db_exec_literal ( sql )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return peak memory usage in MB<CODESPLIT>def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the screen resolution of the primary screen .<CODESPLIT>def get_screen_resolution ( self ) : widget = QDesktopWidget ( ) geometry = widget . availableGeometry ( widget . primaryScreen ( ) ) return geometry . width ( ) , geometry . height ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract from the given iterable of lines the list of words .<CODESPLIT>def extract_words ( lines ) : for line in lines : for word in re . findall ( r"\w+" , line ) : yield word
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a multiline string into a list excluding blank lines .<CODESPLIT>def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\n' ) ) if element ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to read JSON file as OrderedDict<CODESPLIT>def _read_json_file ( self , json_file ) : self . log . debug ( "Reading '%s' JSON file..." % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return index of sub_string in string .<CODESPLIT>def _find ( string , sub_string , start_index ) : result = string . find ( sub_string , start_index ) if result == - 1 : raise TokenError ( "expected '{0}'" . format ( sub_string ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A Python decorator for printing out the execution time for a function .<CODESPLIT>def timeit ( method ) : def timed ( * args , * * kw ) : time_start = time . time ( ) result = method ( * args , * * kw ) time_end = time . time ( ) print ( 'timeit: %r %2.2f sec (%r, %r) ' % ( method . __name__ , time_end - time_start , str ( args ) [ : 20 ] , kw ) ) return result return timed
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle logging .<CODESPLIT>def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out a neat targets dependency tree based on requested targets .<CODESPLIT>def cmd_dot ( conf : Config ) : build_context = BuildContext ( conf ) populate_targets_graph ( build_context , conf ) if conf . output_dot_file is None : write_dot ( build_context , conf , sys . stdout ) else : with open ( conf . output_dot_file , 'w' ) as out_file : write_dot ( build_context , conf , out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if all sequences in the list have the same length .<CODESPLIT>def are_token_parallel ( sequences : Sequence [ Sized ] ) -> bool : if not sequences or len ( sequences ) == 1 : return True return all ( len ( s ) == len ( sequences [ 0 ] ) for s in sequences )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle interactive exit .<CODESPLIT>def exit ( self ) : if self . confirm_exit : if self . ask_yes_no ( 'Do you really want to exit ([y]/n)?' , 'y' ) : self . ask_exit ( ) else : self . ask_exit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if dtype is a real floating point type .<CODESPLIT>def is_real_floating_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . floating )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Starts the web server .<CODESPLIT>def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set focus to next item in sequence<CODESPLIT>def focusNext ( self , event ) : try : event . widget . tk_focusNext ( ) . focus_set ( ) except TypeError : # see tkinter equivalent code for tk_focusNext to see # commented original version name = event . widget . tk . call ( 'tk_focusNext' , event . widget . _w ) event . widget . _nametowidget ( str ( name ) ) . focus_set ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ctypes float pointer array to a numpy array .<CODESPLIT>def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a list of the top topn features in this : class : . Feature \ .<CODESPLIT>def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerce value to an JSON - compatible representation .<CODESPLIT>def _timestamp_to_json_row ( value ) : if isinstance ( value , datetime . datetime ) : value = _microseconds_from_datetime ( value ) * 1e-6 return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints a human readable version of the filter .<CODESPLIT>def Print ( self , output_writer ) : if self . _filters : output_writer . Write ( 'Filters:\n' ) for file_entry_filter in self . _filters : file_entry_filter . Print ( output_writer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crazy set of hyperparameters to test memory optimizations .<CODESPLIT>def super_lm_tpu_memtest ( ) : hparams = super_lm_base ( ) hparams . num_model_shards = 1 hparams . layers = "ffn," * 8 hparams . hidden_size = 4096 hparams . filter_size = 12000 hparams . batch_size = 512 return hparams
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field is not a member of the given value .<CODESPLIT>def selectnotin ( table , field , value , complement = False ) : return select ( table , field , lambda v : v not in value , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of indexes of substr . If substr not found list is empty .<CODESPLIT>def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate unique document id for ElasticSearch .<CODESPLIT>def generate_id ( self , obj ) : object_type = type ( obj ) . __name__ . lower ( ) return '{}_{}' . format ( object_type , self . get_object_id ( obj ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register a callback to be invoked when a new device appears .<CODESPLIT>def add_device_callback ( self , callback ) : _LOGGER . debug ( 'Added new callback %s ' , callback ) self . _cb_new_device . append ( callback )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserialize s ( a str ) to a Python object .<CODESPLIT>def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return unit sphere coordinates from window coordinates .<CODESPLIT>def arcball_map_to_sphere ( point , center , radius ) : v0 = ( point [ 0 ] - center [ 0 ] ) / radius v1 = ( center [ 1 ] - point [ 1 ] ) / radius n = v0 * v0 + v1 * v1 if n > 1.0 : # position outside of sphere n = math . sqrt ( n ) return numpy . array ( [ v0 / n , v1 / n , 0.0 ] ) else : return numpy . array ( [ v0 , v1 , math . sqrt ( 1.0 - n ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins two dictionaries .<CODESPLIT>def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new Image instance with the given size .<CODESPLIT>def resize ( self , size ) : return Image ( self . pil_image . resize ( size , PIL . Image . ANTIALIAS ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read text from stdin and print a helpful message for ttys .<CODESPLIT>def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Drops the trailinz zeros from decimal value . Returns a string<CODESPLIT>def drop_trailing_zeros_decimal ( num ) : out = str ( num ) return out . rstrip ( '0' ) . rstrip ( '.' ) if '.' in out else out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a ctypes void pointer to the memory mapped region .<CODESPLIT>def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create all your database objects ( SQLAlchemy specific ) .<CODESPLIT>def create_db ( app , appbuilder ) : from flask_appbuilder . models . sqla import Base _appbuilder = import_application ( app , appbuilder ) engine = _appbuilder . get_session . get_bind ( mapper = None , clause = None ) Base . metadata . create_all ( engine ) click . echo ( click . style ( "DB objects created" , fg = "green" ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator to make sure that user is root .<CODESPLIT>def require_root ( fn ) : @ wraps ( fn ) def xex ( * args , * * kwargs ) : assert os . geteuid ( ) == 0 , "You have to be root to run function '%s'." % fn . __name__ return fn ( * args , * * kwargs ) return xex
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If we re not on the first line ( of a multiline input ) go a line up otherwise go back in history . ( If nothing is selected . )<CODESPLIT>def auto_up ( self , count = 1 , go_to_start_of_line_if_history_changes = False ) : if self . complete_state : self . complete_previous ( count = count ) elif self . document . cursor_position_row > 0 : self . cursor_up ( count = count ) elif not self . selection_state : self . history_backward ( count = count ) # Go to the start of the line? if go_to_start_of_line_if_history_changes : self . cursor_position += self . document . get_start_of_line_position ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns this programs current memory usage in bytes<CODESPLIT>def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Go to the end of the current line and create a new line<CODESPLIT>def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Safely convert a single number to integer .<CODESPLIT>def safe_int_conv ( number ) : try : return int ( np . array ( number ) . astype ( int , casting = 'safe' ) ) except TypeError : raise ValueError ( 'cannot safely convert {} to integer' . format ( number ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type<CODESPLIT>def QA_util_datetime_to_strdate ( dt ) : strdate = "%04d-%02d-%02d" % ( dt . year , dt . month , dt . day ) return strdate
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the longest common substring in a list of strings . Credit : http : // stackoverflow . com / questions / 2892931 / longest - common - substring - from - more - than - two - strings - python<CODESPLIT>def long_substr ( data ) : substr = '' if len ( data ) > 1 and len ( data [ 0 ] ) > 0 : for i in range ( len ( data [ 0 ] ) ) : for j in range ( len ( data [ 0 ] ) - i + 1 ) : if j > len ( substr ) and all ( data [ 0 ] [ i : i + j ] in x for x in data ) : substr = data [ 0 ] [ i : i + j ] elif len ( data ) == 1 : substr = data [ 0 ] return substr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the indices of all the val in m<CODESPLIT>def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of all parsed comments in a file . Mostly for testing & interactive use .<CODESPLIT>def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quick way to read a file content .<CODESPLIT>def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Insert a new row in the Series .<CODESPLIT>def _insert_row ( self , i , index ) : if i == len ( self . _index ) : self . _add_row ( index ) else : self . _index . insert ( i , index ) self . _data . insert ( i , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the name of the newest file given an iterable of file names .<CODESPLIT>def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap the text on the given line length .<CODESPLIT>def normalize_text ( text , line_len = 80 , indent = "" ) : return "\n" . join ( textwrap . wrap ( text , width = line_len , initial_indent = indent , subsequent_indent = indent ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the distance between two points coord1 and coord2 . These parameters are assumed to be ( x y ) tuples .<CODESPLIT>def _distance ( coord1 , coord2 ) : xdist = coord1 [ 0 ] - coord2 [ 0 ] ydist = coord1 [ 1 ] - coord2 [ 1 ] return sqrt ( xdist * xdist + ydist * ydist )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def mouse_get_pos ( ) : p = POINT ( ) AUTO_IT . AU3_MouseGetPos ( ctypes . byref ( p ) ) return p . x , p . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :<CODESPLIT>def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( "non-list value found where list is expected" ) return all ( isinstance ( x , str ) for x in arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closest distance between a line segment and a point<CODESPLIT>def distance_to_line ( a , b , p ) : return distance ( closest_point ( a , b , p ) , p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that verify if the header parameter is a essential header<CODESPLIT>def required_header ( header ) : if header in IGNORE_HEADERS : return False if header . startswith ( 'HTTP_' ) or header == 'CONTENT_TYPE' : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempts to retrieve an item from the queue Q . If Q is empty None is returned . Blocks for timeout seconds in case the queue is empty so don t use this method for speedy retrieval of multiple items ( use get_all_from_queue for that ) .<CODESPLIT>def get_item_from_queue ( Q , timeout = 0.01 ) : try : item = Q . get ( True , 0.01 ) except Queue . Empty : return None return item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all unwanted characters from text .<CODESPLIT>def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the key ( aka database value ) of a human key ( aka Python identifier ) .<CODESPLIT>def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns numpy array of natural logarithms of values .<CODESPLIT>def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( "ignore" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Warn if nans exist in a numpy array .<CODESPLIT>def warn_if_nans_exist ( X ) : null_count = count_rows_with_nans ( X ) total = len ( X ) percent = 100 * null_count / total if null_count > 0 : warning_message = 'Warning! Found {} rows of {} ({:0.2f}%) with nan values. Only ' 'complete rows will be plotted.' . format ( null_count , total , percent ) warnings . warn ( warning_message , DataWarning )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If pair is in search_list return the index . Otherwise return - 1<CODESPLIT>def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose the most common item from the list or the first item if all items are unique .<CODESPLIT>def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the md5 hash of the given file - object<CODESPLIT>def md5_hash_file ( fh ) : md5 = hashlib . md5 ( ) while True : data = fh . read ( 8192 ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the dev_info data from a dictionary .<CODESPLIT>def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a temporary filename based on filename .<CODESPLIT>def get_incomplete_path ( filename ) : random_suffix = "" . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) return filename + ".incomplete" + random_suffix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pop the heap value from the heap .<CODESPLIT>def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Random uniform variates .<CODESPLIT>def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks for an empty image .<CODESPLIT>def is_empty ( self ) : if ( ( ( self . channels == [ ] ) and ( not self . shape == ( 0 , 0 ) ) ) or ( ( not self . channels == [ ] ) and ( self . shape == ( 0 , 0 ) ) ) ) : raise RuntimeError ( "Channels-shape mismatch." ) return self . channels == [ ] and self . shape == ( 0 , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove null items from a dictionary<CODESPLIT>def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if val is of integer type .<CODESPLIT>def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>last row or column of square A<CODESPLIT>def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get attribute from the target object<CODESPLIT>def get_attr ( self , method_name ) : return self . attrs . get ( method_name ) or self . get_callable_attr ( method_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simultaneously replace multiple strigns in a string<CODESPLIT>def multiple_replace ( string , replacements ) : # type: (str, Dict[str,str]) -> str pattern = re . compile ( "|" . join ( [ re . escape ( k ) for k in sorted ( replacements , key = len , reverse = True ) ] ) , flags = re . DOTALL ) return pattern . sub ( lambda x : replacements [ x . group ( 0 ) ] , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits a string into parts at multiple characters<CODESPLIT>def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a column of the given matrix .<CODESPLIT>def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if given node is inside lambda<CODESPLIT>def is_inside_lambda ( node : astroid . node_classes . NodeNG ) -> bool : parent = node . parent while parent is not None : if isinstance ( parent , astroid . Lambda ) : return True parent = parent . parent return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Public function that reads a local file and generates a SHA256 hash digest for it<CODESPLIT>def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the updated model to the current entity db .<CODESPLIT>def save ( self ) : self . session . add ( self ) self . session . flush ( ) return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new Vec2 with x and y from vec and multiplied by amount .<CODESPLIT>def scale_v2 ( vec , amount ) : return Vec2 ( vec . x * amount , vec . y * amount )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Refresh the screen . You don t need to override this except to update only small portins of the screen .<CODESPLIT>def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i )))<CODESPLIT>def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read the specified pin and return HIGH / true if the pin is pulled high or LOW / false if pulled low .<CODESPLIT>def input ( self , pin ) : return self . mraa_gpio . Gpio . read ( self . mraa_gpio . Gpio ( pin ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Gets the string representation of the given type .<CODESPLIT>def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shot noise corruption to images .<CODESPLIT>def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if value is an integer .<CODESPLIT>def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Scipy norm function<CODESPLIT>def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerce value to an JSON - compatible representation .<CODESPLIT>def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If file is locked then terminate program else lock file .<CODESPLIT>def assert_lock ( fname ) : if not set_lock ( fname ) : logger . error ( 'File {} is already locked. Terminating.' . format ( fname ) ) sys . exit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the non - sequence features from the provided example .<CODESPLIT>def get_example_features ( example ) : return ( example . features . feature if isinstance ( example , tf . train . Example ) else example . context . feature )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns names of object columns in the DataFrame .<CODESPLIT>def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Are two SQLAlchemy columns are equal? Checks based on :<CODESPLIT>def columns_equal ( a : Column , b : Column ) -> bool : return ( a . name == b . name and column_types_equal ( a . type , b . type ) and a . nullable == b . nullable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the item at the given index .<CODESPLIT>def __getitem__ ( self , index ) : row , col = index return self . rows [ row ] [ col ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes an array add indentation to each entry and prints it .<CODESPLIT>def PrintIndented ( self , file , ident , code ) : for entry in code : print >> file , '%s%s' % ( ident , entry )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the eigvals of mat and then find the center eigval difference .<CODESPLIT>def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JsonResponse . Make sure you have django installed first .<CODESPLIT>def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace any non - word characters with a dash .<CODESPLIT>def dashrepl ( value ) : patt = re . compile ( r'\W' , re . UNICODE ) return re . sub ( patt , '-' , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string representing a numpy array of 0 s and 1 s<CODESPLIT>def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert notebook to python script<CODESPLIT>def nb_to_python ( nb_path ) : exporter = python . PythonExporter ( ) output , resources = exporter . from_filename ( nb_path ) return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a list a certain size<CODESPLIT>def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return physical memory usage ( float ) Requires the cross - platform psutil ( > = v0 . 3 ) library ( https : // github . com / giampaolo / psutil )<CODESPLIT>def psutil_phymem_usage ( ) : import psutil # This is needed to avoid a deprecation warning error with  # newer psutil versions  try : percent = psutil . virtual_memory ( ) . percent except : percent = psutil . phymem_usage ( ) . percent return percent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the process ID that the specified window belongs to<CODESPLIT>def getWindowPID ( self , hwnd ) : pid = ctypes . c_ulong ( ) ctypes . windll . user32 . GetWindowThreadProcessId ( hwnd , ctypes . byref ( pid ) ) return int ( pid . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the prime factor of given integer<CODESPLIT>def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decode ( bytearray raw = False ) - > value<CODESPLIT>def decode ( self , bytes , raw = False ) : return struct . unpack ( self . format , buffer ( bytes ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute Pearson correlation coefficient .<CODESPLIT>def cor ( y_true , y_pred ) : y_true , y_pred = _mask_nan ( y_true , y_pred ) return np . corrcoef ( y_true , y_pred ) [ 0 , 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a WAV file and returns the data and sample rate<CODESPLIT>def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a dictionary of arg_name : default_values for the input function<CODESPLIT>def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Represent data as a masked array .<CODESPLIT>def ma ( self ) : a = self . array return numpy . ma . MaskedArray ( a , mask = numpy . logical_not ( numpy . isfinite ( a ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform Z - Normalization on each numeric column of the given table .<CODESPLIT>def standardize ( table , with_std = True ) : if isinstance ( table , pandas . DataFrame ) : cat_columns = table . select_dtypes ( include = [ 'category' ] ) . columns else : cat_columns = [ ] new_frame = _apply_along_column ( table , standardize_column , with_std = with_std ) # work around for apply converting category dtype to object # https://github.com/pydata/pandas/issues/9573 for col in cat_columns : new_frame [ col ] = table [ col ] . copy ( ) return new_frame
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all files in a given directory<CODESPLIT>def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function<CODESPLIT>def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a structured NumPy array into a Table .<CODESPLIT>def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a datetime object of a given timestamp ( in UTC ) .<CODESPLIT>def utcfromtimestamp ( cls , timestamp ) : obj = datetime . datetime . utcfromtimestamp ( timestamp ) obj = pytz . utc . localize ( obj ) return cls ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If called after an update the sprite can move back<CODESPLIT>def move_back ( self , dt ) : self . _position = self . _old_position self . rect . topleft = self . _position self . feet . midbottom = self . rect . midbottom
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>shows JSON indented representation of d<CODESPLIT>def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from an iterable preserving the order .<CODESPLIT>def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .<CODESPLIT>def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert naive datetime to timezone - aware datetime<CODESPLIT>def datetime_to_timezone ( date , tz = "UTC" ) : if not date . tzinfo : date = date . replace ( tzinfo = timezone ( get_timezone ( ) ) ) return date . astimezone ( timezone ( tz ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip agents from a string .<CODESPLIT>def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Improve deepcopy speed .<CODESPLIT>def __deepcopy__ ( self , memo ) : return type ( self ) ( value = self . _value , enum_ref = self . enum_ref )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull a file directly from S3 .<CODESPLIT>def s3_get ( url : str , temp_file : IO ) -> None : s3_resource = boto3 . resource ( "s3" ) bucket_name , s3_path = split_s3_path ( url ) s3_resource . Bucket ( bucket_name ) . download_fileobj ( s3_path , temp_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decide if the Ipython command line is running code .<CODESPLIT>def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , "function" , None ) == pkg_resources . load_entry_point ( "ipython" , "console_scripts" , "ipython" ) . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a tuple that contains ( screen_width screen_height )<CODESPLIT>def getScreenDims ( self ) : width = ale_lib . getScreenWidth ( self . obj ) height = ale_lib . getScreenHeight ( self . obj ) return ( width , height )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose k random elements of array .<CODESPLIT>def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the shape of img .<CODESPLIT>def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of dictionaries which are sorted for only unique entries .<CODESPLIT>def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a datetime object from an isoformat string .<CODESPLIT>def datetime_from_isoformat ( value : str ) : if sys . version_info >= ( 3 , 7 ) : return datetime . fromisoformat ( value ) return datetime . strptime ( value , '%Y-%m-%dT%H:%M:%S.%f' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins two dictionaries .<CODESPLIT>def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of bytes into an integer as per X9 . 62 .<CODESPLIT>def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a label to the x - axis .<CODESPLIT>def add_xlabel ( self , text = None ) : x = self . fit . meta [ 'independent' ] if not text : text = '$' + x [ 'tex_symbol' ] + r'$ $(\si{' + x [ 'siunitx' ] + r'})$' self . plt . set_xlabel ( text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a random color between min and max .<CODESPLIT>def random_color ( _min = MIN_COLOR , _max = MAX_COLOR ) : return color ( random . randint ( _min , _max ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day<CODESPLIT>def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transpose matrix<CODESPLIT>def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230<CODESPLIT>def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the percentile of a list of values .<CODESPLIT>def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a sympy . Symbol with positive and integer assumptions .<CODESPLIT>def symbol_pos_int ( * args , * * kwargs ) : kwargs . update ( { 'positive' : True , 'integer' : True } ) return sympy . Symbol ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callable function for the multiprocessing pool .<CODESPLIT>def compute_capture ( args ) : x , y , w , h , params = args return x , y , mandelbrot_capture ( x , y , w , h , params )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace multiple values in a string<CODESPLIT>def replace ( s , replace ) : for r in replace : s = s . replace ( * r ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an empty QuerySet .<CODESPLIT>def none ( self ) : return EmptyQuerySet ( model = self . model , using = self . _using , connection = self . _connection )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns system clipboard contents .<CODESPLIT>def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replacer oslo_config . cfg . ConfigParser . parse for in - memory cfg .<CODESPLIT>def _config_parse ( self ) : res = super ( cfg . ConfigParser , self ) . parse ( Backend . _config_string_io ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the variable set with the given name .<CODESPLIT>def get_var ( self , name ) : for var in self . vars : if var . name == name : return var else : raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an integer list into a string list .<CODESPLIT>def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Implements the === operator .<CODESPLIT>def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse string into Identity dictionary .<CODESPLIT>def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r A function to support exiting from exit hooks .<CODESPLIT>def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resizes the given image to fit inside a box of the given size .<CODESPLIT>def resize_image ( self , data , size ) : from machina . core . compat import PILImage as Image image = Image . open ( BytesIO ( data ) ) # Resize! image . thumbnail ( size , Image . ANTIALIAS ) string = BytesIO ( ) image . save ( string , format = 'PNG' ) return string . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serve the datasets in a directory over HTTP .<CODESPLIT>def serve_dtool_directory ( directory , port ) : os . chdir ( directory ) server_address = ( "localhost" , port ) httpd = DtoolHTTPServer ( server_address , DtoolHTTPRequestHandler ) httpd . serve_forever ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>wraps ( instancemethod ) returns a function not an instancemethod so its repr () is all messed up ; we want the original repr to show up in the logs therefore we do this trick<CODESPLIT>def _normalize_instancemethod ( instance_method ) : if not hasattr ( instance_method , 'im_self' ) : return instance_method def _func ( * args , * * kwargs ) : return instance_method ( * args , * * kwargs ) _func . __name__ = repr ( instance_method ) return _func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a timestamp string into a microseconds value : param timestamp : return time in microseconds<CODESPLIT>def timestamp_to_microseconds ( timestamp ) : timestamp_str = datetime . datetime . strptime ( timestamp , ISO_DATETIME_REGEX ) epoch_time_secs = calendar . timegm ( timestamp_str . timetuple ( ) ) epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str . microsecond return epoch_time_mus
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .<CODESPLIT>def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create database tables from sqlalchemy models<CODESPLIT>def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save a Keras model definition to JSON with given path<CODESPLIT>def save_keras_definition ( keras_model , path ) : model_json = keras_model . to_json ( ) with open ( path , "w" ) as json_file : json_file . write ( model_json )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the event loop .<CODESPLIT>def run ( self ) : self . signal_init ( ) self . listen_init ( ) self . logger . info ( 'starting' ) self . loop . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .<CODESPLIT>def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a target name matches with an input regular expression .<CODESPLIT>def _namematcher ( regex ) : matcher = re_compile ( regex ) def match ( target ) : target_name = getattr ( target , '__name__' , '' ) result = matcher . match ( target_name ) return result return match
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the margin in pixels above the plot area setting border_top .<CODESPLIT>def calculate_top_margin ( self ) : self . border_top = 5 if self . show_graph_title : self . border_top += self . title_font_size self . border_top += 5 if self . show_graph_subtitle : self . border_top += self . subtitle_font_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializes a numpy array to a compressed base64 string<CODESPLIT>def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decide if the Ipython command line is running code .<CODESPLIT>def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , "function" , None ) == pkg_resources . load_entry_point ( "ipython" , "console_scripts" , "ipython" ) . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if the socket managed by this connection is connected<CODESPLIT>def is_connected ( self ) : try : return self . socket is not None and self . socket . getsockname ( ) [ 1 ] != 0 and BaseTransport . is_connected ( self ) except socket . error : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform an underscore_case string to a mixedCase string<CODESPLIT>def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets a global variable given its name .<CODESPLIT>def get_var ( name , factory = None ) : if name not in _VARS and factory is not None : _VARS [ name ] = factory ( ) return _VARS . get ( name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close all connections .<CODESPLIT>def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether a variable is a numpy integer array .<CODESPLIT>def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get object from string reference .<CODESPLIT>def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs the function associated with the given MenuEntry .<CODESPLIT>def run_func ( entry ) : if entry . func : if entry . args and entry . krgs : return entry . func ( * entry . args , * * entry . krgs ) if entry . args : return entry . func ( * entry . args ) if entry . krgs : return entry . func ( * * entry . krgs ) return entry . func ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>string dict / object / value to JSON<CODESPLIT>def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y<CODESPLIT>def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the python representation of the obj<CODESPLIT>def _decode ( self , obj , context ) : return b'' . join ( map ( int2byte , [ c + 0x60 for c in bytearray ( obj ) ] ) ) . decode ( "utf8" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the files with the commas removed .<CODESPLIT>def readCommaList ( fileList ) : names = fileList . split ( ',' ) fileList = [ ] for item in names : fileList . append ( item ) return fileList
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .<CODESPLIT>def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to read an XML file<CODESPLIT>def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assert that a value must be a given type .<CODESPLIT>def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes an stdin input reader .<CODESPLIT>def __init__ ( self , encoding = 'utf-8' ) : super ( StdinInputReader , self ) . __init__ ( sys . stdin , encoding = encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the cursor to the desired position .<CODESPLIT>def set_cursor ( self , x , y ) : curses . curs_set ( 1 ) self . screen . move ( y , x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for inserting float features into Example proto .<CODESPLIT>def _float_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( float_list = tf . train . FloatList ( value = value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the size of a file - like object .<CODESPLIT>def get_file_size ( fileobj ) : currpos = fileobj . tell ( ) fileobj . seek ( 0 , 2 ) total_size = fileobj . tell ( ) fileobj . seek ( currpos ) return total_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a timestamp string into a microseconds value : param timestamp : return time in microseconds<CODESPLIT>def timestamp_to_microseconds ( timestamp ) : timestamp_str = datetime . datetime . strptime ( timestamp , ISO_DATETIME_REGEX ) epoch_time_secs = calendar . timegm ( timestamp_str . timetuple ( ) ) epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str . microsecond return epoch_time_mus
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes SQL ; returns list of first values of each row .<CODESPLIT>def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Block until all jobs in the ThreadPool are finished . Beware that this can make the program run into a deadlock if another thread adds new jobs to the pool!<CODESPLIT>def wait ( self , timeout = None ) : if not self . __running : raise RuntimeError ( "ThreadPool ain't running" ) self . __queue . wait ( timeout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict from entries in a scala . collection . immutable . Map<CODESPLIT>def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if end - of - file is reached for file fd .<CODESPLIT>def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Push thing to the stack writing the thing to memory and adjusting the stack pointer .<CODESPLIT>def stack_push ( self , thing ) : # increment sp sp = self . regs . sp + self . arch . stack_change self . regs . sp = sp return self . memory . store ( sp , thing , endness = self . arch . memory_endness )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will copy the selected ( upper or lower ) triangle of a square matrix to the opposite side so that the matrix is symmetrical . Alters in place .<CODESPLIT>def symmetrise ( matrix , tri = 'upper' ) : if tri == 'upper' : tri_fn = np . triu_indices else : tri_fn = np . tril_indices size = matrix . shape [ 0 ] matrix [ tri_fn ( size ) [ : : - 1 ] ] = matrix [ tri_fn ( size ) ] return matrix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A wrapper of os . makedirs () .<CODESPLIT>def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the higher parent which is not an AssignName Tuple or List node<CODESPLIT>def assign_parent ( node : astroid . node_classes . NodeNG ) -> astroid . node_classes . NodeNG : while node and isinstance ( node , ( astroid . AssignName , astroid . Tuple , astroid . List ) ) : node = node . parent return node
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generator that loops through all absolute paths of the files within folder<CODESPLIT>def get_all_files ( folder ) : for path , dirlist , filelist in os . walk ( folder ) : for fn in filelist : yield op . join ( path , fn )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .<CODESPLIT>def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterates through each image in the given directory . ( not recursive ) : param dir_path : Directory path where images files are present : return : Iterator to iterate through image files<CODESPLIT>def each_img ( dir_path ) : for fname in os . listdir ( dir_path ) : if fname . endswith ( '.jpg' ) or fname . endswith ( '.png' ) or fname . endswith ( '.bmp' ) : yield fname
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the element from a set lists or dict . >>> L = [ Lucy ] ; S = set ( [ Sky ] ) ; D = { Diamonds : True } ; >>> remove_once ( L Lucy ) ; remove_once ( S Sky ) ; remove_once ( D Diamonds ) ; >>> print L S D [] set ( [] ) {}<CODESPLIT>def remove_once ( gset , elem ) : remove = getattr ( gset , 'remove' , None ) if remove is not None : remove ( elem ) else : del gset [ elem ] return elem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Covert numpy array to tensorflow tensor<CODESPLIT>def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to camel case .<CODESPLIT>def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + "" . join ( x . title ( ) for x in split [ 1 : ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Appends tzinfo and assumes UTC if datetime object has no tzinfo already .<CODESPLIT>def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeros in the list of integers and returns a new list of integers<CODESPLIT>def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into a list of tokens .<CODESPLIT>def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \t' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dict mapping item - > indices .<CODESPLIT>def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check that the image width is superior to width<CODESPLIT>def _width_is_big_enough ( image , width ) : if width > image . size [ 0 ] : raise ImageSizeError ( image . size [ 0 ] , width )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets RAM memory usage<CODESPLIT>def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the integer index of * series * in this sequence .<CODESPLIT>def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if unicode string only contains ASCII characters .<CODESPLIT>def unicode_is_ascii ( u_string ) : assert isinstance ( u_string , str ) try : u_string . encode ( 'ascii' ) return True except UnicodeEncodeError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Main window move event<CODESPLIT>def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ "window_position" ] = repr ( position )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display productpage with normal user and test user buttons<CODESPLIT>def index ( ) : global productpage table = json2html . convert ( json = json . dumps ( productpage ) , table_attributes = "class=\"table table-condensed table-bordered table-hover\"" ) return render_template ( 'index.html' , serviceTable = table )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reads an RDF file into a graph<CODESPLIT>def load_graph_from_rdf ( fname ) : print ( "reading RDF from " + fname + "...." ) store = Graph ( ) store . parse ( fname , format = "n3" ) print ( "Loaded " + str ( len ( store ) ) + " tuples" ) return store
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a n + 1 dim one - hot array from n dim int - categorical array .<CODESPLIT>def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Unwrap a Python 2 . 6 SSL socket so we can call shutdown ()<CODESPLIT>def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an instance from a dictionary .<CODESPLIT>def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .<CODESPLIT>def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rotates an image by deg degrees<CODESPLIT>def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Time execution of function . Returns ( res seconds ) .<CODESPLIT>def timeit ( func , * args , * * kwargs ) : start_time = time . time ( ) res = func ( * args , * * kwargs ) timing = time . time ( ) - start_time return res , timing
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A background thread to kill the process if it takes too long .<CODESPLIT>def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( "Killing program due to %f second timeout" % timeout ) os . _exit ( 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Imputes data set containing Nan values<CODESPLIT>def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of indexes of substr . If substr not found list is empty .<CODESPLIT>def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return Jinja sbatch template for the current tag<CODESPLIT>def sbatch_template ( self ) : template = self . sbatch_template_str if template . startswith ( '#!' ) : # script is embedded in YAML return jinja_environment . from_string ( template ) return jinja_environment . get_template ( template )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resets the namespace by removing all names defined by the user<CODESPLIT>def reset_namespace ( self ) : self . shellwidget . reset_namespace ( warning = self . reset_warning , message = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a field descriptor by field name .<CODESPLIT>def _GetFieldByName ( message_descriptor , field_name ) : try : return message_descriptor . fields_by_name [ field_name ] except KeyError : raise ValueError ( 'Protocol message %s has no "%s" field.' % ( message_descriptor . name , field_name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the Jupyter work_notebook to write_file<CODESPLIT>def save_notebook ( work_notebook , write_file ) : with open ( write_file , 'w' ) as out_nb : json . dump ( work_notebook , out_nb , indent = 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pops the top frame off the frame stack .<CODESPLIT>def __pop_top_frame ( self ) : popped = self . __stack . pop ( ) if self . __stack : self . __stack [ - 1 ] . process_subframe ( popped )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .<CODESPLIT>def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Confusion matrix plot<CODESPLIT>def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run a playbook .<CODESPLIT>def callPlaybook ( self , playbook , ansibleArgs , wait = True , tags = [ "all" ] ) : playbook = os . path . join ( self . playbooks , playbook ) # Path to playbook being executed verbosity = "-vvvvv" if logger . isEnabledFor ( logging . DEBUG ) else "-v" command = [ "ansible-playbook" , verbosity , "--tags" , "," . join ( tags ) , "--extra-vars" ] command . append ( " " . join ( [ "=" . join ( i ) for i in ansibleArgs . items ( ) ] ) ) # Arguments being passed to playbook command . append ( playbook ) logger . debug ( "Executing Ansible call `%s`" , " " . join ( command ) ) p = subprocess . Popen ( command ) if wait : p . communicate ( ) if p . returncode != 0 : # FIXME: parse error codes raise RuntimeError ( "Ansible reported an error when executing playbook %s" % playbook )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple measure of similarity : Number of letters in common / max length<CODESPLIT>def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if list contains either values of type vtype or None .<CODESPLIT>def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the sum of the element - wise product of vectors x and y . >>> dotproduct ( [ 1 2 3 ] [ 1000 100 10 ] ) 1230<CODESPLIT>def dotproduct ( X , Y ) : return sum ( [ x * y for x , y in zip ( X , Y ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace #hashtag and<CODESPLIT>def urlize_twitter ( text ) : html = TwitterText ( text ) . autolink . auto_link ( ) return mark_safe ( html . replace ( 'twitter.com/search?q=' , 'twitter.com/search/realtime/' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the default value for this key . Default only used when no value is provided by the user via arg config or env .<CODESPLIT>def set_default ( self , key , value ) : k = self . _real_key ( key . lower ( ) ) self . _defaults [ k ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .<CODESPLIT>def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge any number of dictionaries<CODESPLIT>def merge_dict ( data , * args ) : results = { } for current in ( data , ) + args : results . update ( current ) return results
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to run commands synchronously for testing .<CODESPLIT>def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( "Event loop is already running." ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return return information indicated in docstring .<CODESPLIT>def returns ( self ) -> T . Optional [ DocstringReturns ] : try : return next ( DocstringReturns . from_meta ( meta ) for meta in self . meta if meta . args [ 0 ] in { "return" , "returns" , "yield" , "yields" } ) except StopIteration : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a timezone - aware datetime object from a datetime string .<CODESPLIT>def parse_datetime ( dt_str , format ) : t = time . strptime ( dt_str , format ) return datetime ( t [ 0 ] , t [ 1 ] , t [ 2 ] , t [ 3 ] , t [ 4 ] , t [ 5 ] , t [ 6 ] , pytz . UTC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates factorial iteratively . If mod is not None then return ( n! % mod ) Time Complexity - O ( n )<CODESPLIT>def factorial ( n , mod = None ) : if not ( isinstance ( n , int ) and n >= 0 ) : raise ValueError ( "'n' must be a non-negative integer." ) if mod is not None and not ( isinstance ( mod , int ) and mod > 0 ) : raise ValueError ( "'mod' must be a positive integer" ) result = 1 if n == 0 : return 1 for i in range ( 2 , n + 1 ) : result *= i if mod : result %= mod return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper method that escapes parameters to a SQL query .<CODESPLIT>def _escape ( s ) : e = s e = e . replace ( '\\' , '\\\\' ) e = e . replace ( '\n' , '\\n' ) e = e . replace ( '\r' , '\\r' ) e = e . replace ( "'" , "\\'" ) e = e . replace ( '"' , '\\"' ) return e
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the GET querstring contains on values but it can contain empty keys . This is better than doing not bool ( request . GET ) as an empty key will return True<CODESPLIT>def check_empty_dict ( GET_dict ) : empty = True for k , v in GET_dict . items ( ) : # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all' : empty = False return empty
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>string dict / object / value to JSON<CODESPLIT>def string ( value ) -> str : return system_json . dumps ( Json ( value ) . safe_object ( ) , ensure_ascii = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python<CODESPLIT>def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates an AWS Chalice project for deployment to AWS Lambda .<CODESPLIT>def create_aws_lambda ( ctx , bucket , region_name , aws_access_key_id , aws_secret_access_key ) : from canari . commands . create_aws_lambda import create_aws_lambda create_aws_lambda ( ctx . project , bucket , region_name , aws_access_key_id , aws_secret_access_key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove an object from the bin folder .<CODESPLIT>def remove_from_lib ( self , name ) : self . __remove_path ( os . path . join ( self . root_dir , "lib" , name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses the Unix ps program to see if a process is running .<CODESPLIT>def is_running ( process_id : int ) -> bool : pstr = str ( process_id ) encoding = sys . getdefaultencoding ( ) s = subprocess . Popen ( [ "ps" , "-p" , pstr ] , stdout = subprocess . PIPE ) for line in s . stdout : strline = line . decode ( encoding ) if pstr in strline : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to snake_case .<CODESPLIT>def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value in the pandas DataFrame<CODESPLIT>def SetValue ( self , row , col , value ) : self . dataframe . iloc [ row , col ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date<CODESPLIT>def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert iterable object into numpy array<CODESPLIT>def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Applies the sofplus activation function element - wise to the input .<CODESPLIT>def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a modified list containing only the indices indicated .<CODESPLIT>def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the serial port e . g . : / dev / tty . usbserial - A4001ib8<CODESPLIT>def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if obj is number .<CODESPLIT>def is_number ( obj ) : return isinstance ( obj , ( int , float , np . int_ , np . float_ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the * bipartite * ( rectangular ) distance matrix between the observations in the first and the second list .<CODESPLIT>def distance_matrix ( trains1 , trains2 , cos , tau ) : return dissimilarity_matrix ( trains1 , trains2 , cos , tau , "distance" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>arr_out = round_array ( array_in )<CODESPLIT>def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert iterable object into numpy array<CODESPLIT>def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list into a space - separated string and puts it in a dictionary<CODESPLIT>def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : " " . join ( str ( i ) for i in list_ ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return evidence codes in order shown in code2name .<CODESPLIT>def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Asserts if a given values implements a valid iterable interface .<CODESPLIT>def assert_iter ( * * kw ) : for name , value in kw . items ( ) : if not isiter ( value ) : raise TypeError ( 'paco: {} must be an iterable object' . format ( name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trick sphinx into displaying the desired module in these objects documentation .<CODESPLIT>def _set_module_names_for_sphinx ( modules : List , new_name : str ) : for obj in modules : obj . __module__ = new_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace month strings occurrences with month number .<CODESPLIT>def replace_month_abbr_with_num ( date_str , lang = DEFAULT_DATE_LANG ) : num , abbr = get_month_from_date_str ( date_str , lang ) return re . sub ( abbr , str ( num ) , date_str , flags = re . IGNORECASE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .<CODESPLIT>def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Random normal variates .<CODESPLIT>def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Expand $vars in a string .<CODESPLIT>def _expand ( self , str , local_vars = { } ) : return ninja_syntax . expand ( str , self . vars , local_vars )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple from parsing a b c d - > ( a b c d )<CODESPLIT>def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create 2D rotation matrix<CODESPLIT>def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .<CODESPLIT>def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return opened file with a specific encoding .<CODESPLIT>def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip the specified number of elements in the list .<CODESPLIT>def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find rightmost value less than x .<CODESPLIT>def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resizes an image preserving the aspect ratio .<CODESPLIT>def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as unicode string .<CODESPLIT>def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current time .<CODESPLIT>def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( "%Y-%m-%d %H:%M:%S" ) return datetime . datetime . now ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The number of days in the month of the given date<CODESPLIT>def _days_in_month ( date ) : if date . month == 12 : reference = type ( date ) ( date . year + 1 , 1 , 1 ) else : reference = type ( date ) ( date . year , date . month + 1 , 1 ) return ( reference - timedelta ( days = 1 ) ) . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializer for consistency<CODESPLIT>def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the magnitude of a vector .<CODESPLIT>def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper parse action to convert tokens to lower case .<CODESPLIT>def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a modified list containing only the indices indicated .<CODESPLIT>def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn dict keys and values into native strings .<CODESPLIT>def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last number_of_bytes of filename<CODESPLIT>def tail ( filename , number_of_bytes ) : with open ( filename , "rb" ) as f : if os . stat ( filename ) . st_size > number_of_bytes : f . seek ( - number_of_bytes , 2 ) return f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a datetime object and returns a string<CODESPLIT>def serialize ( self , value ) : if isinstance ( value , str ) : return value return value . strftime ( DATETIME_FORMAT )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge modified objects into parent transaction .<CODESPLIT>def commit ( self , session = None ) : if self . __cleared : return if self . _parent : # nested transaction self . _commit_parent ( ) else : self . _commit_repository ( ) self . _clear ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of bytes into an integer as per X9 . 62 .<CODESPLIT>def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop logging to logfile and console .<CODESPLIT>def stop_logging ( ) : from . import log logger = logging . getLogger ( "gromacs" ) logger . info ( "GromacsWrapper %s STOPPED logging" , get_version ( ) ) log . clear_handlers ( logger )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the index of the point just before two lines with common x values .<CODESPLIT>def nearest_intersection_idx ( a , b ) : # Difference in the two y-value sets difference = a - b # Determine the point just before the intersection of the lines # Will return multiple points for multiple intersections sign_change_idx , = np . nonzero ( np . diff ( np . sign ( difference ) ) ) return sign_change_idx
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the angle between vectors a and b in degrees .<CODESPLIT>def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort files or folders by modified time<CODESPLIT>def sort_by_modified ( files_or_folders : list ) -> list : return sorted ( files_or_folders , key = os . path . getmtime , reverse = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Packs a list of triple indexes into a 2D numpy array .<CODESPLIT>def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>View the quaternion array as an array of floats<CODESPLIT>def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send an email to this User .<CODESPLIT>def email_user ( self , subject , message , from_email = None ) : send_mail ( subject , message , from_email , [ self . email ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i )))<CODESPLIT>def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return string with compressed whitespace .<CODESPLIT>def clean_whitespace ( string , compact = False ) : for a , b in ( ( '\r\n' , '\n' ) , ( '\r' , '\n' ) , ( '\n\n' , '\n' ) , ( '\t' , ' ' ) , ( '  ' , ' ' ) ) : string = string . replace ( a , b ) if compact : for a , b in ( ( '\n' , ' ' ) , ( '[ ' , '[' ) , ( '  ' , ' ' ) , ( '  ' , ' ' ) , ( '  ' , ' ' ) ) : string = string . replace ( a , b ) return string . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tries to load an encoded json string back into an object : param json_string : : return :<CODESPLIT>def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute average gradient norm of an image<CODESPLIT>def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Match and yield all the tokens of the input string .<CODESPLIT>def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the column width .<CODESPLIT>def _column_resized ( self , col , old_width , new_width ) : self . dataTable . setColumnWidth ( col , new_width ) self . _update_layout ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show ( print out ) current environment variables .<CODESPLIT>def show ( ) : env = get_environment ( ) for key , val in sorted ( env . env . items ( ) , key = lambda item : item [ 0 ] ) : click . secho ( '%s = %s' % ( key , val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read tag data from file and return as numpy array .<CODESPLIT>def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure the widget is shown . Calling this method will also set the widget visibility to True .<CODESPLIT>def show ( self ) : self . visible = True if self . proxy_is_active : self . proxy . ensure_visible ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a 3 - dimensional rotation matrix .<CODESPLIT>def R_rot_3d ( th ) : sx , sy , sz = np . sin ( th ) . T cx , cy , cz = np . cos ( th ) . T R = np . empty ( ( len ( th ) , 3 , 3 ) , dtype = np . float ) R [ : , 0 , 0 ] = cy * cz R [ : , 0 , 1 ] = - cy * sz R [ : , 0 , 2 ] = sy R [ : , 1 , 0 ] = sx * sy * cz + cx * sz R [ : , 1 , 1 ] = - sx * sy * sz + cx * cz R [ : , 1 , 2 ] = - sx * cy R [ : , 2 , 0 ] = - cx * sy * cz + sx * sz R [ : , 2 , 1 ] = cx * sy * sz + sx * cz R [ : , 2 , 2 ] = cx * cy return R
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a csv and returns a List of Dicts with keys given by header row .<CODESPLIT>def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the checkbox matching the CSS selector .<CODESPLIT>def check_by_selector ( self , selector ) : elem = find_element_by_jquery ( world . browser , selector ) if not elem . is_selected ( ) : elem . click ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the MIME type from the Content - Type header value or application / octet - stream if not found .<CODESPLIT>def get_content_type ( headers ) : ptype = headers . get ( 'Content-Type' , 'application/octet-stream' ) if ";" in ptype : # split off not needed extension info ptype = ptype . split ( ';' ) [ 0 ] return ptype . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs a join using the union join function .<CODESPLIT>def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves a framework or system property . As framework properties don t change while it s running this method don t need to be protected .<CODESPLIT>def get_property ( self , name ) : # type: (str) -> object with self . __properties_lock : return self . __properties . get ( name , os . getenv ( name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download the page into a string<CODESPLIT>def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print in color .<CODESPLIT>def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like np . unique ( item_list return_inverse = True )<CODESPLIT>def unique_inverse ( item_list ) : import utool as ut unique_items = ut . unique ( item_list ) inverse = list_alignment ( unique_items , item_list ) return unique_items , inverse
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adjust image balance and contrast<CODESPLIT>def lighting ( im , b , c ) : if b == 0 and c == 1 : return im mu = np . average ( im ) return np . clip ( ( im - mu ) * c + mu + b , 0. , 1. ) . astype ( np . float32 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a character delimited version of the provided list as a Python string<CODESPLIT>def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is a 2D numpy array of bools<CODESPLIT>def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assigns a parameter value to matching instructions in - place .<CODESPLIT>def _bind_parameter ( self , parameter , value ) : for ( instr , param_index ) in self . _parameter_table [ parameter ] : instr . params [ param_index ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether we re in an interactive shell . Sets interactivity off if appropriate . cf http : // stackoverflow . com / questions / 24861351 / how - to - detect - if - python - script - is - being - run - as - a - background - process<CODESPLIT>def determine_interactive ( self ) : try : if not sys . stdout . isatty ( ) or os . getpgrp ( ) != os . tcgetpgrp ( sys . stdout . fileno ( ) ) : self . interactive = 0 return False except Exception : self . interactive = 0 return False if self . interactive == 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>cv2 Image of current window screen<CODESPLIT>def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR   cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .<CODESPLIT>def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a bool from a string .<CODESPLIT>def FromString ( self , string ) : if string . lower ( ) in ( "false" , "no" , "n" ) : return False if string . lower ( ) in ( "true" , "yes" , "y" ) : return True raise TypeValueError ( "%s is not recognized as a boolean value." % string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if key exists in datastore . True if yes False if no .<CODESPLIT>def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get input from the user given an input function and an input string<CODESPLIT>def get_input ( input_func , input_str ) : val = input_func ( "Please enter your {0}: " . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( "You didn't enter a valid {0}, please try again: " . format ( input_str ) ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Assert an alert is showing with the given text .<CODESPLIT>def check_alert ( self , text ) : try : alert = Alert ( world . browser ) if alert . text != text : raise AssertionError ( "Alert text expected to be {!r}, got {!r}." . format ( text , alert . text ) ) except WebDriverException : # PhantomJS is kinda poor pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensure the cursor is within horizontal screen bounds .<CODESPLIT>def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts protobuf message to a JSON dictionary .<CODESPLIT>def MessageToDict ( message , including_default_value_fields = False , preserving_proto_field_name = False ) : printer = _Printer ( including_default_value_fields , preserving_proto_field_name ) # pylint: disable=protected-access return printer . _MessageToJsonObject ( message )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Centre and normalize a given array .<CODESPLIT>def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logs a function s run time<CODESPLIT>def timed_call ( func , * args , log_level = 'DEBUG' , * * kwargs ) : start = time ( ) r = func ( * args , * * kwargs ) t = time ( ) - start log ( log_level , "Call to '{}' took {:0.6f}s" . format ( func . __name__ , t ) ) return r
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate str as a date and return string version of date<CODESPLIT>def _validate_date_str ( str_ ) : if not str_ : return None # Convert to datetime so we can validate it's a real date that exists then # convert it back to the string. try : date = datetime . strptime ( str_ , DATE_FMT ) except ValueError : msg = 'Invalid date format, should be YYYY-MM-DD' raise argparse . ArgumentTypeError ( msg ) return date . strftime ( DATE_FMT )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into separate words .<CODESPLIT>def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split data into chunks of num chars each<CODESPLIT>def group ( data , num ) : return [ data [ i : i + num ] for i in range ( 0 , len ( data ) , num ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows of length n .<CODESPLIT>def rowlenselect ( table , n , complement = False ) : where = lambda row : len ( row ) == n return select ( table , where , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Combine the outer and inner keys of nested dictionaries into a single ordering .<CODESPLIT>def flattened_nested_key_indices ( nested_dict ) : outer_keys , inner_keys = collect_nested_keys ( nested_dict ) combined_keys = list ( sorted ( set ( outer_keys + inner_keys ) ) ) return { k : i for ( i , k ) in enumerate ( combined_keys ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Categorical accuracy<CODESPLIT>def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display productpage with normal user and test user buttons<CODESPLIT>def index ( ) : global productpage table = json2html . convert ( json = json . dumps ( productpage ) , table_attributes = "class=\"table table-condensed table-bordered table-hover\"" ) return render_template ( 'index.html' , serviceTable = table )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Interpolate linearly variable x in rangeX onto rangeY .<CODESPLIT>def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull the value from the cookiejar .<CODESPLIT>def parse_cookies ( self , req , name , field ) : return core . get_value ( req . COOKIES , name , field )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns given method name .<CODESPLIT>def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( "__" ) and not name . endswith ( "__" ) : name = "_{0}{1}" . format ( get_object_name ( method . im_class ) , name ) return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all the unnamed columns<CODESPLIT>def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the given code line by line with printing as list of lines and return variable ans .<CODESPLIT>def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helps remove extraneous whitespace from the lines of a file<CODESPLIT>def lint_file ( in_file , out_file = None ) : for line in in_file : print ( line . strip ( ) , file = out_file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect and login to an FTP server and return ftplib . FTP object .<CODESPLIT>def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .<CODESPLIT>def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute Pearson correlation coefficient .<CODESPLIT>def cor ( y_true , y_pred ) : y_true , y_pred = _mask_nan ( y_true , y_pred ) return np . corrcoef ( y_true , y_pred ) [ 0 , 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reference to a parent class which contains this class and defined within a namespace<CODESPLIT>def top_class ( self ) : curr = self parent = self . parent while isinstance ( parent , class_t ) : curr = parent parent = parent . parent return curr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>SPSS . sav files to Pandas DataFrame through Rpy2<CODESPLIT>def sav_to_pandas_rpy2 ( input_file ) : import pandas . rpy . common as com w = com . robj . r ( 'foreign::read.spss("%s", to.data.frame=TRUE)' % input_file ) return com . convert_robj ( w )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a new image by copying the image on a * color * background .<CODESPLIT>def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( "RGB" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the date that a file was created .<CODESPLIT>def get_creation_datetime ( filepath ) : if platform . system ( ) == 'Windows' : return datetime . fromtimestamp ( os . path . getctime ( filepath ) ) else : stat = os . stat ( filepath ) try : return datetime . fromtimestamp ( stat . st_birthtime ) except AttributeError : # We're probably on Linux. No easy way to get creation dates here, # so we'll settle for when its content was last modified. return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses a date string formatted like YYYY - MM - DD .<CODESPLIT>def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If values in a series match a specified value change them to np . nan .<CODESPLIT>def na_if ( series , * values ) : series = pd . Series ( series ) series [ series . isin ( values ) ] = np . nan return series
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the uppercase chars in the given string .<CODESPLIT>def uppercase_chars ( string : any ) -> str : return '' . join ( [ c if c . isupper ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the input data is a Swagger document<CODESPLIT>def is_valid ( data ) : return bool ( data ) and isinstance ( data , dict ) and bool ( data . get ( "swagger" ) ) and isinstance ( data . get ( 'paths' ) , dict )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : xml_str : str DataONE API XML doc .<CODESPLIT>def str_is_well_formed ( xml_str ) : try : str_to_etree ( xml_str ) except xml . etree . ElementTree . ParseError : return False else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>implementation of safe dumper using Ordered Dict Yaml Dumper<CODESPLIT>def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close all files but the current one<CODESPLIT>def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses hostname from URL . : param url : URL : return : hostname<CODESPLIT>def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts list to string with comma separated values . For string is no - op .<CODESPLIT>def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = "," . join ( value ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert numbers to floats whether the decimal point is . or<CODESPLIT>def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .<CODESPLIT>def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stop stream .<CODESPLIT>def stop ( self ) : if self . stream and self . stream . session . state != STATE_STOPPED : self . stream . stop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Erases n lines from the screen and moves the cursor up to follow<CODESPLIT>def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ "up" ] , end = "" ) print ( codes . cursor [ "eol" ] , end = "" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find rightmost value less than or equal to x .<CODESPLIT>def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Click the element matching the CSS selector .<CODESPLIT>def click_by_selector ( self , selector ) : # No need for separate button press step with selector style. elem = find_element_by_jquery ( world . browser , selector ) elem . click ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructs wrapper for general index creation and deletion<CODESPLIT>def __init__ ( self , collection , index_type_obj ) : self . collection = collection self . index_type_obj = index_type_obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Encodes numpy images into gif string .<CODESPLIT>def _encode_gif ( images , fps ) : writer = WholeVideoWriter ( fps ) writer . write_multi ( images ) return writer . finish ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quick way to read a file content .<CODESPLIT>def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Use all decompressor possible to make the stream<CODESPLIT>def open ( name = None , fileobj = None , closefd = True ) : return Guesser ( ) . open ( name = name , fileobj = fileobj , closefd = closefd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check to see if the internet is on by pinging a set address . : param address : the IP or address to hit : return : a boolean - true if can be reached false if not .<CODESPLIT>def _internet_on ( address ) : try : urllib2 . urlopen ( address , timeout = 1 ) return True except urllib2 . URLError as err : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transparently unzip the file handle<CODESPLIT>def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Define a new macro<CODESPLIT>def define_macro ( self , name , themacro ) : from IPython . core import macro if isinstance ( themacro , basestring ) : themacro = macro . Macro ( themacro ) if not isinstance ( themacro , macro . Macro ) : raise ValueError ( 'A macro must be a string or a Macro instance.' ) self . user_ns [ name ] = themacro
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close the db and release memory<CODESPLIT>def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>py . test for replace_colon<CODESPLIT>def test_replace_colon ( ) : data = ( ( "zone:aap" , '@' , "zone@aap" ) , # s, r, replaced ) for s , r , replaced in data : result = replace_colon ( s , r ) assert result == replaced
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Args : img ( PIL Image ) : Image to be padded .<CODESPLIT>def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return file name ( s ) from Tkinter s file open dialog .<CODESPLIT>def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Same as lazy_binmap except the parameters are flipped for the binary function<CODESPLIT>def lazy_reverse_binmap ( f , xs ) : return ( f ( y , x ) for x , y in zip ( xs , xs [ 1 : ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the syntax of the given URL .<CODESPLIT>def url_syntax_check ( url ) : # pragma: no cover if url and isinstance ( url , str ) : # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config ( True ) return Check ( url ) . is_url_valid ( ) # We return None, there is nothing to check. return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>simple method to determine if a url is relative or absolute<CODESPLIT>def is_relative_url ( url ) : if url . startswith ( "#" ) : return None if url . find ( "://" ) > 0 or url . startswith ( "//" ) : # either 'http(s)://...' or '//cdn...' and therefore absolute return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print training time at end of training<CODESPLIT>def on_train_end ( self , logs ) : duration = timeit . default_timer ( ) - self . train_start print ( 'done, took {:.3f} seconds' . format ( duration ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set visible property of ticklines and ticklabels of an axis to False<CODESPLIT>def _hide_tick_lines_and_labels ( axis ) : for item in axis . get_ticklines ( ) + axis . get_ticklabels ( ) : item . set_visible ( False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the given thing represents a date<CODESPLIT>def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an instance of RedisSet .<CODESPLIT>def get_instance ( key , expire = None ) : global _instances try : instance = _instances [ key ] except KeyError : instance = RedisSet ( key , _redis , expire = expire ) _instances [ key ] = instance return instance
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does a string replace with a list of search and replacements<CODESPLIT>def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bulk insert or update .<CODESPLIT>def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>exit without breaking pipes .<CODESPLIT>def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a password is valid<CODESPLIT>def is_password_valid ( password ) : pattern = re . compile ( r"^.{4,75}$" ) return bool ( pattern . match ( password ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closest distance between a line segment and a point<CODESPLIT>def distance_to_line ( a , b , p ) : return distance ( closest_point ( a , b , p ) , p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load YAML from file .<CODESPLIT>def load_yaml ( yaml_file : str ) -> Any : with open ( yaml_file , 'r' ) as file : return ruamel . yaml . load ( file , ruamel . yaml . RoundTripLoader )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .<CODESPLIT>def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an active Redis client generated from the given database URL .<CODESPLIT>def from_url ( url , db = None , * * kwargs ) : from redis . client import Redis return Redis . from_url ( url , db , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Kill the browser .<CODESPLIT>def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the index of an item in list which satisfies predicate : param predicateFn : predicate function to run on items of list : param items : list of tuples : return : first index for which predicate function returns True<CODESPLIT>def getIndex ( predicateFn : Callable [ [ T ] , bool ] , items : List [ T ] ) -> int : try : return next ( i for i , v in enumerate ( items ) if predicateFn ( v ) ) except StopIteration : return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given object conforms to the Serializable protocol .<CODESPLIT>def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get line count of file<CODESPLIT>def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load and execute a python file .<CODESPLIT>def load_files ( files ) : for py_file in files : LOG . debug ( "exec %s" , py_file ) execfile ( py_file , globals ( ) , locals ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Subsystems used outside of any task .<CODESPLIT>def get ( cls ) : return { SourceRootConfig , Reporting , Reproducer , RunTracker , Changed , BinaryUtil . Factory , Subprocess . Factory }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterable - first replacement of Python s built - in map () function .<CODESPLIT>def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download an HTML page using the requests session and return the final URL after following redirects .<CODESPLIT>def get_page_and_url ( session , url ) : reply = get_reply ( session , url ) return reply . text , reply . url
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the a new dict with underscores instead of hyphens in keys .<CODESPLIT>def dict_keys_without_hyphens ( a_dict ) : return dict ( ( key . replace ( '-' , '_' ) , val ) for key , val in a_dict . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the leftmost index of an element in a list using binary search .<CODESPLIT>def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if x == y and False otherwise .<CODESPLIT>def equal ( x , y ) : x = BigFloat . _implicit_convert ( x ) y = BigFloat . _implicit_convert ( y ) return mpfr . mpfr_equal_p ( x , y )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Represent data as a masked array .<CODESPLIT>def ma ( self ) : a = self . array return numpy . ma . MaskedArray ( a , mask = numpy . logical_not ( numpy . isfinite ( a ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Logarithmic loss with non - necessarily - binary labels .<CODESPLIT>def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invert mapping of dictionary ( i . e . map values to list of keys )<CODESPLIT>def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hide the window .<CODESPLIT>def hide ( self ) : self . tk . withdraw ( ) self . _visible = False if self . _modal : self . tk . grab_release ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a key is valid and raises a ValueError if its not .<CODESPLIT>def _check_valid_key ( self , key ) : if not isinstance ( key , key_type ) : raise ValueError ( '%r is not a valid key type' % key ) if not VALID_KEY_RE . match ( key ) : raise ValueError ( '%r contains illegal characters' % key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the file name from an url Parameters ---------- url : str<CODESPLIT>def get_url_file_name ( url ) : assert isinstance ( url , ( str , _oldstr ) ) return urlparse . urlparse ( url ) . path . split ( '/' ) [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads a model from specified file<CODESPLIT>def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print fatal errors that occurred during validation runs .<CODESPLIT>def print_fatal_results ( results , level = 0 ) : print_level ( logger . critical , _RED + "[X] Fatal Error: %s" , level , results . error )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .<CODESPLIT>def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips trailing whitespace from string lowercases it and replaces spaces with underscores<CODESPLIT>def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\W+' , '_' , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if the GET querstring contains on values but it can contain empty keys . This is better than doing not bool ( request . GET ) as an empty key will return True<CODESPLIT>def check_empty_dict ( GET_dict ) : empty = True for k , v in GET_dict . items ( ) : # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all' : empty = False return empty
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decode base64 string to byte array .<CODESPLIT>def decodebytes ( input ) : py_version = sys . version_info [ 0 ] if py_version >= 3 : return _decodebytes_py3 ( input ) return _decodebytes_py2 ( input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the number of rows in 2D arrays that contain any nan values .<CODESPLIT>def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Expand a filesystem path that may or may not contain user / env vars .<CODESPLIT>def expandpath ( path ) : return os . path . expandvars ( os . path . expanduser ( path ) ) . replace ( "//" , "/" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>decorator to convert a * args method to one taking a iterable<CODESPLIT>def _varargs_to_iterable_method ( func ) : def wrapped ( self , iterable , * * kwargs ) : return func ( self , * iterable , * * kwargs ) return wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Last time step available .<CODESPLIT>def last ( self ) : if self . _last is UNDETERMINED : # not necessarily the last one... self . _last = self . sdat . tseries . index [ - 1 ] return self [ self . _last ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print training time at end of training<CODESPLIT>def on_train_end ( self , logs ) : duration = timeit . default_timer ( ) - self . train_start print ( 'done, took {:.3f} seconds' . format ( duration ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if ALL of the given argument are AST nodes of the given token ( e . g . BINARY )<CODESPLIT>def is_SYMBOL ( token , * symbols ) : from symbols . symbol_ import Symbol assert all ( isinstance ( x , Symbol ) for x in symbols ) for sym in symbols : if sym . token != token : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of processors on this machine .<CODESPLIT>def cpu_count ( ) -> int : if multiprocessing is None : return 1 try : return multiprocessing . cpu_count ( ) except NotImplementedError : pass try : return os . sysconf ( "SC_NPROCESSORS_CONF" ) except ( AttributeError , ValueError ) : pass gen_log . error ( "Could not detect number of processors; assuming 1" ) return 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shortcut to create md5 hash : param s : : return :<CODESPLIT>def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Translate an image in fourier - space with plane waves<CODESPLIT>def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve a User object by ID .<CODESPLIT>def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date<CODESPLIT>def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips trailing whitespace from string lowercases it and replaces spaces with underscores<CODESPLIT>def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\W+' , '_' , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Discover the current time zone and it s standard string representation ( for source { d } ) .<CODESPLIT>def get_timezone ( ) -> Tuple [ datetime . tzinfo , str ] : dt = get_datetime_now ( ) . astimezone ( ) tzstr = dt . strftime ( "%z" ) tzstr = tzstr [ : - 2 ] + ":" + tzstr [ - 2 : ] return dt . tzinfo , tzstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whitespace normalization :<CODESPLIT>def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return "\n" . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the deepest level of nesting within a list of lists<CODESPLIT>def list_depth ( list_ , func = max , _depth = 0 ) : depth_list = [ list_depth ( item , func = func , _depth = _depth + 1 ) for item in list_ if util_type . is_listlike ( item ) ] if len ( depth_list ) > 0 : return func ( depth_list ) else : return _depth
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a percentile range from an array of values .<CODESPLIT>def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field is a member of the given value .<CODESPLIT>def selectin ( table , field , value , complement = False ) : return select ( table , field , lambda v : v in value , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize the string according to normalization list<CODESPLIT>def normalize ( self , string ) : return '' . join ( [ self . _normalize . get ( x , x ) for x in nfd ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fit a Gaussian to the data<CODESPLIT>def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if something quacks like a list .<CODESPLIT>def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Forward mouse cursor position events to the example<CODESPLIT>def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch a subset of randomzied GUIDs from the whitelist<CODESPLIT>def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if var is a list or a tuple ( but not a string! )<CODESPLIT>def is_a_sequence ( var , allow_none = False ) : return isinstance ( var , ( list , tuple ) ) or ( var is None and allow_none )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether one of the items in the list has multiple lines .<CODESPLIT>def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wait until all task are executed .<CODESPLIT>async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert string to int or float .<CODESPLIT>def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return flattened dictionary from MultiDict .<CODESPLIT>def flatten_multidict ( multidict ) : return dict ( [ ( key , value if len ( value ) > 1 else value [ 0 ] ) for ( key , value ) in multidict . iterlists ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the RMS of the audio<CODESPLIT>def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a given file is available in the cache or not<CODESPLIT>def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places a legend box outside a matplotlib Axes instance .<CODESPLIT>def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all instances matching a tag .<CODESPLIT>def _aws_get_instance_by_tag ( region , name , tag , raw ) : client = boto3 . session . Session ( ) . client ( 'ec2' , region ) matching_reservations = client . describe_instances ( Filters = [ { 'Name' : tag , 'Values' : [ name ] } ] ) . get ( 'Reservations' , [ ] ) instances = [ ] [ [ instances . append ( _aws_instance_from_dict ( region , instance , raw ) ) # pylint: disable=expression-not-assigned for instance in reservation . get ( 'Instances' ) ] for reservation in matching_reservations if reservation ] return instances
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print an object as YAML .<CODESPLIT>def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string column into datetime column<CODESPLIT>def convert_str_to_datetime ( df , * , column : str , format : str ) : df [ column ] = pd . to_datetime ( df [ column ] , format = format ) return df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if there s something to read on stdin ( posix version ) .<CODESPLIT>def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace masked - out elements in an array using an iterative image inpainting algorithm .<CODESPLIT>def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tests if an object is a collection .<CODESPLIT>def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse datetime .<CODESPLIT>def parse_datetime ( dt_str ) : date_format = "%Y-%m-%dT%H:%M:%S %z" dt_str = dt_str . replace ( "Z" , " +0000" ) return datetime . datetime . strptime ( dt_str , date_format )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : generator of tuples ( isLastFlag item )<CODESPLIT>def iter_with_last ( iterable ) : # Ensure it's an iterator and get the first field iterable = iter ( iterable ) prev = next ( iterable ) for item in iterable : # Lag by one item so I know I'm not at the end yield False , prev prev = item # Last item yield True , prev
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port .<CODESPLIT>def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms an XML string it to python - zimbra dict format<CODESPLIT>def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Populate axis limits GUI with current plot values .<CODESPLIT>def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines whether the passed value is a string safe for 2 / 3 .<CODESPLIT>def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the SQLAlchemy column type a string type?<CODESPLIT>def is_sqlatype_string ( coltype : Union [ TypeEngine , VisitableType ] ) -> bool : coltype = _coltype_to_typeengine ( coltype ) return isinstance ( coltype , sqltypes . String )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the error rate based on dense predictions and 1 - hot labels .<CODESPLIT>def error_rate ( predictions , labels ) : return 100.0 - ( 100.0 * np . sum ( np . argmax ( predictions , 1 ) == np . argmax ( labels , 1 ) ) / predictions . shape [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register Flask blueprints .<CODESPLIT>def register_blueprints ( app ) : app . register_blueprint ( public . public_bp ) app . register_blueprint ( genes . genes_bp ) app . register_blueprint ( cases . cases_bp ) app . register_blueprint ( login . login_bp ) app . register_blueprint ( variants . variants_bp ) app . register_blueprint ( panels . panels_bp ) app . register_blueprint ( dashboard . dashboard_bp ) app . register_blueprint ( api . api_bp ) app . register_blueprint ( alignviewers . alignviewers_bp ) app . register_blueprint ( phenotypes . hpo_bp ) app . register_blueprint ( institutes . overview )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gaussian model m is [ psill range nugget ]<CODESPLIT>def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to convert variables into datatypes .<CODESPLIT>def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reseed factory . fuzzy s random generator .<CODESPLIT>def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Walk the media / static directories and syncs files to S3<CODESPLIT>def sync_s3 ( self ) : bucket , key = self . open_s3 ( ) for directory in self . DIRECTORIES : for root , dirs , files in os . walk ( directory ) : self . upload_s3 ( ( bucket , key , self . AWS_BUCKET_NAME , directory ) , root , files , dirs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove any duplicate item preserving order<CODESPLIT>def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializes a numpy array to a compressed base64 string<CODESPLIT>def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if we are in a tty .<CODESPLIT>def intty ( cls ) : # XXX: temporary hack until we can detect if we are in a pipe or not return True if hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a boolean indicating if the attribute name is valid or not<CODESPLIT>def _validate_key ( self , key ) : return not any ( [ key . startswith ( i ) for i in self . EXCEPTIONS ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a flatten version of the nested argument<CODESPLIT>def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes functions that are invoked when the user or OS wants to kill this process . : return :<CODESPLIT>def set_stop_handler ( self ) : signal . signal ( signal . SIGTERM , self . graceful_stop ) signal . signal ( signal . SIGABRT , self . graceful_stop ) signal . signal ( signal . SIGINT , self . graceful_stop )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper on iter method callback gets an iterator result<CODESPLIT>def find_all ( self , string , callback ) : for index , output in self . iter ( string ) : callback ( index , output )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prints the top n lines of a file<CODESPLIT>def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace any non - word characters with a dash .<CODESPLIT>def dashrepl ( value ) : patt = re . compile ( r'\W' , re . UNICODE ) return re . sub ( patt , '-' , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a modified list containing only the indices indicated .<CODESPLIT>def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to overcome pickling problem in python2 .<CODESPLIT>def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Crops and / or pads an image to a target width and height .<CODESPLIT>def resize_image_with_crop_or_pad ( img , target_height , target_width ) : h , w = target_height , target_width max_h , max_w , c = img . shape # crop img = crop_center ( img , min ( max_h , h ) , min ( max_w , w ) ) # pad padded_img = np . zeros ( shape = ( h , w , c ) , dtype = img . dtype ) padded_img [ : img . shape [ 0 ] , : img . shape [ 1 ] , : img . shape [ 2 ] ] = img return padded_img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load logger config from file Keyword arguments : filename -- configuration filename ( Default : logging . ini ) * args -- options passed to fileConfig ** kwargs -- options passed to fileConfigg<CODESPLIT>def load_config ( filename = "logging.ini" , * args , * * kwargs ) : logging . config . fileConfig ( filename , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate a delay to retry using an exponential backoff algorithm .<CODESPLIT>def exponential_backoff ( attempt : int , cap : int = 1200 ) -> timedelta : base = 3 temp = min ( base * 2 ** attempt , cap ) return timedelta ( seconds = temp / 2 + random . randint ( 0 , temp / 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if an item is iterable ( list tuple generator ) but not string<CODESPLIT>def _is_iterable ( item ) : return isinstance ( item , collections . Iterable ) and not isinstance ( item , six . string_types )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of entries in a table by counting them .<CODESPLIT>def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = "SELECT COUNT (*) FROM `%s`" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Return the bounding box incorporating all non - zero values in the image . Parameters ---------- img : array_like An array containing non - zero objects . Returns ------- bbox : a list of slicer objects defining the bounding box<CODESPLIT>def bounding_box ( img ) : locations = numpy . argwhere ( img ) mins = locations . min ( 0 ) maxs = locations . max ( 0 ) + 1 return [ slice ( x , y ) for x , y in zip ( mins , maxs ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into a list of tokens .<CODESPLIT>def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \t' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes an object / rabalist from registery . This is useful if you want to allow the garbage collector to free the memory taken by the objects you ve already loaded . Be careful might cause some discrepenties in your scripts . For objects cascades to free the registeries of related rabalists also<CODESPLIT>def removeFromRegistery ( obj ) : if isRabaObject ( obj ) : _unregisterRabaObjectInstance ( obj ) elif isRabaList ( obj ) : _unregisterRabaListInstance ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper around Django s get_language utility . For Django > = 1 . 8 get_language returns None in case no translation is activate . Here we patch this behavior e . g . for back - end functionality requiring access to translated fields<CODESPLIT>def get_language ( ) : from parler import appsettings language = dj_get_language ( ) if language is None and appsettings . PARLER_DEFAULT_ACTIVATE : return appsettings . PARLER_DEFAULT_LANGUAGE_CODE else : return language
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deeply updates a dictionary . List values are concatenated .<CODESPLIT>def deep_update ( d , u ) : for k , v in u . items ( ) : if isinstance ( v , Mapping ) : d [ k ] = deep_update ( d . get ( k , { } ) , v ) elif isinstance ( v , list ) : existing_elements = d . get ( k , [ ] ) d [ k ] = existing_elements + [ ele for ele in v if ele not in existing_elements ] else : d [ k ] = v return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Euclidean distance between two vectors .<CODESPLIT>def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .<CODESPLIT>def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read entire contents of file into a string .<CODESPLIT>def read_string_from_file ( path , encoding = "utf8" ) : with codecs . open ( path , "rb" , encoding = encoding ) as f : value = f . read ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Repeat each item in iterable n times .<CODESPLIT>def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of rows and a column name and returns a list containing a single row ( dict from columns to cells ) that has the maximum numerical value in the given column . We return a list instead of a single dict to be consistent with the return type of select and all_rows .<CODESPLIT>def argmax ( self , rows : List [ Row ] , column : ComparableColumn ) -> List [ Row ] : if not rows : return [ ] value_row_pairs = [ ( row . values [ column . name ] , row ) for row in rows ] if not value_row_pairs : return [ ] # Returns a list containing the row with the max cell value. return [ sorted ( value_row_pairs , key = lambda x : x [ 0 ] , reverse = True ) [ 0 ] [ 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an int of form yyyymmdd to a python date object .<CODESPLIT>def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort list elements by name .<CODESPLIT>def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a reversed iterable over the items in the dictionary . Items are iterated over in their reverse sort order .<CODESPLIT>def __reversed__ ( self ) : _dict = self . _dict return iter ( ( key , _dict [ key ] ) for key in reversed ( self . _list ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True when alias already in shell config .<CODESPLIT>def _is_already_configured ( configuration_details ) : path = Path ( configuration_details . path ) . expanduser ( ) with path . open ( 'r' ) as shell_config : return configuration_details . content in shell_config . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extracts the subject line from an EmailMessage object .<CODESPLIT>def get_subject ( self , msg ) : text , encoding = decode_header ( msg [ 'subject' ] ) [ - 1 ] try : text = text . decode ( encoding ) # If it's already decoded, ignore error except AttributeError : pass return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Hex encode a binary string<CODESPLIT>def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reimplement Qt method to send focus change notification<CODESPLIT>def focusInEvent ( self , event ) : self . focus_changed . emit ( ) return super ( ControlWidget , self ) . focusInEvent ( event )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Output data as a nicely - formatted python data structure<CODESPLIT>def py ( self , output ) : import pprint pprint . pprint ( output , stream = self . outfile )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates a Spearman rank - order correlation coefficient . Taken from Heiman s Basic Statistics for the Behav . Sci ( 1st ) p . 192 .<CODESPLIT>def lspearmanr ( x , y ) : TINY = 1e-30 if len ( x ) != len ( y ) : raise ValueError ( 'Input values not paired in spearmanr.  Aborting.' ) n = len ( x ) rankx = rankdata ( x ) ranky = rankdata ( y ) dsq = sumdiffsquared ( rankx , ranky ) rs = 1 - 6 * dsq / float ( n * ( n ** 2 - 1 ) ) t = rs * math . sqrt ( ( n - 2 ) / ( ( rs + 1.0 ) * ( 1.0 - rs ) ) ) df = n - 2 probrs = betai ( 0.5 * df , 0.5 , df / ( df + t * t ) ) # t already a float # probability values for rs are from part 2 of the spearman function in # Numerical Recipies, p.510.  They are close to tables, but not exact. (?) return rs , probrs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the class is a date type .<CODESPLIT>def is_date_type ( cls ) : if not isinstance ( cls , type ) : return False return issubclass ( cls , date ) and not issubclass ( cls , datetime )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a block of data and parse using the given protobuf object .<CODESPLIT>def read_proto_object ( fobj , klass ) : log . debug ( '%s chunk' , klass . __name__ ) obj = klass ( ) obj . ParseFromString ( read_block ( fobj ) ) log . debug ( 'Header: %s' , str ( obj ) ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verify Django 1 . 11 is present if Python 2 . 7 is active<CODESPLIT>def validate_django_compatible_with_python ( ) : python_version = sys . version [ : 5 ] django_version = django . get_version ( ) if sys . version_info == ( 2 , 7 ) and django_version >= "2" : click . BadArgumentUsage ( "Please install Django v1.11 for Python {}, or switch to Python >= v3.4" . format ( python_version ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if the value is in the list move it to the front and return it .<CODESPLIT>def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if two line segments meet .<CODESPLIT>def line_line_collide ( line1 , line2 ) : s , t , success = segment_intersection ( line1 [ : , 0 ] , line1 [ : , 1 ] , line2 [ : , 0 ] , line2 [ : , 1 ] ) if success : return _helpers . in_interval ( s , 0.0 , 1.0 ) and _helpers . in_interval ( t , 0.0 , 1.0 ) else : disjoint , _ = parallel_lines_parameters ( line1 [ : , 0 ] , line1 [ : , 1 ] , line2 [ : , 0 ] , line2 [ : , 1 ] ) return not disjoint
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get a collection of records by table name . returns a dict ( the json map ) for python 3 . 4<CODESPLIT>def list ( self , table , * * kparams ) : result = self . table_api_get ( table , * * kparams ) return self . to_records ( result , table )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decide if the Ipython command line is running code .<CODESPLIT>def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , "function" , None ) == pkg_resources . load_entry_point ( "ipython" , "console_scripts" , "ipython" ) . __name__ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform a ( multidimensional ) variable access to a flattend sympy expression .<CODESPLIT>def access_to_sympy ( self , var_name , access ) : base_sizes = self . variables [ var_name ] [ 1 ] expr = sympy . Number ( 0 ) for dimension , a in enumerate ( access ) : base_size = reduce ( operator . mul , base_sizes [ dimension + 1 : ] , sympy . Integer ( 1 ) ) expr += base_size * a return expr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns seconds since 0h00 .<CODESPLIT>def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the table names in the database .<CODESPLIT>def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( "SELECT name FROM sqlite_master WHERE type == 'table'" ) return [ name for ( name , ) in cursor ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>clear all files that were to be injected<CODESPLIT>def clear_all ( self ) : self . injections . clear_all ( ) for config_file in CONFIG_FILES : self . injections . clear ( os . path . join ( "~" , config_file ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list with the order that features requested appear in dataset<CODESPLIT>def get_feature_order ( dataset , features ) : all_features = dataset . get_feature_names ( ) i = [ all_features . index ( f ) for f in features ] return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Start web application<CODESPLIT>def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Terminate all workers and threads .<CODESPLIT>def terminate ( self ) : for t in self . _threads : t . quit ( ) self . _thread = [ ] self . _workers = [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an ISO - 8601 formatted string from the provided datetime object<CODESPLIT>def isoformat ( dt ) : if not isinstance ( dt , datetime . datetime ) : raise TypeError ( "Must provide datetime.datetime object to isoformat" ) if dt . tzinfo is None : raise ValueError ( "naive datetime objects are not allowed beyond the library boundaries" ) return dt . isoformat ( ) . replace ( "+00:00" , "Z" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute entropy on the string<CODESPLIT>def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run a command and return its stdout / stderr as a string .<CODESPLIT>def getoutput_pexpect ( self , cmd ) : try : return pexpect . run ( self . sh , args = [ '-c' , cmd ] ) . replace ( '\r\n' , '\n' ) except KeyboardInterrupt : print ( '^C' , file = sys . stderr , end = '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a bool from a string .<CODESPLIT>def FromString ( self , string ) : if string . lower ( ) in ( "false" , "no" , "n" ) : return False if string . lower ( ) in ( "true" , "yes" , "y" ) : return True raise TypeValueError ( "%s is not recognized as a boolean value." % string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove html code contained into the given string .<CODESPLIT>def strip_html ( string , keep_tag_content = False ) : r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE return r . sub ( '' , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert CamelCase to lower_and_underscore .<CODESPLIT>def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get line count of file<CODESPLIT>def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse datetime .<CODESPLIT>def parse_datetime ( dt_str ) : date_format = "%Y-%m-%dT%H:%M:%S %z" dt_str = dt_str . replace ( "Z" , " +0000" ) return datetime . datetime . strptime ( dt_str , date_format )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets the dimensions depending on python version and os<CODESPLIT>def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def attr_cache_clear ( self ) : node = extract_node ( """def cache_clear(self): pass""" ) return BoundMethod ( proxy = node , bound = self . _instance . parent . scope ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pull comma separated string values out of a text file and converts them to float list<CODESPLIT>def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Alternate name for filter so as to not collide with the built - in python filter operator .<CODESPLIT>def filter_ ( stream_spec , filter_name , * args , * * kwargs ) : return filter ( stream_spec , filter_name , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Completer function for Python s readline / libedit implementation .<CODESPLIT>def repl_complete ( text : str , state : int ) -> Optional [ str ] : # Can't complete Keywords, Numerals if __NOT_COMPLETEABLE . match ( text ) : return None elif text . startswith ( ":" ) : completions = kw . complete ( text ) else : ns = get_current_ns ( ) completions = ns . complete ( text ) return list ( completions ) [ state ] if completions is not None else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all files in a given directory<CODESPLIT>def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load the correct module according to the version<CODESPLIT>def load_library ( version ) : check_version ( version ) module_name = SUPPORTED_LIBRARIES [ version ] lib = sys . modules . get ( module_name ) if lib is None : lib = importlib . import_module ( module_name ) return lib
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>if we have a compatible fill_value and arr dtype then fill<CODESPLIT>def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an empty array with appropriate shape .<CODESPLIT>def _create_empty_array ( self , frames , always_2d , dtype ) : import numpy as np if always_2d or self . channels > 1 : shape = frames , self . channels else : shape = frames , return np . empty ( shape , dtype , order = 'C' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string representing a numpy array of 0 s and 1 s<CODESPLIT>def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return file name ( s ) from Tkinter s file open dialog .<CODESPLIT>def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a Status instance from its string representation .<CODESPLIT>def from_string ( cls , s ) : for num , text in cls . _STATUS2STR . items ( ) : if text == s : return cls ( num ) else : raise ValueError ( "Wrong string %s" % s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a symbolic fourier series of order n .<CODESPLIT>def fourier_series ( x , f , n = 0 ) : # Make the parameter objects for all the terms a0 ,  * cos_a = parameters ( ',' . join ( [ 'a{}' . format ( i ) for i in range ( 0 , n + 1 ) ] ) ) sin_b = parameters ( ',' . join ( [ 'b{}' . format ( i ) for i in range ( 1 , n + 1 ) ] ) ) # Construct the series series = a0 + sum ( ai * cos ( i * f * x ) + bi * sin ( i * f * x ) for i , ( ai , bi ) in enumerate ( zip ( cos_a , sin_b ) , start = 1 ) ) return series
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get distance matrix given a matrix . Used in testing .<CODESPLIT>def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a leading hash # at the beginning of every line in the source .<CODESPLIT>def _add_hash ( source ) : source = '\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>x is a 2D sparse matrix with it s first shape equal to 1 .<CODESPLIT>def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a list of the data types for each column in * data * .<CODESPLIT>def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a DataFrame with the duplicated values of the column col_name in df .<CODESPLIT>def duplicated_rows ( df , col_name ) : _check_cols ( df , [ col_name ] ) dups = df [ pd . notnull ( df [ col_name ] ) & df . duplicated ( subset = [ col_name ] ) ] return dups
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform actions before parent main window is closed<CODESPLIT>def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increment ( or add ) numeric suffix to identifier .<CODESPLIT>def _increment_numeric_suffix ( s ) : if re . match ( r".*\d+$" , s ) : return re . sub ( r"\d+$" , lambda n : str ( int ( n . group ( 0 ) ) + 1 ) , s ) return s + "_2"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invert mapping of dictionary ( i . e . map values to list of keys )<CODESPLIT>def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Go to parent directory<CODESPLIT>def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>detect if a model has a given field has<CODESPLIT>def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a numpy array to YAML .<CODESPLIT>def numpy_to_yaml ( representer : Representer , data : np . ndarray ) -> Sequence [ Any ] : return representer . represent_sequence ( "!numpy_array" , data . tolist ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round x and y down to integers .<CODESPLIT>def floor ( self ) : return Point ( int ( math . floor ( self . x ) ) , int ( math . floor ( self . y ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The url of this window<CODESPLIT>def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :<CODESPLIT>def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( "non-list value found where list is expected" ) return all ( isinstance ( x , str ) for x in arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>safe version of pow<CODESPLIT>def safe_pow ( base , exp ) : if exp > MAX_EXPONENT : raise RuntimeError ( "Invalid exponent, max exponent is {}" . format ( MAX_EXPONENT ) ) return base ** exp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to add two numbers<CODESPLIT>def generic_add ( a , b ) : logger . debug ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a date object and return the first day of the month .<CODESPLIT>def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rate limit a function .<CODESPLIT>def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if specified value exists in int enum ; otherwise False .<CODESPLIT>def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increment a metric by value .<CODESPLIT>def incr ( name , value = 1 , rate = 1 , tags = None ) : client ( ) . incr ( name , value , rate , tags )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Return the bounding box incorporating all non - zero values in the image . Parameters ---------- img : array_like An array containing non - zero objects . Returns ------- bbox : a list of slicer objects defining the bounding box<CODESPLIT>def bounding_box ( img ) : locations = numpy . argwhere ( img ) mins = locations . min ( 0 ) maxs = locations . max ( 0 ) + 1 return [ slice ( x , y ) for x , y in zip ( mins , maxs ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes an object ( line triangle image etc ) from the drawing .<CODESPLIT>def delete ( self , id ) : if id in self . _images . keys ( ) : del self . _images [ id ] self . tk . delete ( id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if given filename is an image .<CODESPLIT>def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented .<CODESPLIT>def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the dev_info data from a dictionary .<CODESPLIT>def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does this filename match any of the patterns?<CODESPLIT>def file_matches ( filename , patterns ) : return any ( fnmatch . fnmatch ( filename , pat ) for pat in patterns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : generator of tuples ( isLastFlag item )<CODESPLIT>def iter_with_last ( iterable ) : # Ensure it's an iterator and get the first field iterable = iter ( iterable ) prev = next ( iterable ) for item in iterable : # Lag by one item so I know I'm not at the end yield False , prev prev = item # Last item yield True , prev
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiprocess mapping the given function on the given iterable .<CODESPLIT>def multiprocess_mapping ( func , iterable ) : if os . name == 'nt' : # In Windows there is no fork. return list ( map ( func , iterable ) ) try : p = multiprocessing . Pool ( ) return_data = list ( p . imap ( func , iterable ) ) p . close ( ) p . join ( ) return return_data except OSError : return list ( map ( func , iterable ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Indicates whether or not the given row contains valid data .<CODESPLIT>def is_valid_row ( cls , row ) : for k in row . keys ( ) : if row [ k ] is None : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Moves the text cursor to given line .<CODESPLIT>def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of PIDs currently running on the system .<CODESPLIT>def get_pid_list ( ) : pids = [ int ( x ) for x in os . listdir ( '/proc' ) if x . isdigit ( ) ] return pids
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Builds instance from dictionary of properties .<CODESPLIT>def fromDict ( cls , _dict ) : obj = cls ( ) obj . __dict__ . update ( _dict ) return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Emulate what a Python set () does but keeping the element s order .<CODESPLIT>def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a conda environment inside the current sandbox for the given list of dependencies and options .<CODESPLIT>def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ "conda" , "create" , "--yes" , "--copy" , "--quiet" , "-p" , env_dir ] + list ( options ) + dependencies log . info ( "Creating conda environment: " ) log . info ( "  command line: %s" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( "Environment created" ) return env_dir , env_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wraps the dispatch method to add session support .<CODESPLIT>def dispatch ( self ) : try : webapp2 . RequestHandler . dispatch ( self ) finally : self . session_store . save_sessions ( self . response )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Inserts a horizontal ( commented ) line tot the generated code .<CODESPLIT>def _write_separator ( self ) : tmp = self . _page_width - ( ( 4 * self . __indent_level ) + 2 ) self . _write_line ( '# ' + ( '-' * tmp ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch a subset of randomzied GUIDs from the whitelist<CODESPLIT>def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lists names of all blobs by their prefix .<CODESPLIT>def list_blobs ( self , prefix = '' ) : return [ b . name for b in self . bucket . list_blobs ( prefix = prefix ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare two strings while protecting against timing attacks<CODESPLIT>def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip tweet message .<CODESPLIT>def strip_tweet ( text , remove_url = True ) : if remove_url : text = url_pattern . sub ( '' , text ) else : text = expand_url ( text ) text = mention_pattern . sub ( '' , text ) text = html_parser . unescape ( text ) text = text . strip ( ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform underscore separated string to pascal case<CODESPLIT>def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Covert numpy array to tensorflow tensor<CODESPLIT>def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places a legend box outside a matplotlib Axes instance .<CODESPLIT>def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if day is after month s 3rd friday<CODESPLIT>def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove the last . in the string it it ends with a . for the url structure must follow the flask routing format it should be / model / method instead of / model / method /<CODESPLIT>def blueprint_name_to_url ( name ) : if name [ - 1 : ] == "." : name = name [ : - 1 ] name = str ( name ) . replace ( "." , "/" ) return name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raise a new exception using the preserved traceback of the last one .<CODESPLIT>def _re_raise_as ( NewExc , * args , * * kw ) : etype , val , tb = sys . exc_info ( ) raise NewExc ( * args , * * kw ) , None , tb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dictionary of conversion<CODESPLIT>def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return string with compressed whitespace .<CODESPLIT>def clean_whitespace ( string , compact = False ) : for a , b in ( ( '\r\n' , '\n' ) , ( '\r' , '\n' ) , ( '\n\n' , '\n' ) , ( '\t' , ' ' ) , ( '  ' , ' ' ) ) : string = string . replace ( a , b ) if compact : for a , b in ( ( '\n' , ' ' ) , ( '[ ' , '[' ) , ( '  ' , ' ' ) , ( '  ' , ' ' ) , ( '  ' , ' ' ) ) : string = string . replace ( a , b ) return string . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return ctypes . Array an iterable array of int values in argb .<CODESPLIT>def GetAllPixelColors ( self ) -> ctypes . Array : return self . GetPixelColorsOfRect ( 0 , 0 , self . Width , self . Height )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a dictionary of attributes in the DOT format<CODESPLIT>def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '"%s"="%s"' % item ) for item in sorted ( d . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check the syntax of the given URL .<CODESPLIT>def url_syntax_check ( url ) : # pragma: no cover if url and isinstance ( url , str ) : # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config ( True ) return Check ( url ) . is_url_valid ( ) # We return None, there is nothing to check. return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format numpy array as a string .<CODESPLIT>def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( "," ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + "%s[%s]" % ( arr . dtype , shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The value of Last - Modified HTTP header or None .<CODESPLIT>def last_modified ( self ) -> Optional [ datetime . datetime ] : httpdate = self . _headers . get ( hdrs . LAST_MODIFIED ) if httpdate is not None : timetuple = parsedate ( httpdate ) if timetuple is not None : return datetime . datetime ( * timetuple [ : 6 ] , tzinfo = datetime . timezone . utc ) return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when a new DropDownItem gets selected .<CODESPLIT>def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle the + operator .<CODESPLIT>def __add__ ( self , other ) : return self . _handle_type ( other ) ( self . value + other . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all child objects in nested dict .<CODESPLIT>def as_dict ( self ) : dicts = [ x . as_dict for x in self . children ] return { '{0} {1}' . format ( self . name , self . value ) : dicts }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether this is a ( non - quantized real ) floating point type .<CODESPLIT>def is_floating ( self ) : return ( self . is_numpy_compatible and np . issubdtype ( self . as_numpy_dtype , np . floating ) ) or self . base_dtype == bfloat16
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string to bytes .<CODESPLIT>def to_bytes ( s , encoding = "utf-8" ) : if isinstance ( s , six . binary_type ) : return s if six . PY3 : return bytes ( s , encoding ) return s . encode ( encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if end - of - file is reached for file fd .<CODESPLIT>def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Directory where to store output<CODESPLIT>def output_dir ( self , * args ) -> str : return os . path . join ( self . project_dir , 'output' , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download and unzip from url .<CODESPLIT>def install_from_zip ( url ) : fname = 'tmp.zip' downlad_file ( url , fname ) unzip_file ( fname ) print ( "Removing {}" . format ( fname ) ) os . unlink ( fname )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a column of the given matrix .<CODESPLIT>def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Batches a list into a list of lists with sub - lists sized by a specified batch size .<CODESPLIT>def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the language parameter from the current request .<CODESPLIT>def get_language ( self ) : return get_language_parameter ( self . request , self . query_language_key , default = self . get_default_language ( object = object ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert bytes and non - string into Python 3 str<CODESPLIT>def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Not recommended for use on large lists due to time complexity but it works<CODESPLIT>def index ( self , item ) : for i , x in enumerate ( self . iter ( ) ) : if x == item : return i return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Uses OLS to fit the regression .<CODESPLIT>def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Places all the child widgets in the appropriate positions .<CODESPLIT>def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = "nswe" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = "ns" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts query strings into native Python objects<CODESPLIT>def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print message via subprocess . call function .<CODESPLIT>def print_message ( message = None ) : kwargs = { 'stdout' : sys . stdout , 'stderr' : sys . stderr , 'shell' : True } return subprocess . call ( 'echo "{0}"' . format ( message or '' ) , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move the turtle forward .<CODESPLIT>def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert str_value to an int or a float depending on the numeric value represented by str_value .<CODESPLIT>def str_to_num ( str_value ) : str_value = str ( str_value ) try : return int ( str_value ) except ValueError : return float ( str_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output<CODESPLIT>def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flatten all dimensions of a except the last .<CODESPLIT>def flatten_all_but_last ( a ) : ret = tf . reshape ( a , [ - 1 , tf . shape ( a ) [ - 1 ] ] ) if not tf . executing_eagerly ( ) : ret . set_shape ( [ None ] + a . get_shape ( ) . as_list ( ) [ - 1 : ] ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Trick sphinx into displaying the desired module in these objects documentation .<CODESPLIT>def _set_module_names_for_sphinx ( modules : List , new_name : str ) : for obj in modules : obj . __module__ = new_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Translate an image in fourier - space with plane waves<CODESPLIT>def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Align the position in the file to the next block of specified size<CODESPLIT>def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A tensorflow variable tranfomed to be constrained in a L2 unit ball .<CODESPLIT>def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send a POST request<CODESPLIT>def send_post ( self , url , data , remove_header = None ) : return self . send_request ( method = "post" , url = url , data = data , remove_header = remove_header )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield successive distinct permutations of the elements in * iterable * .<CODESPLIT>def distinct_permutations ( iterable ) : def make_new_permutations ( permutations , e ) : """Internal helper function.         The output permutations are built up by adding element *e* to the         current *permutations* at every possible position.         The key idea is to keep repeated elements (reverse) ordered:         if e1 == e2 and e1 is before e2 in the iterable, then all permutations         with e1 before e2 are ignored.          """ for permutation in permutations : for j in range ( len ( permutation ) ) : yield permutation [ : j ] + [ e ] + permutation [ j : ] if permutation [ j ] == e : break else : yield permutation + [ e ] permutations = [ [ ] ] for e in iterable : permutations = make_new_permutations ( permutations , e ) return ( tuple ( t ) for t in permutations )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of lists into a flat list . Args : x : list of lists<CODESPLIT>def flatten_list ( x : List [ Any ] ) -> List [ Any ] : # noqa return [ item for sublist in x for item in sublist ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return receiver s content type .<CODESPLIT>def content_type ( self ) -> ContentType : return self . _ctype if self . _ctype else self . parent . content_type ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly .<CODESPLIT>def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list with no repeated elements .<CODESPLIT>def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I convert strings into integers floats and strings!<CODESPLIT>def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the user enter max and min values of where the raster points should appear on the y - axis<CODESPLIT>def values ( self ) : lower = float ( self . lowerSpnbx . value ( ) ) upper = float ( self . upperSpnbx . value ( ) ) return ( lower , upper )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if rollover should occur .<CODESPLIT>def should_rollover ( self , record : LogRecord ) -> bool : t = int ( time . time ( ) ) if t >= self . rollover_at : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from an iterable preserving the order .<CODESPLIT>def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if end - of - file is reached for file fd .<CODESPLIT>def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>stack_as_string<CODESPLIT>def stack_as_string ( ) : if sys . version_info . major == 3 : stack = io . StringIO ( ) else : stack = io . BytesIO ( ) traceback . print_stack ( file = stack ) stack . seek ( 0 ) stack = stack . read ( ) return stack
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return string with compressed whitespace .<CODESPLIT>def clean_whitespace ( string , compact = False ) : for a , b in ( ( '\r\n' , '\n' ) , ( '\r' , '\n' ) , ( '\n\n' , '\n' ) , ( '\t' , ' ' ) , ( '  ' , ' ' ) ) : string = string . replace ( a , b ) if compact : for a , b in ( ( '\n' , ' ' ) , ( '[ ' , '[' ) , ( '  ' , ' ' ) , ( '  ' , ' ' ) , ( '  ' , ' ' ) ) : string = string . replace ( a , b ) return string . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether another set contains this set .<CODESPLIT>def issubset ( self , other ) : if len ( self ) > len ( other ) : # Fast check for obvious cases return False return all ( item in other for item in self )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>React to a docstring event and append contracts to it .<CODESPLIT>def process_docstring ( app , what , name , obj , options , lines ) : # pylint: disable=unused-argument # pylint: disable=too-many-arguments lines . extend ( _format_contracts ( what = what , obj = obj ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>create a graphviz graph from text<CODESPLIT>def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>indents paragraphs of text for rst formatting<CODESPLIT>def indent ( block , spaces ) : new_block = '' for line in block . split ( '\n' ) : new_block += spaces + line + '\n' return new_block
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes an environment<CODESPLIT>def delete_environment ( self , environment_name ) : self . ebs . terminate_environment ( environment_name = environment_name , terminate_resources = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call this method from a function that defines a literal shader string as the body argument . Dresses up a shader string in three ways : 1 ) Insert #version at the top 2 ) Insert #line number declaration 3 ) un - indents The line number information can help debug glsl compile errors . The version string needs to be the very first characters in the shader which can be distracting requiring backslashes or other tricks . The unindenting allows you to type the shader code at a pleasing indent level in your python method while still creating an unindented GLSL string at the end .<CODESPLIT>def shader_string ( body , glsl_version = '450 core' ) : line_count = len ( body . split ( '\n' ) ) line_number = inspect . currentframe ( ) . f_back . f_lineno + 1 - line_count return """\ #version %s %s """ % ( glsl_version , shader_substring ( body , stack_frame = 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a dictionary object with keys that are 2tuples represnting a point .<CODESPLIT>def CreateVertices ( self , points ) : gr = digraph ( ) for z , x , Q in points : node = ( z , x , Q ) gr . add_nodes ( [ node ] ) return gr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Mark the occurrence of a given number of events .<CODESPLIT>def mark ( self , n = 1 ) : self . tick_if_necessary ( ) self . count += n self . m1_rate . update ( n ) self . m5_rate . update ( n ) self . m15_rate . update ( n )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert hex string like \ x0A \ xE3 to 2787 .<CODESPLIT>def hex_to_int ( value ) : if version_info . major >= 3 : return int . from_bytes ( value , "big" ) return int ( value . encode ( "hex" ) , 16 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether this path is a symbolic link .<CODESPLIT>def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove element e from model<CODESPLIT>def remove_element ( self , e ) : if e . label is not None : self . elementdict . pop ( e . label ) self . elementlist . remove ( e )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse HTTP status line return status ( int ) and reason .<CODESPLIT>def header_status ( header ) : status_line = header [ : header . find ( '\r' ) ] # 'HTTP/1.1 200 OK' -> (200, 'OK') fields = status_line . split ( None , 2 ) return int ( fields [ 1 ] ) , fields [ 2 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test two dictionary is equal on values . ( ignore order )<CODESPLIT>def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if git command is available .<CODESPLIT>def check_git ( ) : try : with open ( os . devnull , "wb" ) as devnull : subprocess . check_call ( [ "git" , "--version" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( "Please make sure git is installed and on your path." )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap itertools . groupby to make life easier .<CODESPLIT>def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fast %Y - %m - %d parsing .<CODESPLIT>def parse_date ( s ) : try : return datetime . date ( int ( s [ : 4 ] ) , int ( s [ 5 : 7 ] ) , int ( s [ 8 : 10 ] ) ) except ValueError : # other accepted format used in one-day data set return datetime . datetime . strptime ( s , '%d %B %Y' ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the index of the closest in xarr to value val<CODESPLIT>def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call win32 API to refresh the whole Window .<CODESPLIT>def win32_refresh_window ( cls ) : # Get console handle handle = windll . kernel32 . GetConsoleWindow ( ) RDW_INVALIDATE = 0x0001 windll . user32 . RedrawWindow ( handle , None , None , c_uint ( RDW_INVALIDATE ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raise a new exception using the preserved traceback of the last one .<CODESPLIT>def _re_raise_as ( NewExc , * args , * * kw ) : etype , val , tb = sys . exc_info ( ) raise NewExc ( * args , * * kw ) , None , tb
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Filter out duplicate items from an iterable<CODESPLIT>def unique ( iterable ) : seen = set ( ) for item in iterable : if item not in seen : seen . add ( item ) yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .<CODESPLIT>def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the display length of a string . This can differ from the character length if the string contains wide characters .<CODESPLIT>def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle conversion of pymongo cursor into a JSON object formatted for UI consumption<CODESPLIT>def _obj_cursor_to_dictionary ( self , cursor ) : if not cursor : return cursor cursor = json . loads ( json . dumps ( cursor , cls = BSONEncoder ) ) if cursor . get ( "_id" ) : cursor [ "id" ] = cursor . get ( "_id" ) del cursor [ "_id" ] return cursor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Download file from http url link<CODESPLIT>def download_file ( save_path , file_url ) : r = requests . get ( file_url ) # create HTTP response object with open ( save_path , 'wb' ) as f : f . write ( r . content ) return save_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find rightmost value less than or equal to x .<CODESPLIT>def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new dict from an existing dict that only has the given keys<CODESPLIT>def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>attempt to draw str on screen and ignore errors if they occur<CODESPLIT>def add_str ( window , line_num , str ) : try : window . addstr ( line_num , 0 , str ) except curses . error : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .<CODESPLIT>def energy_string_to_float ( string ) : energy_re = re . compile ( "(-?\d+\.\d+)" ) return float ( energy_re . match ( string ) . group ( 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch a subset of randomzied GUIDs from the whitelist<CODESPLIT>def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>transpose matrix<CODESPLIT>def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal helper to return the values of a dictionary sorted by key .<CODESPLIT>def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If block = False ( the default ) die hard and fast if another process has already grabbed the lock for this file .<CODESPLIT>def lock_file ( f , block = False ) : try : flags = fcntl . LOCK_EX if not block : flags |= fcntl . LOCK_NB fcntl . flock ( f . fileno ( ) , flags ) except IOError as e : if e . errno in ( errno . EACCES , errno . EAGAIN ) : raise SystemExit ( "ERROR: %s is locked by another process." % f . name ) raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the total timedelta duration in seconds .<CODESPLIT>def timedelta_seconds ( timedelta ) : return ( timedelta . total_seconds ( ) if hasattr ( timedelta , "total_seconds" ) else timedelta . days * 24 * 3600 + timedelta . seconds + timedelta . microseconds / 1000000. )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decision Tree<CODESPLIT>def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a proper string that should work in both Py3 / Py2<CODESPLIT>def polite_string ( a_string ) : if is_py3 ( ) and hasattr ( a_string , 'decode' ) : try : return a_string . decode ( 'utf-8' ) except UnicodeDecodeError : return a_string return a_string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If pair is in search_list return the index . Otherwise return - 1<CODESPLIT>def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read entire contents of file into a string .<CODESPLIT>def read_string_from_file ( path , encoding = "utf8" ) : with codecs . open ( path , "rb" , encoding = encoding ) as f : value = f . read ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the angle between vectors a and b in degrees .<CODESPLIT>def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Re - index every document in a named index .<CODESPLIT>def update_index ( index ) : logger . info ( "Updating search index: '%s'" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( "Updating search index model: '%s'" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = "index" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( "chunk_size" ) ) responses . append ( response ) return responses
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets all defaults for the given dictionary to those contained in a second defaults dictionary . This convenience method calls :<CODESPLIT>def setDictDefaults ( d , defaults ) : for key , val in defaults . items ( ) : d . setdefault ( key , val ) return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the host s ip number .<CODESPLIT>def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( "8.8.8.8" , 80 ) ) except socket . gaierror : ip_ = "127.0.0.1" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a str of decimal with two digits after a decimal mark .<CODESPLIT>def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return "%1.2f" % ( float ( value ) / 100 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add executable permissions to the file<CODESPLIT>def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return system CPU times as a namedtuple .<CODESPLIT>def get_system_cpu_times ( ) : user , nice , system , idle = _psutil_osx . get_system_cpu_times ( ) return _cputimes_ntuple ( user , nice , system , idle )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given object conforms to the Serializable protocol .<CODESPLIT>def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compare by iteration<CODESPLIT>def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>First order phase correction .<CODESPLIT>def phase_correct_first ( spec , freq , k ) : c_factor = np . exp ( - 1j * k * freq ) c_factor = c_factor . reshape ( ( len ( spec . shape ) - 1 ) * ( 1 , ) + c_factor . shape ) return spec * c_factor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get object from string reference .<CODESPLIT>def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a 3x3 cross - product matrix from a 3 - element vector .<CODESPLIT>def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Instantiate the given extension class and register as a public attribute of the given base .<CODESPLIT>def register_extension_class ( ext , base , * args , * * kwargs ) : ext_instance = ext . plugin ( base , * args , * * kwargs ) setattr ( base , ext . name . lstrip ( '_' ) , ext_instance )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits on multiple given separators .<CODESPLIT>def multi_split ( s , split ) : # type: (S, Iterable[S]) -> List[S] for r in split : s = s . replace ( r , "|" ) return [ i for i in s . split ( "|" ) if len ( i ) > 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Swap the methods atom to remove method with key .<CODESPLIT>def __remove_method ( m : lmap . Map , key : T ) -> lmap . Map : return m . dissoc ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a numpy array to YAML .<CODESPLIT>def numpy_to_yaml ( representer : Representer , data : np . ndarray ) -> Sequence [ Any ] : return representer . represent_sequence ( "!numpy_array" , data . tolist ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the unit tests .<CODESPLIT>def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Send signal to process .<CODESPLIT>def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conver a path string to a list of path elements .<CODESPLIT>def path_to_list ( pathstr ) : return [ elem for elem in pathstr . split ( os . path . pathsep ) if elem ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a model s verbose name to the model class . This allows us to use the models verbose name in steps .<CODESPLIT>def get_model ( name ) : model = MODELS . get ( name . lower ( ) , None ) assert model , "Could not locate model by name '%s'" % name return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>True if specified value exists in int enum ; otherwise False .<CODESPLIT>def has_value ( cls , value : int ) -> bool : return any ( value == item . value for item in cls )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets latest Dusty binary version using the GitHub api<CODESPLIT>def _get_latest_version ( ) : url = 'https://api.github.com/repos/{}/releases/latest' . format ( constants . DUSTY_GITHUB_PATH ) conn = urllib . urlopen ( url ) if conn . getcode ( ) >= 300 : raise RuntimeError ( 'GitHub api returned code {}; can\'t determine latest version.  Aborting' . format ( conn . getcode ( ) ) ) json_data = conn . read ( ) return json . loads ( json_data ) [ 'tag_name' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of rows preceding the data table for * series * in the Excel worksheet .<CODESPLIT>def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>docstring for argparse<CODESPLIT>def cli_run ( ) : parser = argparse . ArgumentParser ( description = 'Stupidly simple code answers from StackOverflow' ) parser . add_argument ( 'query' , help = "What's the problem ?" , type = str , nargs = '+' ) parser . add_argument ( '-t' , '--tags' , help = 'semicolon separated tags -> python;lambda' ) args = parser . parse_args ( ) main ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if two objects are equal .<CODESPLIT>def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Move the cursor up a number of lines .<CODESPLIT>def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an enum from a name Args : enum_name ( str ) : name of the enum Returns : Enum<CODESPLIT>def get_enum_from_name ( self , enum_name ) : return next ( ( e for e in self . enums if e . name == enum_name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Splits a string into parts at multiple characters<CODESPLIT>def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the first value in each row .<CODESPLIT>def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value<CODESPLIT>def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert human readable string to datetime . datetime .<CODESPLIT>def str_to_time ( time_str : str ) -> datetime . datetime : pieces : Any = [ int ( piece ) for piece in time_str . split ( '-' ) ] return datetime . datetime ( * pieces )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>check if day is after month s 3rd friday<CODESPLIT>def after_third_friday ( day = None ) : day = day if day is not None else datetime . datetime . now ( ) now = day . replace ( day = 1 , hour = 16 , minute = 0 , second = 0 , microsecond = 0 ) now += relativedelta . relativedelta ( weeks = 2 , weekday = relativedelta . FR ) return day > now
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns obj . field data as a dict<CODESPLIT>def _basic_field_data ( field , obj ) : value = field . value_from_object ( obj ) return { Field . TYPE : FieldType . VAL , Field . VALUE : value }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return base64 encoded binarystring .<CODESPLIT>def calc_base64 ( s ) : s = compat . to_bytes ( s ) s = compat . base64_encodebytes ( s ) . strip ( ) # return bytestring return compat . to_native ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether another set contains this RangeSet .<CODESPLIT>def issubset ( self , other ) : self . _binary_sanity_check ( other ) return set . issubset ( self , other )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Outputs a string to the console ( stdout ) .<CODESPLIT>def out ( self , output , newline = True ) : click . echo ( output , nl = newline )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts a csv string into a list<CODESPLIT>def csvtolist ( inputstr ) : reader = csv . reader ( [ inputstr ] , skipinitialspace = True ) output = [ ] for r in reader : output += r return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove non - alphanumerical characters from metric word . And trim excessive underscores .<CODESPLIT>def sanitize_word ( s ) : s = re . sub ( '[^\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Intersect dictionaries d1 and d2 by key * and * value .<CODESPLIT>def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port .<CODESPLIT>def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert camel case string to snake case<CODESPLIT>def convert_camel_case_string ( name : str ) -> str : string = re . sub ( "(.)([A-Z][a-z]+)" , r"\1_\2" , name ) return re . sub ( "([a-z0-9])([A-Z])" , r"\1_\2" , string ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the queue is full False otherwise ( not reliable! ) .<CODESPLIT>def full ( self ) : return self . maxsize and len ( self . list ) >= self . maxsize or False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the package is registered on pypi<CODESPLIT>def package_in_pypi ( package ) : url = 'http://pypi.python.org/simple/%s' % package try : urllib . request . urlopen ( url ) return True except urllib . error . HTTPError as e : logger . debug ( "Package not found on pypi: %s" , e ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if cnr or cns files are empty ( only have a header )<CODESPLIT>def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the scroll region on the canvas<CODESPLIT>def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sanity check for csv parser : param row : param length : return : None<CODESPLIT>def _check_list_len ( row , length ) : if len ( row ) != length : raise Exception ( "row length does not match expected length of " + str ( length ) + "\nrow: " + str ( row ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the average color from the list of colors where each color is a 3 - tuple of ( r g b ) values .<CODESPLIT>def get_average_color ( colors ) : c = reduce ( color_reducer , colors ) total = len ( colors ) return tuple ( v / total for v in c )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check to see if the internet is on by pinging a set address . : param address : the IP or address to hit : return : a boolean - true if can be reached false if not .<CODESPLIT>def _internet_on ( address ) : try : urllib2 . urlopen ( address , timeout = 1 ) return True except urllib2 . URLError as err : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the contents of an object stored in S3 as string .<CODESPLIT>def get_as_string ( self , s3_path , encoding = 'utf-8' ) : content = self . get_as_bytes ( s3_path ) return content . decode ( encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get system root directory ( application installed root directory )<CODESPLIT>def get_system_root_directory ( ) : root = os . path . dirname ( __file__ ) root = os . path . dirname ( root ) root = os . path . abspath ( root ) return root
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register service into the system . Called by Services .<CODESPLIT>def register_service ( self , service ) : if service not in self . services : self . services . append ( service )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does a string replace with a list of search and replacements<CODESPLIT>def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to infer an object s dtype for use in arithmetic ops<CODESPLIT>def maybe_infer_dtype_type ( element ) : tipo = None if hasattr ( element , 'dtype' ) : tipo = element . dtype elif is_list_like ( element ) : element = np . asarray ( element ) tipo = element . dtype return tipo
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert a code sequence to HTML<CODESPLIT>def make_html_code ( self , lines ) : line = code_header + '\n' for l in lines : line = line + html_quote ( l ) + '\n' return line + code_footer
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the id of the last written row in table<CODESPLIT>def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( "SELECT seq FROM sqlite_sequence WHERE name='{0}'" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Identify clusters using K - Means algorithm .<CODESPLIT>def cluster_kmeans ( data , n_clusters , * * kwargs ) : km = cl . KMeans ( n_clusters , * * kwargs ) kmf = km . fit ( data ) labels = kmf . labels_ return labels , [ np . nan ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a decimal price and rounds to a number of decimal places<CODESPLIT>def price_rounding ( price , decimals = 2 ) : try : exponent = D ( '.' + decimals * '0' ) except InvalidOperation : # Currencies with no decimal places, ex. JPY, HUF exponent = D ( ) return price . quantize ( exponent , rounding = ROUND_UP )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plots a graph in graphviz dot notation .<CODESPLIT>def plot_dot_graph ( graph , filename = None ) : if not plot . pygraphviz_available : logger . error ( "Pygraphviz is not installed, cannot generate graph plot!" ) return if not plot . PIL_available : logger . error ( "PIL is not installed, cannot display graph plot!" ) return agraph = AGraph ( graph ) agraph . layout ( prog = 'dot' ) if filename is None : filename = tempfile . mktemp ( suffix = ".png" ) agraph . draw ( filename ) image = Image . open ( filename ) image . show ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a tuple of numbers . e . g . vertices normals or teture coords .<CODESPLIT>def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix inversion op .<CODESPLIT>def MatrixInverse ( a , adj ) : return np . linalg . inv ( a if not adj else _adjoint ( a ) ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given string is an url<CODESPLIT>def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim .<CODESPLIT>def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if the argument is a real number ( float or integer ) .<CODESPLIT>def isreal ( obj ) : return ( ( obj is not None ) and ( not isinstance ( obj , bool ) ) and isinstance ( obj , ( int , float ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes all blank lines in @string<CODESPLIT>def remove_blank_lines ( string ) : return "\n" . join ( line for line in string . split ( "\n" ) if len ( line . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert camelcase to lowercase and underscore .<CODESPLIT>def camel_to_underscore ( string ) : string = FIRST_CAP_RE . sub ( r'\1_\2' , string ) return ALL_CAP_RE . sub ( r'\1_\2' , string ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set y - axis limits of a subplot .<CODESPLIT>def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .<CODESPLIT>def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>zfill ( x width ) - > string<CODESPLIT>def zfill ( x , width ) : if not isinstance ( x , basestring ) : x = repr ( x ) return x . zfill ( width )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>iterate through the noun phrases<CODESPLIT>def enumerate_chunks ( phrase , spacy_nlp ) : if ( len ( phrase ) > 1 ) : found = False text = " " . join ( [ rl . text for rl in phrase ] ) doc = spacy_nlp ( text . strip ( ) , parse = True ) for np in doc . noun_chunks : if np . text != text : found = True yield np . text , find_chunk ( phrase , np . text . split ( " " ) ) if not found and all ( [ rl . pos [ 0 ] != "v" for rl in phrase ] ) : yield text , phrase
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield compressed chunks from a data array<CODESPLIT>def _file_chunks ( self , data , chunk_size ) : for i in xrange ( 0 , len ( data ) , chunk_size ) : yield self . compressor ( data [ i : i + chunk_size ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers<CODESPLIT>def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create parametric ellipse from 200 points .<CODESPLIT>def create_ellipse ( width , height , angle ) : angle = angle / 180.0 * np . pi thetas = np . linspace ( 0 , 2 * np . pi , 200 ) a = width / 2.0 b = height / 2.0 x = a * np . cos ( thetas ) * np . cos ( angle ) - b * np . sin ( thetas ) * np . sin ( angle ) y = a * np . cos ( thetas ) * np . sin ( angle ) + b * np . sin ( thetas ) * np . cos ( angle ) z = np . zeros ( thetas . shape ) return np . vstack ( ( x , y , z ) ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to a redis instance .<CODESPLIT>def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a number to a precision<CODESPLIT>def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if test is True for all array elements . Otherwise returns False .<CODESPLIT>def isarray ( array , test , dim = 2 ) : if dim > 1 : return all ( isarray ( array [ i ] , test , dim - 1 ) for i in range ( len ( array ) ) ) return all ( test ( i ) for i in array )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the Jaccard similarity between two sets of nodes . Called by mroc .<CODESPLIT>def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tool to ensure input and output data have the same number of samples<CODESPLIT>def check_lengths ( * arrays ) : lengths = [ len ( array ) for array in arrays ] if len ( np . unique ( lengths ) ) > 1 : raise ValueError ( 'Inconsistent data lengths: {}' . format ( lengths ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the progress ratio and percentage .<CODESPLIT>def ratio_and_percentage ( current , total , time_remaining ) : return "{} / {} ({}% completed)" . format ( current , total , int ( current / total * 100 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Init a noise variable .<CODESPLIT>def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output<CODESPLIT>def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes input from user . Works for Python 2 and 3 .<CODESPLIT>def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create the toolkit widget for the proxy object .<CODESPLIT>def create_widget ( self ) : d = self . declaration button_type = UIButton . UIButtonTypeSystem if d . flat else UIButton . UIButtonTypeRoundedRect self . widget = UIButton ( buttonWithType = button_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find rightmost value less than or equal to x .<CODESPLIT>def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a copy of dct without keys keys<CODESPLIT>def _delete_keys ( dct , keys ) : c = deepcopy ( dct ) assert isinstance ( keys , list ) for k in keys : c . pop ( k ) return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>parse the domain from the url<CODESPLIT>def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the receiver s contribution to tree diagram .<CODESPLIT>def _tree_line ( self , no_type : bool = False ) -> str : return self . _tree_line_prefix ( ) + " " + self . iname ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Configure a Domain registry entry .<CODESPLIT>def _config_win32_domain ( self , domain ) : # we call str() on domain to convert it from unicode to ascii self . domain = dns . name . from_text ( str ( domain ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace masked - out elements in an array using an iterative image inpainting algorithm .<CODESPLIT>def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>guess_file_class : determines what file the content is Args : filepath ( str ) : filepath of file to check Returns : string indicating file s class<CODESPLIT>def guess_file_type ( kind , filepath = None , youtube_id = None , web_url = None , encoding = None ) : if youtube_id : return FileTypes . YOUTUBE_VIDEO_FILE elif web_url : return FileTypes . WEB_VIDEO_FILE elif encoding : return FileTypes . BASE64_FILE else : ext = os . path . splitext ( filepath ) [ 1 ] [ 1 : ] . lower ( ) if kind in FILE_TYPE_MAPPING and ext in FILE_TYPE_MAPPING [ kind ] : return FILE_TYPE_MAPPING [ kind ] [ ext ] return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns files matched by all extensions in the extensions list<CODESPLIT>def glob_by_extensions ( directory , extensions ) : directorycheck ( directory ) files = [ ] xt = files . extend for ex in extensions : xt ( glob . glob ( '{0}/*.{1}' . format ( directory , ex ) ) ) return files
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: obj : numpy . ndarray : Vector representation for this camera .<CODESPLIT>def vec ( self ) : return np . r_ [ self . fx , self . fy , self . cx , self . cy , self . skew , self . height , self . width ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>stupid windows . converts the backslash to forwardslash for consistency<CODESPLIT>def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , "/" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines the height and width of the console window<CODESPLIT>def size ( ) : try : assert os != 'nt' and sys . stdout . isatty ( ) rows , columns = os . popen ( 'stty size' , 'r' ) . read ( ) . split ( ) except ( AssertionError , AttributeError , ValueError ) : # in case of failure, use dimensions of a full screen 13" laptop rows , columns = DEFAULT_HEIGHT , DEFAULT_WIDTH return int ( rows ) , int ( columns )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>delete all the eggs in the directory specified<CODESPLIT>def delete_all_eggs ( self ) : path_to_delete = os . path . join ( self . egg_directory , "lib" , "python" ) if os . path . exists ( path_to_delete ) : shutil . rmtree ( path_to_delete )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be an iterable ( list array tuple )<CODESPLIT>def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Resets the iterator to the start .<CODESPLIT>def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the keys that maps to the top n max values in the given dict .<CODESPLIT>def get_keys_of_max_n ( dict_obj , n ) : return sorted ( [ item [ 0 ] for item in sorted ( dict_obj . items ( ) , key = lambda item : item [ 1 ] , reverse = True ) [ : n ] ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the unit tests .<CODESPLIT>def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reset to the default text color on console window . Return bool True if succeed otherwise False .<CODESPLIT>def ResetConsoleColor ( ) -> bool : if sys . stdout : sys . stdout . flush ( ) bool ( ctypes . windll . kernel32 . SetConsoleTextAttribute ( _ConsoleOutputHandle , _DefaultConsoleColor ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns system clipboard contents .<CODESPLIT>def paste ( xsel = False ) : selection = "primary" if xsel else "clipboard" try : return subprocess . Popen ( [ "xclip" , "-selection" , selection , "-o" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( "utf-8" ) except OSError as why : raise XclipNotFound
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given two data points [ X Y ] linearly interpolate those at x .<CODESPLIT>def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function to display sympy expression using display style LaTeX in PNG .<CODESPLIT>def print_display_png ( o ) : s = latex ( o , mode = 'plain' ) s = s . strip ( '$' ) # As matplotlib does not support display style, dvipng backend is # used here. png = latex_to_png ( '$$%s$$' % s , backend = 'dvipng' ) return png
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a copy of the list without duplicates .<CODESPLIT>def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert instances of textx types and match rules to python types .<CODESPLIT>def convert ( self , value , _type ) : return self . type_convertors . get ( _type , lambda x : x ) ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the terminal window size of the child tty .<CODESPLIT>def setwinsize ( self , rows , cols ) : self . _winsize = ( rows , cols ) self . pty . set_size ( cols , rows )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a unique string with length n .<CODESPLIT>def _uniqueid ( n = 30 ) : return '' . join ( random . SystemRandom ( ) . choice ( string . ascii_uppercase + string . ascii_lowercase ) for _ in range ( n ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get user name provide by operating system<CODESPLIT>def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if filename has changed since the last check . If this is the first check assume the file is changed .<CODESPLIT>def has_changed ( filename ) : key = os . path . abspath ( filename ) mtime = get_mtime ( key ) if key not in _mtime_cache : _mtime_cache [ key ] = mtime return True return mtime > _mtime_cache [ key ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove non - alphanumerical characters from metric word . And trim excessive underscores .<CODESPLIT>def sanitize_word ( s ) : s = re . sub ( '[^\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the case as an Excel spreadsheet .<CODESPLIT>def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads a model from specified file<CODESPLIT>def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .<CODESPLIT>def energy_string_to_float ( string ) : energy_re = re . compile ( "(-?\d+\.\d+)" ) return float ( energy_re . match ( string ) . group ( 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>dictionary of conversion<CODESPLIT>def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns its parameter as an integer or raises django . forms . ValidationError .<CODESPLIT>def clean_int ( x ) -> int : try : return int ( x ) except ValueError : raise forms . ValidationError ( "Cannot convert to integer: {}" . format ( repr ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads text file contents<CODESPLIT>def read_text_from_file ( path : str ) -> str : with open ( path ) as text_file : content = text_file . read ( ) return content
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draws a representation of a random forest in IPython . Parameters : ----------- t : The tree you wish to draw df : The data used to train the tree . This is used to get the names of the features .<CODESPLIT>def draw_tree ( t , df , size = 10 , ratio = 0.6 , precision = 0 ) : s = export_graphviz ( t , out_file = None , feature_names = df . columns , filled = True , special_characters = True , rotate = True , precision = precision ) IPython . display . display ( graphviz . Source ( re . sub ( 'Tree {' , f'Tree {{ size={size}; ratio={ratio}' , s ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a shell - escaped version of the string s .<CODESPLIT>def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the non - sequence features from the provided example .<CODESPLIT>def get_example_features ( example ) : return ( example . features . feature if isinstance ( example , tf . train . Example ) else example . context . feature )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array .<CODESPLIT>def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Optional<CODESPLIT>def optional ( self , value = None ) : # If there's no value, this is a getter if value is None : return this . _optional # Else, set the flag else : this . _optional = value and True or False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for fast reading from sensor files .<CODESPLIT>def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Downsample x by factor using striding .<CODESPLIT>def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the tests .<CODESPLIT>def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield all items from iterable except the last one .<CODESPLIT>def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Directly send utf8 bytes to stdout<CODESPLIT>def imp_print ( self , text , end ) : sys . stdout . write ( ( text + end ) . encode ( "utf-8" ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the exectuable bit on the given filename<CODESPLIT>def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last weekday in a given month . e . g :<CODESPLIT>def get_last_weekday_in_month ( year , month , weekday ) : day = date ( year , month , monthrange ( year , month ) [ 1 ] ) while True : if day . weekday ( ) == weekday : break day = day - timedelta ( days = 1 ) return day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .<CODESPLIT>def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like pretty but print to stdout .<CODESPLIT>def pprint ( obj , verbose = False , max_width = 79 , newline = '\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether path is a directory to which the user has write access .<CODESPLIT>def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Toggle linear / log scale for Y - axis .<CODESPLIT>def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the size in bytes .<CODESPLIT>def get_size_in_bytes ( self , handle ) : fpath = self . _fpath_from_handle ( handle ) return os . stat ( fpath ) . st_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a year is leap year .<CODESPLIT>def _is_leap_year ( year ) : isleap = ( ( np . mod ( year , 4 ) == 0 ) & ( ( np . mod ( year , 100 ) != 0 ) | ( np . mod ( year , 400 ) == 0 ) ) ) return isleap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disable event loop integration with wxPython .<CODESPLIT>def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This parallel fetcher uses gevent one uses gevent<CODESPLIT>def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a string representing a numpy array of 0 s and 1 s<CODESPLIT>def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Perform singular value decomposition for dimensionality reduction of the input matrix .<CODESPLIT>def _svd ( cls , matrix , num_concepts = 5 ) : u , s , v = svds ( matrix , k = num_concepts ) return u , s , v
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize s into ASCII and replace non - word characters with delimiter .<CODESPLIT>def slugify ( s , delimiter = '-' ) : s = unicodedata . normalize ( 'NFKD' , to_unicode ( s ) ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' ) return RE_SLUG . sub ( delimiter , s ) . strip ( delimiter ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>checks if you are on a 64 bit platform<CODESPLIT>def check64bit ( current_system = "python" ) : if current_system == "python" : return sys . maxsize > 2147483647 elif current_system == "os" : import platform pm = platform . machine ( ) if pm != ".." and pm . endswith ( '64' ) : # recent Python (not Iron) return True else : if 'PROCESSOR_ARCHITEW6432' in os . environ : return True # 32 bit program running on 64 bit Windows try : # 64 bit Windows 64 bit program return os . environ [ 'PROCESSOR_ARCHITECTURE' ] . endswith ( '64' ) except IndexError : pass # not Windows try : # this often works in Linux return '64' in platform . architecture ( ) [ 0 ] except Exception : # is an older version of Python, assume also an older os@ # (best we can guess) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a Django project is being managed with manage . py or django - admin scripts<CODESPLIT>def is_managed ( ) : for item in sys . argv : if re . search ( r'manage.py|django-admin|django' , item ) is not None : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip all color codes from a string . Returns empty string for falsey inputs .<CODESPLIT>def strip_codes ( s : Any ) -> str : return codepat . sub ( '' , str ( s ) if ( s or ( s == 0 ) ) else '' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Disconnect ( logout ) service instance<CODESPLIT>def __Logout ( si ) : try : if si : content = si . RetrieveContent ( ) content . sessionManager . Logout ( ) except Exception as e : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the * cmd * and exit with the proper exit code .<CODESPLIT>def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Searches for the specified method and returns its descriptor .<CODESPLIT>def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the distance between two Vectors<CODESPLIT>def distance ( vec1 , vec2 ) : if isinstance ( vec1 , Vector2 ) and isinstance ( vec2 , Vector2 ) : dist_vec = vec2 - vec1 return dist_vec . length ( ) else : raise TypeError ( "vec1 and vec2 must be Vector2's" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wipes compiled and cached python files . To simulate : pynt clean [ dry_run = y ]<CODESPLIT>def clean ( dry_run = 'n' ) : file_patterns = [ '*.pyc' , '*.pyo' , '*~' ] dir_patterns = [ '__pycache__' ] recursive_pattern_delete ( project_paths . root , file_patterns , dir_patterns , dry_run = bool ( dry_run . lower ( ) == 'y' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a list of indexes .<CODESPLIT>def _read_indexlist ( self , name ) : setattr ( self , '_' + name , [ self . _timeline [ int ( i ) ] for i in self . db . lrange ( 'site:{0}' . format ( name ) , 0 , - 1 ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all groups of a user<CODESPLIT>def get_groups ( self , username ) : username = ldap . filter . escape_filter_chars ( self . _byte_p2 ( username ) ) userdn = self . _get_user ( username , NO_ATTR ) searchfilter = self . group_filter_tmpl % { 'userdn' : userdn , 'username' : username } groups = self . _search ( searchfilter , NO_ATTR , self . groupdn ) ret = [ ] for entry in groups : ret . append ( self . _uni ( entry [ 0 ] ) ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given string starts with one of the prefixes in the given list otherwise return False .<CODESPLIT>def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether one of the items in the list has multiple lines .<CODESPLIT>def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a property by name<CODESPLIT>def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a similarity matrix of % of shared sequence<CODESPLIT>def _calculate_similarity ( c ) : ma = { } for idc in c : set1 = _get_seqs ( c [ idc ] ) [ ma . update ( { ( idc , idc2 ) : _common ( set1 , _get_seqs ( c [ idc2 ] ) , idc , idc2 ) } ) for idc2 in c if idc != idc2 and ( idc2 , idc ) not in ma ] # logger.debug("_calculate_similarity_ %s" % ma) return ma
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the first value in each row .<CODESPLIT>def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes SSIM .<CODESPLIT>def compute_ssim ( image1 , image2 , gaussian_kernel_sigma = 1.5 , gaussian_kernel_width = 11 ) : gaussian_kernel_1d = get_gaussian_kernel ( gaussian_kernel_width , gaussian_kernel_sigma ) return SSIM ( image1 , gaussian_kernel_1d ) . ssim_value ( image2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a list of the top topn features in this : class : . Feature \ .<CODESPLIT>def top ( self , topn = 10 ) : return [ self [ i ] for i in argsort ( list ( zip ( * self ) ) [ 1 ] ) [ : : - 1 ] [ : topn ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an aiosqlite cursor wrapping a sqlite3 cursor object .<CODESPLIT>async def cursor ( self ) -> Cursor : return Cursor ( self , await self . _execute ( self . _conn . cursor ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the largest contig for each strain : param contig_lengths_dict : dictionary of strain name : reverse - sorted list of all contig lengths : return : longest_contig_dict : dictionary of strain name : longest contig<CODESPLIT>def find_largest_contig ( contig_lengths_dict ) : # Initialise the dictionary longest_contig_dict = dict ( ) for file_name , contig_lengths in contig_lengths_dict . items ( ) : # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict [ file_name ] = contig_lengths [ 0 ] return longest_contig_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The maximum integer value of a value - set . It is only defined when there is exactly one region .<CODESPLIT>def max ( self ) : if len ( self . regions ) != 1 : raise ClaripyVSAOperationError ( "'max()' onlly works on single-region value-sets." ) return self . get_si ( next ( iter ( self . regions ) ) ) . max
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fast %Y - %m - %d parsing .<CODESPLIT>def parse_date ( s ) : try : return datetime . date ( int ( s [ : 4 ] ) , int ( s [ 5 : 7 ] ) , int ( s [ 8 : 10 ] ) ) except ValueError : # other accepted format used in one-day data set return datetime . datetime . strptime ( s , '%d %B %Y' ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list of coords for 3 points Compute the area of this triangle .<CODESPLIT>def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Match two names .<CODESPLIT>def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks to see if a 2D list is a valid 2D matrix<CODESPLIT>def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill an array from a list<CODESPLIT>def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize the string according to normalization list<CODESPLIT>def normalize ( self , string ) : return '' . join ( [ self . _normalize . get ( x , x ) for x in nfd ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns this programs current memory usage in bytes<CODESPLIT>def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the path from the root to node as a list of node names .<CODESPLIT>def _get_node_path ( self , node ) : path = [ ] while node . up : path . append ( node . name ) node = node . up return list ( reversed ( path ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bulk load docs<CODESPLIT>def bulk_load_docs ( es , docs ) : chunk_size = 200 try : results = elasticsearch . helpers . bulk ( es , docs , chunk_size = chunk_size ) log . debug ( f"Elasticsearch documents loaded: {results[0]}" ) # elasticsearch.helpers.parallel_bulk(es, terms, chunk_size=chunk_size, thread_count=4) if len ( results [ 1 ] ) > 0 : log . error ( "Bulk load errors {}" . format ( results ) ) except elasticsearch . ElasticsearchException as e : log . error ( "Indexing error: {}\n" . format ( e ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if key exists in datastore . True if yes False if no .<CODESPLIT>def check_key ( self , key : str ) -> bool : keys = self . get_keys ( ) return key in keys
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call this to give this Widget the input focus .<CODESPLIT>def focus ( self ) : self . _has_focus = True self . _frame . move_to ( self . _x , self . _y , self . _h ) if self . _on_focus is not None : self . _on_focus ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>View the quaternion array as an array of floats<CODESPLIT>def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Composes the passed filters into an and - joined filter .<CODESPLIT>def BROADCAST_FILTER_NOT ( func ) : return lambda u , command , * args , * * kwargs : not func ( u , command , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read and return a view of size bytes from memory starting at start_position .<CODESPLIT>def memory_read ( self , start_position : int , size : int ) -> memoryview : return self . _memory . read ( start_position , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dictionary of words and word counts in a string .<CODESPLIT>def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is the current OS a Windows?<CODESPLIT>def _platform_is_windows ( platform = sys . platform ) : matched = platform in ( 'cygwin' , 'win32' , 'win64' ) if matched : error_msg = "Windows isn't supported yet" raise OSError ( error_msg ) return matched
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the given time into HH : MM : SS<CODESPLIT>def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return "%02d:%02d:%02d" % ( h , m , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert special characters using %xx escape .<CODESPLIT>def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fill file at<CODESPLIT>def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Magic method dispatcher<CODESPLIT>def __getattr__ ( self , * args , * * kwargs ) : return xmlrpc . client . _Method ( self . __request , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if a value is numeric .<CODESPLIT>def is_numeric ( value ) : return type ( value ) in [ int , float , np . int8 , np . int16 , np . int32 , np . int64 , np . float16 , np . float32 , np . float64 , np . float128 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The function compares strings ignoring case<CODESPLIT>def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize .<CODESPLIT>def __init__ ( self , find , subcon ) : Subconstruct . __init__ ( self , subcon ) self . find = find
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes an object / rabalist from registery . This is useful if you want to allow the garbage collector to free the memory taken by the objects you ve already loaded . Be careful might cause some discrepenties in your scripts . For objects cascades to free the registeries of related rabalists also<CODESPLIT>def removeFromRegistery ( obj ) : if isRabaObject ( obj ) : _unregisterRabaObjectInstance ( obj ) elif isRabaList ( obj ) : _unregisterRabaListInstance ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Paste before cursor .<CODESPLIT>def yank ( event ) : event . current_buffer . paste_clipboard_data ( event . cli . clipboard . get_data ( ) , count = event . arg , paste_mode = PasteMode . EMACS )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if * path * is a directory<CODESPLIT>def isdir ( path , * * kwargs ) : import os . path return os . path . isdir ( path , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build a C ++ binary executable<CODESPLIT>def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of rows of the main dataframe<CODESPLIT>def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , "Can not count data" ) return return num
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the last NoteContainer in the Bar .<CODESPLIT>def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns number of wraps around given method .<CODESPLIT>def wrap_count ( method ) : number = 0 while hasattr ( method , '__aspects_orig' ) : number += 1 method = method . __aspects_orig return number
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructs a FastbootCommands instance .<CODESPLIT>def __init__ ( self , usb ) : self . _usb = usb self . _protocol = self . protocol_handler ( usb )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if unicode string only contains ASCII characters .<CODESPLIT>def unicode_is_ascii ( u_string ) : assert isinstance ( u_string , str ) try : u_string . encode ( 'ascii' ) return True except UnicodeEncodeError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given DataFrame has a column of the given name ( string ) and there exists at least one non - NaN value in that column ; return False otherwise .<CODESPLIT>def is_not_null ( df : DataFrame , col_name : str ) -> bool : if ( isinstance ( df , pd . DataFrame ) and col_name in df . columns and df [ col_name ] . notnull ( ) . any ( ) ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse a JSON string and build an entity .<CODESPLIT>def from_json ( cls , json_doc ) : try : d = json . load ( json_doc ) except AttributeError : # catch the read() error d = json . loads ( json_doc ) return cls . from_dict ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper to make map () behave the same on Py2 and Py3 .<CODESPLIT>def mmap ( func , iterable ) : if sys . version_info [ 0 ] > 2 : return [ i for i in map ( func , iterable ) ] else : return map ( func , iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to unpickle data from picklefile .<CODESPLIT>def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeros in the list of integers and returns a new list of integers<CODESPLIT>def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put curly brackets round an indented text<CODESPLIT>def dumped ( text , level , indent = 2 ) : return indented ( "{\n%s\n}" % indented ( text , level + 1 , indent ) or "None" , level , indent ) + "\n"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .<CODESPLIT>def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns files matched by all extensions in the extensions list<CODESPLIT>def glob_by_extensions ( directory , extensions ) : directorycheck ( directory ) files = [ ] xt = files . extend for ex in extensions : xt ( glob . glob ( '{0}/*.{1}' . format ( directory , ex ) ) ) return files
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean the previous generated files .<CODESPLIT>def cli ( ctx , project_dir ) : exit_code = SCons ( project_dir ) . clean ( ) ctx . exit ( exit_code )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the element with the highest probability .<CODESPLIT>def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Merge all the PDF files in pdf_filepaths in a new PDF file out_filepath .<CODESPLIT>def merge_pdfs ( pdf_filepaths , out_filepath ) : merger = PdfFileMerger ( ) for pdf in pdf_filepaths : merger . append ( PdfFileReader ( open ( pdf , 'rb' ) ) ) merger . write ( out_filepath ) return out_filepath
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns path to packaged static files<CODESPLIT>def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write GML comment .<CODESPLIT>def comment ( self , s , * * args ) : self . writeln ( s = u'comment "%s"' % s , * * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether the given platform is a Unix - like platform with the usual Unix filesystem . When the parameter is omitted it defaults to sys . platform<CODESPLIT>def is_unix_like ( platform = None ) : platform = platform or sys . platform platform = platform . lower ( ) return platform . startswith ( "linux" ) or platform . startswith ( "darwin" ) or platform . startswith ( "cygwin" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last object in file .<CODESPLIT>def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Drops and re - creates the SQL schema<CODESPLIT>def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Expand $vars in a string .<CODESPLIT>def _expand ( self , str , local_vars = { } ) : return ninja_syntax . expand ( str , self . vars , local_vars )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits<CODESPLIT>def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs drag a element to another elmenet .<CODESPLIT>def drag_and_drop ( self , droppable ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . drag_and_drop ( self . _element , droppable . _element ) . perform ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the console .<CODESPLIT>def clear ( ) : if sys . platform . startswith ( "win" ) : call ( "cls" , shell = True ) else : call ( "clear" , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns True if type represents C ++ array type False otherwise<CODESPLIT>def is_array ( type_ ) : nake_type = remove_alias ( type_ ) nake_type = remove_reference ( nake_type ) nake_type = remove_cv ( nake_type ) return isinstance ( nake_type , cpptypes . array_t )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check that a binary operator is surrounded by exactly one space .<CODESPLIT>def _check_surrounded_by_space ( self , tokens , i ) : self . _check_space ( tokens , i , ( _MUST , _MUST ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a flatten version of the nested argument<CODESPLIT>def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a python string to c array .<CODESPLIT>def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the table * name * exists in the database .<CODESPLIT>def has_table ( self , name ) : return len ( self . sql ( "SELECT name FROM sqlite_master WHERE type='table' AND name=?" , parameters = ( name , ) , asrecarray = False , cache = False ) ) > 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the Cython method header for methods without arguments except self .<CODESPLIT>def method_header ( method_name , nogil = False , idx_as_arg = False ) : if not config . FASTCYTHON : nogil = False header = 'cpdef inline void %s(self' % method_name header += ', int idx)' if idx_as_arg else ')' header += ' nogil:' if nogil else ':' return header
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prints the top n lines of a file<CODESPLIT>def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the passed variable is a tuple with two floats or integers<CODESPLIT>def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate standard deviation weighted by errors<CODESPLIT>def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves the dictionary in json format : param fname : file to save to<CODESPLIT>def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if value is an instance of float .<CODESPLIT>def test_value ( self , value ) : if not isinstance ( value , float ) : raise ValueError ( 'expected float value: ' + str ( type ( value ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is the same functionality as int . from_bytes in python 3<CODESPLIT>def _from_bytes ( bytes , byteorder = "big" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select rows where the given field is a member of the given value .<CODESPLIT>def selectin ( table , field , value , complement = False ) : return select ( table , field , lambda v : v in value , complement = complement )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def __PrintEnumDocstringLines ( self , enum_type ) : description = enum_type . description or '%s enum type.' % enum_type . name for line in textwrap . wrap ( 'r"""%s' % description , self . __printer . CalculateWidth ( ) ) : self . __printer ( line ) PrintIndentedDescriptions ( self . __printer , enum_type . values , 'Values' ) self . __printer ( '"""' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts bokehJS timestamp to datetime64 .<CODESPLIT>def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the nth value of array<CODESPLIT>def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the list of distinct values with preserving order .<CODESPLIT>def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .<CODESPLIT>def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if an item is iterable ( list tuple generator ) but not string<CODESPLIT>def _is_iterable ( item ) : return isinstance ( item , collections . Iterable ) and not isinstance ( item , six . string_types )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes an stdin input reader .<CODESPLIT>def __init__ ( self , encoding = 'utf-8' ) : super ( StdinInputReader , self ) . __init__ ( sys . stdin , encoding = encoding )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts an dict to a Enum .<CODESPLIT>def dict_to_enum_fn ( d : Dict [ str , Any ] , enum_class : Type [ Enum ] ) -> Enum : return enum_class [ d [ 'name' ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gather a list of proxies to use .<CODESPLIT>def _GetProxies ( self ) : # Detect proxies from the OS environment. result = client_utils . FindProxies ( ) # Also try to connect directly if all proxies fail. result . append ( "" ) # Also try all proxies configured in the config system. result . extend ( config . CONFIG [ "Client.proxy_servers" ] ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Imports from javascript source file . globals is your globals ()<CODESPLIT>def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , "r" , "utf-8" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clear the displayed image .<CODESPLIT>def clear ( self ) : self . _imgobj = None try : # See if there is an image on the canvas self . canvas . delete_object_by_tag ( self . _canvas_img_tag ) self . redraw ( ) except KeyError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Close log<CODESPLIT>def close_log ( log , verbose = True ) : if verbose : print ( 'Closing log file:' , log . name ) # Send closing message. log . info ( 'The log file has been closed.' ) # Remove all handlers from log. [ log . removeHandler ( handler ) for handler in log . handlers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format numpy array as a string .<CODESPLIT>def array2string ( arr : numpy . ndarray ) -> str : shape = str ( arr . shape ) [ 1 : - 1 ] if shape . endswith ( "," ) : shape = shape [ : - 1 ] return numpy . array2string ( arr , threshold = 11 ) + "%s[%s]" % ( arr . dtype , shape )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set y - axis limits of a subplot .<CODESPLIT>def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join the given iterable with<CODESPLIT>def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a vtk matrix to a numpy . ndarray<CODESPLIT>def trans_from_matrix ( matrix ) : t = np . zeros ( ( 4 , 4 ) ) for i in range ( 4 ) : for j in range ( 4 ) : t [ i , j ] = matrix . GetElement ( i , j ) return t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves a value to session .<CODESPLIT>def _session_set ( self , key , value ) : self . session [ self . _session_key ( key ) ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the request headers .<CODESPLIT>def __call__ ( self , r ) : r . headers [ 'Authorization' ] = 'JWT {jwt}' . format ( jwt = self . token ) return r
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls a procedure .<CODESPLIT>def callproc ( self , name , params , param_types = None ) : if param_types : placeholders = [ self . sql_writer . typecast ( self . sql_writer . to_placeholder ( ) , t ) for t in param_types ] else : placeholders = [ self . sql_writer . to_placeholder ( ) for p in params ] # TODO: This may be Postgres specific... qs = "select * from {0}({1});" . format ( name , ", " . join ( placeholders ) ) return self . execute ( qs , params ) , params
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes all files whose filename matches the glob pattern ( via : func : glob . glob ) .<CODESPLIT>def rmglob ( pattern : str ) -> None : for f in glob . glob ( pattern ) : os . remove ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Build query and passes to Elasticsearch then returns the raw format returned .<CODESPLIT>def raw ( self ) : es = self . get_es ( ) params = dict ( self . query_params ) mlt_fields = self . mlt_fields or params . pop ( 'mlt_fields' , [ ] ) body = self . s . build_search ( ) if self . s else '' hits = es . mlt ( index = self . index , doc_type = self . doctype , id = self . id , mlt_fields = mlt_fields , body = body , * * params ) log . debug ( hits ) return hits
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of characters in two strings that don t exactly match<CODESPLIT>def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a file from an AWS S3 bucket .<CODESPLIT>def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all unwanted characters from text .<CODESPLIT>def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the number of factor levels for each categorical column .<CODESPLIT>def nlevels ( self ) : levels = self . levels ( ) return [ len ( l ) for l in levels ] if levels else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Digits needed to comforatbly display values in [ minval maxval ]<CODESPLIT>def _digits ( minval , maxval ) : if minval == maxval : return 3 else : return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .<CODESPLIT>def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Under UNIX : is a keystroke available?<CODESPLIT>def _kbhit_unix ( ) -> bool : dr , dw , de = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return dr != [ ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>set colouring on if STDOUT is a terminal device off otherwise<CODESPLIT>def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the numpy dtype for the image<CODESPLIT>def _get_image_numpy_dtype ( self ) : try : ftype = self . _info [ 'img_equiv_type' ] npy_type = _image_bitpix2npy [ ftype ] except KeyError : raise KeyError ( "unsupported fits data type: %d" % ftype ) return npy_type
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict with swapped keys and values<CODESPLIT>def inverted_dict ( d ) : return dict ( ( force_hashable ( v ) , k ) for ( k , v ) in viewitems ( dict ( d ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the content of the zip - file at zip_path into target_folder .<CODESPLIT>def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield all items from iterable except the last one .<CODESPLIT>def butlast ( iterable ) : iterable = iter ( iterable ) try : first = next ( iterable ) except StopIteration : return for second in iterable : yield first first = second
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets path from query string<CODESPLIT>def get_path_from_query_string ( req ) : if req . args . get ( 'path' ) is None : raise exceptions . UserError ( 'Path not found in query string' ) return req . args . get ( 'path' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Builds sphinx docs from a given directory .<CODESPLIT>def build_docs ( directory ) : os . chdir ( directory ) process = subprocess . Popen ( [ "make" , "html" ] , cwd = directory ) process . communicate ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a QuerySet and the name of field containing datetimes return the latest ( most recent ) date .<CODESPLIT>def _latest_date ( self , query , datetime_field_name ) : return list ( query . aggregate ( django . db . models . Max ( datetime_field_name ) ) . values ( ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print the object s representation .<CODESPLIT>def pretty ( obj , verbose = False , max_width = 79 , newline = '\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return possible range for min function .<CODESPLIT>def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether a path names an existing executable file .<CODESPLIT>def is_executable ( path ) : return os . path . isfile ( path ) and os . access ( path , os . X_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the Poisson PMF .<CODESPLIT>def EvalPoissonPmf ( k , lam ) : # don't use the scipy function (yet).  for lam=0 it returns NaN; # should be 0.0 # return scipy.stats.poisson.pmf(k, lam) return lam ** k * math . exp ( - lam ) / math . factorial ( k )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply re . sub to bunch of ( pattern repl )<CODESPLIT>def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provide the root module of a TF - 2 . 0 API for use within TensorBoard .<CODESPLIT>def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>adds information to the sequence for better debugging currently only an index property on each point in the sequence .<CODESPLIT>def debug ( sequence ) : points = [ ] for i , p in enumerate ( sequence ) : copy = Point ( p ) copy [ 'index' ] = i points . append ( copy ) return sequence . __class__ ( points )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fast median operation for masked array using 50th - percentile<CODESPLIT>def fast_median ( a ) : a = checkma ( a ) #return scoreatpercentile(a.compressed(), 50) if a . count ( ) > 0 : out = np . percentile ( a . compressed ( ) , 50 ) else : out = np . ma . masked return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Intercept standard output in a with - context : return : cStringIO instance<CODESPLIT>def capture_stdout ( ) : stdout = sys . stdout sys . stdout = six . moves . cStringIO ( ) try : yield sys . stdout finally : sys . stdout = stdout
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Adds self as child of parent then adds parent .<CODESPLIT>def add_parent ( self , parent ) : parent . add_child ( self ) self . parent = parent return parent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return n size lists from a given list l<CODESPLIT>def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a tuple from parsing a b c d - > ( a b c d )<CODESPLIT>def _parse_tuple_string ( argument ) : if isinstance ( argument , str ) : return tuple ( int ( p . strip ( ) ) for p in argument . split ( ',' ) ) return argument
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Can edit this object<CODESPLIT>def has_edit_permission ( self , request ) : return request . user . is_authenticated and request . user . is_active and request . user . is_staff
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Push item onto heap maintaining the heap invariant .<CODESPLIT>def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>copy the dict filter_keywords<CODESPLIT>def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>\ Asserts that two iterables contain the same values .<CODESPLIT>def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if an item is iterable ( list tuple generator ) but not string<CODESPLIT>def _is_iterable ( item ) : return isinstance ( item , collections . Iterable ) and not isinstance ( item , six . string_types )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts any object to JSON - like readable format ready to be printed for debugging purposes : param obj : Any object : return : string<CODESPLIT>def get_object_as_string ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , list ) : return '\r\n\;' . join ( [ get_object_as_string ( item ) for item in obj ] ) attrs = vars ( obj ) as_string = ', ' . join ( "%s: %s" % item for item in attrs . items ( ) ) return as_string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>prints the top n lines of a file<CODESPLIT>def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list produced by applying : func : multiple_replace to every string in stringlist .<CODESPLIT>def replace_in_list ( stringlist : Iterable [ str ] , replacedict : Dict [ str , str ] ) -> List [ str ] : newlist = [ ] for fromstring in stringlist : newlist . append ( multiple_replace ( fromstring , replacedict ) ) return newlist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set value in the pandas DataFrame<CODESPLIT>def SetValue ( self , row , col , value ) : self . dataframe . iloc [ row , col ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert unix timestamp to human readable date / time string<CODESPLIT>def timestamp_to_datetime ( cls , dt , dt_format = DATETIME_FORMAT ) : return cls . convert_datetime ( cls . get_datetime ( dt ) , dt_format = dt_format )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get line count of file<CODESPLIT>def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return line ending .<CODESPLIT>def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>pops multiple keys off a dict like object<CODESPLIT>def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Changes volume<CODESPLIT>def setVolume ( self , volume ) : val = float ( val ) cmd = "volume %s" % val self . _execute ( cmd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def _ndarray_representer ( dumper , data ) : mapping = [ ( 'object' , data . tolist ( ) ) , ( 'dtype' , data . dtype . name ) ] return dumper . represent_mapping ( _NUMPY_ARRAY_TAG , mapping )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>List of GPU device names detected by TensorFlow .<CODESPLIT>def available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Within the dictionary d find a key that matches ( in case - insensitive fashion ) the key k and return it ( or None if there isn t one ) .<CODESPLIT>def get_case_insensitive_dict_key ( d : Dict , k : str ) -> Optional [ str ] : for key in d . keys ( ) : if k . lower ( ) == key . lower ( ) : return key return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix solve op .<CODESPLIT>def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Try to automatically detect an image field<CODESPLIT>def _image_field ( self ) : for field in self . model . _meta . fields : if isinstance ( field , ImageField ) : return field . name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression .<CODESPLIT>def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is a finite number .<CODESPLIT>def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validate input data with input schema .<CODESPLIT>def validate ( schema , data , owner = None ) : schema . _validate ( data = data , owner = owner )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if given filename is an image .<CODESPLIT>def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report effective gevent monkey patching on the logs .<CODESPLIT>def gevent_monkey_patch_report ( self ) : try : import gevent . socket import socket if gevent . socket . socket is socket . socket : self . log ( "gevent monkey patching is active" ) return True else : self . notify_user ( "gevent monkey patching failed." ) except ImportError : self . notify_user ( "gevent is not installed, monkey patching failed." ) return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conver a path string to a list of path elements .<CODESPLIT>def path_to_list ( pathstr ) : return [ elem for elem in pathstr . split ( os . path . pathsep ) if elem ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace regex with string .<CODESPLIT>def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the Webserver / SocketIO and app<CODESPLIT>def run ( context , port ) : global ctx ctx = context app . run ( port = port )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y<CODESPLIT>def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns Gaussian smoothed image .<CODESPLIT>def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = "nearest" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last n rows in the table<CODESPLIT>def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal random datetime generator .<CODESPLIT>def _rnd_datetime ( self , start , end ) : return self . from_utctimestamp ( random . randint ( int ( self . to_utctimestamp ( start ) ) , int ( self . to_utctimestamp ( end ) ) , ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute timestamp from a datetime object that could be timezone aware or unaware .<CODESPLIT>def timestamp_from_datetime ( dt ) : try : utc_dt = dt . astimezone ( pytz . utc ) except ValueError : utc_dt = dt . replace ( tzinfo = pytz . utc ) return timegm ( utc_dt . timetuple ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an instance using the launcher .<CODESPLIT>def create ( self , ami , count , config = None ) : return self . Launcher ( config = config ) . launch ( ami , count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I convert strings into integers floats and strings!<CODESPLIT>def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output<CODESPLIT>def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate n values between start and end .<CODESPLIT>def _xxrange ( self , start , end , step_count ) : _step = ( end - start ) / float ( step_count ) return ( start + ( i * _step ) for i in xrange ( int ( step_count ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialises a protobuf object as json<CODESPLIT>def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether we re in an interactive shell . Sets interactivity off if appropriate . cf http : // stackoverflow . com / questions / 24861351 / how - to - detect - if - python - script - is - being - run - as - a - background - process<CODESPLIT>def determine_interactive ( self ) : try : if not sys . stdout . isatty ( ) or os . getpgrp ( ) != os . tcgetpgrp ( sys . stdout . fileno ( ) ) : self . interactive = 0 return False except Exception : self . interactive = 0 return False if self . interactive == 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from list while preserving order .<CODESPLIT>def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return leading whitespace .<CODESPLIT>def get_indentation ( line ) : if line . strip ( ) : non_whitespace_index = len ( line ) - len ( line . lstrip ( ) ) return line [ : non_whitespace_index ] else : return ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates in a list .<CODESPLIT>def _uniquify ( _list ) : seen = set ( ) result = [ ] for x in _list : if x not in seen : result . append ( x ) seen . add ( x ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exit the shell session .<CODESPLIT>def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the index of elem in the reversed iterator .<CODESPLIT>def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Horizontally flip the given PIL Image .<CODESPLIT>def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provide a command prompt .<CODESPLIT>def input ( self , prompt , default = None , show_default = True ) : return click . prompt ( prompt , default = default , show_default = show_default )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new PSet with elements in iterable added<CODESPLIT>def update ( self , iterable ) : e = self . evolver ( ) for element in iterable : e . add ( element ) return e . persistent ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Query the configured LDAP server .<CODESPLIT>def search ( self , filterstr , attrlist ) : return self . _paged_search_ext_s ( self . settings . BASE , ldap . SCOPE_SUBTREE , filterstr = filterstr , attrlist = attrlist , page_size = self . settings . PAGE_SIZE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a Boto connection to the provided S3 bucket .<CODESPLIT>def s3_connect ( bucket_name , s3_access_key_id , s3_secret_key ) : conn = connect_s3 ( s3_access_key_id , s3_secret_key ) try : return conn . get_bucket ( bucket_name ) except S3ResponseError as e : if e . status == 403 : raise Exception ( "Bad Amazon S3 credentials." ) raise
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterative mean .<CODESPLIT>def average ( iterator ) : count = 0 total = 0 for num in iterator : count += 1 total += num return float ( total ) / count
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>expects a _n . array returns the global minimum of ( value - array ) ^2<CODESPLIT>def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create database tables from sqlalchemy models<CODESPLIT>def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return minimal quantum of a number as defined by precision .<CODESPLIT>def get_decimal_quantum ( precision ) : assert isinstance ( precision , ( int , decimal . Decimal ) ) return decimal . Decimal ( 10 ) ** ( - precision )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Spawns a kafka continuous consumer thread<CODESPLIT>def _spawn_kafka_consumer_thread ( self ) : self . logger . debug ( "Spawn kafka consumer thread" "" ) self . _consumer_thread = Thread ( target = self . _consumer_loop ) self . _consumer_thread . setDaemon ( True ) self . _consumer_thread . start ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a ctypes double pointer array to a numpy array .<CODESPLIT>def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute the given multiquery .<CODESPLIT>async def executemany ( self , sql : str , parameters : Iterable [ Iterable [ Any ] ] ) -> None : await self . _execute ( self . _cursor . executemany , sql , parameters )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if value can be part of binary / bitwise operations .<CODESPLIT>def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>quit || exit || q Stop and quit the current debugging session<CODESPLIT>def do_quit ( self , arg ) : for name , fh in self . _backup : setattr ( sys , name , fh ) self . console . writeline ( '*** Aborting program ***\n' ) self . console . flush ( ) self . console . close ( ) WebPdb . active_instance = None return Pdb . do_quit ( self , arg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets<CODESPLIT>def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>webargs error handler that uses Flask - RESTful s abort function to return a JSON error response to the client .<CODESPLIT>def handle_request_parsing_error ( err , req , schema , error_status_code , error_headers ) : abort ( error_status_code , errors = err . messages )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a single document from the collection this class is bound to . Additional arguments are processed according to _prepare_find prior to passing to PyMongo where positional parameters are interpreted as query fragments parametric keyword arguments combined and other keyword arguments passed along with minor transformation . Automatically calls to_mongo with the retrieved data . https : // api . mongodb . com / python / current / api / pymongo / collection . html#pymongo . collection . Collection . find_one<CODESPLIT>def find_one ( cls , * args , * * kw ) : if len ( args ) == 1 and not isinstance ( args [ 0 ] , Filter ) : args = ( getattr ( cls , cls . __pk__ ) == args [ 0 ] , ) Doc , collection , query , options = cls . _prepare_find ( * args , * * kw ) result = Doc . from_mongo ( collection . find_one ( query , * * options ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the progress ratio and percentage .<CODESPLIT>def ratio_and_percentage ( current , total , time_remaining ) : return "{} / {} ({}% completed)" . format ( current , total , int ( current / total * 100 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call a remote api method but don t raise if an error occurred .<CODESPLIT>def safe_call ( cls , method , * args ) : return cls . call ( method , * args , safe = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from a list while keeping order .<CODESPLIT>def dedup ( seq ) : seen = set ( ) for item in seq : if item not in seen : seen . add ( item ) yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the HEAD commit SHA1 of repository in current dir .<CODESPLIT>def get_last_commit ( git_path = None ) : if git_path is None : git_path = GIT_PATH line = get_last_commit_line ( git_path ) revision_id = line . split ( ) [ 1 ] return revision_id
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d delete d [ key ] if it exists .<CODESPLIT>def dictlist_wipe_key ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : d . pop ( key , None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all the database column names for the specified table .<CODESPLIT>def get_column_names ( engine : Engine , tablename : str ) -> List [ str ] : return [ info . name for info in gen_columns_info ( engine , tablename ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate the first value in each row .<CODESPLIT>def genfirstvalues ( cursor : Cursor , arraysize : int = 1000 ) -> Generator [ Any , None , None ] : return ( row [ 0 ] for row in genrows ( cursor , arraysize ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log in to instagram with given username and password and internally store session object .<CODESPLIT>def login ( self , user : str , passwd : str ) -> None : self . context . login ( user , passwd )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if given node is inside lambda<CODESPLIT>def is_inside_lambda ( node : astroid . node_classes . NodeNG ) -> bool : parent = node . parent while parent is not None : if isinstance ( parent , astroid . Lambda ) : return True parent = parent . parent return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compiles the given source from TypeScript to ES5 using TypescriptServices . js<CODESPLIT>def typescript_compile ( source ) : with open ( TS_COMPILER , 'r' ) as tsservices_js : return evaljs ( ( tsservices_js . read ( ) , 'ts.transpile(dukpy.tscode, {options});' . format ( options = TSC_OPTIONS ) ) , tscode = source )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator to explicitly mark functions that are exposed in a lib .<CODESPLIT>def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The function compares strings ignoring case<CODESPLIT>def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Is this a call with exactly 1 argument where that argument is positional?<CODESPLIT>def _is_one_arg_pos_call ( call ) : return isinstance ( call , astroid . Call ) and len ( call . args ) == 1 and not call . keywords
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the topmost parent of the current category .<CODESPLIT>def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Loads a model from specified file<CODESPLIT>def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a gzipped version of a previously opened file s buffer .<CODESPLIT>def get_gzipped_contents ( input_file ) : zbuf = StringIO ( ) zfile = GzipFile ( mode = "wb" , compresslevel = 6 , fileobj = zbuf ) zfile . write ( input_file . read ( ) ) zfile . close ( ) return ContentFile ( zbuf . getvalue ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Format a string for screen printing .<CODESPLIT>def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove duplicates from a sequence preserving order<CODESPLIT>def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a byte array into an integer array . The number of bytes forming an integer is defined by num<CODESPLIT>def convert_bytes_to_ints ( in_bytes , num ) : dt = numpy . dtype ( '>i' + str ( num ) ) return numpy . frombuffer ( in_bytes , dt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates .<CODESPLIT>def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process command line arguments and walk inputs .<CODESPLIT>def run ( args ) : raw_arguments = get_arguments ( args [ 1 : ] ) process_arguments ( raw_arguments ) walk . run ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove non - alphanumerical characters from metric word . And trim excessive underscores .<CODESPLIT>def sanitize_word ( s ) : s = re . sub ( '[^\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the last object in file .<CODESPLIT>def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate a service class for the service contained in the specified metadata class .<CODESPLIT>def build_service_class ( metadata ) : i = importlib . import_module ( metadata ) service = i . service env = get_jinja_env ( ) service_template = env . get_template ( 'service.py.jinja2' ) with open ( api_path ( service . name . lower ( ) ) , 'w' ) as t : t . write ( service_template . render ( service_md = service ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python 3 input () / Python 2 raw_input ()<CODESPLIT>def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get all unique links in the html of the page source . Page links include those obtained from : a - > href img - > src link - > href and script - > src .<CODESPLIT>def get_unique_links ( self ) : page_url = self . get_current_url ( ) soup = self . get_beautiful_soup ( self . get_page_source ( ) ) links = page_utils . _get_unique_links ( page_url , soup ) return links
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Downsample x by factor using striding .<CODESPLIT>def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a list of point objects ( which must have x and y fields ) . Returns a list of 3 - tuples : the indices of the points that form a Delaunay triangle .<CODESPLIT>def computeDelaunayTriangulation ( points ) : siteList = SiteList ( points ) context = Context ( ) context . triangulate = True voronoi ( siteList , context ) return context . triangles
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates data is a timestamp<CODESPLIT>def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve a simple OAuth Token for use with the local http client .<CODESPLIT>def get_oauth_token ( ) : url = "{0}/token" . format ( DEFAULT_ORIGIN [ "Origin" ] ) r = s . get ( url = url ) return r . json ( ) [ "t" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( Point Point ) - > Point Return the point that lies in between the two input points .<CODESPLIT>def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save object as json on CNS .<CODESPLIT>def save_json ( object , handle , indent = 2 ) : obj_json = json . dumps ( object , indent = indent , cls = NumpyJSONEncoder ) handle . write ( obj_json )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cast uint32 RGB image to 4 uint8 channels .<CODESPLIT>def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Snap coordinates on the grid with integer coordinates<CODESPLIT>def coords_on_grid ( self , x , y ) : if isinstance ( x , float ) : x = int ( self . _round ( x ) ) if isinstance ( y , float ) : y = int ( self . _round ( y ) ) if not self . _y_coord_down : y = self . _extents - y return x , y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert a ctypes structure to a dictionary<CODESPLIT>def struct2dict ( struct ) : return { x : getattr ( struct , x ) for x in dict ( struct . _fields_ ) . keys ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return manhattan distance between two lists of numbers .<CODESPLIT>def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove the last NoteContainer in the Bar .<CODESPLIT>def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds the longest path in a dag between two nodes<CODESPLIT>def dag_longest_path ( graph , source , target ) : if source == target : return [ source ] allpaths = nx . all_simple_paths ( graph , source , target ) longest_path = [ ] for l in allpaths : if len ( l ) > len ( longest_path ) : longest_path = l return longest_path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get distance between pairs of lat - lon points<CODESPLIT>def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix multiplication using binary<CODESPLIT>def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Let the DBMS perform a sum on a queryset<CODESPLIT>def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set of hyperparameters .<CODESPLIT>def transformer_ae_a3 ( ) : hparams = transformer_ae_base ( ) hparams . batch_size = 4096 hparams . layer_prepostprocess_dropout = 0.3 hparams . optimizer = "Adafactor" hparams . learning_rate = 0.25 hparams . learning_rate_warmup_steps = 10000 return hparams
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort input filename list by datetime<CODESPLIT>def sort_fn_list ( fn_list ) : dt_list = get_dt_list ( fn_list ) fn_list_sort = [ fn for ( dt , fn ) in sorted ( zip ( dt_list , fn_list ) ) ] return fn_list_sort
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>construct the model matrix columns for the term<CODESPLIT>def build_columns ( self , X , verbose = False ) : return sp . sparse . csc_matrix ( X [ : , self . feature ] [ : , np . newaxis ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calls a procedure .<CODESPLIT>def callproc ( self , name , params , param_types = None ) : if param_types : placeholders = [ self . sql_writer . typecast ( self . sql_writer . to_placeholder ( ) , t ) for t in param_types ] else : placeholders = [ self . sql_writer . to_placeholder ( ) for p in params ] # TODO: This may be Postgres specific... qs = "select * from {0}({1});" . format ( name , ", " . join ( placeholders ) ) return self . execute ( qs , params ) , params
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pop the heap value from the heap .<CODESPLIT>def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the pixel at ( x y ) to the integers in sequence color .<CODESPLIT>def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if list contains either values of type vtype or None .<CODESPLIT>def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the given time into HH : MM : SS<CODESPLIT>def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return "%02d:%02d:%02d" % ( h , m , s )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterable - first replacement of Python s built - in map () function .<CODESPLIT>def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a list of coords for 3 points Compute the area of this triangle .<CODESPLIT>def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a bool determining if the process is in a running state or not<CODESPLIT>def is_running ( self ) : return self . state in [ self . STATE_IDLE , self . STATE_ACTIVE , self . STATE_SLEEPING ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the moving average of an array .<CODESPLIT>def moving_average ( array , n = 3 ) : ret = _np . cumsum ( array , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Register service into the system . Called by Services .<CODESPLIT>def register_service ( self , service ) : if service not in self . services : self . services . append ( service )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an ExpMatrix containing all pairwise sample correlations .<CODESPLIT>def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .<CODESPLIT>def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call the handlers for the specified record .<CODESPLIT>async def handle ( self , record ) : if ( not self . disabled ) and self . filter ( record ) : await self . callHandlers ( record )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers<CODESPLIT>def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>tool to ensure input and output data have the same number of samples<CODESPLIT>def check_lengths ( * arrays ) : lengths = [ len ( array ) for array in arrays ] if len ( np . unique ( lengths ) ) > 1 : raise ValueError ( 'Inconsistent data lengths: {}' . format ( lengths ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple measure of similarity : Number of letters in common / max length<CODESPLIT>def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a dictionary of attributes in the DOT format<CODESPLIT>def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '"%s"="%s"' % item ) for item in sorted ( d . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if email is valid<CODESPLIT>def is_valid_email ( email ) : pattern = re . compile ( r'[\w\.-]+@[\w\.-]+[.]\w+' ) return bool ( pattern . match ( email ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handle keyboard interrupt and other errors .<CODESPLIT>def run ( self ) : try : self . run_checked ( ) except KeyboardInterrupt : thread . interrupt_main ( ) except Exception : self . internal_error ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Whether any of the strings contains any of the candidates .<CODESPLIT>def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Recieving the JSON file from uulm<CODESPLIT>def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( "utf-8" ) data = json . loads ( data ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the input filename with path is a file and is not empty .<CODESPLIT>def isfile_notempty ( inputfile : str ) -> bool : try : return isfile ( inputfile ) and getsize ( inputfile ) > 0 except TypeError : raise TypeError ( 'inputfile is not a valid type' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a name which includes the module name and function name .<CODESPLIT>def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For use with SELECT ( or SELECT - like PRAGMA ) statements .<CODESPLIT>def querySQL ( self , sql , args = ( ) ) : if self . debug : result = timeinto ( self . queryTimes , self . _queryandfetch , sql , args ) else : result = self . _queryandfetch ( sql , args ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print format some XML so it s readable .<CODESPLIT>def pp_xml ( body ) : pretty = xml . dom . minidom . parseString ( body ) return pretty . toprettyxml ( indent = "  " )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the dot product of the given vectors .<CODESPLIT>def dot_product ( self , other ) : return self . x * other . x + self . y * other . y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves and removes the first task from the heap .<CODESPLIT>def PopTask ( self ) : try : _ , task = heapq . heappop ( self . _heap ) except IndexError : return None self . _task_identifiers . remove ( task . identifier ) return task
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An iterable of column names for a particular table or view .<CODESPLIT>def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a datetime object and returns a string<CODESPLIT>def serialize ( self , value ) : if isinstance ( value , str ) : return value return value . strftime ( DATETIME_FORMAT )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert to float if object is a float string .<CODESPLIT>def _tofloat ( obj ) : if "inf" in obj . lower ( ) . strip ( ) : return obj try : return int ( obj ) except ValueError : try : return float ( obj ) except ValueError : return obj
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the value for key of membersuite_object_data .<CODESPLIT>def value_for_key ( membersuite_object_data , key ) : key_value_dicts = { d [ 'Key' ] : d [ 'Value' ] for d in membersuite_object_data [ "Fields" ] [ "KeyValueOfstringanyType" ] } return key_value_dicts [ key ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param tup : a list of tuples : param di : a dictionary converted from tup : return : dictionary<CODESPLIT>def _convert ( tup , dictlist ) : di = { } for a , b in tup : di . setdefault ( a , [ ] ) . append ( b ) for key , val in di . items ( ) : dictlist . append ( ( key , val ) ) return dictlist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all ( and only ) the chars in the given string .<CODESPLIT>def chars ( string : any ) -> str : return '' . join ( [ c if c . isalpha ( ) else '' for c in str ( string ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the flattened version of a 2D list . List - correlate to the a . flat () method of NumPy arrays .<CODESPLIT>def flat ( l ) : newl = [ ] for i in range ( len ( l ) ) : for j in range ( len ( l [ i ] ) ) : newl . append ( l [ i ] [ j ] ) return newl
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space .<CODESPLIT>def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Writes a file if it doesn t already exist with the same content .<CODESPLIT>def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( "Not overwriting {} because it is unchanged" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns the qth most probable element in the dawg .<CODESPLIT>def qth_pw ( self , q ) : return heapq . nlargest ( q + 2 , self . _T . iteritems ( ) , key = operator . itemgetter ( 1 ) ) [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a string ( string ) and a numeric base ( base ) decode the string into an integer .<CODESPLIT>def decode ( string , base ) : base = int ( base ) code_string = get_code_string ( base ) result = 0 if base == 16 : string = string . lower ( ) while len ( string ) > 0 : result *= base result += code_string . find ( string [ 0 ] ) string = string [ 1 : ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return relevant twitter timeline<CODESPLIT>def twitter_timeline ( screen_name , since_id = None ) : consumer_key = twitter_credential ( 'consumer_key' ) consumer_secret = twitter_credential ( 'consumer_secret' ) access_token = twitter_credential ( 'access_token' ) access_token_secret = twitter_credential ( 'access_secret' ) auth = tweepy . OAuthHandler ( consumer_key , consumer_secret ) auth . set_access_token ( access_token , access_token_secret ) api = tweepy . API ( auth ) return get_all_tweets ( screen_name , api , since_id )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the console .<CODESPLIT>def clear ( ) : if sys . platform . startswith ( "win" ) : call ( "cls" , shell = True ) else : call ( "clear" , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes SQL ; returns list of first values of each row .<CODESPLIT>def fetchallfirstvalues ( self , sql : str , * args ) -> List [ Any ] : rows = self . fetchall ( sql , * args ) return [ row [ 0 ] for row in rows ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Show a basic reference about the GUI Console .<CODESPLIT>def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Plot the empirical histogram versus best - fit distribution s PDF .<CODESPLIT>def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>takes a list of lists l and returns a flat list<CODESPLIT>def flatten_list ( l : List [ list ] ) -> list : return [ v for inner_l in l for v in inner_l ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Truncates a value to a number of decimals places<CODESPLIT>def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 )<CODESPLIT>def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a millisecond accuracy timestamp to a datetime<CODESPLIT>def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of characters at the beginning of text that are whitespace .<CODESPLIT>def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Current thread ident . If current thread is main thread then it returns None .<CODESPLIT>def threadid ( self ) : current = self . thread . ident main = get_main_thread ( ) if main is None : return current else : return current if current != main . ident else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserializes Java objects and primitive data serialized by ObjectOutputStream from a string .<CODESPLIT>def loads ( string ) : f = StringIO . StringIO ( string ) marshaller = JavaObjectUnmarshaller ( f ) marshaller . add_transformer ( DefaultObjectTransformer ( ) ) return marshaller . readObject ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if two objects are equal based on a comparison of the specified attributes attrs .<CODESPLIT>def simple_eq ( one : Instance , two : Instance , attrs : List [ str ] ) -> bool : return all ( getattr ( one , a ) == getattr ( two , a ) for a in attrs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to handle what to do when the stop button is pressed<CODESPLIT>def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging  if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a dictionary of attributes in the DOT format<CODESPLIT>def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '"%s"="%s"' % item ) for item in sorted ( d . items ( ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return manhattan distance between two lists of numbers .<CODESPLIT>def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if the filename exists under the path .<CODESPLIT>def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A dialog to get a directory name . Returns the name of a directory or None if user chose to cancel . If the default argument specifies a directory name and that directory exists then the dialog box will start with that directory .<CODESPLIT>def ask_folder ( message = 'Select folder.' , default = '' , title = '' ) : return backend_api . opendialog ( "ask_folder" , dict ( message = message , default = default , title = title ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get width and height of a PDF<CODESPLIT>def dimensions ( path ) : pdf = PdfFileReader ( path ) size = pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse ASDL from the given file and return a Module node describing it .<CODESPLIT>def parse ( filename ) : with open ( filename ) as f : parser = ASDLParser ( ) return parser . parse ( f . read ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a numpy array from a base64 buffer<CODESPLIT>def decode_arr ( data ) : data = data . encode ( 'utf-8' ) return frombuffer ( base64 . b64decode ( data ) , float64 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Counts the word frequences in a list of sentences .<CODESPLIT>def count_words ( file ) : c = Counter ( ) with open ( file , 'r' ) as f : for l in f : words = l . strip ( ) . split ( ) c . update ( words ) return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put curly brackets round an indented text<CODESPLIT>def dumped ( text , level , indent = 2 ) : return indented ( "{\n%s\n}" % indented ( text , level + 1 , indent ) or "None" , level , indent ) + "\n"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads an array from bytestring with big - endian data .<CODESPLIT>def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Last modified timestamp as a UTC datetime<CODESPLIT>def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads cplex file and returns glpk problem .<CODESPLIT>def glpk_read_cplex ( path ) : from swiglpk import glp_create_prob , glp_read_lp problem = glp_create_prob ( ) glp_read_lp ( problem , None , path ) return problem
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the width of the table including padding and borders .<CODESPLIT>def table_width ( self ) : outer_widths = max_dimensions ( self . table_data , self . padding_left , self . padding_right ) [ 2 ] outer_border = 2 if self . outer_border else 0 inner_border = 1 if self . inner_column_border else 0 return table_width ( outer_widths , outer_border , inner_border )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove an object from the bin folder .<CODESPLIT>def remove_from_lib ( self , name ) : self . __remove_path ( os . path . join ( self . root_dir , "lib" , name ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>detect if a model has a given field has<CODESPLIT>def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the log of the binomial coefficient .<CODESPLIT>def LogBinomialCoef ( n , k ) : return n * log ( n ) - k * log ( k ) - ( n - k ) * log ( n - k )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>start the bot<CODESPLIT>def run ( self , forever = True ) : loop = self . create_connection ( ) self . add_signal_handlers ( ) if forever : loop . run_forever ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate angle between two vectors<CODESPLIT>def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _infer_interval_breaks ( np . arange ( 5 )) array ( [ - 0 . 5 0 . 5 1 . 5 2 . 5 3 . 5 4 . 5 ] )<CODESPLIT>def _infer_interval_breaks ( coord ) : coord = np . asarray ( coord ) deltas = 0.5 * ( coord [ 1 : ] - coord [ : - 1 ] ) first = coord [ 0 ] - deltas [ 0 ] last = coord [ - 1 ] + deltas [ - 1 ] return np . r_ [ [ first ] , coord [ : - 1 ] + deltas , [ last ] ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate time delta from latched time and current time<CODESPLIT>def elapsed_time_from ( start_time ) : time_then = make_time ( start_time ) time_now = datetime . utcnow ( ) . replace ( microsecond = 0 ) if time_then is None : return delta_t = time_now - time_then return delta_t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the modified time for a file as a datetime instance<CODESPLIT>def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Probability density function ( normal distribution )<CODESPLIT>def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If output is string then print the string and also time used<CODESPLIT>def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Checks if l is iterable and contains only integral types<CODESPLIT>def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert datetime to epoch seconds .<CODESPLIT>def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if value is an integer .<CODESPLIT>def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .<CODESPLIT>def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Exponential function<CODESPLIT>def Exponential ( x , a , tau , y0 ) : return np . exp ( x / tau ) * a + y0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pyqt specific resize callback .<CODESPLIT>def resize ( self , width , height ) : if not self . fbo : return # pyqt reports sizes in actual buffer size self . width = width // self . widget . devicePixelRatio ( ) self . height = height // self . widget . devicePixelRatio ( ) self . buffer_width = width self . buffer_height = height super ( ) . resize ( width , height )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>a normal old python function to return the Nth fibonacci number .<CODESPLIT>def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a US format date and return epoch .<CODESPLIT>def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , "%m/%d/%Y" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Are two indexes equal? Checks by comparing str () versions of them . ( AM UNSURE IF THIS IS ENOUGH . )<CODESPLIT>def indexes_equal ( a : Index , b : Index ) -> bool : return str ( a ) == str ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict from entries in a scala . collection . immutable . Map<CODESPLIT>def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set foreground - and background colors and intensity .<CODESPLIT>def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cleans the column names on a DataFrame Parameters : df - DataFrame The DataFrame to clean<CODESPLIT>def clean_colnames ( df ) : col_list = [ ] for index in range ( _dutils . cols ( df ) ) : col_list . append ( df . columns [ index ] . strip ( ) . lower ( ) . replace ( ' ' , '_' ) ) df . columns = col_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a table row to a dictionary .<CODESPLIT>def row_to_dict ( row ) : o = { } for colname in row . colnames : if isinstance ( row [ colname ] , np . string_ ) and row [ colname ] . dtype . kind in [ 'S' , 'U' ] : o [ colname ] = str ( row [ colname ] ) else : o [ colname ] = row [ colname ] return o
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write text . An additional attribute terminator with a value of None is added to the logging record to indicate that StreamHandler should not add a newline .<CODESPLIT>def write ( self , text ) : self . logger . log ( self . loglevel , text , extra = { 'terminator' : None } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether this is a ( non - quantized ) integer type .<CODESPLIT>def is_integer ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_integer' ) : return dtype . is_integer return np . issubdtype ( np . dtype ( dtype ) , np . integer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the attribute name identifier<CODESPLIT>def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove a symlink . Used for model shortcut links .<CODESPLIT>def symlink_remove ( link ) : # https://stackoverflow.com/q/26554135/6400719 if os . path . isdir ( path2str ( link ) ) and is_windows : # this should only be on Py2.7 and windows os . rmdir ( path2str ( link ) ) else : os . unlink ( path2str ( link ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing zeroes from indexable collection of numbers<CODESPLIT>def __remove_trailing_zeros ( self , collection ) : index = len ( collection ) - 1 while index >= 0 and collection [ index ] == 0 : index -= 1 return collection [ : index + 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Runs command on the system with given args .<CODESPLIT>def run_command ( cmd , * args ) : command = ' ' . join ( ( cmd , args ) ) p = Popen ( command , shell = True , stdout = PIPE , stderr = PIPE ) stdout , stderr = p . communicate ( ) return p . retcode , stdout , stderr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve core and memory information for the current machine .<CODESPLIT>def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { "memory" : float ( "%.1f" % ( free_bytes / BYTES_IN_GIG ) ) , "cores" : multiprocessing . cpu_count ( ) , "name" : socket . gethostname ( ) } ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Joins a voice channel<CODESPLIT>async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print security object information for a pdf document<CODESPLIT>def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a position in a file which is known to be read & handled . It assumes a buffered file and streaming processing .<CODESPLIT>def get_known_read_position ( fp , buffered = True ) : buffer_size = io . DEFAULT_BUFFER_SIZE if buffered else 0 return max ( fp . tell ( ) - buffer_size , 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helpful in situations where browser / app may recognize Unicode encoding in the \ u0b8e type syntax but not actual unicode glyph / code - point<CODESPLIT>def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u"u'" + u"" . join ( [ u"\\u%04x" % ord ( l ) for l in _letter ] ) + u"'"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The fraction of n - grams matching between two sequences<CODESPLIT>def __similarity ( s1 , s2 , ngrams_fn , n = 3 ) : ngrams1 , ngrams2 = set ( ngrams_fn ( s1 , n = n ) ) , set ( ngrams_fn ( s2 , n = n ) ) matches = ngrams1 . intersection ( ngrams2 ) return 2 * len ( matches ) / ( len ( ngrams1 ) + len ( ngrams2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pads an image to a square then resamples to max_size<CODESPLIT>def pad_image ( arr , max_size = 400 ) : dim = np . max ( arr . shape ) img = np . zeros ( ( dim , dim , 3 ) , dtype = arr . dtype ) xl = ( dim - arr . shape [ 0 ] ) // 2 yl = ( dim - arr . shape [ 1 ] ) // 2 img [ xl : arr . shape [ 0 ] + xl , yl : arr . shape [ 1 ] + yl , : ] = arr return resample_image ( img , max_size = max_size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints the specified message and exits the program with the specified exit status .<CODESPLIT>def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bernstein polynomial .<CODESPLIT>def Bernstein ( n , k ) : coeff = binom ( n , k ) def _bpoly ( x ) : return coeff * x ** k * ( 1 - x ) ** ( n - k ) return _bpoly
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>append item and print it to stdout<CODESPLIT>def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a string to a string that is safe for a filename Args : string ( str ) : A string to make safe for a filename<CODESPLIT>def get_filename_safe_string ( string ) : invalid_filename_chars = [ '\\' , '/' , ':' , '"' , '*' , '?' , '|' , '\n' , '\r' ] if string is None : string = "None" for char in invalid_filename_chars : string = string . replace ( char , "" ) string = string . rstrip ( "." ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wraps the given dictionary such that the given fallback function will be called when a nonexistent key is accessed .<CODESPLIT>def _defaultdict ( dct , fallback = _illegal_character ) : out = defaultdict ( lambda : fallback ) for k , v in six . iteritems ( dct ) : out [ k ] = v return out
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get width of a string in the current font<CODESPLIT>def _string_width ( self , s ) : s = str ( s ) w = 0 for i in s : w += self . character_widths [ i ] return w * self . font_size / 1000.0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>area () - > number<CODESPLIT>def area ( self ) : area = 0.0 for segment in self . segments ( ) : area += ( ( segment . p . x * segment . q . y ) - ( segment . q . x * segment . p . y ) ) / 2 return area
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Configuration - friendly boolean type converter .<CODESPLIT>def boolean ( value ) : if isinstance ( value , bool ) : return value if value == "" : return False return strtobool ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a tif file to a 2D NumPy array<CODESPLIT>def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a python file and returns a awslambda . Code object : param python_file : : return :<CODESPLIT>def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\n' , lambda_function ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Prints the specified message and exits the program with the specified exit status .<CODESPLIT>def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if two pathes represent the same file .<CODESPLIT>def samefile ( a : str , b : str ) -> bool : try : return os . path . samefile ( a , b ) except OSError : return os . path . normpath ( a ) == os . path . normpath ( b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decorator to make sure that user is root .<CODESPLIT>def require_root ( fn ) : @ wraps ( fn ) def xex ( * args , * * kwargs ) : assert os . geteuid ( ) == 0 , "You have to be root to run function '%s'." % fn . __name__ return fn ( * args , * * kwargs ) return xex
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns file type for given file field . Args : field ( str ) : File field<CODESPLIT>def _file_type ( self , field ) : type = mimetypes . guess_type ( self . _files [ field ] ) [ 0 ] return type . encode ( "utf-8" ) if isinstance ( type , unicode ) else str ( type )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a Stripe API timestamp response ( unix epoch ) to a native datetime .<CODESPLIT>def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns day number of the last day of the month : param t : datetime : return : int<CODESPLIT>def get_last_day_of_month ( t : datetime ) -> int : tn = t + timedelta ( days = 32 ) tn = datetime ( year = tn . year , month = tn . month , day = 1 ) tt = tn - timedelta ( hours = 1 ) return tt . day
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helpful in situations where browser / app may recognize Unicode encoding in the \ u0b8e type syntax but not actual unicode glyph / code - point<CODESPLIT>def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u"u'" + u"" . join ( [ u"\\u%04x" % ord ( l ) for l in _letter ] ) + u"'"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Match and yield all the tokens of the input string .<CODESPLIT>def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if the folder exisits . If not create the folder<CODESPLIT>def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate equality between two ( Comparable ) objects .<CODESPLIT>def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread<CODESPLIT>async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .<CODESPLIT>def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a list a certain size<CODESPLIT>def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether a path names an existing executable file .<CODESPLIT>def is_executable ( path ) : return os . path . isfile ( path ) and os . access ( path , os . X_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute all tests ( normal and slow ) with coverage enabled .<CODESPLIT>def coverage ( ctx , opts = "" ) : return test ( ctx , coverage = True , include_slow = True , opts = opts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>autoscan will check all of the serial ports to see if they have a matching VID : PID for a MicroPython board .<CODESPLIT>def autoscan ( ) : for port in serial . tools . list_ports . comports ( ) : if is_micropython_usb_device ( port ) : connect_serial ( port [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a variation from a base value<CODESPLIT>def _gauss ( mean : int , sigma : int ) -> int : return int ( random . gauss ( mean , sigma ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Visualize the persistence image<CODESPLIT>def show ( self , imgs , ax = None ) : ax = ax or plt . gca ( ) if type ( imgs ) is not list : imgs = [ imgs ] for i , img in enumerate ( imgs ) : ax . imshow ( img , cmap = plt . get_cmap ( "plasma" ) ) ax . axis ( "off" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the log of the magnitude spectrum of frames<CODESPLIT>def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if a system process identifer exists in process table .<CODESPLIT>def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove arduino / examples / all directory .<CODESPLIT>def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates accuracy<CODESPLIT>def accuracy ( self ) : true_pos = self . matrix [ 0 ] [ 0 ] false_pos = self . matrix [ 1 ] [ 0 ] false_neg = self . matrix [ 0 ] [ 1 ] true_neg = self . matrix [ 1 ] [ 1 ] num = 1.0 * ( true_pos + true_neg ) den = true_pos + true_neg + false_pos + false_neg return divide ( num , den )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .<CODESPLIT>def energy_string_to_float ( string ) : energy_re = re . compile ( "(-?\d+\.\d+)" ) return float ( energy_re . match ( string ) . group ( 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip SGML / XML tags and replace adjacent whitespace by one space .<CODESPLIT>def do_striptags ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return Markup ( unicode ( value ) ) . striptags ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine if a file is empty or not .<CODESPLIT>def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return Jinja sbatch template for the current tag<CODESPLIT>def sbatch_template ( self ) : template = self . sbatch_template_str if template . startswith ( '#!' ) : # script is embedded in YAML return jinja_environment . from_string ( template ) return jinja_environment . get_template ( template )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the moving average ( rolling mean ) of an array of a certain window size .<CODESPLIT>def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if n is a prime number<CODESPLIT>def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redirect stdout back to the original stdout .<CODESPLIT>def __exit__ ( self , * args ) : sys . stdout = self . _orig self . _devnull . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>kill process Args : process - Popen object for process<CODESPLIT>def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>New event for light .<CODESPLIT>def async_update ( self , event ) : self . update_attr ( event . get ( 'state' , { } ) ) super ( ) . async_update ( event )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts Synergy Timestamp for session to UTC zone seconds since epoch<CODESPLIT>def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .<CODESPLIT>def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .<CODESPLIT>def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Bitwise xor on equal length bytearrays .<CODESPLIT>def xor ( a , b ) : return bytearray ( i ^ j for i , j in zip ( a , b ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the screen resolution of the primary screen .<CODESPLIT>def get_screen_resolution ( self ) : widget = QDesktopWidget ( ) geometry = widget . availableGeometry ( widget . primaryScreen ( ) ) return geometry . width ( ) , geometry . height ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return dict mapping item - > indices .<CODESPLIT>def _duplicates ( list_ ) : item_indices = { } for i , item in enumerate ( list_ ) : try : item_indices [ item ] . append ( i ) except KeyError : # First time seen item_indices [ item ] = [ i ] return item_indices
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns full ISO string for the given date<CODESPLIT>def to_iso_string ( self ) -> str : assert isinstance ( self . value , datetime ) return datetime . isoformat ( self . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Path join helper method Join paths if list passed<CODESPLIT>def prepare_path ( path ) : if type ( path ) == list : return os . path . join ( * path ) return path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a list of the REST API versions supported by the array<CODESPLIT>def _list_available_rest_versions ( self ) : url = "https://{0}/api/api_version" . format ( self . _target ) data = self . _request ( "GET" , url , reestablish_session = False ) return data [ "version" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract a de - duped collection ( set ) of text from a file . Expected file format is one item per line .<CODESPLIT>def read_set_from_file ( filename : str ) -> Set [ str ] : collection = set ( ) with open ( filename , 'r' ) as file_ : for line in file_ : collection . add ( line . rstrip ( ) ) return collection
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sample from independent normal distributions<CODESPLIT>def sample_normal ( mean , var , rng ) : ret = numpy . sqrt ( var ) * rng . randn ( * mean . shape ) + mean return ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of tuples describing a table into a HTML string<CODESPLIT>def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterative mean .<CODESPLIT>def average ( iterator ) : count = 0 total = 0 for num in iterator : count += 1 total += num return float ( total ) / count
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of names of columns that are string type .<CODESPLIT>def _get_str_columns ( sf ) : return [ name for name in sf . column_names ( ) if sf [ name ] . dtype == str ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>writes the line and count newlines after the line<CODESPLIT>def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split text into list of sentences .<CODESPLIT>def split_into_sentences ( s ) : s = re . sub ( r"\s+" , " " , s ) s = re . sub ( r"[\\.\\?\\!]" , "\n" , s ) return s . split ( "\n" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param fields : a list which contains either 0 1 or 2 values : return : a tuple with default values of ;<CODESPLIT>def _get_tuple ( self , fields ) : v1 = '' v2 = '' if len ( fields ) > 0 : v1 = fields [ 0 ] if len ( fields ) > 1 : v2 = fields [ 1 ] return v1 , v2
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run lint checks using flake8 .<CODESPLIT>def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if the pathname refers to an existing directory .<CODESPLIT>def isdir ( s ) : try : st = os . stat ( s ) except os . error : return False return stat . S_ISDIR ( st . st_mode )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pareses the address string into coordinates to match address_to_coords return object<CODESPLIT>def coords_string_parser ( self , coords ) : lat , lon = coords . split ( ',' ) return { "lat" : lat . strip ( ) , "lon" : lon . strip ( ) , "bounds" : { } }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>detect if a model has a given field has<CODESPLIT>def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Custom type for managing dates in the command - line .<CODESPLIT>def Date ( value ) : from datetime import datetime try : return datetime ( * reversed ( [ int ( val ) for val in value . split ( '/' ) ] ) ) except Exception as err : raise argparse . ArgumentTypeError ( "invalid date '%s'" % value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to FTP server login and return an ftplib . FTP instance .<CODESPLIT>def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the host s ip number .<CODESPLIT>def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( "8.8.8.8" , 80 ) ) except socket . gaierror : ip_ = "127.0.0.1" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Executes SQL ; returns the first value of the first row or None .<CODESPLIT>def fetchvalue ( self , sql : str , * args ) -> Optional [ Any ] : row = self . fetchone ( sql , * args ) if row is None : return None return row [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Process an iterable of dictionaries . For each dictionary d convert ( in place ) d [ key ] to a float . If that fails convert it to None .<CODESPLIT>def dictlist_convert_to_float ( dict_list : Iterable [ Dict ] , key : str ) -> None : for d in dict_list : try : d [ key ] = float ( d [ key ] ) except ValueError : d [ key ] = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves dictionary as CSV file .<CODESPLIT>def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test for greater than .<CODESPLIT>def __gt__ ( self , other ) : if isinstance ( other , Address ) : return str ( self ) > str ( other ) raise TypeError
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function to print messages on a single line in the terminal<CODESPLIT>def println ( msg ) : sys . stdout . write ( msg ) sys . stdout . flush ( ) sys . stdout . write ( '\x08' * len ( msg ) ) sys . stdout . flush ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Select a subset of features from the example dict .<CODESPLIT>def _select_features ( example , feature_list = None ) : feature_list = feature_list or [ "inputs" , "targets" ] return { f : example [ f ] for f in feature_list }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param l : List of strings to join : param arg : A pipe - separated list of final_join ( and ) and initial_join ( ) strings . For example : return : A string that grammatically concatenates the items in the list .<CODESPLIT>def _grammatical_join_filter ( l , arg = None ) : if not arg : arg = " and |, " try : final_join , initial_joins = arg . split ( "|" ) except ValueError : final_join = arg initial_joins = ", " return grammatical_join ( l , initial_joins , final_join )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove empty utterances from a list of utterances Args : utterances : The list of utterance we are processing<CODESPLIT>def remove_empty_text ( utterances : List [ Utterance ] ) -> List [ Utterance ] : return [ utter for utter in utterances if utter . text . strip ( ) != "" ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether a path names an existing directory we can list and read files from .<CODESPLIT>def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rate limit a function .<CODESPLIT>def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a name which includes the module name and function name .<CODESPLIT>def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the SSE to the cluster center<CODESPLIT>def _cal_dist2center ( X , center ) : dmemb2cen = scipy . spatial . distance . cdist ( X , center . reshape ( 1 , X . shape [ 1 ] ) , metric = 'seuclidean' ) return ( np . sum ( dmemb2cen ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Concatenate url and argument dictionary regardless of whether url has existing query parameters .<CODESPLIT>def url_concat ( url , args ) : if not args : return url if url [ - 1 ] not in ( '?' , '&' ) : url += '&' if ( '?' in url ) else '?' return url + urllib . urlencode ( args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket<CODESPLIT>def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Communicate with the child process without closing stdin .<CODESPLIT>def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes trailing whitespace on each line .<CODESPLIT>def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\n' ) ] return '\n' . join ( lines )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .<CODESPLIT>def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes a decimal price and rounds to a number of decimal places<CODESPLIT>def price_rounding ( price , decimals = 2 ) : try : exponent = D ( '.' + decimals * '0' ) except InvalidOperation : # Currencies with no decimal places, ex. JPY, HUF exponent = D ( ) return price . quantize ( exponent , rounding = ROUND_UP )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Finds common values<CODESPLIT>def find_commons ( lists ) : others = lists [ 1 : ] return [ val for val in lists [ 0 ] if is_in_all ( val , others ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an ISO - 8601 formatted string from the provided datetime object<CODESPLIT>def isoformat ( dt ) : if not isinstance ( dt , datetime . datetime ) : raise TypeError ( "Must provide datetime.datetime object to isoformat" ) if dt . tzinfo is None : raise ValueError ( "naive datetime objects are not allowed beyond the library boundaries" ) return dt . isoformat ( ) . replace ( "+00:00" , "Z" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return random lognormal variates .<CODESPLIT>def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generator of list folder in the path . folders only<CODESPLIT>def listfolderpath ( p ) : for entry in scandir . scandir ( p ) : if entry . is_dir ( ) : yield entry . path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join list of columns into a string for a SQL query<CODESPLIT>def join_cols ( cols ) : return ", " . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>matching of datetimes in time columns for data filtering<CODESPLIT>def datetime_match ( data , dts ) : dts = dts if islistable ( dts ) else [ dts ] if any ( [ not isinstance ( i , datetime . datetime ) for i in dts ] ) : error_msg = ( "`time` can only be filtered by datetimes" ) raise TypeError ( error_msg ) return data . isin ( dts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract table names from an SQL query .<CODESPLIT>def extract_table_names ( query ) : # a good old fashioned regex. turns out this worked better than actually parsing the code tables_blocks = re . findall ( r'(?:FROM|JOIN)\s+(\w+(?:\s*,\s*\w+)*)' , query , re . IGNORECASE ) tables = [ tbl for block in tables_blocks for tbl in re . findall ( r'\w+' , block ) ] return set ( tables )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decode the contents of a value from a serialized stream .<CODESPLIT>def decode_value ( stream ) : length = decode_length ( stream ) ( value , ) = unpack_value ( ">{:d}s" . format ( length ) , stream ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether a path names an existing directory we can list and read files from .<CODESPLIT>def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Filters given query with the below regex and returns lists of quoted and unquoted strings<CODESPLIT>def filter_query ( s ) : matches = re . findall ( r'(?:"([^"]*)")|([^"]*)' , s ) result_quoted = [ t [ 0 ] . strip ( ) for t in matches if t [ 0 ] ] result_unquoted = [ t [ 1 ] . strip ( ) for t in matches if t [ 1 ] ] return result_quoted , result_unquoted
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove instance from instance list<CODESPLIT>def pop ( ) : pid = os . getpid ( ) thread = threading . current_thread ( ) Wdb . _instances . pop ( ( pid , thread ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a Python object stored in a specified YAML file .<CODESPLIT>def ReadManyFromPath ( filepath ) : with io . open ( filepath , mode = "r" , encoding = "utf-8" ) as filedesc : return ReadManyFromFile ( filedesc )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to turn a string representation of true into boolean True .<CODESPLIT>def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializes a numpy array to a compressed base64 string<CODESPLIT>def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if file or directory is world writable .<CODESPLIT>def is_writable_by_others ( filename ) : mode = os . stat ( filename ) [ stat . ST_MODE ] return mode & stat . S_IWOTH
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a stream handler if it exists .<CODESPLIT>def find_console_handler ( logger ) : for handler in logger . handlers : if ( isinstance ( handler , logging . StreamHandler ) and handler . stream == sys . stderr ) : return handler
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional<CODESPLIT>def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a list of names of columns that are string type .<CODESPLIT>def _get_str_columns ( sf ) : return [ name for name in sf . column_names ( ) if sf [ name ] . dtype == str ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Does a string replace with a list of search and replacements<CODESPLIT>def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterates through each image in the given directory . ( not recursive ) : param dir_path : Directory path where images files are present : return : Iterator to iterate through image files<CODESPLIT>def each_img ( dir_path ) : for fname in os . listdir ( dir_path ) : if fname . endswith ( '.jpg' ) or fname . endswith ( '.png' ) or fname . endswith ( '.bmp' ) : yield fname
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>http : // stackoverflow . com / questions / 1230669 / subprocess - deleting - child - processes - in - windows<CODESPLIT>def _psutil_kill_pid ( pid ) : try : parent = Process ( pid ) for child in parent . children ( recursive = True ) : child . kill ( ) parent . kill ( ) except NoSuchProcess : return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses S3 URL .<CODESPLIT>def parse_s3_url ( url ) : bucket = '' path = '' if url : result = urlparse ( url ) bucket = result . netloc path = result . path . strip ( '/' ) return bucket , path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch a subset of randomzied GUIDs from the whitelist<CODESPLIT>def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>I strip extra whitespace off multi - line strings if they are ready to be stripped!<CODESPLIT>def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compress a file returning the new filename ( . gz )<CODESPLIT>def __gzip ( filename ) : zipname = filename + '.gz' file_pointer = open ( filename , 'rb' ) zip_pointer = gzip . open ( zipname , 'wb' ) zip_pointer . writelines ( file_pointer ) file_pointer . close ( ) zip_pointer . close ( ) return zipname
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a one element byte string to signed int for python 2 support .<CODESPLIT>def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( "b" , string ) [ 0 ] else : return struct . unpack ( "b" , bytes ( [ string ] ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert axis coordinate to bin index .<CODESPLIT>def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an ARF timestamp to a datetime . datetime object ( naive local time )<CODESPLIT>def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list into a space - separated string and puts it in a dictionary<CODESPLIT>def encode_list ( key , list_ ) : # type: (str, Iterable) -> Dict[str, str] if not list_ : return { } return { key : " " . join ( str ( i ) for i in list_ ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Inserts a horizontal ( commented ) line tot the generated code .<CODESPLIT>def _write_separator ( self ) : tmp = self . _page_width - ( ( 4 * self . __indent_level ) + 2 ) self . _write_line ( '# ' + ( '-' * tmp ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Iterate through all elements .<CODESPLIT>def __iter__ ( self ) : for value , count in self . counts ( ) : for _ in range ( count ) : yield value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from strings to integers<CODESPLIT>def str2int ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . str2int ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Argument class constructor should be used inside a class that inherits the BaseAction class .<CODESPLIT>def __init__ ( self , name , flag , * * kwargs ) : self . name = name self . flag = flag self . options = kwargs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new copied dictionary without the keys with None values from the given Mapping object .<CODESPLIT>def clean_map ( obj : Mapping [ Any , Any ] ) -> Mapping [ Any , Any ] : return { k : v for k , v in obj . items ( ) if v is not None }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Matrix multiplication using binary<CODESPLIT>def __rmatmul__ ( self , other ) : return self . T . dot ( np . transpose ( other ) ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( str ) - > int All the digits in a given string are concatenated and converted into a single number .<CODESPLIT>def try_cast_int ( s ) : try : temp = re . findall ( '\d' , str ( s ) ) temp = '' . join ( temp ) return int ( temp ) except : return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>View the quaternion array as an array of floats<CODESPLIT>def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>( Point Point ) - > Point Return the point that lies in between the two input points .<CODESPLIT>def _mid ( pt1 , pt2 ) : ( x0 , y0 ) , ( x1 , y1 ) = pt1 , pt2 return 0.5 * ( x0 + x1 ) , 0.5 * ( y0 + y1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>rounds float to closest int : rtype : int : param n : float<CODESPLIT>def proper_round ( n ) : return int ( n ) + ( n / abs ( n ) ) * int ( abs ( n - int ( n ) ) >= 0.5 ) if n != 0 else 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a list of strings to a list of integers .<CODESPLIT>def strings_to_integers ( strings : Iterable [ str ] ) -> Iterable [ int ] : return strings_to_ ( strings , lambda x : int ( float ( x ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove any duplicate item preserving order<CODESPLIT>def de_duplicate ( items ) : result = [ ] for item in items : if item not in result : result . append ( item ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a method from a given class or instance . When the method doest not exist it returns None . Also works with properties and cached properties .<CODESPLIT>def get_class_method ( cls_or_inst , method_name ) : cls = cls_or_inst if isinstance ( cls_or_inst , type ) else cls_or_inst . __class__ meth = getattr ( cls , method_name , None ) if isinstance ( meth , property ) : meth = meth . fget elif isinstance ( meth , cached_property ) : meth = meth . func return meth
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return an image with the binarised version of the data of img .<CODESPLIT>def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips zeros while handling - M and empty strings<CODESPLIT>def remove_leading_zeros ( num : str ) -> str : if not num : return num if num . startswith ( 'M' ) : ret = 'M' + num [ 1 : ] . lstrip ( '0' ) elif num . startswith ( '-' ) : ret = '-' + num [ 1 : ] . lstrip ( '0' ) else : ret = num . lstrip ( '0' ) return '0' if ret in ( '' , 'M' , '-' ) else ret
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .<CODESPLIT>def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly .<CODESPLIT>def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the number of ticks .<CODESPLIT>def ynticks ( self , nticks , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'nticks' ] = nticks return self
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shot noise corruption to images .<CODESPLIT>def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts array into chunks with consecutive elements of given step size . http : // stackoverflow . com / questions / 7352684 / how - to - find - the - groups - of - consecutive - elements - from - an - array - in - numpy<CODESPLIT>def consecutive ( data , stepsize = 1 ) : return np . split ( data , np . where ( np . diff ( data ) != stepsize ) [ 0 ] + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Quit signal handler .<CODESPLIT>def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( "\nSIGINT in frame signal received. Quitting..." ) sys . stdout . flush ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Validates that the object itself is some kinda string<CODESPLIT>def is_unicode ( string ) : str_type = str ( type ( string ) ) if str_type . find ( 'str' ) > 0 or str_type . find ( 'unicode' ) > 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The current position of the cursor .<CODESPLIT>def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if an item is iterable ( list tuple generator ) but not string<CODESPLIT>def _is_iterable ( item ) : return isinstance ( item , collections . Iterable ) and not isinstance ( item , six . string_types )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>str to bytes ( py3k )<CODESPLIT>def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set a float option .<CODESPLIT>def set_float ( self , option , value ) : if not isinstance ( value , float ) : raise TypeError ( "Value must be a float" ) self . options [ option ] = value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Take a US format date and return epoch .<CODESPLIT>def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , "%m/%d/%Y" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort data rows and order columns<CODESPLIT>def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Redirect the stdout<CODESPLIT>def redirect_stdout ( new_stdout ) : old_stdout , sys . stdout = sys . stdout , new_stdout try : yield None finally : sys . stdout = old_stdout
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .<CODESPLIT>def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Callback to go to the next tab . Called by the accel key .<CODESPLIT>def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Main entry point for assertions ( called by the wrapper ) . expect is a function the wrapper class uses to assert a given match .<CODESPLIT>def __call__ ( self , actual_value , expect ) : self . _expect = expect if self . expected_value is NO_ARG : return self . asserts ( actual_value ) return self . asserts ( actual_value , self . expected_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if obj is number .<CODESPLIT>def is_number ( obj ) : return isinstance ( obj , ( int , float , np . int_ , np . float_ ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a vector with the elements rounded to the given number of digits .<CODESPLIT>def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conveinience :<CODESPLIT>def get_tablenames ( cur ) : cur . execute ( "SELECT name FROM sqlite_master WHERE type='table'" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return n_clusters centroids of points<CODESPLIT>def _centroids ( n_clusters : int , points : List [ List [ float ] ] ) -> List [ List [ float ] ] : k_means = KMeans ( n_clusters = n_clusters ) k_means . fit ( points ) closest , _ = pairwise_distances_argmin_min ( k_means . cluster_centers_ , points ) return list ( map ( list , np . array ( points ) [ closest . tolist ( ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decodes the given JSON as primitives<CODESPLIT>def json_decode ( data ) : if isinstance ( data , six . binary_type ) : data = data . decode ( 'utf-8' ) return json . loads ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>converts a object to list if object is a list it creates a comma seperated string .<CODESPLIT>def _tostr ( self , obj ) : if not obj : return '' if isinstance ( obj , list ) : return ', ' . join ( map ( self . _tostr , obj ) ) return str ( obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Coerce value to an JSON - compatible representation .<CODESPLIT>def _date_to_json ( value ) : if isinstance ( value , datetime . date ) : value = value . isoformat ( ) return value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a name which includes the module name and function name .<CODESPLIT>def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Round a float to a precision<CODESPLIT>def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Upgrade all packages skip obsoletes if obsoletes = 0 in yum . conf .<CODESPLIT>def update ( kernel = False ) : manager = MANAGER cmds = { 'yum -y --color=never' : { False : '--exclude=kernel* update' , True : 'update' } } cmd = cmds [ manager ] [ kernel ] run_as_root ( "%(manager)s %(cmd)s" % locals ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is builtin in python2 but we have to roll our own on py3 .<CODESPLIT>def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return whether num is a power of two<CODESPLIT>def is_power_of_2 ( num ) : log = math . log2 ( num ) return int ( log ) == float ( log )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the longest string size for a string entry across data .<CODESPLIT>def _prm_get_longest_stringsize ( string_list ) : maxlength = 1 for stringar in string_list : if isinstance ( stringar , np . ndarray ) : if stringar . ndim > 0 : for string in stringar . ravel ( ) : maxlength = max ( len ( string ) , maxlength ) else : maxlength = max ( len ( stringar . tolist ( ) ) , maxlength ) else : maxlength = max ( len ( stringar ) , maxlength ) # Make the string Col longer than needed in order to allow later on slightly larger strings return int ( maxlength * 1.5 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts list of tuples to dictionary with duplicate keys converted to lists .<CODESPLIT>def items_to_dict ( items ) : res = collections . defaultdict ( list ) for k , v in items : res [ k ] . append ( v ) return normalize_dict ( dict ( res ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reconnect to rabbitmq server<CODESPLIT>def reconnect ( self ) : import pika import pika . exceptions self . connection = pika . BlockingConnection ( pika . URLParameters ( self . amqp_url ) ) self . channel = self . connection . channel ( ) try : self . channel . queue_declare ( self . name ) except pika . exceptions . ChannelClosed : self . connection = pika . BlockingConnection ( pika . URLParameters ( self . amqp_url ) ) self . channel = self . connection . channel ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Copy text to clipboard without prompts<CODESPLIT>def copy_without_prompts ( self ) : text = self . get_selected_text ( ) lines = text . split ( os . linesep ) for index , line in enumerate ( lines ) : if line . startswith ( '>>> ' ) or line . startswith ( '... ' ) : lines [ index ] = line [ 4 : ] text = os . linesep . join ( lines ) QApplication . clipboard ( ) . setText ( text )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load a python module from its absolute filesystem path<CODESPLIT>def load_from_file ( module_path ) : from imp import load_module , PY_SOURCE imported = None if module_path : with open ( module_path , 'r' ) as openfile : imported = load_module ( 'mod' , openfile , module_path , ( 'imported' , 'r' , PY_SOURCE ) ) return imported
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete a mongo document collection using pymongo . Mongo daemon assumed to be running .<CODESPLIT>def delete_collection ( mongo_uri , database_name , collection_name ) : client = pymongo . MongoClient ( mongo_uri ) db = client [ database_name ] db . drop_collection ( collection_name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Efficient conversion from scipy sparse matrix to cvxopt sparse matrix<CODESPLIT>def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parses hostname from URL . : param url : URL : return : hostname<CODESPLIT>def url_host ( url : str ) -> str : from urllib . parse import urlparse res = urlparse ( url ) return res . netloc . split ( ':' ) [ 0 ] if res . netloc else ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return lines of a file with whitespace removed<CODESPLIT>def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( "Could not open file: {!r}" . format ( filename ) ) return [ line . strip ( ) for line in lines ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a string of the form [ basename - TIMESTAMP . ext ] where TIMESTAMP is of the form YYYYMMDD - HHMMSS - MILSEC<CODESPLIT>def timestamp_filename ( basename , ext = None ) : dt = datetime . now ( ) . strftime ( '%Y%m%d-%H%M%S-%f' ) if ext : return '%s-%s.%s' % ( basename , dt , ext ) return '%s-%s' % ( basename , dt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serialize the query to a structure using the query DSL .<CODESPLIT>def serialize ( self ) : data = { 'doc' : self . doc } if isinstance ( self . query , Query ) : data [ 'query' ] = self . query . serialize ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Split a text into a list of tokens .<CODESPLIT>def split ( text : str ) -> List [ str ] : return [ word for word in SEPARATOR . split ( text ) if word . strip ( ' \t' ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pad a matrix with zeros on all sides .<CODESPLIT>def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fetch a subset of randomzied GUIDs from the whitelist<CODESPLIT>def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print at most limit elements of list .<CODESPLIT>def _brief_print_list ( lst , limit = 7 ) : lst = list ( lst ) if len ( lst ) > limit : return _brief_print_list ( lst [ : limit // 2 ] , limit ) + ', ..., ' + _brief_print_list ( lst [ - limit // 2 : ] , limit ) return ', ' . join ( [ "'%s'" % str ( i ) for i in lst ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply function to specified field of effect if it is not None otherwise return default .<CODESPLIT>def apply_to_field_if_exists ( effect , field_name , fn , default ) : value = getattr ( effect , field_name , None ) if value is None : return default else : return fn ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Write a dict to a JSON file .<CODESPLIT>def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a new raw REST interface to stats resources<CODESPLIT>def stats ( self ) : import ns1 . rest . stats return ns1 . rest . stats . Stats ( self . config )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Maps values to bins Args : values ( list or list of lists ) - list of values to map to colors res ( int ) - resolution of the color map ( default : 100 ) Returns : list of numbers representing bins<CODESPLIT>def vals2bins ( vals , res = 100 ) : # flatten if list of lists if any ( isinstance ( el , list ) for el in vals ) : vals = list ( itertools . chain ( * vals ) ) return list ( np . digitize ( vals , np . linspace ( np . min ( vals ) , np . max ( vals ) + 1 , res + 1 ) ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrapper for session . request Handle connection reset error even from pyopenssl<CODESPLIT>def send_request ( self , * args , * * kwargs ) : try : return self . session . request ( * args , * * kwargs ) except ConnectionError : self . session . close ( ) return self . session . request ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a Python date that corresponds to the specified string representation .<CODESPLIT>def string_to_date ( value ) : if isinstance ( value , datetime . date ) : return value return dateutil . parser . parse ( value ) . date ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if there s something to read on stdin ( posix version ) .<CODESPLIT>def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For a single index and return the value<CODESPLIT>def get_cell ( self , index ) : i = sorted_index ( self . _index , index ) if self . _sort else self . _index . index ( index ) return self . _data [ i ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when closing this window .<CODESPLIT>def closeEvent ( self , event ) : logger . debug ( "closeEvent" ) self . argosApplication . saveSettingsIfNeeded ( ) self . finalize ( ) self . argosApplication . removeMainWindow ( self ) event . accept ( ) logger . debug ( "closeEvent accepted" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initialize an API .<CODESPLIT>def initialize_api ( flask_app ) : if not flask_restplus : return api = flask_restplus . Api ( version = "1.0" , title = "My Example API" ) api . add_resource ( HelloWorld , "/hello" ) blueprint = flask . Blueprint ( "api" , __name__ , url_prefix = "/api" ) api . init_app ( blueprint ) flask_app . register_blueprint ( blueprint )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be an iterable ( list array tuple )<CODESPLIT>def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reverse sorts a #dict by a given key optionally returning it as a #tuple . By default the @dict is sorted by it s value .<CODESPLIT>def revrank_dict ( dict , key = lambda t : t [ 1 ] , as_tuple = False ) : sorted_list = sorted ( dict . items ( ) , key = key , reverse = True ) return OrderedDict ( sorted_list ) if not as_tuple else tuple ( sorted_list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a JavaRDD of Object by unpickling<CODESPLIT>def _to_java_object_rdd ( rdd ) : rdd = rdd . _reserialize ( AutoBatchedSerializer ( PickleSerializer ( ) ) ) return rdd . ctx . _jvm . org . apache . spark . mllib . api . python . SerDe . pythonToJava ( rdd . _jrdd , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print out a log message only if verbose mode .<CODESPLIT>def logv ( msg , * args , * * kwargs ) : if settings . VERBOSE : log ( msg , * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from list while preserving order .<CODESPLIT>def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Serializes a K8S resource to YAML - formatted file .<CODESPLIT>def serialize_yaml_tofile ( filename , resource ) : stream = file ( filename , "w" ) yaml . dump ( resource , stream , default_flow_style = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if a given file is available in the cache or not<CODESPLIT>def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Read a WAV file and returns the data and sample rate<CODESPLIT>def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>write back json response<CODESPLIT>def write_json_response ( self , response ) : self . write ( tornado . escape . json_encode ( response ) ) self . set_header ( "Content-Type" , "application/json" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The Euclidean distance between two vectors .<CODESPLIT>def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from an iterable preserving the order .<CODESPLIT>def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response .<CODESPLIT>def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == "POST" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == "OPTIONS" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Called when a new DropDownItem gets selected .<CODESPLIT>def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get milliseconds from a timedelta .<CODESPLIT>def timedelta2millisecond ( td ) : milliseconds = td . days * 24 * 60 * 60 * 1000 milliseconds += td . seconds * 1000 milliseconds += td . microseconds / 1000 return milliseconds
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse datetime .<CODESPLIT>def parse_datetime ( dt_str ) : date_format = "%Y-%m-%dT%H:%M:%S %z" dt_str = dt_str . replace ( "Z" , " +0000" ) return datetime . datetime . strptime ( dt_str , date_format )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>append item and print it to stdout<CODESPLIT>def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update the column width .<CODESPLIT>def _column_resized ( self , col , old_width , new_width ) : self . dataTable . setColumnWidth ( col , new_width ) self . _update_layout ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Conveinience :<CODESPLIT>def get_tablenames ( cur ) : cur . execute ( "SELECT name FROM sqlite_master WHERE type='table'" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the day name<CODESPLIT>def get_day_name ( self ) -> str : weekday = self . value . isoweekday ( ) - 1 return calendar . day_name [ weekday ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove duplicates from list while preserving order .<CODESPLIT>def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Method to extract keywords from the text provided .<CODESPLIT>def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For Python3 compatibility of generator .<CODESPLIT>def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strip the whitespace from all column names in the given DataFrame and return the result .<CODESPLIT>def clean_column_names ( df : DataFrame ) -> DataFrame : f = df . copy ( ) f . columns = [ col . strip ( ) for col in f . columns ] return f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the shape of img .<CODESPLIT>def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Locate the command s man page .<CODESPLIT>def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current mouse location ( coordinates and screen number ) .<CODESPLIT>def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determine the number of leaves in a tree<CODESPLIT>def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>unicode to bytes<CODESPLIT>def u2b ( string ) : if ( ( PY2 and isinstance ( string , unicode ) ) or ( ( not PY2 ) and isinstance ( string , str ) ) ) : return string . encode ( 'utf-8' ) return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a comma separated string to a list<CODESPLIT>def _str_to_list ( s ) : _list = s . split ( "," ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a new dict from an existing dict that only has the given keys<CODESPLIT>def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a key from S3<CODESPLIT>def read_key ( self , key , bucket_name = None ) : obj = self . get_key ( key , bucket_name ) return obj . get ( ) [ 'Body' ] . read ( ) . decode ( 'utf-8' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Provide the root module of a TF - 2 . 0 API for use within TensorBoard .<CODESPLIT>def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def stdoutwriteline ( * args ) : s = "" for i in args : s += str ( i ) + " " s = s . strip ( ) sys . stdout . write ( str ( s ) + "\n" ) sys . stdout . flush ( ) return s
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return unix SECOND timestamp of num mondays ago<CODESPLIT>def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Slicing op .<CODESPLIT>def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Query device for all attributes that exist regardless of power state .<CODESPLIT>def refresh_core ( self ) : self . log . info ( 'Sending out mass query for all attributes' ) for key in ATTR_CORE : self . query ( key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Execute all tests ( normal and slow ) with coverage enabled .<CODESPLIT>def coverage ( ctx , opts = "" ) : return test ( ctx , coverage = True , include_slow = True , opts = opts )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokenizes * source * and returns the tokens as a list of lists .<CODESPLIT>def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Constructs an object holding a datetime / timestamp value .<CODESPLIT>def Timestamp ( year , month , day , hour , minute , second ) : return datetime . datetime ( year , month , day , hour , minute , second )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an ExpMatrix containing all pairwise sample correlations .<CODESPLIT>def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Put an object into a ftps URL .<CODESPLIT>def write ( url , content , * * args ) : with FTPSResource ( url , * * args ) as resource : resource . write ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if value is an integer long integer or float .<CODESPLIT>def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>manipulate json data on the fly<CODESPLIT>def set_json_item ( key , value ) : data = get_json ( ) data [ key ] = value request = get_request ( ) request [ "BODY" ] = json . dumps ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Verifies that a string path actually exists and is a file<CODESPLIT>def valid_file ( path : str ) -> bool : path = Path ( path ) . expanduser ( ) log . debug ( "checking if %s is a valid file" , path ) return path . exists ( ) and path . is_file ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create a folder recursive .<CODESPLIT>def create_dir_rec ( path : Path ) : if not path . exists ( ) : Path . mkdir ( path , parents = True , exist_ok = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>generic plotting method overplotting any existing plot<CODESPLIT>def oplot ( self , x , y , * * kw ) : self . panel . oplot ( x , y , * * kw )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The function compares strings ignoring case<CODESPLIT>def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return boolean sequence or scalar indicating whether each string in the sequence or scalar starts with passed pattern . Equivalent to str . startswith () .<CODESPLIT>def _startswith ( expr , pat ) : return _string_op ( expr , Startswith , output_type = types . boolean , _pat = pat )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>For list values returns the index location of element x . If x does not exist will raise an error .<CODESPLIT>def sorted_index ( values , x ) : i = bisect_left ( values , x ) j = bisect_right ( values , x ) return values [ i : j ] . index ( x ) + i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return grandparent s path string<CODESPLIT>def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes // - comments and single - line C - style / * * / comments .<CODESPLIT>def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param str s : string with tabs : param str replace : e . g . 4 spaces : rtype : str<CODESPLIT>def replace_tab_indent ( s , replace = "    " ) : prefix = get_indent_prefix ( s ) return prefix . replace ( "\t" , replace ) + s [ len ( prefix ) : ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the number of widgets currently displayed ( takes child splits into account ) .<CODESPLIT>def count ( self ) : c = self . main_tab_widget . count ( ) for child in self . child_splitters : c += child . count ( ) return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replace regex with string .<CODESPLIT>def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the encoding type .<CODESPLIT>def get_encoding ( binary ) : try : from chardet import detect except ImportError : LOGGER . error ( "Please install the 'chardet' module" ) sys . exit ( 1 ) encoding = detect ( binary ) . get ( 'encoding' ) return 'iso-8859-1' if encoding == 'CP949' else encoding
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return unique list of iterable items preserving order .<CODESPLIT>def uniqued ( iterable ) : seen = set ( ) return [ item for item in iterable if item not in seen and not seen . add ( item ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Private method for setting axis limits .<CODESPLIT>def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lookup country for IP address .<CODESPLIT>def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Detects whether a line is present within a file .<CODESPLIT>def is_line_in_file ( filename : str , line : str ) -> bool : assert "\n" not in line with open ( filename , "r" ) as file : for fileline in file : if fileline == line : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dict where the keys are all the values listed in the values of the original dict<CODESPLIT>def inverted_dict_of_lists ( d ) : new_dict = { } for ( old_key , old_value_list ) in viewitems ( dict ( d ) ) : for new_key in listify ( old_value_list ) : new_dict [ new_key ] = old_key return new_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>autoscan will check all of the serial ports to see if they have a matching VID : PID for a MicroPython board .<CODESPLIT>def autoscan ( ) : for port in serial . tools . list_ports . comports ( ) : if is_micropython_usb_device ( port ) : connect_serial ( port [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if user answers y<CODESPLIT>def yesno ( prompt ) : prompt += " [y/n]" a = "" while a not in [ "y" , "n" ] : a = input ( prompt ) . lower ( ) return a == "y"
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple function to add two numbers<CODESPLIT>def generic_add ( a , b ) : logger . debug ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieves the Python library directory path .<CODESPLIT>def GetPythonLibraryDirectoryPath ( ) : path = sysconfig . get_python_lib ( True ) _ , _ , path = path . rpartition ( sysconfig . PREFIX ) if path . startswith ( os . sep ) : path = path [ 1 : ] return path
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current time .<CODESPLIT>def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( "%Y-%m-%d %H:%M:%S" ) return datetime . datetime . now ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Truncates a value to a number of decimals places<CODESPLIT>def truncate ( value : Decimal , n_digits : int ) -> Decimal : return Decimal ( math . trunc ( value * ( 10 ** n_digits ) ) ) / ( 10 ** n_digits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>add the field with endianness to the buffer<CODESPLIT>def addfield ( self , pkt , buf , val ) : self . set_endianess ( pkt ) return self . fld . addfield ( pkt , buf , val )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rounds a float value off to the desired precision<CODESPLIT>def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get distance matrix given a matrix . Used in testing .<CODESPLIT>def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a version of the query string with the _e _k and _s values removed .<CODESPLIT>def filter_query_string ( query ) : return '&' . join ( [ q for q in query . split ( '&' ) if not ( q . startswith ( '_k=' ) or q . startswith ( '_e=' ) or q . startswith ( '_s' ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return all child objects in nested dict .<CODESPLIT>def as_dict ( self ) : dicts = [ x . as_dict for x in self . children ] return { '{0} {1}' . format ( self . name , self . value ) : dicts }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Free the underlying C array<CODESPLIT>def free ( self ) : if self . _ptr is None : return Gauged . array_free ( self . ptr ) FloatArray . ALLOCATIONS -= 1 self . _ptr = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes a filter object .<CODESPLIT>def __init__ ( self ) : super ( FilterObject , self ) . __init__ ( ) self . _filter_expression = None self . _matcher = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates the Jaccard similarity between two sets of nodes . Called by mroc .<CODESPLIT>def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set cursor position<CODESPLIT>def set_cursor_position ( self , position ) : position = self . get_position ( position ) cursor = self . textCursor ( ) cursor . setPosition ( position ) self . setTextCursor ( cursor ) self . ensureCursorVisible ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>convert a ctypes structure to a dictionary<CODESPLIT>def struct2dict ( struct ) : return { x : getattr ( struct , x ) for x in dict ( struct . _fields_ ) . keys ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Display the difference between modules in a file and imported modules .<CODESPLIT>def diff ( file_ , imports ) : modules_not_imported = compare_modules ( file_ , imports ) logging . info ( "The following modules are in {} but do not seem to be imported: " "{}" . format ( file_ , ", " . join ( x for x in modules_not_imported ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: return : int<CODESPLIT>def __next__ ( self ) : self . current += 1 if self . current > self . total : raise StopIteration else : return self . iterable [ self . current - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns whether a path names an existing executable file .<CODESPLIT>def is_executable ( path ) : return os . path . isfile ( path ) and os . access ( path , os . X_OK )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Connect to FTP server login and return an ftplib . FTP instance .<CODESPLIT>def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last location of the minimal value of x . The position is calculated relatively to the length of x .<CODESPLIT>def last_location_of_minimum ( x ) : x = np . asarray ( x ) return 1.0 - np . argmin ( x [ : : - 1 ] ) / len ( x ) if len ( x ) > 0 else np . NaN
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove multiple elements from a list and return result . This implementation is faster than the alternative below . Also note the creation of a new list to avoid altering the original . We don t have any current use for the original intact list but may in the future ...<CODESPLIT>def remove_elements ( target , indices ) : copied = list ( target ) for index in reversed ( indices ) : del copied [ index ] return copied
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Small transformer model with small batch size for fast step times .<CODESPLIT>def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets a HTTP header for future requests .<CODESPLIT>def set_header ( self , key , value ) : self . conn . issue_command ( "Header" , _normalize_header ( key ) , value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Continuous constant pulse .<CODESPLIT>def constant ( times : np . ndarray , amp : complex ) -> np . ndarray : return np . full ( len ( times ) , amp , dtype = np . complex_ )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract table names from an SQL query .<CODESPLIT>def extract_table_names ( query ) : # a good old fashioned regex. turns out this worked better than actually parsing the code tables_blocks = re . findall ( r'(?:FROM|JOIN)\s+(\w+(?:\s*,\s*\w+)*)' , query , re . IGNORECASE ) tables = [ tbl for block in tables_blocks for tbl in re . findall ( r'\w+' , block ) ] return set ( tables )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the log of the magnitude spectrum of frames<CODESPLIT>def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A static value ( does not change at runtime ) which is known at compile time<CODESPLIT>def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a numpy row - major homogenous transformation matrix to a flat column - major GLfloat transformation .<CODESPLIT>def matrix_to_gl ( matrix ) : matrix = np . asanyarray ( matrix , dtype = np . float64 ) if matrix . shape != ( 4 , 4 ) : raise ValueError ( 'matrix must be (4,4)!' ) # switch to column major and flatten to (16,) column = matrix . T . flatten ( ) # convert to GLfloat glmatrix = ( gl . GLfloat * 16 ) ( * column ) return glmatrix
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a Vector as the product of the vector and a real number .<CODESPLIT>def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Ensures : attr : subject contains * other * .<CODESPLIT>def contains ( self , element ) : self . _run ( unittest_case . assertIn , ( element , self . _subject ) ) return ChainInspector ( self . _subject )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function which returns an array with the Intervals boundaries .<CODESPLIT>def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>function : to be called with each stream element as its only argument<CODESPLIT>def __init__ ( self , function ) : super ( filter , self ) . __init__ ( ) self . function = function
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>count occurences in a list of lists >>> count ( [[ a b ] [ a ]] ) defaultdict ( int { a : 2 b : 1 } )<CODESPLIT>def count ( args ) : counts = defaultdict ( int ) for arg in args : for item in arg : counts [ item ] = counts [ item ] + 1 return counts
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call java and return version information .<CODESPLIT>def java_version ( ) : result = subprocess . check_output ( [ c . JAVA , '-version' ] , stderr = subprocess . STDOUT ) first_line = result . splitlines ( ) [ 0 ] return first_line . decode ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a value wrap it in a 0 - D numpy . ndarray .<CODESPLIT>def to_0d_array ( value : Any ) -> np . ndarray : if np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and value . ndim == 0 ) : return np . array ( value ) else : return to_0d_object_array ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>wrapper for : py : func : json . load<CODESPLIT>def load ( cls , fp , * * kwargs ) : json_obj = json . load ( fp , * * kwargs ) return parse ( cls , json_obj )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Normalize the data to be in the [ 0 1 ] range .<CODESPLIT>def normalize ( data ) : out_data = data . copy ( ) for i , sample in enumerate ( out_data ) : out_data [ i ] /= sum ( out_data [ i ] ) return out_data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get a value from a tag ( if it exists )<CODESPLIT>def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a python string to C string .<CODESPLIT>def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a context manager that hides the cursor while inside it and makes it visible on leaving .<CODESPLIT>def hidden_cursor ( self ) : self . stream . write ( self . hide_cursor ) try : yield finally : self . stream . write ( self . normal_cursor )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get resource variable .<CODESPLIT>def _get_var_from_string ( item ) : modname , varname = _split_mod_var_names ( item ) if modname : mod = __import__ ( modname , globals ( ) , locals ( ) , [ varname ] , - 1 ) return getattr ( mod , varname ) else : return globals ( ) [ varname ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yield one date per day from starting date to ending date .<CODESPLIT>def daterange ( start_date , end_date ) : for n in range ( int ( ( end_date - start_date ) . days ) ) : yield start_date + timedelta ( n )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extract the boundaries from a list of indexes<CODESPLIT>def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turn a list into a comma - and / or and - separated string .<CODESPLIT>def list_to_str ( lst ) : if len ( lst ) == 1 : str_ = lst [ 0 ] elif len ( lst ) == 2 : str_ = ' and ' . join ( lst ) elif len ( lst ) > 2 : str_ = ', ' . join ( lst [ : - 1 ] ) str_ += ', and {0}' . format ( lst [ - 1 ] ) else : raise ValueError ( 'List of length 0 provided.' ) return str_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Decode a JSON int64 to bson . int64 . Int64 .<CODESPLIT>def _parse_canonical_int64 ( doc ) : l_str = doc [ '$numberLong' ] if len ( doc ) != 1 : raise TypeError ( 'Bad $numberLong, extra field(s): %s' % ( doc , ) ) return Int64 ( l_str )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be an iterable ( list array tuple )<CODESPLIT>def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a suspicious number ( e . g . ligand position ) is in fact a negative number represented as a 32 bit integer and returns the actual number .<CODESPLIT>def int32_to_negative ( int32 ) : dct = { } if int32 == 4294967295 : # Special case in some structures (note, this is just a workaround) return - 1 for i in range ( - 1000 , - 1 ) : dct [ np . uint32 ( i ) ] = i if int32 in dct : return dct [ int32 ] else : return int32
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>helper function for quick base conversions from strings to integers<CODESPLIT>def str2int ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . str2int ( num )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get np array of bin edges<CODESPLIT>def getEdges ( npArr ) : edges = np . concatenate ( ( [ 0 ] , npArr [ : , 0 ] + npArr [ : , 2 ] ) ) return np . array ( [ Decimal ( str ( i ) ) for i in edges ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>returns a random element from seq n times . If n is None it continues indefinitly<CODESPLIT>def rand_elem ( seq , n = None ) : return map ( random . choice , repeat ( seq , n ) if n is not None else repeat ( seq ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .<CODESPLIT>def input_int_default ( question = "" , default = 0 ) : answer = input_string ( question ) if answer == "" or answer == "yes" : return default else : return int ( answer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generalised logarithm<CODESPLIT>def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Covert numpy array to tensorflow tensor<CODESPLIT>def astensor ( array : TensorLike ) -> BKTensor : tensor = tf . convert_to_tensor ( value = array , dtype = CTYPE ) return tensor
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Removes tags from objects<CODESPLIT>def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts python datetime to epoch microseconds .<CODESPLIT>def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>remove duplicates from a sequence preserving order<CODESPLIT>def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the list of all cached global names<CODESPLIT>def get_all_names ( self ) : result = set ( ) for module in self . names : result . update ( set ( self . names [ module ] ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert any array into a 2d numpy array .<CODESPLIT>def make_2d ( ary ) : dim_0 ,  * _ = np . atleast_1d ( ary ) . shape return ary . reshape ( dim_0 , - 1 , order = "F" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if two numbers are equal up to the specified number of places after the decimal point .<CODESPLIT>def _float_almost_equal ( float1 , float2 , places = 7 ) : if round ( abs ( float2 - float1 ) , places ) == 0 : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Very simple grep that returns the first matching line in a file . String matching only does not do REs as currently implemented .<CODESPLIT>def grep ( pattern , filename ) : try : # for line in file # if line matches pattern: #    return line return next ( ( L for L in open ( filename ) if L . find ( pattern ) >= 0 ) ) except StopIteration : return ''
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Square of the euclidean distance<CODESPLIT>def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Formats the text input with newlines given the user specified width for each line .<CODESPLIT>def wrap ( s , width = 80 ) : return '\n' . join ( textwrap . wrap ( str ( s ) , width = width ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if an http server runs on a given port .<CODESPLIT>def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add the default arguments to the parser .<CODESPLIT>def _add_default_arguments ( parser ) : parser . add_argument ( '-c' , '--config' , action = 'store' , dest = 'config' , help = 'Path to the configuration file' ) parser . add_argument ( '-f' , '--foreground' , action = 'store_true' , dest = 'foreground' , help = 'Run the application interactively' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the shape of img .<CODESPLIT>def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sum the widths of the columns that make up the span plus the extra .<CODESPLIT>def get_span_char_width ( span , column_widths ) : start_column = span [ 0 ] [ 1 ] column_count = get_span_column_count ( span ) total_width = 0 for i in range ( start_column , start_column + column_count ) : total_width += column_widths [ i ] total_width += column_count - 1 return total_width
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ceil a number to within a given rounding accuracy<CODESPLIT>def ceil_nearest ( x , dx = 1 ) : precision = get_sig_digits ( dx ) return round ( math . ceil ( float ( x ) / dx ) * dx , precision )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be an iterable ( list array tuple )<CODESPLIT>def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .<CODESPLIT>def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pretty print an object as YAML .<CODESPLIT>def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove all values that are zero .<CODESPLIT>def remove_falsy_values ( counter : Mapping [ Any , int ] ) -> Mapping [ Any , int ] : return { label : count for label , count in counter . items ( ) if count }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return time in milliseconds from start_time<CODESPLIT>def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Invert mapping of dictionary ( i . e . map values to list of keys )<CODESPLIT>def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clean up processes after SIGTERM or SIGINT is received .<CODESPLIT>def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load proxy list from configured proxy source<CODESPLIT>def load ( self ) : self . _list = self . _source . load ( ) self . _list_iter = itertools . cycle ( self . _list )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Entry point for the jupytext script<CODESPLIT>def jupytext_cli ( args = None ) : try : jupytext ( args ) except ( ValueError , TypeError , IOError ) as err : sys . stderr . write ( '[jupytext] Error: ' + str ( err ) + '\n' ) exit ( 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a set of kwargs turns them into a string which can then be passed to a command . : param kwargs : kwargs from a function call . : return : outstr : A string which is if no kwargs were given and the kwargs in string format otherwise .<CODESPLIT>def kwargs_to_string ( kwargs ) : outstr = '' for arg in kwargs : outstr += ' -{} {}' . format ( arg , kwargs [ arg ] ) return outstr
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>: param session : actually it is a sqlalchemy session : return : version number<CODESPLIT>def get_db_version ( session ) : value = session . query ( ProgramInformation . value ) . filter ( ProgramInformation . name == "db_version" ) . scalar ( ) return int ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def is_alive ( self ) : try : self . wait ( 0 ) except WindowsError : e = sys . exc_info ( ) [ 1 ] return e . winerror == win32 . WAIT_TIMEOUT return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Package up the public attributes as a dict .<CODESPLIT>def as_dict ( self ) : attrs = vars ( self ) return { key : attrs [ key ] for key in attrs if not key . startswith ( '_' ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generate all matches found within a string for a regex and yield each match as a string<CODESPLIT>def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Increment the date by a certain number and return date object . as the specific string format .<CODESPLIT>def inc_date ( date_obj , num , date_fmt ) : return ( date_obj + timedelta ( days = num ) ) . strftime ( date_fmt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the default bucket from a list of buckets i . e . the largest bucket .<CODESPLIT>def get_default_bucket_key ( buckets : List [ Tuple [ int , int ] ] ) -> Tuple [ int , int ] : return max ( buckets )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility method to run commands synchronously for testing .<CODESPLIT>def _run_sync ( self , method : Callable , * args , * * kwargs ) -> Any : if self . loop . is_running ( ) : raise RuntimeError ( "Event loop is already running." ) if not self . is_connected : self . loop . run_until_complete ( self . connect ( ) ) task = asyncio . Task ( method ( * args , * * kwargs ) , loop = self . loop ) result = self . loop . run_until_complete ( task ) self . loop . run_until_complete ( self . quit ( ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Enable a default web proxy<CODESPLIT>def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .<CODESPLIT>def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get from a list with an optional default value .<CODESPLIT>def list_get ( l , idx , default = None ) : try : if l [ idx ] : return l [ idx ] else : return default except IndexError : return default
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a boolean indicating if the code is executed inside softimage .<CODESPLIT>def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an instance from a dictionary .<CODESPLIT>def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if the current process is running in Windows - On - Windows 64 bits .<CODESPLIT>def _get_wow64 ( ) : # Try to determine if the debugger itself is running on WOW64. # On error assume False. if bits == 64 : wow64 = False else : try : wow64 = IsWow64Process ( GetCurrentProcess ( ) ) except Exception : wow64 = False return wow64
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def parse_parameter ( value ) : if any ( ( isinstance ( value , float ) , isinstance ( value , int ) , isinstance ( value , bool ) ) ) : return value try : return int ( value ) except ValueError : try : return float ( value ) except ValueError : if value in string_aliases . true_boolean_aliases : return True elif value in string_aliases . false_boolean_aliases : return False else : return str ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculate time delta from latched time and current time<CODESPLIT>def elapsed_time_from ( start_time ) : time_then = make_time ( start_time ) time_now = datetime . utcnow ( ) . replace ( microsecond = 0 ) if time_then is None : return delta_t = time_now - time_then return delta_t
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This removes newlines and multiple spaces from a string .<CODESPLIT>def normalize_value ( text ) : result = text . replace ( '\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert hex string like \ x0A \ xE3 to 2787 .<CODESPLIT>def hex_to_int ( value ) : if version_info . major >= 3 : return int . from_bytes ( value , "big" ) return int ( value . encode ( "hex" ) , 16 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets RAM memory usage<CODESPLIT>def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run python eval on the input string .<CODESPLIT>def get_value ( self , context ) : if self . value : return expressions . eval_string ( self . value , context ) else : # Empty input raises cryptic EOF syntax err, this more human # friendly raise ValueError ( '!py string expression is empty. It must be a ' 'valid python expression instead.' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reshuffle the indicies of a bipartite matrix A [ ij kl ] - > A [ lj ki ] .<CODESPLIT>def _reshuffle ( mat , shape ) : return np . reshape ( np . transpose ( np . reshape ( mat , shape ) , ( 3 , 1 , 2 , 0 ) ) , ( shape [ 3 ] * shape [ 1 ] , shape [ 0 ] * shape [ 2 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>visit an Ellipsis node by returning a fresh instance of it<CODESPLIT>def visit_ellipsis ( self , node , parent ) : return nodes . Ellipsis ( getattr ( node , "lineno" , None ) , getattr ( node , "col_offset" , None ) , parent )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Draw a round corner<CODESPLIT>def round_corner ( radius , fill ) : corner = Image . new ( 'L' , ( radius , radius ) , 0 ) # (0, 0, 0, 0)) draw = ImageDraw . Draw ( corner ) draw . pieslice ( ( 0 , 0 , radius * 2 , radius * 2 ) , 180 , 270 , fill = fill ) return corner
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a list of Token into a list of Token asuming size == 1<CODESPLIT>def append_position_to_token_list ( token_list ) : return [ PositionToken ( value . content , value . gd , index , index + 1 ) for ( index , value ) in enumerate ( token_list ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print security object information for a pdf document<CODESPLIT>def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Utility to generate enum classes used by annotations .<CODESPLIT>def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sort the data .<CODESPLIT>def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reshape data into ( num_example batch_size )<CODESPLIT>def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Converts a URI parts to corresponding IRI parts in a given charset .<CODESPLIT>def uri_to_iri_parts ( path , query , fragment ) : path = url_unquote ( path , '%/;?' ) query = url_unquote ( query , '%;/?:@&=+,$#' ) fragment = url_unquote ( fragment , '%;/?:@&=+,$#' ) return path , query , fragment
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Direct access to byte data .<CODESPLIT>def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output<CODESPLIT>def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if value is an integer long integer or float .<CODESPLIT>def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokenizes * source * and returns the tokens as a list of lists .<CODESPLIT>def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .<CODESPLIT>async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Cast uint32 RGB image to 4 uint8 channels .<CODESPLIT>def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Will make any functions return an iterable objects by wrapping its result in a list .<CODESPLIT>def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Tokenizes a given text into sentences applying filters and lemmatizing them . Returns a SyntacticUnit list .<CODESPLIT>def clean_text_by_sentences ( text , language = "english" , additional_stopwords = None ) : init_textcleanner ( language , additional_stopwords ) original_sentences = split_sentences ( text ) filtered_sentences = filter_words ( original_sentences ) return merge_syntactic_units ( original_sentences , filtered_sentences )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Delete all whitespace from the end of the line .<CODESPLIT>def _delete_whitespace ( self ) : while isinstance ( self . _lines [ - 1 ] , ( self . _Space , self . _LineBreak , self . _Indent ) ) : del self . _lines [ - 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>ndarray containing tuples of pairwise indices .<CODESPLIT>def pairwise_indices ( self ) : return np . array ( [ sig . pairwise_indices for sig in self . values ] ) . T
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run asyncio ( should be called in a thread ) and close the loop and the zmq context when the thread ends : param loop : : param zmq_context : : return :<CODESPLIT>def _run_asyncio ( loop , zmq_context ) : try : asyncio . set_event_loop ( loop ) loop . run_forever ( ) except : pass finally : loop . close ( ) zmq_context . destroy ( 1000 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a dict of 1d array to a numpy recarray<CODESPLIT>def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert the value to its string representation<CODESPLIT>def _cast_to_type ( self , value ) : if isinstance ( value , str ) or value is None : return value return str ( value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a matplotlib colormap .<CODESPLIT>def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set limits for the point meta ( colormap ) .<CODESPLIT>def set_mlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_mlimits ( min , max )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load JSON file<CODESPLIT>def from_file ( file_path ) -> dict : with io . open ( file_path , 'r' , encoding = 'utf-8' ) as json_stream : return Json . parse ( json_stream , True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert exception info into a string suitable for display .<CODESPLIT>def exception_format ( ) : return "" . join ( traceback . format_exception ( sys . exc_info ( ) [ 0 ] , sys . exc_info ( ) [ 1 ] , sys . exc_info ( ) [ 2 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .<CODESPLIT>def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( "lib2to3.fixes" , args = args . sources ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>JSON serializer for objects not serializable by default json code<CODESPLIT>def json_serial ( obj ) : if isinstance ( obj , LegipyModel ) : return obj . to_json ( ) elif isinstance ( obj , ( datetime . date , datetime . datetime ) ) : return obj . isoformat ( ) raise TypeError ( "Type {0} not serializable" . format ( repr ( type ( obj ) ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Render our pages as a jinja template for fancy templating goodness .<CODESPLIT>def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Upermutate 1 - D data that is sorted by indices_of_increasing .<CODESPLIT>def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a table row to a dictionary .<CODESPLIT>def row_to_dict ( row ) : o = { } for colname in row . colnames : if isinstance ( row [ colname ] , np . string_ ) and row [ colname ] . dtype . kind in [ 'S' , 'U' ] : o [ colname ] = str ( row [ colname ] ) else : o [ colname ] = row [ colname ] return o
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserializes string to date .<CODESPLIT>def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return unique rows<CODESPLIT>def _unique_rows_numpy ( a ) : a = np . ascontiguousarray ( a ) unique_a = np . unique ( a . view ( [ ( '' , a . dtype ) ] * a . shape [ 1 ] ) ) return unique_a . view ( a . dtype ) . reshape ( ( unique_a . shape [ 0 ] , a . shape [ 1 ] ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is a finite number .<CODESPLIT>def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert anything to a bytearray . See - http : // stackoverflow . com / questions / 7585435 / best - way - to - convert - string - to - bytes - in - python - 3 - http : // stackoverflow . com / questions / 10459067 / how - to - convert - my - bytearrayb - x9e - x18k - x9a - to - something - like - this - x9e - x1<CODESPLIT>def to_bytes ( data : Any ) -> bytearray : # noqa if isinstance ( data , int ) : return bytearray ( [ data ] ) return bytearray ( data , encoding = 'latin-1' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Shape of histogram s data .<CODESPLIT>def shape ( self ) -> Tuple [ int , ... ] : return tuple ( bins . bin_count for bins in self . _binnings )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the UTC time now but with no timezone information in : class : datetime . datetime format .<CODESPLIT>def get_now_utc_notz_datetime ( ) -> datetime . datetime : now = datetime . datetime . utcnow ( ) return now . replace ( tzinfo = None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Information about Cauldron and its Python interpreter .<CODESPLIT>def get_environment_info ( ) -> dict : data = _environ . systems . get_system_data ( ) data [ 'cauldron' ] = _environ . package_settings . copy ( ) return data
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse ISO8601 timestamps given by github API .<CODESPLIT>def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the module name associated with a frame num_frames_back in the call stack . This function adds 1 to account for itself so num_frames_back should be given relative to the caller .<CODESPLIT>def _module_name_from_previous_frame ( num_frames_back ) : frm = inspect . stack ( ) [ num_frames_back + 1 ] return inspect . getmodule ( frm [ 0 ] ) . __name__
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrieve a list of all system services .<CODESPLIT>def get_services ( ) : with win32 . OpenSCManager ( dwDesiredAccess = win32 . SC_MANAGER_ENUMERATE_SERVICE ) as hSCManager : try : return win32 . EnumServicesStatusEx ( hSCManager ) except AttributeError : return win32 . EnumServicesStatus ( hSCManager )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function for running binary search on a sorted list .<CODESPLIT>def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the attribute name identifier<CODESPLIT>def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function<CODESPLIT>def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Replaces from a string ** input ** all the occurrences of some symbols according to mapping ** repls ** .<CODESPLIT>def __replace_all ( repls : dict , input : str ) -> str : return re . sub ( '|' . join ( re . escape ( key ) for key in repls . keys ( ) ) , lambda k : repls [ k . group ( 0 ) ] , input )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Partition a list into equally sized pieces including last smaller parts http : // stackoverflow . com / questions / 5129102 / python - equivalent - to - clojures - partition - all<CODESPLIT>def partition_all ( n , iterable ) : it = iter ( iterable ) while True : chunk = list ( itertools . islice ( it , n ) ) if not chunk : break yield chunk
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Multiply each number by a constant such that the sum is 1 . 0 >>> normalize ( [ 1 2 1 ] ) [ 0 . 25 0 . 5 0 . 25 ]<CODESPLIT>def normalize ( numbers ) : total = float ( sum ( numbers ) ) return [ n / total for n in numbers ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the console .<CODESPLIT>def clear ( ) : if sys . platform . startswith ( "win" ) : call ( "cls" , shell = True ) else : call ( "clear" , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the number of edges of the CFG Args : function ( core . declarations . function . Function ) Returns : int<CODESPLIT>def compute_number_edges ( function ) : n = 0 for node in function . nodes : n += len ( node . sons ) return n
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Stops iterating before yielding the specified idx .<CODESPLIT>def stop_at ( iterable , idx ) : for i , item in enumerate ( iterable ) : if i == idx : return yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Marker for a token<CODESPLIT>def token ( name ) : def wrap ( f ) : tokenizers . append ( ( name , f ) ) return f return wrap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y<CODESPLIT>def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert seconds to hours mins and seconds .<CODESPLIT>def _to_hours_mins_secs ( time_taken ) : mins , secs = divmod ( time_taken , 60 ) hours , mins = divmod ( mins , 60 ) return hours , mins , secs
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns min ( val1 val2 ) returning None only if both values are None<CODESPLIT>def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make sure thre is no whitespace in the given string . Will raise a ValueError if whitespace is detected<CODESPLIT>def _check_whitespace ( string ) : if string . count ( ' ' ) + string . count ( '\t' ) + string . count ( '\n' ) > 0 : raise ValueError ( INSTRUCTION_HAS_WHITESPACE )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wraps a function to run in a given directory .<CODESPLIT>def change_dir ( directory ) : def cd_decorator ( func ) : @ wraps ( func ) def wrapper ( * args , * * kwargs ) : org_path = os . getcwd ( ) os . chdir ( directory ) func ( * args , * * kwargs ) os . chdir ( org_path ) return wrapper return cd_decorator
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenience function for loading yaml - encoded data from disk .<CODESPLIT>def load_yaml ( filepath ) : with open ( filepath ) as f : txt = f . read ( ) return yaml . load ( txt )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Transform a query line into a ( lng lat ) pair of coordinates .<CODESPLIT>def coords_from_query ( query ) : try : coords = json . loads ( query ) except ValueError : vals = re . split ( r'[,\s]+' , query . strip ( ) ) coords = [ float ( v ) for v in vals ] return tuple ( coords [ : 2 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode .<CODESPLIT>def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print something on screen when self . verbose == True<CODESPLIT>def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Advances to next line .<CODESPLIT>def advance_one_line ( self ) : current_line = self . _current_token . line_number while current_line == self . _current_token . line_number : self . _current_token = ConfigParser . Token ( * next ( self . _token_generator ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Did the user depress and release the button to signify a click? MouseStateType is the button to query . Values found under StateTypes . py<CODESPLIT>def is_clicked ( self , MouseStateType ) : return self . previous_mouse_state . query_state ( MouseStateType ) and ( not self . current_mouse_state . query_state ( MouseStateType ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Count the number of rows in 2D arrays that contain any nan values .<CODESPLIT>def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert JSON string to an ordered defaultdict .<CODESPLIT>def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a matplotlib colormap .<CODESPLIT>def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Skip a section<CODESPLIT>def _skip_section ( self ) : self . _last = self . _f . readline ( ) while len ( self . _last ) > 0 and len ( self . _last [ 0 ] . strip ( ) ) == 0 : self . _last = self . _f . readline ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Gets the user enter max and min values of where the raster points should appear on the y - axis<CODESPLIT>def values ( self ) : lower = float ( self . lowerSpnbx . value ( ) ) upper = float ( self . upperSpnbx . value ( ) ) return ( lower , upper )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Install Postgres on remote<CODESPLIT>def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A helper function that finds the position of the most significant bit in a 1darray of 1s and 0s i . e . the first position where a 1 appears reading left to right .<CODESPLIT>def most_significant_bit ( lst : np . ndarray ) -> int : return np . argwhere ( np . asarray ( lst ) == 1 ) [ 0 ] [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given a dictionary and a key list remove any data in the dictionary with the given keys .<CODESPLIT>def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>treats the 2 sets are sets of taxon IDs on the same ( unstated ) universe of taxon ids . Returns True clades implied by each are compatible and False otherwise<CODESPLIT>def sets_are_rooted_compat ( one_set , other ) : if one_set . issubset ( other ) or other . issubset ( one_set ) : return True return not intersection_not_empty ( one_set , other )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an array . Keyword arguments as per : func : zarr . creation . zeros .<CODESPLIT>def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A background thread to kill the process if it takes too long .<CODESPLIT>def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( "Killing program due to %f second timeout" % timeout ) os . _exit ( 2 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Are we being asked to look up a list of things instead of a single thing? We check for the __iter__ attribute so that this can cover types that don t have to be known by this module such as NumPy arrays .<CODESPLIT>def is_iterable ( obj ) : return ( hasattr ( obj , "__iter__" ) and not isinstance ( obj , str ) and not isinstance ( obj , tuple ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load and parse a feature file .<CODESPLIT>def load_feature ( fname , language ) : fname = os . path . abspath ( fname ) feat = parse_file ( fname , language ) return feat
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add dots .<CODESPLIT>def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reload the device .<CODESPLIT>def reload ( self , save_config = True ) : if save_config : self . device . send ( "copy running-config startup-config" ) self . device ( "reload" , wait_for_string = "This command will reboot the system" ) self . device . ctrl . sendline ( "y" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks whether a variable is a numpy integer array .<CODESPLIT>def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates col_widths in code_array<CODESPLIT>def _xls2col_widths ( self , worksheet , tab ) : for col in xrange ( worksheet . ncols ) : try : xls_width = worksheet . colinfo_map [ col ] . width pys_width = self . xls_width2pys_width ( xls_width ) self . code_array . col_widths [ col , tab ] = pys_width except KeyError : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Base absolute path of container .<CODESPLIT>def base_path ( self ) : return os . path . join ( self . container . base_path , self . name )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>There s probably a way to do this with string functions but I was lazy . Replace all instances of \ r or \ n in a string with something else .<CODESPLIT>def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = "" for segment in segments : string += segment return string
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if value is an integer .<CODESPLIT>def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create ctypes pointer to object .<CODESPLIT>def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a lowercase string with punctuation and bad chars removed : param s : string to clean<CODESPLIT>def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\u200b' , " " ) . strip ( ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>unset _instance for this class and singleton parents .<CODESPLIT>def clear_instance ( cls ) : if not cls . initialized ( ) : return for subclass in cls . _walk_mro ( ) : if isinstance ( subclass . _instance , cls ) : # only clear instances that are instances # of the calling class subclass . _instance = None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This is to support iterators over a file - like object .<CODESPLIT>def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given an index for the text return the corresponding ( row col ) tuple . ( 0 - based . Returns ( 0 0 ) for index = 0 . )<CODESPLIT>def translate_index_to_position ( self , index ) : # Find start of this line. row , row_index = self . _find_line_start_index ( index ) col = index - row_index return row , col
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if an http server runs on a given port .<CODESPLIT>def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the the number of columns required to display a string<CODESPLIT>def _visual_width ( line ) : return len ( re . sub ( colorama . ansitowin32 . AnsiToWin32 . ANSI_CSI_RE , "" , line ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Word - level n - grams that match between two strings<CODESPLIT>def word_matches ( s1 , s2 , n = 3 ) : return __matches ( s1 , s2 , word_ngrams , n = n )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Outputs json without whitespace .<CODESPLIT>def compress ( obj ) : return json . dumps ( obj , sort_keys = True , separators = ( ',' , ':' ) , cls = CustomEncoder )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the lowest common multiple of 2 numbers<CODESPLIT>def lcm ( num1 , num2 ) : if num1 > num2 : bigger = num1 else : bigger = num2 while True : if bigger % num1 == 0 and bigger % num2 == 0 : return bigger bigger += 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a hash of the contents of a dictionary<CODESPLIT>def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks for local config overrides for pylint and add them in the correct pylint options format .<CODESPLIT>def get_pylint_options ( config_dir = '.' ) : # type: (str) -> List[str] if PYLINT_CONFIG_NAME in os . listdir ( config_dir ) : pylint_config_path = PYLINT_CONFIG_NAME else : pylint_config_path = DEFAULT_PYLINT_CONFIG_PATH return [ '--rcfile={}' . format ( pylint_config_path ) ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits<CODESPLIT>def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Builds sphinx docs from a given directory .<CODESPLIT>def build_docs ( directory ) : os . chdir ( directory ) process = subprocess . Popen ( [ "make" , "html" ] , cwd = directory ) process . communicate ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse Config File from yaml file .<CODESPLIT>def _parse_config ( config_file_path ) : config_file = open ( config_file_path , 'r' ) config = yaml . load ( config_file ) config_file . close ( ) return config
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>The return type for this method in a JSON - compatible format .<CODESPLIT>def returns ( self ) : return_type = self . signature . return_type none_type = type ( None ) if return_type is not None and return_type is not none_type : return return_type . __name__
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Choose k random elements of array .<CODESPLIT>def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a gzipped version of a previously opened file s buffer .<CODESPLIT>def get_gzipped_contents ( input_file ) : zbuf = StringIO ( ) zfile = GzipFile ( mode = "wb" , compresslevel = 6 , fileobj = zbuf ) zfile . write ( input_file . read ( ) ) zfile . close ( ) return ContentFile ( zbuf . getvalue ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether the given value is a byte or unicode string .<CODESPLIT>def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert string or other Python object to boolean .<CODESPLIT>def to_bool ( value : Any ) -> bool : return bool ( strtobool ( value ) if isinstance ( value , str ) else value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the element with the highest probability .<CODESPLIT>def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a callable that sends the actual API request internally .<CODESPLIT>def __getattr__ ( self , item : str ) -> Callable : return functools . partial ( self . call_action , item )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .<CODESPLIT>def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>If we re not on the first line ( of a multiline input ) go a line up otherwise go back in history . ( If nothing is selected . )<CODESPLIT>def auto_up ( self , count = 1 , go_to_start_of_line_if_history_changes = False ) : if self . complete_state : self . complete_previous ( count = count ) elif self . document . cursor_position_row > 0 : self . cursor_up ( count = count ) elif not self . selection_state : self . history_backward ( count = count ) # Go to the start of the line? if go_to_start_of_line_if_history_changes : self . cursor_position += self . document . get_start_of_line_position ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Outputs json with formatting edits + object handling .<CODESPLIT>def dumps ( obj ) : return json . dumps ( obj , indent = 4 , sort_keys = True , cls = CustomEncoder )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Update context menu<CODESPLIT>def update_menu ( self ) : self . menu . clear ( ) add_actions ( self . menu , self . create_context_menu_actions ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the contents of a file .<CODESPLIT>def writefile ( openedfile , newcontents ) : openedfile . seek ( 0 ) openedfile . truncate ( ) openedfile . write ( newcontents )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate overlap count between the values of two dictionaries<CODESPLIT>def _calc_overlap_count ( markers1 : dict , markers2 : dict , ) : overlaps = np . zeros ( ( len ( markers1 ) , len ( markers2 ) ) ) j = 0 for marker_group in markers1 : tmp = [ len ( markers2 [ i ] . intersection ( markers1 [ marker_group ] ) ) for i in markers2 . keys ( ) ] overlaps [ j , : ] = tmp j += 1 return overlaps
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Simple helper hash function<CODESPLIT>def _my_hash ( arg_list ) : # type: (List[Any]) -> int res = 0 for arg in arg_list : res = res * 31 + hash ( arg ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .<CODESPLIT>def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create unique labels .<CODESPLIT>def get_labels ( labels ) : label_u = unique_labels ( labels ) label_u_line = [ i + "_line" for i in label_u ] return label_u , label_u_line
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Upgrade to a later version<CODESPLIT>def upgrade ( directory , sql , tag , x_arg , revision ) : _upgrade ( directory , revision , sql , tag , x_arg )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Lock connection from being used else where<CODESPLIT>def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Yields file name if matches a regular expression pattern .<CODESPLIT>def match_files ( files , pattern : Pattern ) : for name in files : if re . match ( pattern , name ) : yield name
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the centroid for a set of vectors<CODESPLIT>def find_dist_to_centroid ( cvects , idx_list , weights = None ) : centroid = find_centroid ( cvects , idx_list , weights ) dist_vals = np . degrees ( np . arccos ( ( centroid * cvects . T [ idx_list ] ) . sum ( 1 ) ) ) return dist_vals , centroid
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a dict that accumulates the values for each key in an iterator of doubles .<CODESPLIT>def _group_dict_set ( iterator ) : d = defaultdict ( set ) for key , value in iterator : d [ key ] . add ( value ) return dict ( d )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run a Tensorflow model on the Iris dataset .<CODESPLIT>def main ( argv = None ) : args = parse_arguments ( sys . argv if argv is None else argv ) tf . logging . set_verbosity ( tf . logging . INFO ) learn_runner . run ( experiment_fn = get_experiment_fn ( args ) , output_dir = args . job_dir )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Receive the content of url parse it as JSON and return the object .<CODESPLIT>def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deletes the database file .<CODESPLIT>def __del__ ( self ) : if self . _delete_file : try : os . remove ( self . name ) except ( OSError , IOError ) : pass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Retrun True if x is a valid YYYYMMDD date ; otherwise return False .<CODESPLIT>def valid_date ( x : str ) -> bool : try : if x != dt . datetime . strptime ( x , DATE_FORMAT ) . strftime ( DATE_FORMAT ) : raise ValueError return True except ValueError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Begin logging of a task<CODESPLIT>def start_task ( self , task ) : self . info ( "Calculating {}..." . format ( task ) ) self . tasks [ task ] = self . timer ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Computes the unnormalized PDF of the normal distribution .<CODESPLIT>def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Compute the total size of all elements in objects .<CODESPLIT>def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( "IGNORING: type=%s; o=%s" % ( str ( type ( o ) ) , str ( o ) ) ) return res
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get a slice from a table column holding arrays . ( see : func : table . getcolslice )<CODESPLIT>def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reduced Euclidean distance .<CODESPLIT>def rdist ( x , y ) : result = 0.0 for i in range ( x . shape [ 0 ] ) : result += ( x [ i ] - y [ i ] ) ** 2 return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given object conforms to the Serializable protocol .<CODESPLIT>def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates converts to a masked array<CODESPLIT>def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the appropriate IPython code magic when called with an alias for a language .<CODESPLIT>def magic ( self , alias ) : if alias in self . aliases : return self . aliases [ alias ] else : return "%%{}\n" . format ( alias )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if cnr or cns files are empty ( only have a header )<CODESPLIT>def _cnx_is_empty ( in_file ) : with open ( in_file ) as in_handle : for i , line in enumerate ( in_handle ) : if i > 0 : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A variant of memoized_property that allows for setting of properties ( for tests etc ) .<CODESPLIT>def testable_memoized_property ( func = None , key_factory = per_instance , * * kwargs ) : getter = memoized_method ( func = func , key_factory = key_factory , * * kwargs ) def setter ( self , val ) : with getter . put ( self ) as putter : putter ( val ) return property ( fget = getter , fset = setter , fdel = lambda self : getter . forget ( self ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculates and returns a month number basing on PESEL standard .<CODESPLIT>def calculate_month ( birth_date ) : year = int ( birth_date . strftime ( '%Y' ) ) month = int ( birth_date . strftime ( '%m' ) ) + ( ( int ( year / 100 ) - 14 ) % 5 ) * 20 return month
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a dataframe that is a cross between dataframes df1 and df2<CODESPLIT>def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Daemonize the running process .<CODESPLIT>def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an OrderedDict containing C values to a 1D array .<CODESPLIT>def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add optparse or argparse option depending on CmdHelper initialization .<CODESPLIT>def add_option ( self , * args , * * kwargs ) : if self . parseTool == 'argparse' : if args and args [ 0 ] == '' : # no short option args = args [ 1 : ] return self . parser . add_argument ( * args , * * kwargs ) else : return self . parser . add_option ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a list a certain size<CODESPLIT>def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>>>> _isint ( 123 ) True >>> _isint ( 123 . 45 ) False<CODESPLIT>def _isint ( string ) : return type ( string ) is int or ( isinstance ( string , _binary_type ) or isinstance ( string , _text_type ) ) and _isconvertible ( int , string )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Flip an image horizontally or vertically .<CODESPLIT>def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fold all values of the matrix into [ 0 1 ] .<CODESPLIT>def normalize_matrix ( matrix ) : abs_matrix = np . abs ( matrix . copy ( ) ) return abs_matrix / abs_matrix . max ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the memory byte size of a Numpy array as an integer .<CODESPLIT>def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Add a blank row with only an index value to self . df . This is done inplace .<CODESPLIT>def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Has a 50 / 50 chance of calling a function<CODESPLIT>def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print a formatted indented text .<CODESPLIT>def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Performs a random step without a self - loop .<CODESPLIT>def pagerank_limit_push ( s , r , w_i , a_i , push_node , rho ) : # Calculate the A and B quantities to infinity A_inf = rho * r [ push_node ] B_inf = ( 1 - rho ) * r [ push_node ] # Update approximate Pagerank and residual vectors s [ push_node ] += A_inf r [ push_node ] = 0.0 # Update residual vector at push node's adjacent nodes r [ a_i ] += B_inf * w_i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if value is an integer long integer or float .<CODESPLIT>def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a one element byte string to signed int for python 2 support .<CODESPLIT>def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( "b" , string ) [ 0 ] else : return struct . unpack ( "b" , bytes ( [ string ] ) ) [ 0 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get input from the user given an input function and an input string<CODESPLIT>def get_input ( input_func , input_str ) : val = input_func ( "Please enter your {0}: " . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( "You didn't enter a valid {0}, please try again: " . format ( input_str ) ) return val
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the timeout to the websocket .<CODESPLIT>def settimeout ( self , timeout ) : self . sock_opt . timeout = timeout if self . sock : self . sock . settimeout ( timeout )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes an array add indentation to each entry and prints it .<CODESPLIT>def PrintIndented ( self , file , ident , code ) : for entry in code : print >> file , '%s%s' % ( ident , entry )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an instance from a dictionary .<CODESPLIT>def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Converts array into chunks with consecutive elements of given step size . http : // stackoverflow . com / questions / 7352684 / how - to - find - the - groups - of - consecutive - elements - from - an - array - in - numpy<CODESPLIT>def consecutive ( data , stepsize = 1 ) : return np . split ( data , np . where ( np . diff ( data ) != stepsize ) [ 0 ] + 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location .<CODESPLIT>def get_mnist ( data_type = "train" , location = "/tmp/mnist" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .<CODESPLIT>def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the value of the other type instance to use in an operator method namely when the method s instance is on the left side of the expression .<CODESPLIT>def value_left ( self , other ) : return other . value if isinstance ( other , self . __class__ ) else other
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Report whether this RangeSet contains another set .<CODESPLIT>def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return physical memory usage ( float ) Requires the cross - platform psutil ( > = v0 . 3 ) library ( https : // github . com / giampaolo / psutil )<CODESPLIT>def psutil_phymem_usage ( ) : import psutil # This is needed to avoid a deprecation warning error with  # newer psutil versions  try : percent = psutil . virtual_memory ( ) . percent except : percent = psutil . phymem_usage ( ) . percent return percent
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the number of bytes stored in the value of key within hash name<CODESPLIT>def hstrlen ( self , name , key ) : with self . pipe as pipe : return pipe . hstrlen ( self . redis_key ( name ) , key )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>* Get the root path for this python package - used in unit testing code *<CODESPLIT>def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + "/../" return packagePath
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper that clears the composition .<CODESPLIT>def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = "black" ) del draw
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if a given string is an url<CODESPLIT>def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Like print but a function . I . e . prints out all arguments as print would do . Specify output stream like this ::<CODESPLIT>def prin ( * args , * * kwargs ) : print >> kwargs . get ( 'out' , None ) , " " . join ( [ str ( arg ) for arg in args ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Handles whitespace cleanup .<CODESPLIT>def handle_whitespace ( text ) : text = re_retab . sub ( sub_retab , text ) text = re_whitespace . sub ( '' , text ) . strip ( ) return text
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create database tables from sqlalchemy models<CODESPLIT>def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the molecular weight of the polypeptide sequence .<CODESPLIT>def sequence_molecular_weight ( seq ) : if 'X' in seq : warnings . warn ( _nc_warning_str , NoncanonicalWarning ) return sum ( [ residue_mwt [ aa ] * n for aa , n in Counter ( seq ) . items ( ) ] ) + water_mass
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the last week as a period string<CODESPLIT>def get_period_last_3_months ( ) -> str : today = Datum ( ) today . today ( ) # start_date = today - timedelta(weeks=13) start_date = today . clone ( ) start_date . subtract_months ( 3 ) period = get_period ( start_date . date , today . date ) return period
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .<CODESPLIT>def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Strips spaces : param x : : return :<CODESPLIT>def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\t' , b'' ) return x
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Accepts a binary string and returns the detected filetype . Return value is the mimetype if mime = True otherwise a human readable name .<CODESPLIT>def from_buffer ( buffer , mime = False ) : m = _get_magic_type ( mime ) return m . from_buffer ( buffer )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Standard euclidean distance .<CODESPLIT>def euclidean ( x , y ) : result = 0.0 for i in range ( x . shape [ 0 ] ) : result += ( x [ i ] - y [ i ] ) ** 2 return np . sqrt ( result )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Centre and normalize a given array .<CODESPLIT>def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT><CODESPLIT>def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove instance from instance list<CODESPLIT>def pop ( ) : pid = os . getpid ( ) thread = threading . current_thread ( ) Wdb . _instances . pop ( ( pid , thread ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert an image to PNG format with Pillow . : arg file - like fp : The image file . : rtype : bytes<CODESPLIT>def file_to_png ( fp ) : import PIL . Image # pylint: disable=import-error with io . BytesIO ( ) as dest : PIL . Image . open ( fp ) . save ( dest , "PNG" , optimize = True ) return dest . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the method is a bound method ( attached to an class instance .<CODESPLIT>def __is_bound_method ( method ) : if not ( hasattr ( method , "__func__" ) and hasattr ( method , "__self__" ) ) : return False # Bound methods have a __self__ attribute pointing to the owner instance return six . get_method_self ( method ) is not None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Direct access to byte data .<CODESPLIT>def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Opens the file and reads the value<CODESPLIT>def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return true if a value is a finite number .<CODESPLIT>def is_finite ( value : Any ) -> bool : return isinstance ( value , int ) or ( isinstance ( value , float ) and isfinite ( value ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Updates background color<CODESPLIT>def _update_bordercolor ( self , bordercolor ) : border_color = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_ACTIVEBORDER ) border_color . SetRGB ( bordercolor ) self . linecolor_choice . SetColour ( border_color )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if * path * is a directory<CODESPLIT>def isdir ( path , * * kwargs ) : import os . path return os . path . isdir ( path , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Clears the console .<CODESPLIT>def clear ( ) : if sys . platform . startswith ( "win" ) : call ( "cls" , shell = True ) else : call ( "clear" , shell = True )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generator that yields lines from standard input .<CODESPLIT>def standard_input ( ) : with click . get_text_stream ( "stdin" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( "utf-8" )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Deserializes a JSONified : obj : numpy . ndarray that was created using numpy s : obj : save function .<CODESPLIT>def deserialize_ndarray_npy ( d ) : with io . BytesIO ( ) as f : f . write ( json . loads ( d [ 'npy' ] ) . encode ( 'latin-1' ) ) f . seek ( 0 ) return np . load ( f )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Generalised logarithm<CODESPLIT>def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks if we already have an opened tab with the same name .<CODESPLIT>def _name_exists ( self , name ) : for i in range ( self . count ( ) ) : if self . tabText ( i ) == name : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>implementation of safe dumper using Ordered Dict Yaml Dumper<CODESPLIT>def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets a horiztonal line<CODESPLIT>def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a dictionary from a URL params<CODESPLIT>def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Make a list a certain size<CODESPLIT>def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check if n is a prime number<CODESPLIT>def is_prime ( n ) : if n % 2 == 0 and n > 2 : return False return all ( n % i for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .<CODESPLIT>def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>evaluates expression in current context and returns its value<CODESPLIT>def eval ( self , expression , use_compilation_plan = False ) : code = 'PyJsEvalResult = eval(%s)' % json . dumps ( expression ) self . execute ( code , use_compilation_plan = use_compilation_plan ) return self [ 'PyJsEvalResult' ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get the current mouse location ( coordinates and screen number ) .<CODESPLIT>def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Creates a PDF by embedding the first page from the given image and writes some text to it .<CODESPLIT>def main ( filename ) : # Prepare font. font_family = 'arial' font = Font ( font_family , bold = True ) if not font : raise RuntimeError ( 'No font found for %r' % font_family ) # Initialize PDF document on a stream. with Document ( 'output.pdf' ) as document : # Initialize a new page and begin its context. with document . Page ( ) as ctx : # Open the image to embed. with Image ( filename ) as embed : # Set the media box for the page to the same as the # image to embed. ctx . box = embed . box # Embed the image. ctx . embed ( embed ) # Write some text. ctx . add ( Text ( 'Hello World' , font , size = 14 , x = 100 , y = 60 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the item that appears most frequently in the given list .<CODESPLIT>def most_frequent ( lst ) : lst = lst [ : ] highest_freq = 0 most_freq = None for val in unique ( lst ) : if lst . count ( val ) > highest_freq : most_freq = val highest_freq = lst . count ( val ) return most_freq
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a naive datetime object for the given timezone . A timezone is any pytz - like or datetime . tzinfo - like timezone object . If no timezone is given then UTC is assumed .<CODESPLIT>def now ( timezone = None ) : d = datetime . datetime . utcnow ( ) if not timezone : return d return to_timezone ( d , timezone ) . replace ( tzinfo = None )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns date range for the previous full month .<CODESPLIT>def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if a system process identifer exists in process table .<CODESPLIT>def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Rate limit a function .<CODESPLIT>def rate_limited ( max_per_hour : int , * args : Any ) -> Callable [ ... , Any ] : return util . rate_limited ( max_per_hour , * args )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Call an alias given its name and the rest of the line .<CODESPLIT>def call_alias ( self , alias , rest = '' ) : cmd = self . transform_alias ( alias , rest ) try : self . shell . system ( cmd ) except : self . shell . showtraceback ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>write the html file contents to disk<CODESPLIT>def _save_file ( self , filename , contents ) : with open ( filename , 'w' ) as f : f . write ( contents )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Print dicttree in Json - like format . keys are sorted<CODESPLIT>def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( "," , ": " ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Saves dictionary as CSV file .<CODESPLIT>def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run the tests .<CODESPLIT>def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>variance of the values must have 2 or more entries .<CODESPLIT>def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns an image tensor .<CODESPLIT>def read_image ( filepath ) : im_bytes = tf . io . read_file ( filepath ) im = tf . image . decode_image ( im_bytes , channels = CHANNELS ) im = tf . image . convert_image_dtype ( im , tf . float32 ) return im
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .<CODESPLIT>def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Attempt to setattr but catch AttributeErrors .<CODESPLIT>def safe_setattr ( obj , name , value ) : try : setattr ( obj , name , value ) return True except AttributeError : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Initializes functions that are invoked when the user or OS wants to kill this process . : return :<CODESPLIT>def set_stop_handler ( self ) : signal . signal ( signal . SIGTERM , self . graceful_stop ) signal . signal ( signal . SIGABRT , self . graceful_stop ) signal . signal ( signal . SIGINT , self . graceful_stop )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>gets the dimensions depending on python version and os<CODESPLIT>def get_window_dim ( ) : version = sys . version_info if version >= ( 3 , 3 ) : return _size_36 ( ) if platform . system ( ) == 'Windows' : return _size_windows ( ) return _size_27 ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find the time this file was last modified .<CODESPLIT>def get_mtime ( fname ) : try : mtime = os . stat ( fname ) . st_mtime_ns except OSError : # The file might be right in the middle of being written # so sleep time . sleep ( 1 ) mtime = os . stat ( fname ) . st_mtime_ns return mtime
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () .<CODESPLIT>def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Construct a single page PDF from the provided page in memory<CODESPLIT>def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Partial objects do not serialize correctly in python2 . x -- this fixes the bugs<CODESPLIT>def save_partial ( self , obj ) : self . save_reduce ( _genpartial , ( obj . func , obj . args , obj . keywords ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>must be an iterable ( list array tuple )<CODESPLIT>def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a CSV object to a numpy array .<CODESPLIT>def csv_to_numpy ( string_like , dtype = None ) : # type: (str) -> np.array stream = StringIO ( string_like ) return np . genfromtxt ( stream , dtype = dtype , delimiter = ',' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table .<CODESPLIT>def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Takes two clicks and returns the slope .<CODESPLIT>def click_estimate_slope ( ) : c1 = _pylab . ginput ( ) if len ( c1 ) == 0 : return None c2 = _pylab . ginput ( ) if len ( c2 ) == 0 : return None return ( c1 [ 0 ] [ 1 ] - c2 [ 0 ] [ 1 ] ) / ( c1 [ 0 ] [ 0 ] - c2 [ 0 ] [ 0 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Function that prune the decision tree .<CODESPLIT>def pruning ( self , X , y , cost_mat ) : self . tree_ . tree_pruned = copy . deepcopy ( self . tree_ . tree ) if self . tree_ . n_nodes > 0 : self . _pruning ( X , y , cost_mat ) nodes_pruned = self . _nodes ( self . tree_ . tree_pruned ) self . tree_ . n_nodes_pruned = len ( nodes_pruned )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>get the covarince between two points implied by Vario2d<CODESPLIT>def covariance ( self , pt0 , pt1 ) : x = np . array ( [ pt0 [ 0 ] , pt1 [ 0 ] ] ) y = np . array ( [ pt0 [ 1 ] , pt1 [ 1 ] ] ) names = [ "n1" , "n2" ] return self . covariance_matrix ( x , y , names = names ) . x [ 0 , 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>return the number of channels present in samples<CODESPLIT>def numchannels ( samples : np . ndarray ) -> int : if len ( samples . shape ) == 1 : return 1 else : return samples . shape [ 1 ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper to get bins for histplot .<CODESPLIT>def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns inverse of transformation .<CODESPLIT>def inverse ( self ) : invr = np . linalg . inv ( self . affine_matrix ) return SymmOp ( invr )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert camelcase names to underscore<CODESPLIT>def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\1_\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\1_\2' , s1 ) . lower ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>determine whether two sequence names from a repeatmasker alignment match .<CODESPLIT>def _rm_name_match ( s1 , s2 ) : m_len = min ( len ( s1 ) , len ( s2 ) ) return s1 [ : m_len ] == s2 [ : m_len ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a grayscale image to BGR image .<CODESPLIT>def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the coverage object of pytest - cov .<CODESPLIT>def get_cov ( config ) : # Check with hasplugin to avoid getplugin exception in older pytest. if config . pluginmanager . hasplugin ( '_cov' ) : plugin = config . pluginmanager . getplugin ( '_cov' ) if plugin . cov_controller : return plugin . cov_controller . cov return None
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap vertical table in a function for TabularOutputFormatter .<CODESPLIT>def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Closes and waits for subprocess to exit .<CODESPLIT>def _finish ( self ) : if self . _process . returncode is None : self . _process . stdin . flush ( ) self . _process . stdin . close ( ) self . _process . wait ( ) self . closed = True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a re . match object if an empty comment was found on line .<CODESPLIT>def _match_space_at_line ( line ) : regex = re . compile ( r"^{0}$" . format ( _MDL_COMMENT ) ) return regex . match ( line )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Calculate the voxel coordinates of a straight line between the two given end points<CODESPLIT>def line_segment ( X0 , X1 ) : X0 = sp . around ( X0 ) . astype ( int ) X1 = sp . around ( X1 ) . astype ( int ) if len ( X0 ) == 3 : L = sp . amax ( sp . absolute ( [ [ X1 [ 0 ] - X0 [ 0 ] ] , [ X1 [ 1 ] - X0 [ 1 ] ] , [ X1 [ 2 ] - X0 [ 2 ] ] ] ) ) + 1 x = sp . rint ( sp . linspace ( X0 [ 0 ] , X1 [ 0 ] , L ) ) . astype ( int ) y = sp . rint ( sp . linspace ( X0 [ 1 ] , X1 [ 1 ] , L ) ) . astype ( int ) z = sp . rint ( sp . linspace ( X0 [ 2 ] , X1 [ 2 ] , L ) ) . astype ( int ) return [ x , y , z ] else : L = sp . amax ( sp . absolute ( [ [ X1 [ 0 ] - X0 [ 0 ] ] , [ X1 [ 1 ] - X0 [ 1 ] ] ] ) ) + 1 x = sp . rint ( sp . linspace ( X0 [ 0 ] , X1 [ 0 ] , L ) ) . astype ( int ) y = sp . rint ( sp . linspace ( X0 [ 1 ] , X1 [ 1 ] , L ) ) . astype ( int ) return [ x , y ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>r Repeat each item in iterable n times .<CODESPLIT>def stretch ( iterable , n = 2 ) : times = range ( n ) for item in iterable : for i in times : yield item
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Calculate the median of a list .<CODESPLIT>def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns all column names and their data types as a list .<CODESPLIT>def dtypes ( self ) : return [ ( str ( f . name ) , f . dataType . simpleString ( ) ) for f in self . schema . fields ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return view of the recarray with all int32 cast to int64 .<CODESPLIT>def to_int64 ( a ) : # build new dtype and replace i4 --> i8 def promote_i4 ( typestr ) : if typestr [ 1 : ] == 'i4' : typestr = typestr [ 0 ] + 'i8' return typestr dtype = [ ( name , promote_i4 ( typestr ) ) for name , typestr in a . dtype . descr ] return a . astype ( dtype )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Reads a tif file to a 2D NumPy array<CODESPLIT>def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Find a single document by id<CODESPLIT>def find_one_by_id ( self , _id ) : document = ( yield self . collection . find_one ( { "_id" : ObjectId ( _id ) } ) ) raise Return ( self . _obj_cursor_to_dictionary ( document ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>calculates a rough guess of runtime based on product of parameters<CODESPLIT>def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>This will equal 124 for the V1 database .<CODESPLIT>def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns path as an absolute path with ~user and env var expansion applied .<CODESPLIT>def expand_path ( path ) : return os . path . abspath ( os . path . expandvars ( os . path . expanduser ( path ) ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Helper function to get the location of a Python file .<CODESPLIT>def getScriptLocation ( ) : location = os . path . abspath ( "./" ) if __file__ . rfind ( "/" ) != - 1 : location = __file__ [ : __file__ . rfind ( "/" ) ] return location
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the contents of the sql file from the given filename .<CODESPLIT>def _get_sql ( filename ) : with open ( os . path . join ( SQL_DIR , filename ) , 'r' ) as f : return f . read ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load the noise texture data into the current texture unit<CODESPLIT>def load ( self ) : glTexImage3D ( GL_TEXTURE_3D , 0 , GL_LUMINANCE16_ALPHA16 , self . width , self . width , self . width , 0 , GL_LUMINANCE_ALPHA , GL_UNSIGNED_SHORT , ctypes . byref ( self . data ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set the modified time of a file<CODESPLIT>def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)  mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Localize a datetime object to local time .<CODESPLIT>def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create database tables from sqlalchemy models<CODESPLIT>def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Sets the cursor to the desired position .<CODESPLIT>def set_cursor ( self , x , y ) : curses . curs_set ( 1 ) self . screen . move ( y , x )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>read an image from file - PIL doesnt close nicely<CODESPLIT>def load_image ( fname ) : with open ( fname , "rb" ) as f : i = Image . open ( fname ) #i.load() return i
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Efficient cartesian product of a list of 1D arrays returning the expanded array views for each dimensions . By default arrays are flattened which may be controlled with the flat flag . The array views can be turned into regular arrays with the copy flag .<CODESPLIT>def cartesian_product ( arrays , flat = True , copy = False ) : arrays = np . broadcast_arrays ( * np . ix_ ( * arrays ) ) if flat : return tuple ( arr . flatten ( ) if copy else arr . flat for arr in arrays ) return tuple ( arr . copy ( ) if copy else arr for arr in arrays )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if the given object conforms to the Serializable protocol .<CODESPLIT>def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns type of the data for the given FeatureType .<CODESPLIT>def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Determines if two rectangles each input as a tuple ( xmin xmax ymin ymax ) intersect .<CODESPLIT>def boxes_intersect ( box1 , box2 ) : xmin1 , xmax1 , ymin1 , ymax1 = box1 xmin2 , xmax2 , ymin2 , ymax2 = box2 if interval_intersection_width ( xmin1 , xmax1 , xmin2 , xmax2 ) and interval_intersection_width ( ymin1 , ymax1 , ymin2 , ymax2 ) : return True else : return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Checks object if it s a peewee model and unique .<CODESPLIT>def _check_model ( obj , models = None ) : return isinstance ( obj , type ) and issubclass ( obj , pw . Model ) and hasattr ( obj , '_meta' )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>1x1 convolution<CODESPLIT>def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Join two state vectors into a larger qubit state<CODESPLIT>def join_states ( * states : State ) -> State : vectors = [ ket . vec for ket in states ] vec = reduce ( outer_product , vectors ) return State ( vec . tensor , vec . qubits )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns a bs4 object of the page requested<CODESPLIT>def get_soup ( page = '' ) : content = requests . get ( '%s/%s' % ( BASE_URL , page ) ) . text return BeautifulSoup ( content )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Wrap standard function to easily pass into map processing .<CODESPLIT>def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get zero - indexed line from an open file - like .<CODESPLIT>def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Remove . postXXXX postfix from version<CODESPLIT>def drop_post ( self ) : post_index = self . version . find ( '.post' ) if post_index >= 0 : self . version = self . version [ : post_index ]
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount .<CODESPLIT>def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create an array . Keyword arguments as per : func : zarr . creation . empty .<CODESPLIT>def empty ( self , name , * * kwargs ) : return self . _write_op ( self . _empty_nosync , name , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return frequencies for DFT<CODESPLIT>def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Test if DATABASES [ default ] exists<CODESPLIT>def db_exists ( ) : logger . info ( "Checking to see if %s already exists" , repr ( DB [ "NAME" ] ) ) try : # Hide stderr since it is confusing here psql ( "" , stderr = subprocess . STDOUT ) except subprocess . CalledProcessError : return False return True
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>reads an RDF file into a graph<CODESPLIT>def load_graph_from_rdf ( fname ) : print ( "reading RDF from " + fname + "...." ) store = Graph ( ) store . parse ( fname , format = "n3" ) print ( "Loaded " + str ( len ( store ) ) + " tuples" ) return store
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Get distance between pairs of lat - lon points<CODESPLIT>def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Check whether the passed variable is a tuple with two floats or integers<CODESPLIT>def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Create object .<CODESPLIT>def __call__ ( self , factory_name , * args , * * kwargs ) : return self . factories [ factory_name ] ( * args , * * kwargs )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Parse ISO8601 timestamps given by github API .<CODESPLIT>def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Extracts all integers from a string an return them in a list<CODESPLIT>def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Turns a Python unicode string list into a Java String array .<CODESPLIT>def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( "java/lang/String" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return a prettier version of obj<CODESPLIT>def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Pre - order depth - first<CODESPLIT>def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Set GUI on - top flag<CODESPLIT>def inFocus ( self ) : previous_flags = self . window . flags ( ) self . window . setFlags ( previous_flags | QtCore . Qt . WindowStaysOnTopHint )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Returns the data as numpy . array from each partition .<CODESPLIT>def toarray ( self ) : rdd = self . _rdd . map ( lambda x : x . toarray ( ) ) return np . concatenate ( rdd . collect ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Fibonacci example function<CODESPLIT>def fib ( n ) : assert n > 0 a , b = 1 , 1 for i in range ( n - 1 ) : a , b = b , a + b return a
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Makes the given dictionary symmetric . Values are assumed to be unique .<CODESPLIT>def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return True if created today .<CODESPLIT>def created_today ( self ) : if self . datetime . date ( ) == datetime . today ( ) . date ( ) : return True return False
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Given k kilobytes report back the correct format as string .<CODESPLIT>def reportMemory ( k , options , field = None , isBytes = False ) : if options . pretty : return prettyMemory ( int ( k ) , field = field , isBytes = isBytes ) else : if isBytes : k /= 1024. if field is not None : return "%*dK" % ( field - 1 , k ) # -1 for the "K" else : return "%dK" % int ( k )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Internal function to read an XML file<CODESPLIT>def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Run unit tests .<CODESPLIT>def test ( * args ) : subprocess . call ( [ "py.test-2.7" ] + list ( args ) ) subprocess . call ( [ "py.test-3.4" ] + list ( args ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Return the duplicates in a list .<CODESPLIT>def find_duplicates ( l : list ) -> set : return set ( [ x for x in l if l . count ( x ) > 1 ] )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .<CODESPLIT>def energy_string_to_float ( string ) : energy_re = re . compile ( "(-?\d+\.\d+)" ) return float ( energy_re . match ( string ) . group ( 0 ) )
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Load and parse a feature file .<CODESPLIT>def load_feature ( fname , language ) : fname = os . path . abspath ( fname ) feat = parse_file ( fname , language ) return feat
1<CODESPLIT>URL<CODESPLIT>func_name<CODESPLIT>Log memory usage before and after a method .<CODESPLIT>def memory_usage ( method ) : def wrapper ( * args , * * kwargs ) : logging . info ( 'Memory before method %s is %s.' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) result = method ( * args , * * kwargs ) logging . info ( 'Memory after method %s is %s' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) return result return wrapper
